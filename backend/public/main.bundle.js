/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 240);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(93));
__export(__webpack_require__(263));
__export(__webpack_require__(157));
__export(__webpack_require__(264));
__export(__webpack_require__(265));
__export(__webpack_require__(266));
__export(__webpack_require__(161));
__export(__webpack_require__(162));
__export(__webpack_require__(267));
__export(__webpack_require__(268));
__export(__webpack_require__(163));
__export(__webpack_require__(156));
__export(__webpack_require__(269));
__export(__webpack_require__(110));
__export(__webpack_require__(270));
__export(__webpack_require__(164));
/** @module Utils */
/** @docs-package-description
 * The bentleyjs-core package contains classes to solve problems that are common for both client and server use cases.
 */
/**
 * @docs-group-description BeSQLite
 * Classes for working with SQLite databases. SQLite underlies IModelDb and ECDb - see [Executing ECSQL]($docs/learning/ECSQL.md)
 */
/**
 * @docs-group-description Errors
 * Classes for working with errors.
 */
/**
 * @docs-group-description Events
 * Classes for raising and handling events.
 */
/**
 * @docs-group-description Ids
 * Classes for working with unique identifiers.
 */
/**
 * @docs-group-description Logging
 * Classes for configuring and logging diagnostic messages - see [Learning about Logging]($docs/learning/common/Logging.md)
 */
/**
 * @docs-group-description Utils
 * Miscellaneous utility classes.
 */


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Utility */
// REMARK:
// The docs-group-description comments are followed by empty classes with names corresponding to the doc-group.
// Normally (in committed code) these are commented out.
// The comments have distinctive strings so that simple search and replace can make the "real".
// This is useful when working on the documentation:  When the empty classes are present, VSCode will format the doc comments
// for and display them when the mouse hovers over the class name.
/**
 * @docs-package-description
 * The geometry-core package contains classes for workiing with CAD geometry:  points, vectors, curves, surfaces, and analytic solids
 */
/**
 * @docs-group-description CartesianGeometry
 * Points, Vectors, Planes, and Transformations for x,y,z geometry.
 * * Fundamental cartesian geometry objects:
 * * * Point2d, Point3d -- points with x,y,z coordinates
 * * * Vector2d, Vector3d -- vectors with x,y,z coordinates
 * * * RotMatrix -- 3x3 matrix
 * * * * commonly used for pure rotations
 * * * * scale and skew entries are also allowed.
 * * * Transform -- an origin and axes.
 * * * Range1d, Range2d, Range3d -- subsets of 1d, 2d, and 3d space bounded by low and high values.
 * * * Ray3d -- a ray defined by origin and direction vector
 * * * Plane3dByOriginAndUnitNormal -- a plane defined by an origin and a single vector which is perpendicular to the plane
 * * * plane3dByOriginAndVectors -- a plane defined by an origin and two vectors in the plane.
 * * Angles
 * * * Angle -- a strongly typed angle object whose method names make it clear whether input and outputs are degrees or radians.
 * * * AngleSweep -- an angular interval
 * * * YawPitchAndRollAngles -- 3 angles that define a rotated coordinte system.
 * * Utility classes
 * * * FrameBuilder -- construction of coordinate frames from mixed data sources.
 * * * ClipPlane -- a single plane
 * * * ConvexClipPlaneSet -- an array of planes bounding a convex volumne
 * * * ClipPlaneSet -- an array of ConvexClipPlaneSet, defining the union of their volumes
 * * * Constant -- various numeric values exported as readonly constants
 */
// doc:export class CartesianGeometryDoc { }
/**
 * @docs-group-description ArraysAndInterfaces
 * These classes support array operations and inheritance-based algorithms.
 * * Arrays
 * * * GrowableArray -- A carrier for a Float64Array, with methods that hide reallocation of the underlying array as contents are added.
 * * * Point2dArray, Point3dArray, Point4dArray, Vector3dArray -- miscellaneous operations on arrays of 2d and 3d points.
 * * Interfaces
 * * * GeometryHandler -- a double-dispatch protocal used for efficient implementation of algorithms that work on many geometry types.
 *
 */
// doc:export class ArraysAndInterfacesDoc { }
/**
 * @docs-group-description Bspline
 * A bspline curve or surface is used for curved freeform geometry defined by controls points (sometimes called poles).
 * * BSplineCurve --  a curve in XYZ coordinates
 * * BSplineSurfaceXYZ -- a surface with XYZ
 * * BsplineSurfaceXYZW -- a surface with weighted (rational) XYZ coordinates
 * * KnotVector -- vector of breakpoints in bspline definitions.
 */
// doc:export class BsplineDoc { }
/**
 * @docs-group-description Curve
 * Curves in the GeometryQuery hierarchy: LineSegment3d, LineString3d, Arc3d, TransitionSpiral3d
 * * CurvePrimitive -- base class for parametric curves
 * * * LineSegment3d -- a (bounded) portion of an unbounded line
 * * * Arc3d -- a circular or elliptic arc
 * * * LineString3d -- a sequence of points joined by line segments
 * * * TransitionSpiral -- controlled transition between curvatures
 * * Support classes
 * * PointString3d -- a sequence of isolated points
 * * StrokeOptions -- tolerances to describe stroking accuracy
 * * RecursiveCurveProcessor, RecursiveCurveProcessorWithStack -- algorithmic support for trees with CurvePrimitives at the leaf level.
 */
// doc:export class CurveDoc { }
/**
 * @docs-group-description Numerics
 * The Numerics classes have geometric and numeric methods used during large algorithms in other classes.
 */
// doc:export class NumericsDoc { }
/**
 * @docs-group-description Polyface
 * A Polyface is a mesh structure with arrays of points that are shared among multiple incident facets.
 */
// doc:export class PolyfaceDoc { }
/**
 * @docs-group-description Serialization
 * These classes are related to serialization of geometry classes.
 * * IModelJson.Reader, IModelJson.Writer -- Conversion of in-memory geometry objects to json objects for persistence and transmission.
 */
// doc:export class SerializationDoc { }
/**
 * @docs-group-description Solid
 * Analytic Solids in the GeometryQuery hierarchy: Box, Sphere, Cone, TorusPipe, LinearSweep, RotationalSweep, RuledSweep
 * * Box -- a box solid.  This is usually rectangular on all faces, but can in one directly like a view frustum
 * * Sphere -- a sphere
 * * Cone -- a cone or cylinder
 * * TorusPipe -- a pipe elbow
 * * LinearSweep -- a linar sweep of a base contour
 * * RotationalSweep -- a rotational sweep of a base contour
 * * RuledSweep -- two or more similarly structured contours joined by linear rule lines.
 */
// doc:export class SolidDOc { }
/**
 * @docs-group-description Utility
 * These modules and classes are outside the geometric structure
 * * geometry-core.ts -- gathers and exports class, so callers can import from geometry-core without knowning which classes
 *        are in which files.
 */
// doc:export class Utility { }
/**
 * @docs-group-description Topology
 * The Topology classes provide adjacency structures used in triangulations.
 */
// doc:export class TopologyDoc { }
__export(__webpack_require__(4));
__export(__webpack_require__(3));
__export(__webpack_require__(6));
__export(__webpack_require__(21));
__export(__webpack_require__(241));
__export(__webpack_require__(37));
__export(__webpack_require__(134));
__export(__webpack_require__(136));
__export(__webpack_require__(242));
__export(__webpack_require__(135));
__export(__webpack_require__(244));
__export(__webpack_require__(46));
__export(__webpack_require__(139));
__export(__webpack_require__(138));
__export(__webpack_require__(245));
__export(__webpack_require__(66));
__export(__webpack_require__(106));
__export(__webpack_require__(246));
__export(__webpack_require__(247));
__export(__webpack_require__(47));
__export(__webpack_require__(140));
__export(__webpack_require__(14));
__export(__webpack_require__(249));
__export(__webpack_require__(12));
__export(__webpack_require__(141));
__export(__webpack_require__(38));
__export(__webpack_require__(10));
__export(__webpack_require__(142));
__export(__webpack_require__(67));
__export(__webpack_require__(143));
__export(__webpack_require__(144));
__export(__webpack_require__(145));
__export(__webpack_require__(146));
__export(__webpack_require__(151));
__export(__webpack_require__(152));
__export(__webpack_require__(39));
__export(__webpack_require__(153));
__export(__webpack_require__(91));
__export(__webpack_require__(154));
__export(__webpack_require__(107));
__export(__webpack_require__(155));
__export(__webpack_require__(108));
__export(__webpack_require__(148));
__export(__webpack_require__(92));
__export(__webpack_require__(147));
__export(__webpack_require__(252));
__export(__webpack_require__(150));
__export(__webpack_require__(109));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(192));
__export(__webpack_require__(58));
__export(__webpack_require__(311));
__export(__webpack_require__(193));
__export(__webpack_require__(312));
__export(__webpack_require__(313));
__export(__webpack_require__(314));
__export(__webpack_require__(315));
__export(__webpack_require__(316));
__export(__webpack_require__(51));
__export(__webpack_require__(27));
__export(__webpack_require__(195));
__export(__webpack_require__(34));
__export(__webpack_require__(16));
__export(__webpack_require__(196));
__export(__webpack_require__(317));
__export(__webpack_require__(318));
__export(__webpack_require__(319));
__export(__webpack_require__(320));
__export(__webpack_require__(198));
__export(__webpack_require__(119));
__export(__webpack_require__(197));
__export(__webpack_require__(199));
__export(__webpack_require__(194));
__export(__webpack_require__(321));
__export(__webpack_require__(201));
__export(__webpack_require__(116));
__export(__webpack_require__(200));
__export(__webpack_require__(52));
__export(__webpack_require__(117));
__export(__webpack_require__(71));
__export(__webpack_require__(28));
__export(__webpack_require__(42));
__export(__webpack_require__(59));
__export(__webpack_require__(322));
__export(__webpack_require__(324));
__export(__webpack_require__(204));
__export(__webpack_require__(330));
__export(__webpack_require__(331));
__export(__webpack_require__(332));
/** @docs-package-description
 * The imodeljs-common package contains classes for working with iModels that can be used in both [frontend]($docs/learning/frontend/index.md) and [backend]($docs/learning/backend/index.md).
 */
/**
 * @docs-group-description WireFormats
 * Definitions of the "props" interfaces and types that define the [wire format]($docs/earning/wireformat.md) for communication between the frontend and backend
 */
/**
 * @docs-group-description Codes
 * Classes for working with [Codes]($docs/bis/intro/codes.md)
 */
/**
 * @docs-group-description Geometry
 * Classes for working with geometry.
 */
/**
 * @docs-group-description Views
 * Classes for working with views of models and elements.
 */
/**
 * @docs-group-description Rendering
 * Classes for rendering geometry in views.
 */
/**
 * @docs-group-description Symbology
 * Classes that affect the appearance of geometry in a view
 */
/**
 * @docs-group-description iModels
 * Classes for working with [iModels]($docs/overview/IModels.md) in both the frontend and backend
 */
/**
 * @docs-group-description RpcInterface
 * Classes for working with [RpcInterfaces]($docs/learning/RpcInterface.md).
 */
/**
 * @docs-group-description ECSQL
 * Classes for working with [ECSQL]($docs/learning/ECSQL.md), [Spatial Queries]($docs/learning/SpatialQueries.md), and [ECSQL Geometry Functions]($docs/learning/GeometrySqlFuncs.md)
 */
/**
 * @docs-group-description FeatureGates
 * Classes for configuring and gating (limiting at runtime) access to features.
 */


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
const PointVector_1 = __webpack_require__(4);
class Geometry {
    /** Points and vectors can be emitted in two forms:
      *
      * *  preferJSONArray === true :       [x,y,z]
      * *  preferJSONArray === false :      {x: 1, y: 2, z: 3}
      */
    // possible names for this class: Geometry, Distance, Units
    static correctSmallMetricDistance(distance, replacement = 0.0) {
        if (Math.abs(distance) < Geometry.smallMetricDistance) {
            return replacement;
        }
        return distance;
    }
    /**
   * @returns If `a` is large enough, return `1/a`, using Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
   * @param a denominator of division
   */
    static inverseMetricDistance(a) { return (Math.abs(a) <= Geometry.smallMetricDistance) ? undefined : 1.0 / a; }
    /**
     * @returns If `a` is large enough, return `1/a`, using the square of Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
     * @param a denominator of division
     */
    static inverseMetricDistanceSquared(a) {
        return (Math.abs(a) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / a;
    }
    static isSameCoordinate(x, y, tol) {
        if (tol)
            return Math.abs(x - y) < Math.abs(tol);
        return Math.abs(x - y) < Geometry.smallMetricDistance;
    }
    static isSameCoordinateSquared(x, y) {
        return Math.abs(Math.sqrt(x) - Math.sqrt(y)) < Geometry.smallMetricDistance;
    }
    static isSamePoint3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSameXYZ(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSamePoint3dXY(dataA, dataB) { return dataA.distanceXY(dataB) < Geometry.smallMetricDistance; }
    static isSameVector3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSamePoint2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    static isSameVector2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with x as first test, y second.
     */
    static lexicalXYLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        return 0;
    }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with y as first test, x second.
     */
    static lexicalYXLessThan(a, b) {
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        return 0;
    }
    static lexicalXYZLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.z < b.z)
            return -1;
        else if (a.z > b.z)
            return 1;
        return 0;
    }
    static isSmallRelative(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    static isSmallAngleRadians(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    static isAlmostEqualNumber(a, b) {
        return Math.abs(a - b) < Geometry.smallAngleRadians * Math.max(a, b);
    }
    static isDistanceWithinTol(distance, tol) {
        return Math.abs(distance) <= Math.abs(tol);
    }
    static isSmallMetricDistance(distance) {
        return Math.abs(distance) <= Geometry.smallMetricDistance;
    }
    static isSmallMetricDistanceSquared(distanceSquared) {
        return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;
    }
    static cyclic3dAxis(axis) {
        /* Direct test for the most common cases, avoid modulo */
        if (axis >= 0) {
            if (axis < 3)
                return axis;
            if (axis < 6)
                return axis - 3;
            return axis % 3;
        }
        const j = axis + 3;
        if (j >= 0)
            return j;
        return 2 - ((-axis - 1) % 3);
    }
    /** Return the AxisOrder for which axisIndex is the first named axis.
     * * `axisIndex===0`returns AxisOrder.XYZ
     * * `axisIndex===1`returns AxisOrder.YZX
     * * `axisIndex===2`returns AxisOrder.ZXY
     */
    static axisIndexToRightHandedAxisOrder(axisIndex) {
        if (axisIndex === 0)
            return 0 /* XYZ */;
        if (axisIndex === 1)
            return 1 /* YZX */;
        if (axisIndex === 2)
            return 2 /* ZXY */;
        return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));
    }
    /** @returns the largest absolute distance from a to either of b0 or b1 */
    static maxAbsDiff(a, b0, b1) { return Math.max(Math.abs(a - b0), Math.abs(a - b1)); }
    /** @returns the largest absolute absolute value among x,y,z */
    static maxAbsXYZ(x, y, z) {
        return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));
    }
    /** @returns the largest signed value among a, b, c */
    static maxXYZ(a, b, c) {
        let q = a;
        if (b > q)
            q = b;
        if (c > q)
            q = c;
        return q;
    }
    /** @returns Return the hypotenuse sqrt(x\*x + y\*y). This is much faster than Math.hypot(x,y).*/
    static hypotenuseXY(x, y) { return Math.sqrt(x * x + y * y); }
    /** @returns Return the squared hypotenuse (x\*x + y\*y). */
    static hypotenuseSquaredXY(x, y) { return x * x + y * y; }
    /** @returns Return the square of x */
    static square(x) { return x * x; }
    /** @returns Return the hypotenuse sqrt(x\*x + y\*y). This is much faster than Math.hypot(x,y, z).*/
    static hypotenuseXYZ(x, y, z) { return Math.sqrt(x * x + y * y + z * z); }
    static hypotenuseSquaredXYZ(x, y, z) { return x * x + y * y + z * z; }
    static hypotenuseXYZW(x, y, z, w) { return Math.sqrt(x * x + y * y + z * z + w * w); }
    static hypotenuseSquaredXYZW(x, y, z, w) { return x * x + y * y + z * z + w * w; }
    /**
     * Return the distance between xy points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     */
    static distanceXYXY(x0, y0, x1, y1) {
        return Geometry.hypotenuseXY(x1 - x0, y1 - y0);
    }
    /**
     * Return the distance between xyz points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param z0 z coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     * @param z1 z coordinate of point 1
     */
    static distanceXYZXYZ(x0, y0, z0, x1, y1, z1) {
        return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);
    }
    /** @returns Returns the triple product of 3 vectors provided as x,y,z number sequences.
     *
     * * The triple product is the determinant of the 3x3 matrix with the 9 numbers placed in either row or column order.
     * * The triple product is positive if the 3 vectors form a right handed coordinate system.
     * * The triple product is negative if the 3 vectors form a left handed coordinate system.
     * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:
     *
     * ** U dot (V cross W)
     * ** V dot (W cross U)
     * ** W dot (U cross V)
     * **  (-U dot (W cross V))  -- (note the negative -- reversing cross product order changes the sign)
     * ** (-V dot (U cross W)) -- (note the negative -- reversing cross product order changes the sign)
     * ** (-W dot (V cross U)) -- (note the negative -- reversing cross product order changes the sign)
     * * the triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a common vertex.
     */
    static tripleProduct(ux, uy, uz, vx, vy, vz, wx, wy, wz) {
        return ux * (vy * wz - vz * wy)
            + uy * (vz * wx - vx * wz)
            + uz * (vx * wy - vy * wx);
    }
    /**  2D cross product of vectors layed out as scalars. */
    static crossProductXYXY(ux, uy, vx, vy) {
        return ux * vy - uy * vx;
    }
    /**  3D cross product of vectors layed out as scalars. */
    static crossProductXYZXYZ(ux, uy, uz, vx, vy, vz, result) {
        return PointVector_1.Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /**  3D dot product of vectors layed out as scalars. */
    static dotProductXYZXYZ(ux, uy, uz, vx, vy, vz) {
        return ux * vx + uy * vy + uz * vz;
    }
    static clampToStartEnd(x, a, b) {
        if (a > b)
            return Geometry.clampToStartEnd(x, b, a);
        if (x < a)
            return a;
        if (b < x)
            return b;
        return x;
    }
    /** simple interpolation between values, but choosing (based on fraction) a or b as starting point for maximum accuracy. */
    static interpolate(a, f, b) {
        return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);
    }
    /** given an axisOrder (e.g. XYZ, YZX, ZXY, XZYLeftHanded etc) and an (integer) offset, resolve to an axis index. */
    static axisOrderToAxis(order, index) {
        const axis = order <= 2 /* ZXY */ ? order + index : (order - 4 /* XZY */) - index;
        return Geometry.cyclic3dAxis(axis);
    }
    /** Return (a modulo period), e.g. for use as a cyclid index.  Both a and period may be negative. */
    static modulo(a, period) {
        if (period <= 0) {
            if (period === 0)
                return a;
            return -Geometry.modulo(-a, -period);
        }
        if (a >= 0) {
            if (a < period)
                return a;
            if (a < 2 * period)
                return a - period;
        }
        else {
            a += period; // hopefully move into primary period without division and floor
            if (a > 0)
                return a;
        }
        const m = Math.floor(a / period);
        return a - m * period;
    }
    /** return 0 if the value is undefined, 1 if defined. */
    static defined01(value) { return value === undefined ? 0 : 1; }
    /** normally, return numerator/denominator.
     * but if the ratio would exceed Geometry.largeFractionResult, return undefined.
     */
    static conditionalDivideFraction(numerator, denominator) {
        if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))
            return numerator / denominator;
        return undefined;
    }
    /** return the 0, 1, or 2 pairs of (c,s) values that solve
     * {constCoff + cosCoff * c + sinCoff * s = }
     * with the constraint {c*c+s*s = 1}
     */
    static solveTrigForm(constCoff, cosCoff, sinCoff) {
        {
            const delta2 = cosCoff * cosCoff + sinCoff * sinCoff;
            const constCoff2 = constCoff * constCoff;
            // let nSolution = 0;
            let result;
            if (delta2 > 0.0) {
                const lambda = -constCoff / delta2;
                const a2 = constCoff2 / delta2;
                const D2 = 1.0 - a2;
                if (D2 >= 0.0) {
                    const mu = Math.sqrt(D2 / delta2);
                    /* c0,s0 = closest approach of line to origin */
                    const c0 = lambda * cosCoff;
                    const s0 = lambda * sinCoff;
                    // nSolution = 2;
                    result = [PointVector_1.Vector2d.create(c0 - mu * sinCoff, s0 + mu * cosCoff), PointVector_1.Vector2d.create(c0 + mu * sinCoff, s0 - mu * cosCoff)];
                }
            }
            return result;
        }
    }
    /** normally,  return the number result of conditionalDivideFraction.
     * but if conditionalDivideFraction fails return specified default number.
     */
    static safeDivideFraction(numerator, denominator, defaultResult) {
        const a = Geometry.conditionalDivideFraction(numerator, denominator);
        if (a !== undefined)
            return a;
        return defaultResult;
    }
    /** For a line f(x) whose function values at x0 and x1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate(x0, f0, x1, f1, targetF = 0) {
        const g = Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
        if (g)
            return Geometry.interpolate(x0, g, x1);
        return undefined;
    }
    /** For a line f(x) whose function values at x=0 and x=1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate01(f0, f1, targetF = 0) {
        return Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
    }
    /** Return true if json is an array with at least minEntries, and all entries are numbers (including those beyond minEntries) */
    static isNumberArray(json, minEntries = 0) {
        if (Array.isArray(json) && json.length >= minEntries) {
            let entry;
            for (entry of json) {
                //        if (!(entry as number) && entry !== 0.0)
                if (!Number.isFinite(entry))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** Return true if json is an array of at least numNumberArrays, with at least minEntries in each number array.
     */
    static isArrayOfNumberArray(json, numNumberArray, minEntries = 0) {
        if (Array.isArray(json) && json.length >= numNumberArray) {
            let entry;
            for (entry of json)
                if (!Geometry.isNumberArray(entry, minEntries))
                    return false;
            return true;
        }
        return false;
    }
    /** return the number of steps to take so that numSteps * stepSize >= total.
     * minCount is returned for both (a) setSize 0 or less and (b) stepSize > total.
     * A small tolerance is applied for almost
    */
    static stepCount(stepSize, total, minCount = 1, maxCount = 101) {
        if (stepSize <= 0)
            return minCount;
        if (stepSize >= total)
            return minCount;
        const stepCount = Math.floor((total + 0.999999 * stepSize) / stepSize);
        if (stepCount < minCount)
            return minCount;
        if (stepCount > maxCount)
            return maxCount;
        return stepCount;
    }
    /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)
     * @param x value to test.
     * @param apply01 if false, accept all x.
     */
    static isIn01(x, apply01 = true) { return apply01 ? x >= 0.0 && x <= 1.0 : true; }
}
Geometry.smallMetricDistance = 1.0e-6;
Geometry.smallMetricDistanceSquared = 1.0e-12;
Geometry.smallAngleRadians = 1.0e-12;
Geometry.smallAngleRadiansSquared = 1.0e-24;
Geometry.largeFractionResult = 1.0e10;
Geometry.fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - 1.0e-12; // smallAngleRadians less than 360degrees
exports.Geometry = Geometry;
/**
 * Carries the numeric value of an angle.
 * * The numeric value is private, and callers should not know or care whether it is in degrees or radians.
 * * The various access method are named so that callers can specify whether untyped numbers passed in or out are degrees or radians.
 */
class Angle {
    constructor(radians = 0, degrees) { this._radians = radians; this._degrees = degrees; }
    clone() { return new Angle(this._radians, this._degrees); }
    /**
     * Return a new Angle object for angle given in degrees.
     * @param degrees angle in degrees
     */
    static createDegrees(degrees) { return new Angle(Angle.degreesToRadians(degrees), degrees); }
    /**
     * Return a (new) Angle object for a value given in radians.
     * @param radians angle in radians
     */
    static createRadians(radians) { return new Angle(radians); }
    /**
     * Set this angle to a value given in radians.
     * @param radians angle given in radians
     */
    setRadians(radians) { this._radians = radians; this._degrees = undefined; }
    /**
     * Set this angle to a value given in degrees.
     * @param degrees angle given in degrees.
     */
    setDegrees(degrees) { this._radians = Angle.degreesToRadians(degrees); this._degrees = degrees; }
    /** Create an angle for a full circle. */
    static create360() { return new Angle(Math.PI * 2.0, 360.0); }
    /**
     * @return a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in determining the (otherwise ambiguous)
     * quadrant.
     * @param numerator numerator for tangent
     * @param denominator denominator for tangent
     */
    static createAtan2(numerator, denominator) { return new Angle(Math.atan2(numerator, denominator)); }
    /**
     * Copy all contents of `other` to this Angle.
     * @param other source data
     */
    setFrom(other) { this._radians = other._radians; this._degrees = other._degrees; }
    /**
     * Create an Angle from a JSON object
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     * @return a new Angle
     */
    static fromJSON(json, defaultValRadians) {
        const val = new Angle();
        val.setFromJSON(json, defaultValRadians);
        return val;
    }
    /**
     * set an Angle from a JSON object
     * * A simple number is degrees.
     * * specified `json.degrees` or `json._degrees` is degree value.
     * * specified `son.radians` or `json._radians` is radians value.
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     */
    setFromJSON(json, defaultValRadians) {
        this._radians = defaultValRadians ? defaultValRadians : 0;
        if (!json)
            return;
        if (typeof json === "number") {
            this.setDegrees(json);
        }
        else if (typeof json.degrees === "number") {
            this.setDegrees(json.degrees);
        }
        else if (typeof json._degrees === "number") {
            this.setDegrees(json._degrees);
        }
        else if (typeof json.radians === "number") {
            this.setRadians(json.radians);
        }
        else if (typeof json._radians === "number") {
            this.setRadians(json._radians);
        }
    }
    /** Convert an Angle to a JSON object as a number in degrees */
    toJSON() { return this.degrees; }
    toJSONRadians() { return { radians: this.radians }; }
    /** @returns Return the angle measured in radians. */
    get radians() { return this._radians; }
    /** @returns Return the angle measured in degrees. */
    get degrees() { return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians); }
    /**
     * Convert an angle in degrees to radians.
     * @param degrees angle in degrees
     */
    static degreesToRadians(degrees) { return degrees * Math.PI / 180; }
    /**
     * Convert an angle in radians to degrees.
     * @param degrees angle in radians
     */
    static radiansToDegrees(radians) {
        if (radians < 0)
            return -Angle.radiansToDegrees(-radians);
        // Now radians is positive ...
        const pi = Math.PI;
        const factor = 180.0 / pi;
        if (radians <= 0.25 * pi)
            return factor * radians;
        if (radians < 0.75 * pi)
            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);
        if (radians <= 1.25 * pi)
            return 180.0 + 180 * ((radians - pi) / pi);
        if (radians <= 1.75 * pi)
            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);
        // all larger radians reference from 360 degrees (2PI)
        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);
    }
    /**
     * @returns Return the cosine of this Angle object's angle.
     */
    cos() { return Math.cos(this._radians); }
    /**
     * @returns Return the sine of this Angle object's angle.
     */
    sin() { return Math.sin(this._radians); }
    /**
     * @returns Return the tangent of this Angle object's angle.
     */
    tan() { return Math.tan(this._radians); }
    static isFullCircleRadians(radians) { return Math.abs(radians) >= Geometry.fullCircleRadiansMinusSmallAngle; }
    isFullCircle() { return Angle.isFullCircleRadians(this._radians); }
    /** Adjust a radians value so it is positive in 0..360 */
    static adjustDegrees0To360(degrees) {
        if (degrees >= 0) {
            const period = 360.0;
            if (degrees < period)
                return degrees;
            const numPeriods = Math.floor(degrees / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustDegrees0To360(-degrees);
        return 360.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -180..180 */
    static adjustDegreesSigned180(degrees) {
        if (Math.abs(degrees) <= 180.0)
            return degrees;
        if (degrees >= 0) {
            const period = 360.0;
            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustDegreesSigned180(-degrees);
    }
    /** Adjust a radians value so it is positive in 0..2Pi */
    static adjustRadians0To2Pi(radians) {
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            if (radians < period)
                return radians;
            const numPeriods = Math.floor(radians / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustRadians0To2Pi(-radians);
        return Math.PI * 2.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -PI..PI */
    static adjustRadiansMinusPiPlusPi(radians) {
        if (Math.abs(radians) <= Math.PI)
            return radians;
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustRadiansMinusPiPlusPi(-radians);
    }
    static zero() { return new Angle(0); }
    isExactZero() { return this.radians === 0; }
    isAlmostZero() { return Math.abs(this.radians) < Geometry.smallAngleRadians; }
    /** Create an angle object with degrees adjusted into 0..360. */
    static createDegreesAdjustPositive(degrees) { return Angle.createDegrees(Angle.adjustDegrees0To360(degrees)); }
    /** Create an angle object with degrees adjusted into -180..180. */
    static createDegreesAdjustSigned180(degrees) { return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees)); }
    /**
     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)
     * @param radiansA first radians value
     * @param radiansB second radians value
     */
    static isAlmostEqualRadiansAllowPeriodShift(radiansA, radiansB) {
        // try to get simple conclusions with un-shifted radians ...
        const delta = Math.abs(radiansA - radiansB);
        if (delta <= Geometry.smallAngleRadians)
            return true;
        const period = Math.PI * 2.0;
        if (Math.abs(delta - period) <= Geometry.smallAngleRadians)
            return true;
        const numPeriod = Math.round(delta / period);
        const delta1 = delta - numPeriod * period;
        return Math.abs(delta1) <= Geometry.smallAngleRadians;
    }
    /**
     * Test if this angle and other are equivalent, allowing shift by full circle (i.e. by a multiple of 360 degrees)
     */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians);
    }
    /**
     * Test if two this angle and other are almost equal, NOT allowing shift by full circle multiples of 360 degrees.
     */
    isAlmostEqualNoPeriodShift(other) { return Math.abs(this._radians - other._radians) < Geometry.smallAngleRadians; }
    /**
     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.
     */
    static isAlmostEqualRadiansNoPeriodShift(radiansA, radiansB) { return Math.abs(radiansA - radiansB) < Geometry.smallAngleRadians; }
    /**
     * Test if dot product values indicate non-zero length perpendicular vectors.
     * @param dotUU dot product of vectorU with itself
     * @param dotVV dot product of vectorV with itself
     * @param dotUV dot product of vectorU with vectorV
     */
    static isPerpendicularDotSet(dotUU, dotVV, dotUV) {
        return dotUU > Geometry.smallMetricDistanceSquared
            && dotVV > Geometry.smallMetricDistanceSquared
            && dotUV * dotUV <= Geometry.smallAngleRadiansSquared * dotUU * dotVV;
    }
    /**
     * Return cosine, sine, and radians for the half angle of a cosine,sine pair.
     * @param rCos2A cosine value (scaled by radius) for initial angle.
     * @param rSin2A sine value (scaled by radius) for final angle.
     */
    static trigValuesToHalfAngleTrigValues(rCos2A, rSin2A) {
        const r = Geometry.hypotenuseXY(rCos2A, rSin2A);
        if (r < Geometry.smallMetricDistance) {
            return { c: 1.0, s: 0.0, radians: 0.0 };
        }
        else {
            /* If the caller really gave you sine and cosine values, r should be 1.  However,*/
            /* to allow scaled values -- e.g. the x and y components of any vector -- we normalize*/
            /* right here.  This adds an extra sqrt and 2 divides to the whole process, but improves*/
            /* both the usefulness and robustness of the computation.*/
            let cosA = 1.0;
            let sinA = 0.0;
            const cos2A = rCos2A / r;
            const sin2A = rSin2A / r;
            if (cos2A >= 0.0) {
                /* Original angle in NE and SE quadrants.  Half angle in same quadrant */
                cosA = Math.sqrt(0.5 * (1.0 + cos2A));
                sinA = sin2A / (2.0 * (cosA));
            }
            else {
                if (sin2A > 0.0) {
                    /* Original angle in NW quadrant. Half angle in NE quadrant */
                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));
                }
                else {
                    /* Original angle in SW quadrant. Half angle in SE quadrant*/
                    /* cosA comes out positive because both sines are negative. */
                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));
                }
                cosA = sin2A / (2.0 * (sinA));
            }
            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };
        }
    }
    /**
       * Return the half angle of angle between vectors U, V with given vector dots.
       * @param dotUU dot product of vectorU with itself
       * @param dotVV dot product of vectorV with itself
       * @param dotUV dot product of vectorU with vectorV
       */
    static dotProductsToHalfAngleTrigValues(dotUU, dotVV, dotUV, favorZero = true) {
        const rcos = dotUU - dotVV;
        const rsin = 2.0 * dotUV;
        if (favorZero && Math.abs(rsin) < Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))
            return { c: 1.0, s: 0.0, radians: 0.0 };
        return Angle.trigValuesToHalfAngleTrigValues(rcos, rsin);
    }
}
Angle.piOver4Radians = 7.85398163397448280000e-001;
Angle.piOver2Radians = 1.57079632679489660000e+000;
Angle.piRadians = 3.14159265358979310000e+000;
Angle.pi2Radians = 6.28318530717958620000e+000;
Angle.degreesPerRadian = (45.0 / Angle.piOver4Radians);
Angle.radiansPerDegree = (Angle.piOver4Radians / 45.0);
Angle.piOver12Radians = 0.26179938779914943653855361527329;
exports.Angle = Angle;
/**
 * An AngleSweep is a pair of angles at start and end of an interval.
 *
 * *  For stroking purposes, the "included interval" is all angles numerically reached by theta = start + f*(end-start), where f is between 0 and 1.
 * *  This stroking formula is simple numbers -- 2PI shifts are not involved.
 * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.
 * *  If (start < end) the angle proceeds CCW around the unit circle.
 * *  If (end < start) the angle proceeds CW around the unit circle.
 * *  Angles beyond 360 are fine as endpoints.
 *
 * **  (350,370) covers the same unit angles as (-10,10).
 * **  (370,350) covers the same unit angles as (10,-10).
 */
class AngleSweep {
    /** Read-property for degrees at the start of this AngleSweep. */
    get startDegrees() { return Angle.radiansToDegrees(this._radians0); }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endDegrees() { return Angle.radiansToDegrees(this._radians1); }
    /** Read-property for signed start-to-end sweep in degrees. */
    get sweepDegrees() { return Angle.radiansToDegrees(this._radians1 - this._radians0); }
    /** Read-property for degrees at the start of this AngleSweep. */
    get startRadians() { return this._radians0; }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endRadians() { return this._radians1; }
    /** Read-property for signed start-to-end sweep in radians. */
    get sweepRadians() { return this._radians1 - this._radians0; }
    /** Return the (strongly typed) start angle */
    get startAngle() { return Angle.createRadians(this._radians0); }
    /** Return the (strongly typed) end angle */
    get endAngle() { return Angle.createRadians(this._radians1); }
    /** (private) constructor with start and end angles in radians.
     *  * Use explicitly named static methods to clarify intent and units of inputs:
     *
     * * createStartEndRadians (startRadians:number, endRadians:number)
     * * createStartEndDegrees (startDegrees:number, endDegrees:number)
     * * createStartEnd (startAngle:Angle, endAngle:Angle)
     * * createStartSweepRadians (startRadians:number, sweepRadians:number)
     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)
     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)
    */
    constructor(startRadians = 0, endRadians = 0) { this._radians0 = startRadians; this._radians1 = endRadians; }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, endRadians);
        return result;
    }
    /** Return the angle obtained by subtracting radians from this angle. */
    cloneMinusRadians(radians) { return new AngleSweep(this._radians0 - radians, this._radians1 - radians); }
    /** create an AngleSweep from start and end angles given in degrees. */
    static createStartEndDegrees(startDegrees = 0, endDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees), result);
    }
    /** create an angle sweep from strongly typed start and end angles */
    static createStartEnd(startAngle, endAngle, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startAngle.radians, endAngle.radians);
        return result;
    }
    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */
    static createStartSweep(startAngle, sweepAngle, result) {
        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);
    }
    /** @returns Return a sweep with limits interpolated between this and other. */
    interpolate(fraction, other) {
        return new AngleSweep(Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry.interpolate(this._radians1, fraction, other._radians1));
    }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartSweepRadians(startRadians = 0, sweepRadians = Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, startRadians + sweepRadians);
        return result;
    }
    /** create an AngleSweep from start and sweep given in degrees.  */
    static createStartSweepDegrees(startDegrees = 0, sweepDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(startDegrees + sweepDegrees), result);
    }
    /** directly set the start and end angles in radians */
    setStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI) {
        const delta = endRadians - startRadians;
        if (Angle.isFullCircleRadians(delta)) {
            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;
        }
        this._radians0 = startRadians;
        this._radians1 = endRadians;
    }
    /** directly set the start and end angles in degrees */
    setStartEndDegrees(startDegrees = 0, endDegrees = 360.0) {
        this.setStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees));
    }
    /** copy from other AngleSweep. */
    setFrom(other) { this._radians0 = other._radians0; this._radians1 = other._radians1; }
    /** create a full circle sweep (CCW). startRadians defaults to 0 */
    static create360(startRadians) {
        startRadians = startRadians ? startRadians : 0.0;
        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);
    }
    /** create a sweep from the south pole to the north pole. */
    static createFullLatitude() { return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI); }
    /** Reverse the start and end angle in place. */
    reverseInPlace() { const a = this._radians0; this._radians0 = this._radians1; this._radians1 = a; }
    /** Restrict start and end angles into the range (-90,+90) in degrees. */
    capLatitudeInPlace() {
        const limit = 0.5 * Math.PI;
        this._radians0 = Geometry.clampToStartEnd(this._radians0, -limit, limit);
        this._radians1 = Geometry.clampToStartEnd(this._radians1, -limit, limit);
    }
    /** Ask if the sweep is counterclockwise, i.e. positive sweep */
    isCCW() { return this._radians1 >= this._radians0; }
    /** Ask if the sweep is a full circle. */
    isFullCircle() { return Angle.isFullCircleRadians(this.sweepRadians); }
    /** Ask if the sweep is a full sweep from south pole to north pole. */
    isFullLatitudeSweep() {
        const a = Math.PI * 0.5;
        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)
            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);
    }
    /** return a clone of this sweep. */
    clone() { return new AngleSweep(this._radians0, this._radians1); }
    /** Convert fractional position in the sweep to radians. */
    fractionToRadians(fraction) {
        return fraction < 0.5 ?
            this._radians0 + fraction * (this._radians1 - this._radians0)
            : this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);
    }
    /** Convert fractional position in the sweep to strongly typed Angle object. */
    fractionToAngle(fraction) {
        return Angle.createRadians(this.fractionToRadians(fraction));
    }
    /** return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).
     * This is the number of fractional intervals required to cover a whole circle.
     */
    fractionPeriod() {
        return Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);
    }
    /** return the fractional ized position of the angle,
     * computed without consideration of 2PI period.
     * That is, an angle that is numerically much beyond than the end angle
     * will produce a large fraction and an angle much beyond the start angle
     * will produce a large negative fraction.
     *
     */
    angleToUnboundedFraction(theta) {
        return Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);
    }
    /** map an angle to a fractional coordinate which is:
    *
    * *  the start angle is at fraction 0
    * *  the end angle is at fraction 1
    * *  interior angles are between 0 and 1
    * *  all exterior angles are at fractions greater than 1
    * *  the periodic jump is at full wraparound to the start angle
     */
    angleToPositivePeriodicFraction(theta) { return this.radiansToPositivePeriodicFraction(theta.radians); }
    /**
     * Convert each value in an array from radians to fraction.
     * @param data array that is input as radians, output as fractions
     */
    radiansArraytoPositivePeriodicFractions(data) {
        const n = data.length;
        for (let i = 0; i < n; i++) {
            data.reassign(i, this.radiansToPositivePeriodicFraction(data.at(i)));
        }
    }
    radiansToPositivePeriodicFraction(radians) {
        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        const delta = radians - this._radians0;
        if (sweep > 0) {
            const delta1 = Angle.adjustRadians0To2Pi(delta);
            const fraction1 = Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle.adjustRadians0To2Pi(-delta);
        const fraction2 = Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction2;
    }
    /** map an angle to a fractional coordinate which is:
    *
    * *  the start angle is at fraction 0
    * *  the end angle is at fraction 1
    * *  interior angles are between 0 and 1
    * *  small negative for angles just "before" the start angle
    * *  more than one for angles just "after" the end angle
    * *  the periodic jump is at the middle of the "outside" interval
    */
    angleToSignedPeriodicFraction(theta) {
        return this.radiansToSignedPeriodicFraction(theta.radians);
    }
    radiansToSignedPeriodicFraction(radians) {
        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        // measure from middle of interval ...
        const delta = radians - this._radians0 - 0.5 * sweep;
        if (sweep > 0) {
            const delta1 = Angle.adjustRadiansMinusPiPlusPi(delta);
            const fraction1 = 0.5 + Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle.adjustRadiansMinusPiPlusPi(-delta);
        const fraction = 0.5 + Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction;
    }
    /** test if an angle is within the sweep */
    isAngleInSweep(angle) { return this.isRadiansInSweep(angle.radians); }
    /** test if radians are within sweep  */
    isRadiansInSweep(radians) {
        // quick out for simple inside ...
        const delta0 = radians - this._radians0;
        const delta1 = radians - this._radians1;
        if (delta0 * delta1 <= 0.0)
            return true;
        return this.radiansToPositivePeriodicFraction(radians) <= 1.0;
    }
    /** set this AngleSweep from various sources:
     *
     * * if json is undefined, a full-circle sweep is returned.
     * * If json is an AngleSweep object it is is cloned
     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.
     */
    setFromJSON(json) {
        if (!json)
            this.setStartEndRadians(); // default full circle
        else if (json instanceof AngleSweep)
            this.setFrom(json);
        else if (Geometry.isNumberArray(json.degrees, 2))
            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);
        else if (Geometry.isNumberArray(json.radians, 2))
            this.setStartEndRadians(json.radians[0], json.radians[1]);
        else if (Geometry.isNumberArray(json, 2))
            this.setStartEndDegrees(json[0], json[1]);
    }
    /** create an AngleSweep from a json object. */
    static fromJSON(json) {
        const result = AngleSweep.create360();
        result.setFromJSON(json);
        return result;
    }
    /**
     * Convert an AngleSweep to a JSON object.
     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}
     */
    toJSON() {
        // return { degrees: [this.startDegrees, this.endDegrees] };
        return [this.startDegrees, this.endDegrees];
    }
    /** test if start and end angles match, with no test for 360-degree shifts. */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)
            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
    /** test if start and end angles match, allowing for 360-degree shifts. */
    isAlmostEqualNoPeriodShift(other) {
        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)
            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
}
exports.AngleSweep = AngleSweep;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(3);
const AnalyticGeometry_1 = __webpack_require__(11);
const Transform_1 = __webpack_require__(6);
/** Minimal object containing x,y and operations that are meaningful without change in both point and vector. */
class XY {
    /** Set both x and y. */
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y to zero */
    setZero() { this.x = 0; this.y = 0; }
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y from other. */
    setFrom(other) {
        if (other) {
            this.x = other.x;
            this.y = other.y;
        }
        else {
            this.x = 0;
            this.y = 0;
        }
    }
    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqual(other, tol) { return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol); }
    /** return a json array or object with the [x,y] data.  */
    toJSON() { return [this.x, this.y]; }
    toJSONXY() { return { x: this.x, y: this.y }; }
    /** Set x and y from a JSON source */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0);
            return;
        }
        this.set(0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));
    }
    /** @returns true if the x,y components are both small by metric metric tolerance */
    isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y)); }
    /** Return the magnitude of the vector */
    magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    /** Return the squared magnitude of the vector.  */
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    /** @returns true if the x,y components are exactly equal. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y; }
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector2d.create(other.x - this.x, other.y - this.y, result);
    }
    /** Return a unit vector from this point to other */
    unitVectorTo(target, result) {
        return this.vectorTo(target, result).normalize(result);
    }
}
exports.XY = XY;
/** Minimal object containing x,y,z and operations that are meaningful without change in both point and vector. */
class XYZ {
    /**
     * Set the x,y,z  parts.
     * @param x (optional) x part
     * @param y (optional) y part
     * @param z (optional) z part
     */
    set(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /** Set the x,y,z parts to zero. */
    setZero() { this.x = 0; this.y = 0; this.z = 0; }
    constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /** Type guard for XAndY.
     * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.
     */
    static isXAndY(arg) { return arg.x !== undefined && arg.y !== undefined; }
    /** Type guard to determine whether an object has a member called "z" */
    static hasZ(arg) { return arg.z !== undefined; }
    /** Type guard for XYAndZ.  */
    static isXYAndZ(arg) { return this.isXAndY(arg) && this.hasZ(arg); }
    /**
     * Set the x,y,z parts from one of these input types
     *
     * * XYZ -- copy the x,y,z parts
     * * Float64Array -- Copy from indices 0,1,2 to x,y,z
     * * XY -- copy the x, y parts and set z=0
     */
    setFrom(other) {
        if (XYZ.isXAndY(other)) {
            this.x = other.x;
            this.y = other.y;
            this.z = XYZ.hasZ(other) ? other.z : 0;
        }
        else {
            this.x = other[0];
            this.y = other[1];
            this.z = other[2];
        }
    }
    /** Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.
     * @param other The other XYAndZ to compare
     * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]
     */
    isAlmostEqual(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z, tol);
    }
    /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */
    isAlmostEqualXYZ(x, y, z, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, z, tol);
    }
    /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqualXY(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol);
    }
    /** Return a JSON object as array [x,y,z] */
    toJSON() { return [this.x, this.y, this.z]; }
    toJSONXYZ() { return { x: this.x, y: this.y, z: this.z }; }
    /** Pack the x,y,z values in a Float64Array. */
    toFloat64Array() { return Float64Array.of(this.x, this.y, this.z); }
    /**
     * Set the x,y,z properties from one of several json forms:
     *
     * *  array of numbers: [x,y,z]
     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}
     */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0, json[2] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0, json.z || 0);
            return;
        }
        this.set(0, 0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (xDist * xDist + yDist * yDist + zDist * zDist);
    }
    /** Return the XY distance from this point to other */
    distanceXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared XY distance from this point to other */
    distanceSquaredXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));
    }
    /**
     * Return the x,y, z component corresponding to 0,1,2.
     */
    at(index) { if (index < 0.5)
        return this.x; if (index > 1.5)
        return this.z; return this.y; }
    /** Return the index (0,1,2) of the x,y,z component with largest absolute value */
    indexOfMaxAbs() {
        let index = 0;
        let a = Math.abs(this.x);
        let b = Math.abs(this.y);
        if (b > a) {
            index = 1;
            a = b;
        }
        b = Math.abs(this.z);
        if (b > a) {
            index = 2;
            a = b;
        }
        return index;
    }
    /** Return true if the if x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */
    isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y) && Geometry_1.Geometry.isSmallMetricDistance(this.z);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }
    /** Return the sqrt of the sum of squared x,y,z parts */
    magnitude() { return Math.hypot(this.x, this.y, this.z); }
    /** Return the sum of squared x,y,z parts */
    magnitudeSquared() { return this.x * this.x + this.y * this.y + this.z * this.z; }
    /** Return sqrt of the sum of squared x,y parts */
    magnitudeXY() { return Math.hypot(this.x, this.y); }
    /** Return the sum of squared x,y parts */
    magnitudeSquaredXY() { return this.x * this.x + this.y * this.y; }
    /** exact equality test. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y && this.z === other.z; }
    /** equality test with Geometry.smallMetricDistance tolerance */
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** add x,y,z from other in place. */
    addInPlace(other) { this.x += other.x; this.y += other.y; this.z += other.z; }
    /** add (in place) the scaled x,y,z of other */
    addScaledInPlace(other, scale) {
        this.x += scale * other.x;
        this.y += scale * other.y;
        this.z += scale * other.z;
    }
    /** Multiply the x, y, z parts by scale. */
    scaleInPlace(scale) { this.x *= scale; this.y *= scale; this.z *= scale; }
    /** Clone strongly typed as Point3d */
    cloneAsPoint3d() { return Point3d.create(this.x, this.y, this.z); }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);
    }
    /** Return a multiple of a the (full length) vector from this point to other */
    scaledVectorTo(other, scale, result) {
        return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);
    }
    /** Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.
     * @param other target of created vector.
     * @param result optional result vector.
     */
    unitVectorTo(target, result) { return this.vectorTo(target, result).normalize(result); }
    /** Freeze this XYZ */
    freeze() { Object.freeze(this); }
}
exports.XYZ = XYZ;
class Point3d extends XYZ {
    /** Constructor for Point3d */
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    static fromJSON(json) { const val = new Point3d(); val.setFromJSON(json); return val; }
    /** Return a new Point3d with the same coordinates */
    clone() { return new Point3d(this.x, this.y, this.z); }
    /** Create a new Point3d with given coordinates
     * @param x x part
     * @param y y part
     * @param z z part
     */
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Point3d(x, y, z);
    }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 3)
                return Point3d.create(data[0], data[1], data[2], result);
            if (data.length >= 2)
                return Point3d.create(data[0], data[1], 0, result);
            if (data.length >= 1)
                return Point3d.create(data[0], 0, 0, result);
            return Point3d.create(0, 0, 0, result);
        }
        return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);
    }
    /**
     * Copy x,y,z from
     * @param xyzData flat array of xyzxyz for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPacked(xyzData, pointIndex, result) {
        const indexX = pointIndex * 3;
        if (indexX >= 0 && indexX + 2 < xyzData.length)
            return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);
        return undefined;
    }
    /**
     * Copy and unweight xyzw.
     * @param xyzData flat array of xyzwxyzw for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 4 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPackedXYZW(xyzData, pointIndex, result) {
        const indexX = pointIndex * 4;
        if (indexX >= 0 && indexX + 3 < xyzData.length) {
            const w = xyzData[indexX + 3];
            if (!Geometry_1.Geometry.isSmallMetricDistance(w)) {
                const divW = 1.0 / w;
                return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);
            }
        }
        return undefined;
    }
    /** Create a new point with 000 xyz */
    static createZero(result) { return Point3d.create(0, 0, 0, result); }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a vector
     * *  the result is perpendicular to both vectors, with right hand orientation
     * *  the magnitude of the vector is twice the area of the triangle.
     */
    crossProductToPoints(pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);
    }
    /** Return the triple product of the vectors from this to pointA, pointB, pointC
     *
     * * This is a scalar (number)
     * *  This is 6 times the (signed) volume of the tetrahedron on the 4 points.
     */
    tripleProductToPoints(pointA, pointB, pointC) {
        return Geometry_1.Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);
    }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a scalar
     * *  the magnitude of the vector is twice the signed area of the triangle.
     * *  this is positive for counter-clockwise order of the points, negative for clockwise.
     */
    crossProductToPointsXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);
        const t = fraction - 1.0;
        return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);
    }
    /**
     * Return a ray whose ray.origin is interpolated, and ray.direction is the vector between points with a
     * scale factor applied.
     * @param fraction fractional position between points.
     * @param other endpoint of interpolation
     * @param tangentScale scale factor to apply to the startToEnd vector
     * @param result  optional receiver.
     */
    interpolatePointAndTangent(fraction, other, tangentScale, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dz = other.z - this.z;
        result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);
        if (fraction <= 0.5)
            result.origin.set(this.x + fraction * dx, this.y + fraction * dy, this.z + fraction * dz);
        else {
            const t = fraction - 1.0;
            result.origin.set(other.x + t * dx, other.y + t * dy, other.z + t * dz);
        }
        return result;
    }
    /** Return a point with independent x,y,z fractional interpolation. */
    interpolateXYZ(fractionX, fractionY, fractionZ, other, result) {
        return Point3d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), Geometry_1.Geometry.interpolate(this.z, fractionZ, other.z), result);
    }
    /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */
    interpolatePerpendicularXY(fraction, pointB, fractionXYPerp, result) {
        result = result ? result : new Point3d();
        const vector = pointB.minus(this);
        this.interpolate(fraction, pointB, result);
        result.x -= fractionXYPerp * vector.y;
        result.y += fractionXYPerp * vector.x;
        return result;
    }
    /** Return point minus vector */
    minus(vector, result) {
        return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);
    }
    /** Return point plus vector */
    plusXYZ(dx = 0, dy = 0, dz = 0, result) {
        return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);
    }
    /**
     * Return a point that is scaled from the source point.
     * @param source existing point
     * @param scale scale factor to apply to its x,y,z parts
     * @param result optional point to receive coordinates
     */
    static createScale(source, scale, result) {
        return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);
    }
    /** create a point that is a linear combination (weighted sum) of 2 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     */
    static add2Scaled(pointA, scaleA, pointB, scaleB, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);
    }
    /** Create a point that is a linear combination (weighted sum) of 3 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     * @param pointC third input point.
     * @param scaleC scale factor for pointC
     */
    static add3Scaled(pointA, scaleA, pointB, scaleB, pointC, scaleC, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);
    }
    /**
     * Return the dot product of vectors from this to pointA and this to pointB.
     * @param targetA target point for first vector
     * @param targetB target point for second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y) +
            (targetA.z - this.z) * (targetB.z - this.z);
    }
    /** Return the fractional projection of this onto a line between points.
     *
     */
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction = 0) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point3d = Point3d;
/** 3D vector with x,y,z properties */
class Vector3d extends XYZ {
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    clone() { return new Vector3d(this.x, this.y, this.z); }
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Vector3d(x, y, z);
    }
    /**
     * Create a vector which is cross product of two vectors supplied as separate arguments
     * @param ux x coordinate of vector u
     * @param uy y coordinate of vector u
     * @param uz z coordinate of vector u
     * @param vx x coordinate of vector v
     * @param vy y coordinate of vector v
     * @param vz z coordinate of vector v
     * @param result optional result vector.
     */
    static createCrossProduct(ux, uy, uz, vx, vy, vz, result) {
        return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /**
     * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)
     * @param ax x coordinate of origin
     * @param ay y coordinate of origin
     * @param az z coordinate of origin
     * @param bx x coordinate of target point b
     * @param by y coordinate of target point b
     * @param bz z coordinate of target point b
     * @param cx x coordinate of target point c
     * @param cy y coordinate of target point c
     * @param cz z coordinate of target point c
     */
    addCrossProductToTargetsInPlace(ax, ay, az, bx, by, bz, cx, cy, cz) {
        const ux = bx - ax;
        const uy = by - ay;
        const uz = bz - az;
        const vx = cx - ax;
        const vy = cy - ay;
        const vz = cz - az;
        this.x += uy * vz - uz * vy;
        this.y += uz * vx - ux * vz;
        this.z += ux * vy - uy * vx;
    }
    /**
     * Return the cross product of the vectors from origin to pointA and pointB.
     *
     * * the result is a vector
     * * the result is perpendicular to both vectors, with right hand orientation
     * * the magnitude of the vector is twice the area of the triangle.
     */
    static createCrossProductToPoints(origin, pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);
    }
    /**
     * Return a vector defined by polar coordinates distance and angle from x axis
     * @param r distance measured from origin
     * @param theta angle from x axis to the vector (in xy plane)
     * @param z optional z coordinate
     */
    static createPolar(r, theta, z) {
        return Vector3d.create(r * theta.cos(), r * theta.sin(), z);
    }
    /**
     * Return a vector defined in spherical coordinates.
     * @param r sphere radius
     * @param theta angle in xy plane
     * @param phi angle from xy plane to the vector
     */
    static createSpherical(r, theta, phi) {
        const cosPhi = phi.cos();
        return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), phi.sin());
    }
    static fromJSON(json) { const val = new Vector3d(); val.setFromJSON(json); return val; }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 3)
                return Vector3d.create(data[0], data[1], data[2]);
            if (data.length >= 2)
                return Vector3d.create(data[0], data[1], 0);
            if (data.length >= 1)
                return Vector3d.create(data[0], 0, 0);
            return Vector3d.create(0, 0, 0);
        }
        return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);
    }
    /**
     * Return a vector defined by start and end points (end - start).
     * @param start start point for vector
     * @param end end point for vector
     * @param result optional result
     */
    static createStartEnd(start, end, result) {
        if (result) {
            result.set(end.x - start.x, end.y - start.y, end.z - start.z);
            return result;
        }
        return new Vector3d(end.x - start.x, end.y - start.y, end.z - start.z);
    }
    /**
     * @param x0 start point x coordinate
     * @param y0 start point y coordinate
     * @param z0 start point z coordinate
     * @param x1 end point x coordinate
     * @param y1 end point y coordinate
     * @param z1 end point z coordinate
     * @param result optional result vector
     */
    static createStartEndXYZXYZ(x0, y0, z0, x1, y1, z1, result) {
        if (result) {
            result.set(x1 - x0, y1 - y0, z1 - z0);
            return result;
        }
        return new Vector3d(x1 - x0, y1 - y0, z1 - z0);
    }
    /**
     * Return a vector which is the input vector rotated around the axis vector.
     * @param vector initial vector
     * @param axis axis of rotation
     * @param angle angle of rotation.  If undefined, 90 degrees is implied
     * @param result optional result vector
     */
    static createRotateVectorAroundVector(vector, axis, angle) {
        // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula
        const unitAxis = axis.normalize();
        if (unitAxis) {
            const xProduct = unitAxis.crossProduct(vector);
            if (angle) {
                const c = angle.cos();
                const s = angle.sin();
                return Vector3d.add3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));
            }
            else {
                // implied c = 0, s = 1 . . .
                return vector.plusScaled(unitAxis, unitAxis.dotProduct(vector));
            }
        }
        // unchanged vector if axis is null
        return undefined;
    }
    /**
     * Set (replace) xzz components so they are a vector from point0 to point1
     * @param point0 start point of computed vector
     * @param point1 end point of computed vector.
     */
    setStartEnd(point0, point1) {
        this.x = point1.x - point0.x;
        this.y = point1.y - point0.y;
        this.z = point1.z - point0.z;
    }
    /** Return a vector with 000 xyz parts. */
    static createZero(result) { return Vector3d.create(0, 0, 0, result); }
    /** Return a unit X vector  */
    static unitX() { return new Vector3d(1, 0, 0); }
    /** Return a unit Y vector  */
    static unitY() { return new Vector3d(0, 1, 0); }
    /** Return a unit Z vector  */
    static unitZ() { return new Vector3d(0, 0, 1); }
    /** Divide by denominator, but return undefined if denominator is zero. */
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /**
     * Return a pair object containing (a) property `v` which is a unit vector in the direction
     * of the input and (b) property mag which is the magnitude (length) of the input (instance) prior to normalization.
     * If the instance (input) is a near zero length the `v` property of the output is undefined.
     * @param result optional result.
     */
    normalizeWithLength(result) {
        const magnitude = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector3d();
        return { v: this.safeDivideOrNull(magnitude, result), mag: magnitude };
    }
    /**
     * Return a unit vector parallel with this.  Return undefined if this.magnitude is near zero.
     * @param result optional result.
     */
    normalize(result) { return this.normalizeWithLength(result).v; }
    /**
     * If this vector has nonzero length, divide by the length to change to a unit vector.
     * @returns true if normalization completed.
     */
    normalizeInPlace() {
        const a = Geometry_1.Geometry.inverseMetricDistance(this.magnitude());
        if (!a)
            return false;
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return true;
    }
    /** Return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction = 0) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return numerator / denominator;
    }
    /** Return a new vector with components negated from the calling instance.
     * @param result optional result vector.
     */
    negate(result) {
        result = result ? result : new Vector3d();
        result.x = -this.x;
        result.y = -this.y;
        result.z = -this.z;
        return result;
    }
    /** Return a vector same length as this but rotate 90 degrees CCW */
    rotate90CCWXY(result) {
        result = result ? result : new Vector3d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = this.z;
        return result;
    }
    unitPerpendicularXY(result) {
        result = result ? result : new Vector3d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = 0.0;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector3d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        result.z = this.z;
        return result;
    }
    rotate90Towards(target, result) {
        const normal = this.crossProduct(target).normalize();
        return normal ? normal.crossProduct(this, result) : undefined;
    }
    rotate90Around(axis, result) {
        const unitNormal = axis.normalize();
        return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;
    }
    // Adding vectors
    interpolate(fraction, right, result) {
        result = result ? result : new Vector3d();
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (right.x - this.x);
            result.y = this.y + fraction * (right.y - this.y);
            result.z = this.z + fraction * (right.z - this.z);
        }
        else {
            const t = fraction - 1.0;
            result.x = right.x + t * (right.x - this.x);
            result.y = right.y + t * (right.y - this.y);
            result.z = right.z + t * (right.z - this.z);
        }
        return result;
    }
    plus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        result.z = this.z + vector.z;
        return result;
    }
    minus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        result.z = this.z - vector.z;
        return result;
    }
    /** Return vector + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        result.z = this.z + vector.z * scaleFactor;
        return result;
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;
        return result;
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;
        return result;
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    static add2Scaled(vectorA, scaleA, vectorB, scaleB, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` with all components presented as numbers */
    static add2ScaledXYZ(ax, ay, az, scaleA, bx, by, bz, scaleB, result) {
        return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);
    }
    static add3Scaled(vectorA, scaleA, vectorB, scaleB, vectorC, scaleC, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);
    }
    /** Return vector * scalar */
    scale(scale, result) {
        result = result ? result : new Vector3d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        result.z = this.z * scale;
        return result;
    }
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return new Vector3d();
        return this.scale(length / mag, result);
    }
    unitCrossProduct(vectorB, result) {
        return this.crossProduct(vectorB, result).normalize(result);
    }
    unitCrossProductWithDefault(vectorB, x, y, z, result) {
        const unit = this.crossProduct(vectorB, result).normalize(result);
        if (unit === undefined)
            return Vector3d.create(x, y, z, result);
        return unit;
    }
    normalizeWithDefault(x, y, z, result) {
        const unit = this.normalize(result);
        if (unit)
            return unit;
        return Vector3d.create(x, y, z, result);
    }
    tryNormalizeInPlace(smallestMagnitude = Geometry_1.Geometry.smallMetricDistance) {
        const a = this.magnitude();
        if (a < smallestMagnitude || a === 0.0)
            return false;
        this.scaleInPlace(1.0 / a);
        return true;
    }
    sizedCrossProduct(vectorB, productLength, result) {
        result = this.crossProduct(vectorB, result);
        const length = result.magnitude();
        if (length !== 0)
            result.scale(productLength / length, result);
        return result;
    }
    // products
    crossProductMagnitudeSquared(vectorB) {
        const xx = this.y * vectorB.z - this.z * vectorB.y;
        const yy = this.z * vectorB.x - this.x * vectorB.z;
        const zz = this.x * vectorB.y - this.y * vectorB.x;
        return xx * xx + yy * yy + zz * zz;
    }
    crossProductMagnitude(vectorB) {
        return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));
    }
    dotProduct(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;
    }
    /** Dot product with vector from pointA to pointB */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y)
            + this.z * (pointB.z - pointA.z);
    }
    /** Cross product with vector from pointA to pointB */
    crossProductStartEnd(pointA, pointB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);
    }
    /** Cross product (xy parts only) with vector from pointA to pointB */
    crossProductStartEndXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */
    dotProductStartEndXYZ(pointA, x, y, z) {
        return this.x * (x - pointA.x)
            + this.y * (y - pointA.y)
            + this.z * (z - pointA.z);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as (weighted) x,y,z,w
     * * pointB is a homogeneous point that has to be unweighted
     * * if the weight is near zero metric, the return is zero.
     */
    dotProductStartEndXYZW(pointA, x, y, z, w) {
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return 0.0;
        const dw = 1.0 / w;
        return this.x * (dw * x - pointA.x)
            + this.y * (dw * y - pointA.y)
            + this.z * (dw * z - pointA.z);
    }
    dotProductXY(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y;
    }
    /**
     * Dot product with vector (x,y,z)
     * @param x x component for dot product
     * @param y y component for dot product
     * @param z z component for dot product
     */
    dotProductXYZ(x, y, z = 0) {
        return this.x * x + this.y * y + this.z * z;
    }
    tripleProduct(vectorB, vectorC) {
        return Geometry_1.Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);
    }
    crossProductXY(vectorB) {
        return this.x * vectorB.y - this.y * vectorB.x;
    }
    crossProduct(vectorB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);
    }
    // angles
    angleTo(vectorB) {
        return Geometry_1.Angle.createAtan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));
    }
    angleToXY(vectorB) {
        return Geometry_1.Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));
    }
    planarRadiansTo(vector, planeNormal) {
        const square = planeNormal.dotProduct(planeNormal);
        if (square === 0.0)
            return 0.0;
        const factor = 1.0 / square;
        const projection0 = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);
        const projection1 = vector.plusScaled(planeNormal, -vector.dotProduct(planeNormal) * factor);
        return projection0.signedRadiansTo(projection1, planeNormal);
    }
    planarAngleTo(vector, planeNormal) {
        return Geometry_1.Angle.createRadians(this.planarRadiansTo(vector, planeNormal));
    }
    signedRadiansTo(vector1, vectorW) {
        const p = this.crossProduct(vector1);
        const theta = Math.atan2(p.magnitude(), this.dotProduct(vector1));
        if (vectorW.dotProduct(p) < 0.0)
            return -theta;
        else
            return theta;
    }
    signedAngleTo(vector1, vectorW) { return Geometry_1.Angle.createRadians(this.signedRadiansTo(vector1, vectorW)); }
    /*  smallerUnorientedAngleTo(vectorB: Vector3d): Angle { }
      signedAngleTo(vectorB: Vector3d, upVector: Vector3d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector3d, vectorB: Vector3d): boolean { }
      isInCCWSector(vectorA: Vector3d, vectorB: Vector3d, upVector: Vector3d): boolean { }
      */
    /**
     * Test if this vector is parallel to other.
     * @param other second vector in comparison
     * @param oppositeIsParallel if the vectors are on the same line but in opposite directions, return this value.
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isParallelTo(other, oppositeIsParallel = false, returnValueIfAnInputIsZeroLength = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return returnValueIfAnInputIsZeroLength;
        const cross2 = this.crossProductMagnitudeSquared(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross2 <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    /**
     * Test if this vector is perpendicular to other.
     * @param other second vector in comparison
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isPerpendicularTo(other, returnValueIfAnInputIsZeroLength = false) {
        const aa = this.magnitudeSquared();
        if (aa < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const bb = other.magnitudeSquared();
        if (bb < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const ab = this.dotProduct(other);
        return ab * ab <= Geometry_1.Geometry.smallAngleRadiansSquared * aa * bb;
    }
}
exports.Vector3d = Vector3d;
class Segment1d {
    constructor(x0, x1) {
        this.x0 = x0;
        this.x1 = x1;
    }
    set(x0, x1) { this.x0 = x0, this.x1 = x1; }
    static create(x0 = 0, x1 = 1, result) {
        if (!result)
            return new Segment1d(x0, x1);
        result.set(x0, x1);
        return result;
    }
    setFrom(other) { this.x0 = other.x0; this.x1 = other.x1; }
    clone() { return new Segment1d(this.x0, this.x1); }
    fractionToPoint(fraction) { return Geometry_1.Geometry.interpolate(this.x0, fraction, this.x1); }
    reverseInPlace() { const x = this.x0; this.x0 = this.x1; this.x1 = x; }
    /**
     * Near equality test, using Geometry.isSameCoordinate for tolerances.
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x0, other.x0) && Geometry_1.Geometry.isSameCoordinate(this.x1, other.x1);
    }
    /**
     * Return true if the segment limits are (exactly) 0 and 1
     */
    isExact01() { return this.x0 === 0.0 && this.x1 === 1.0; }
}
exports.Segment1d = Segment1d;
/** Three angles that determine the orientation of an object in space. Sometimes referred to as [TaitBryan angles](https://en.wikipedia.org/wiki/Euler_angles). */
class YawPitchRollAngles {
    constructor(yaw = Geometry_1.Angle.zero(), pitch = Geometry_1.Angle.zero(), roll = Geometry_1.Angle.zero()) {
        this.yaw = yaw;
        this.pitch = pitch;
        this.roll = roll;
    }
    /** Freeze this YawPitchRollAngles */
    freeze() { Object.freeze(this.yaw); Object.freeze(this.pitch); Object.freeze(this.roll); }
    /** constructor for YawPitchRollAngles with angles in degrees. */
    static createDegrees(yawDegrees, pitchDegrees, rollDegrees) {
        return new YawPitchRollAngles(Geometry_1.Angle.createDegrees(yawDegrees), Geometry_1.Angle.createDegrees(pitchDegrees), Geometry_1.Angle.createDegrees(rollDegrees));
    }
    /** constructor for YawPitchRollAngles with angles in radians. */
    static createRadians(yawRadians, pitchRadians, rollRadians) {
        return new YawPitchRollAngles(Geometry_1.Angle.createRadians(yawRadians), Geometry_1.Angle.createRadians(pitchRadians), Geometry_1.Angle.createRadians(rollRadians));
    }
    static fromJSON(json) {
        json = json ? json : {};
        return new YawPitchRollAngles(Geometry_1.Angle.fromJSON(json.yaw), Geometry_1.Angle.fromJSON(json.pitch), Geometry_1.Angle.fromJSON(json.roll));
    }
    setFromJSON(json) {
        json = json ? json : {};
        this.yaw = Geometry_1.Angle.fromJSON(json.yaw);
        this.pitch = Geometry_1.Angle.fromJSON(json.pitch);
        this.roll = Geometry_1.Angle.fromJSON(json.roll);
    }
    /** Convert to a JSON object of form { pitch: 20 , roll: 29.999999999999996 , yaw: 10 }. Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted. */
    toJSON() {
        const val = {};
        if (!this.pitch.isAlmostZero())
            val.pitch = this.pitch.toJSON();
        if (!this.roll.isAlmostZero())
            val.roll = this.roll.toJSON();
        if (!this.yaw.isAlmostZero())
            val.yaw = this.yaw.toJSON();
        return val;
    }
    /**
     * Install all rotations from `other` into `this`.
     * @param other YawPitchRollAngles source
     */
    setFrom(other) {
        this.yaw.setFrom(other.yaw);
        this.pitch.setFrom(other.pitch);
        this.roll.setFrom(other.roll);
    }
    /**
     * * Compare angles between `this` and `other`.
     * * Comparisons are via `isAlmostEqualAllowPeriodShift`.
     * @param other YawPitchRollAngles source
     */
    isAlmostEqual(other) {
        return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)
            && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)
            && this.roll.isAlmostEqualAllowPeriodShift(other.roll);
    }
    /**
     * Make a copy of this YawPitchRollAngles.
     */
    clone() { return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone()); }
    /**
     * Expand the angles into a (rigid rotation) matrix.
     *
     * * The returned matrix is "rigid" -- unit length rows and columns, and its transpose is its inverse.
     * * The "rigid" matrix is always a right handed coordinate system.
     * @param result optional pre-allocated `RotMatrix`
     */
    toRotMatrix(result) {
        const c0 = Math.cos(this.yaw.radians);
        const s0 = Math.sin(this.yaw.radians);
        const c1 = Math.cos(this.pitch.radians);
        const s1 = Math.sin(this.pitch.radians);
        const c2 = Math.cos(this.roll.radians);
        const s2 = Math.sin(this.roll.radians);
        return Transform_1.RotMatrix.createRowValues(c0 * c1, -(s0 * c2 + c0 * s1 * s2), (s0 * s2 - c0 * s1 * c2), s0 * c1, (c0 * c2 - s0 * s1 * s2), -(c0 * s2 + s0 * s1 * c2), s1, c1 * s2, c1 * c2, result);
    }
    /** @returns Return the largest angle in radians */
    maxAbsRadians() {
        return Geometry_1.Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** Return the sum of the angles in squared radians */
    sumSquaredRadians() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** @returns true if the rotation is 0 */
    isIdentity(allowPeriodShift = true) {
        if (allowPeriodShift)
            return Geometry_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)
                && Geometry_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)
                && Geometry_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);
        else
            return Geometry_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)
                && Geometry_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)
                && Geometry_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);
    }
    /** Return the largest difference of angles (in radians) between this and other */
    maxDiffRadians(other) {
        return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);
    }
    /** Return the largest angle in degrees. */
    maxAbsDegrees() { return Geometry_1.Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return the sum of squared angles in degrees. */
    sumSquaredDegrees() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return an object from a Transform as an origin and YawPitchRollAngles. */
    static tryFromTransform(transform) {
        // bundle up the transform's origin with the angle data extracted from the transform
        return {
            angles: YawPitchRollAngles.createFromRotMatrix(transform.matrix),
            origin: Point3d.createFrom(transform.origin),
        };
    }
    /** Attempts to create a YawPitchRollAngles object from an RotMatrix
     * * This conversion fails if the matrix is not rigid (unit rows and columns, transpose is inverse)
     * * In the failure case the method's return value is `undefined`.
     * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with a set of angles.
     */
    static createFromRotMatrix(matrix, result) {
        const s1 = matrix.at(2, 0);
        const c1 = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2));
        const pitchA = Geometry_1.Angle.createAtan2(s1, c1); // with positive cosine
        const pitchB = Geometry_1.Angle.createAtan2(s1, -c1); // with negative cosine
        const angles = result ? result : new YawPitchRollAngles(); // default undefined . . .
        if (c1 < Geometry_1.Geometry.smallAngleRadians) {
            angles.yaw = Geometry_1.Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));
            angles.pitch = pitchA;
            angles.roll = Geometry_1.Angle.createRadians(0.0);
        }
        else {
            const yawA = Geometry_1.Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));
            const rollA = Geometry_1.Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));
            const yawB = Geometry_1.Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));
            const rollB = Geometry_1.Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));
            const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);
            const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);
            const absFactor = 0.95;
            const radiansA = yprA.maxAbsRadians();
            const radiansB = yprB.maxAbsRadians();
            if (radiansA < absFactor * radiansB) {
                angles.setFrom(yprA);
            }
            else if (radiansB < absFactor * radiansA) {
                angles.setFrom(yprB);
            }
            else {
                const sumA = yprA.sumSquaredRadians();
                const sumB = yprB.sumSquaredRadians();
                if (sumA <= sumB) {
                    angles.setFrom(yprA);
                }
                else {
                    angles.setFrom(yprB);
                }
            }
        }
        const matrix1 = angles.toRotMatrix();
        return matrix.maxDiff(matrix1) < Geometry_1.Geometry.smallAngleRadians ? angles : undefined;
    }
}
exports.YawPitchRollAngles = YawPitchRollAngles;
class Point2d extends XY {
    /** Constructor for Point2d */
    constructor(x = 0, y = 0) { super(x, y); }
    clone() { return new Point2d(this.x, this.y); }
    /**
     * Return a point (newly created unless result provided) with given x,y coordinates
     * @param x x coordinate
     * @param y y coordinate
     * @param result optional result
     */
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Point2d(x, y);
    }
    static fromJSON(json) { const val = new Point2d(); val.setFromJSON(json); return val; }
    static createFrom(xy, result) {
        if (xy)
            return Point2d.create(xy.x, xy.y, result);
        return Point2d.create(0, 0, result);
    }
    static createZero(result) { return Point2d.create(0, 0, result); }
    addForwardLeft(tangentFraction, leftFraction, vector) {
        const dx = vector.x;
        const dy = vector.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    forwardLeftInterpolate(tangentFraction, leftFraction, point) {
        const dx = point.x - this.x;
        const dy = point.y - this.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point2d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), result);
        const t = fraction - 1.0;
        return Point2d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), result);
    }
    /** Return a point with independent x,y fractional interpolation. */
    interpolateXY(fractionX, fractionY, other, result) {
        return Point2d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), result);
    }
    /** Return point minus vector */
    minus(vector, result) {
        return Point2d.create(this.x - vector.x, this.y - vector.y, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point2d.create(this.x + vector.x, this.y + vector.y, result);
    }
    /** Return point plus vector */
    plusXY(dx = 0, dy = 0, result) {
        return Point2d.create(this.x + dx, this.y + dy, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point2d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, result);
    }
    /**
     * @returns dot product of vector from this to targetA and vector from this to targetB
     * @param targetA target of first vector
     * @param targetB target of second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y);
    }
    /** Returns the (scalar) cross product of two points/vectors, computed from origin to target1 and target2 */
    crossProductToPoints(target1, target2) {
        const x1 = target1.x - this.x;
        const y1 = target1.y - this.y;
        const x2 = target2.x - this.x;
        const y2 = target2.y - this.y;
        return x1 * y2 - y1 * x2;
    }
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point2d = Point2d;
/** 3D vector with x,y properties */
class Vector2d extends XY {
    constructor(x = 0, y = 0) { super(x, y); }
    clone() { return new Vector2d(this.x, this.y); }
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Vector2d(x, y);
    }
    // unit X vector
    static unitX() { return new Vector2d(1, 0); }
    // unit Y vector
    static unitY() { return new Vector2d(0, 1); }
    // zero vector
    static createZero(result) { return Vector2d.create(0, 0, result); }
    /** copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 2)
                return Vector2d.create(data[0], data[1]);
            if (data.length >= 1)
                return Vector2d.create(data[0], 0);
            return Vector2d.create(0, 0);
        }
        return Vector2d.create(data.x, data.y, result);
    }
    static fromJSON(json) { const val = new Vector2d(); val.setFromJSON(json); return val; }
    static createPolar(r, theta) {
        return Vector2d.create(r * theta.cos());
    }
    static createStartEnd(point0, point1, result) {
        if (result) {
            result.set(point1.x - point0.x, point1.y - point0.y);
            return result;
        }
        return new Vector2d(point1.x - point0.x, point1.y - point0.y);
    }
    static createOffsetBisector(unitPerpA, unitPerpB, offset) {
        let bisector = unitPerpA.plus(unitPerpB);
        bisector = bisector.normalize();
        if (bisector) {
            const c = offset * bisector.dotProduct(unitPerpA);
            return bisector.scale(c);
        }
        return undefined;
    }
    // Divide by denominator, but return undefined if denominator is zero.
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    normalize(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector2d();
        return this.safeDivideOrNull(mag, result);
    }
    /** return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return numerator / denominator;
    }
    /** Negate components */
    negate(result) {
        result = result ? result : new Vector2d();
        result.x = -this.x;
        result.y = -this.y;
        return result;
    }
    // return a vector same length as this but rotate 90 degrees CCW
    rotate90CCWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        return result;
    }
    // return a vector same length as this but rotate 90 degrees CW
    rotate90CWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = yy;
        result.y = -xx;
        return result;
    }
    unitPerpendicularXY(result) {
        result = result ? result : new Vector2d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector2d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        return result;
    }
    /** return the interpolation {this + fraction * (right - this)} */
    interpolate(fraction, right, result) {
        result = result ? result : new Vector2d();
        /* For best last-bit behavior, if fraction is below 0.5, use this as base point.   If above 0.5, use right as base point.   */
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (right.x - this.x);
            result.y = this.y + fraction * (right.y - this.y);
        }
        else {
            const t = fraction - 1.0;
            result.x = right.x + t * (right.x - this.x);
            result.y = right.y + t * (right.y - this.y);
        }
        return result;
    }
    /** return {this + vector}. */
    plus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        return result;
    }
    /** return {this - vector}. */
    minus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        return result;
    }
    /** Return {point + vector \* scalar} */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        return result;
    }
    /** Return {point + vectorA \* scalarA + vectorB \* scalarB} */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        return result;
    }
    /** Return {this + vectorA \* scalarA + vectorB \* scalarB + vectorC \* scalarC} */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        return result;
    }
    /** Return {this * scale} */
    scale(scale, result) {
        result = result ? result : new Vector2d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        return result;
    }
    /** return a vector parallel to this but with specified length */
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return new Vector2d();
        return this.scale(length / mag, result);
    }
    /** return the dot product of this with vectorB */
    dotProduct(vectorB) { return this.x * vectorB.x + this.y * vectorB.y; }
    /** dot product with vector from pointA to pointB */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y);
    }
    /** vector cross product {this CROSS vectorB} */
    crossProduct(vectorB) { return this.x * vectorB.y - this.y * vectorB.x; }
    /** return the (signed) angle from this to vectorB.   This is positive if the shortest turn is counterclockwise, negative if clockwise. */
    angleTo(vectorB) {
        return Geometry_1.Angle.createAtan2(this.crossProduct(vectorB), this.dotProduct(vectorB));
    }
    /*  smallerUnorientedAngleTo(vectorB: Vector2d): Angle { }
      signedAngleTo(vectorB: Vector2d, upVector: Vector2d): Angle { }
      planarAngleTo(vectorB: Vector2d, planeNormal: Vector2d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector2d, vectorB: Vector2d): boolean { }
      isInCCWSector(vectorA: Vector2d, vectorB: Vector2d, upVector: Vector2d): boolean { }
      */
    isParallelTo(other, oppositeIsParallel = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return false;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return false;
        const cross = this.crossProduct(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross * cross <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    isPerpendicularTo(other) {
        return Geometry_1.Angle.isPerpendicularDotSet(this.magnitudeSquared(), other.magnitudeSquared(), this.dotProduct(other));
    }
}
exports.Vector2d = Vector2d;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module IModelApp */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_clients_1 = __webpack_require__(18);
const ViewManager_1 = __webpack_require__(190);
const ToolAdmin_1 = __webpack_require__(214);
const AccuDraw_1 = __webpack_require__(105);
const AccuSnap_1 = __webpack_require__(79);
const ElementLocateManager_1 = __webpack_require__(78);
const TentativePoint_1 = __webpack_require__(215);
const imodeljs_i18n_1 = __webpack_require__(342);
const Tool_1 = __webpack_require__(15);
const imodeljs_common_1 = __webpack_require__(2);
const NotificationManager_1 = __webpack_require__(123);
const System_1 = __webpack_require__(7);
const bentleyjs_core_1 = __webpack_require__(0);
const selectTool = __webpack_require__(236);
const viewTool = __webpack_require__(77);
const idleTool = __webpack_require__(237);
/**
 * An instance of IModelApp is the frontend administrator for applications that read, write, or display an iModel in a browser.
 * It connects the user interface with the iModelJs services. There can be only one IModelApp active in a session.
 *
 * Applications may customize the behavior of the IModelApp services by subclassing this class and supplying different
 * implementations of them.
 *
 * Before any interactive operations may be performed, [[IModelApp.startup]] must be called (typically on a subclass of IModelApp)
 */
class IModelApp {
    static get renderSystem() { return IModelApp._renderSystem; }
    static get initialized() { return IModelApp._initialized; }
    /** IModel Server Client to be used for all frontend operations */
    static get iModelClient() {
        if (!this._imodelClient)
            this._imodelClient = new imodeljs_clients_1.IModelHubClient(this.hubDeploymentEnv);
        else if (this._imodelClient.deploymentEnv !== this.hubDeploymentEnv)
            throw new imodeljs_common_1.IModelError(86017 /* ServerUnavailable */);
        return this._imodelClient;
    }
    static set iModelClient(client) {
        this._imodelClient = client;
    }
    static get hasRenderSystem() { return this._renderSystem !== undefined && this._renderSystem.isValid(); }
    /**
     * This method must be called before any iModelJs frontend services are used. Typically, an application will make a subclass of IModelApp
     * and call this method on that subclass. E.g:
     * ``` ts
     * MyApp extends IModelApp {
     *  . . .
     * }
     * ```
     * in your source somewhere before you use any iModelJs services, call:
     * ``` ts
     * MyApp.startup();
     * ```
     */
    static startup(imodelClient) {
        if (IModelApp._initialized)
            throw new imodeljs_common_1.IModelError(65537 /* AlreadyLoaded */, "startup may only be called once");
        IModelApp._initialized = true;
        if (imodelClient !== undefined)
            this._imodelClient = imodelClient;
        // get the localization system set up so registering tools works. At startup, the only namespace is the system namespace.
        IModelApp.i18n = new imodeljs_i18n_1.I18N(["iModelJs"], "iModelJs", this.supplyI18NOptions());
        const tools = IModelApp.tools; // first register all the core tools. Subclasses may choose to override them.
        const coreNamespace = IModelApp.i18n.registerNamespace("CoreTools");
        tools.registerModule(selectTool, coreNamespace);
        tools.registerModule(idleTool, coreNamespace);
        tools.registerModule(viewTool, coreNamespace);
        this.onStartup(); // allow subclasses to register their tools, etc.
        // the startup function may have already allocated any of these members, so first test whether they're present
        if (!IModelApp._renderSystem)
            IModelApp._renderSystem = this.supplyRenderSystem();
        if (!IModelApp.viewManager)
            IModelApp.viewManager = new ViewManager_1.ViewManager();
        if (!IModelApp.notifications)
            IModelApp.notifications = new NotificationManager_1.NotificationManager();
        if (!IModelApp.toolAdmin)
            IModelApp.toolAdmin = new ToolAdmin_1.ToolAdmin();
        if (!IModelApp.accuDraw)
            IModelApp.accuDraw = new AccuDraw_1.AccuDraw();
        if (!IModelApp.accuSnap)
            IModelApp.accuSnap = new AccuSnap_1.AccuSnap();
        if (!IModelApp.locateManager)
            IModelApp.locateManager = new ElementLocateManager_1.ElementLocateManager();
        if (!IModelApp.tentativePoint)
            IModelApp.tentativePoint = new TentativePoint_1.TentativePoint();
        IModelApp._renderSystem.onInitialized();
        IModelApp.viewManager.onInitialized();
        IModelApp.toolAdmin.onInitialized();
        IModelApp.accuDraw.onInitialized();
        IModelApp.accuSnap.onInitialized();
        IModelApp.locateManager.onInitialized();
        IModelApp.tentativePoint.onInitialized();
    }
    /** Should be called before the application exits to release any held resources. */
    static shutdown() {
        IModelApp.toolAdmin.onShutDown();
        IModelApp._renderSystem = bentleyjs_core_1.dispose(IModelApp._renderSystem);
        IModelApp._initialized = false;
    }
    /**
     * Implement this method to register your app's tools, override implementation of managers, and initialize your app-specific members.
     * @note The default tools will already be registered, so if you register tools with the same toolId, your tools will override the defaults.
     */
    static onStartup() { }
    /**
     * Implement this method to supply options for the initialization of the [I18N]($i18n) system.
     */
    static supplyI18NOptions() { return undefined; }
    /**
     * Implement this method to supply the RenderSystem that provides display capabilities.
     */
    static supplyRenderSystem() { return System_1.System.create(); }
}
IModelApp._initialized = false;
/** The deployment environment of Connect and iModelHub Services - this identifies up the location used to find Projects and iModels. */
IModelApp.hubDeploymentEnv = "QA";
IModelApp.features = new imodeljs_common_1.FeatureGates();
IModelApp.tools = new Tool_1.ToolRegistry();
exports.IModelApp = IModelApp;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(3);
const Geometry4d_1 = __webpack_require__(46);
const Range_1 = __webpack_require__(21);
const PointVector_1 = __webpack_require__(4);
/* tslint:disable:variable-name jsdoc-format*/
/** A RotMatrix is tagged indicating one of the following states:
 * * unknown: it is not know if the matrix is invertible.
 * * inverseStored: the matrix has its inverse stored
 * * singular: the matrix is known to be singular.
 */
var InverseMatrixState;
(function (InverseMatrixState) {
    InverseMatrixState[InverseMatrixState["unknown"] = 0] = "unknown";
    InverseMatrixState[InverseMatrixState["inverseStored"] = 1] = "inverseStored";
    InverseMatrixState[InverseMatrixState["singular"] = 2] = "singular";
})(InverseMatrixState = exports.InverseMatrixState || (exports.InverseMatrixState = {}));
function loadMatrix(dest, a00, a01, a02, a10, a11, a12, a20, a21, a22) {
    dest[0] = a00;
    dest[1] = a01;
    dest[2] = a02;
    dest[3] = a10;
    dest[4] = a11;
    dest[5] = a12;
    dest[6] = a20;
    dest[7] = a21;
    dest[8] = a22;
}
/**
 * * multiply 3x3 matrix `a*b`, store in c.
 * * All params assumed length 9, allocated by caller.
 * * c may alias either input.
 */
function multiplyMatrixMatrix(a, b, result) {
    if (!result)
        result = new Float64Array(9);
    loadMatrix(result, (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]), (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]), (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]), (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]), (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]), (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]), (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));
    return result;
}
/**
 * * multiply 3x3 matrix `a*bTranspose`, store in c.
 * * All params assumed length 9, allocated by caller.
 * * c may alias either input.
 */
function multiplyMatrixMatrixTranspose(a, b, result) {
    if (!result)
        result = new Float64Array(9);
    loadMatrix(result, (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]), (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]), (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]), (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]), (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]), (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]), (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));
    return result;
}
/** transpose 3x3 coefficients in place */
function transpose3x3InPlace(a) {
    let q = a[1];
    a[1] = a[3];
    a[3] = q;
    q = a[2];
    a[2] = a[6];
    a[6] = q;
    q = a[5];
    a[5] = a[7];
    a[7] = q;
}
/** transpose 3x3 coefficients in place */
function copy3x3Transposed(a, dest) {
    if (dest === a) {
        transpose3x3InPlace(a);
    }
    else {
        if (!dest)
            dest = new Float64Array(9);
        dest[0] = a[0];
        dest[1] = a[3];
        dest[2] = a[6];
        dest[3] = a[1];
        dest[4] = a[4];
        dest[5] = a[7];
        dest[6] = a[2];
        dest[7] = a[5];
        dest[8] = a[8];
    }
    return dest;
}
/**
 * * multiply 3x3 matrix `a*bTranspose`, store in c.
 * * All params assumed length 9, allocated by caller.
 * * c may alias either input.
 */
function multiplyMatrixTransposeMatrix(a, b, result) {
    if (!result)
        result = new Float64Array(9);
    loadMatrix(result, (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]), (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]), (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]), (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]), (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]), (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]), (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]), (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]), (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));
    return result;
}
/** A RotMatrix (short for RotationMatrix) is a 3x3 matrix.
 * * The name from common use to hold a rigid body rotation,, but its 3x3 contents can
 * also hold scaling and skewing.
 * * The 9 entries are stored in row-major order in the coffs array.
 * * If the matrix inverse is known it is stored in the inverseCoffs array.
 * * The inverse status (unknown, inverseStored, singular) status is indicated by the inverseState property.
 * * constructions method that are able to determine the inverse store it immediately and
 *     note that in the inverseState.
 * * constructions (e.g. createRowValues) for which the inverse is not immediately known mark the
 *     inverseState as unknown.
 * * Later queries for the inverse trigger full computation if needed at that time.
 * * Most matrix queries are present with both "column" and "row" variants.
 * * Usage elsewhere in the library is typically "column" based.  For example, in a Transform
 *     that carries a coordinate frame the matrix columns are the unit vectors for the axes.
 */
class RotMatrix {
    /**
     *
     * @param coffs optional coefficient array.  This is captured.
     */
    constructor(coffs) {
        this.coffs = coffs ? coffs : new Float64Array(9);
        this.inverseCoffs = undefined;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** Freeze this RotMatrix. */
    freeze() { this.computeCachedInverse(true); Object.freeze(this); }
    /** Return a json object containing the 9 numeric entries as a single array in row major order,
     * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`
     * */
    toJSON() {
        return [[this.coffs[0], this.coffs[1], this.coffs[2]],
            [this.coffs[3], this.coffs[4], this.coffs[5]],
            [this.coffs[6], this.coffs[7], this.coffs[8]]];
    }
    setFromJSON(json) {
        this.inverseCoffs = undefined;
        if (!json) {
            this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return;
        }
        if (!Array.isArray(json)) {
            if (json instanceof RotMatrix)
                this.setFrom(json);
            return;
        }
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 3)) {
            const data = json;
            this.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
            return;
        }
        if (json.length === 9) {
            const data = json;
            this.setRowValues(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);
        }
        else if (json.length === 4) {
            const data = json;
            this.setRowValues(data[0], data[1], 0, data[2], data[3], 0, 0, 0, 1);
        }
    }
    /** @returns Return a new RotMatrix constructed from contents of the json value. */
    static fromJSON(json) { const result = RotMatrix.createIdentity(); result.setFromJSON(json); return result; }
    /** Test if this RotMatrix and other are within tolerance in all numeric entries.
     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol
     */
    isAlmostEqual(other, tol) {
        if (tol)
            return Geometry_1.Geometry.isDistanceWithinTol(this.maxDiff(other), tol);
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /** Test for exact (bitwise) equality with other. */
    isExactEqual(other) { return this.maxDiff(other) === 0.0; }
    /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */
    isXY() {
        return this.coffs[2] === 0.0
            && this.coffs[5] === 0.0
            && this.coffs[6] === 0.0
            && this.coffs[7] === 0.0
            && this.coffs[8] === 1.0;
    }
    // !! does not clear supplied result !!
    static _create(result) { return result ? result : new RotMatrix(); }
    /** @returns a RotMatrix populated by numeric values given in row-major order.
    *  set all entries in the matrix from call parameters appearing in row - major order.
    * @param axx Row x, column x(0, 0) entry
    * @param axy Row x, column y(0, 1) entry
    * @param axz Row x, column z(0, 2) entry
    * @param ayx Row y, column x(1, 0) entry
    * @param ayy Row y, column y(1, 1) entry
    * @param ayz Row y, column z(1, 2) entry
    * @param azx Row z, column x(2, 0) entry
    * @param azy Row z, column y(2, 2) entry
    * @param azz row z, column z(2, 3) entry
    */
    static createRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz, result) {
        result = result ? result : new RotMatrix();
        result.inverseState = InverseMatrixState.unknown;
        result.coffs[0] = axx;
        result.coffs[1] = axy;
        result.coffs[2] = axz;
        result.coffs[3] = ayx;
        result.coffs[4] = ayy;
        result.coffs[5] = ayz;
        result.coffs[6] = azx;
        result.coffs[7] = azy;
        result.coffs[8] = azz;
        return result;
    }
    /**
     * Create a RotMatrix with caller-supplied coefficients and optional inverse coefficients.
     * * The inputs are captured into the new RotMatrix.
     * * The caller is responsible for validity of the inverse coefficients.
     * @param coffs (required) array of 9 coefficients.
     * @param inverseCoffs (optional) array of 9 coefficients.
     * @returns a RotMatrix populated by a coffs array.
     */
    static createCapture(coffs, inverseCoffs) {
        const result = new RotMatrix(coffs);
        if (inverseCoffs) {
            result.inverseCoffs = inverseCoffs;
            result.inverseState = InverseMatrixState.inverseStored;
        }
        else {
            result.inverseState = InverseMatrixState.unknown;
        }
        return result;
    }
    // install all matrix entries.
    static createColumnsInAxisOrder(axisOrder, columnA, columnB, columnC, result) {
        if (!result)
            result = new RotMatrix();
        if (axisOrder === 0 /* XYZ */) {
            result.setColumns(columnA, columnB, columnC);
        }
        else if (axisOrder === 1 /* YZX */) {
            result.setColumns(columnB, columnC, columnA);
        }
        else if (axisOrder === 2 /* ZXY */) {
            result.setColumns(columnC, columnA, columnB);
        }
        else if (axisOrder === 4 /* XZY */) {
            result.setColumns(columnA, columnC, columnB);
        }
        else if (axisOrder === 5 /* YXZ */) {
            result.setColumns(columnB, columnA, columnC);
        }
        else if (axisOrder === 6 /* ZYX */) {
            result.setColumns(columnC, columnB, columnA);
        }
        else {
            result.setColumns(columnA, columnB, columnC);
        }
        return result;
    }
    /**
     *  set all entries in the matrix from call parameters appearing in row-major order.
     * @param axx Row x, column x (0,0) entry
     * @param axy Row x, column y (0,1) entry
     * @param axz Row x, column z (0,2) entry
     * @param ayx Row y, column x (1,0) entry
     * @param ayy Row y, column y (1,1) entry
     * @param ayz Row y, column z (1,2) entry
     * @param azx Row z, column x (2,0) entry
     * @param azy Row z, column y (2,2) entry
     * @param azz row z, column z (2,3) entry
     */
    setRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz) {
        this.coffs[0] = axx;
        this.coffs[1] = axy;
        this.coffs[2] = axz;
        this.coffs[3] = ayx;
        this.coffs[4] = ayy;
        this.coffs[5] = ayz;
        this.coffs[6] = azx;
        this.coffs[7] = azy;
        this.coffs[8] = azz;
        this.inverseState = InverseMatrixState.unknown;
    }
    setIdentity() { this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1); this.setupInverseTranspose(); }
    setZero() { this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0); this.inverseState = InverseMatrixState.singular; }
    setFrom(other) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] = other.coffs[i];
        this.inverseState = InverseMatrixState.unknown; // we don't trust the other .. . .
    }
    clone(result) {
        result = result ? result : new RotMatrix();
        result.setFrom(this);
        return result;
    }
    static createZero() {
        const retVal = new RotMatrix();
        retVal.inverseState = InverseMatrixState.singular;
        return retVal;
    }
    static createIdentity(result) {
        result = result ? result : new RotMatrix();
        result.setIdentity();
        return result;
    }
    /** Create a matrix with uniform scale factors */
    static createUniformScale(scaleFactor) {
        return RotMatrix.createScale(scaleFactor, scaleFactor, scaleFactor);
    }
    /**
     *
     * *  use createHeadsUpPerpendicular to generate a vectorV perpendicular to vectorA
     * *  construct a frame using createRigidFromColumns (vectorA, vectorB, axisOrder)
     */
    static createRigidHeadsUp(vectorA, axisOrder = 2 /* ZXY */, result) {
        const vectorB = RotMatrix.createRigidHeadsUpFavorXYPlane(vectorA);
        const matrix = RotMatrix.createRigidFromColumns(vectorA, vectorB, axisOrder, result);
        if (matrix) {
            matrix.setupInverseTranspose();
            return matrix;
        }
        return RotMatrix.createIdentity(result);
    }
    /**
     *
     * * return a vector that is perpendicular to the input direction.
     * * Among the infinite number of perpendiculars possible, this method
     * favors having one in the xy plane.
     * * Hence, when vectorA is NOT close to the Z axis, the returned vector is Z cross vectorA.
     * * But vectorA is close to the Z axis, the returned vector is unitY cross vectorA.
     */
    static createRigidHeadsUpFavorXYPlane(vector, result) {
        const a = vector.magnitude();
        const b = a / 64.0; // A constant from the dawn of time in the CAD industry.
        if (Math.abs(vector.x) < b && Math.abs(vector.y) < b) {
            return PointVector_1.Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, -1, 0, result);
        }
        return PointVector_1.Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, 0, 1, result);
    }
    /**
   *
   * * return a vector that is perpendicular to the input direction.
   * * Among the infinite number of perpendiculars possible, this method
   * favors having one near the Z.
   * That is achieved by crossing "this" vector with the result of createHeadsUpPerpendicularFavorXYPlane.
   */
    static createHeadsUpPerpendicularNearZ(vector, result) {
        result = RotMatrix.createRigidHeadsUpFavorXYPlane(vector, result);
        return vector.crossProduct(result);
    }
    /** Create a matrix with distinct x,y,z diagonal (scale) entries */
    static createScale(scaleFactorX, scaleFactorY, scaleFactorZ, result) {
        if (result)
            result.setZero();
        else
            result = new RotMatrix();
        result.coffs[0] = scaleFactorX;
        result.coffs[4] = scaleFactorY;
        result.coffs[8] = scaleFactorZ;
        if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {
            result.inverseState = InverseMatrixState.singular;
        }
        else {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,
                0, 1 / scaleFactorY, 0,
                0, 0, 1 / scaleFactorZ]);
        }
        return result;
    }
    /** @returns return a rotation of specified angle around an axis */
    static createRotationAroundVector(axis, angle, result) {
        const c = angle.cos();
        const s = angle.sin();
        const v = 1.0 - c;
        const unit = axis.normalize();
        if (unit) {
            const retVal = RotMatrix.createRowValues(unit.x * unit.x * v + c, unit.x * unit.y * v - s * unit.z, unit.x * unit.z * v + s * unit.y, unit.y * unit.x * v + s * unit.z, unit.y * unit.y * v + c, unit.y * unit.z * v - s * unit.x, unit.z * unit.x * v - s * unit.y, unit.z * unit.y * v + s * unit.x, unit.z * unit.z * v + c, result);
            retVal.setupInverseTranspose();
            return retVal;
        }
        return undefined;
    }
    /*
    // this implementation has problems distinguishing failure (normalize) from small angle.
    public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, error: boolean } {
  
      const result = { axis: Vector3d.unitZ(), angle: Angle.createRadians(0), error: true };
      if (this.isIdentity()) {
        result.error = false;
        return result;
      }
      if (!this.isRigid())
        return result;
      const QminusI = this.clone();
      QminusI.coffs[0] -= 1.0;
      QminusI.coffs[4] -= 1.0;
      QminusI.coffs[8] -= 1.0;
      // Each column of (Q - I) is the motion of the corresponding axis vector
      // during the rotation.
      // Only one of the three axes can really be close to the rotation axis.
      const delta0 = QminusI.columnX();
      const delta1 = QminusI.columnY();
      const delta2 = QminusI.columnZ();
      const cross01 = delta0.crossProduct(delta1);
      const cross12 = delta1.crossProduct(delta2);
      const cross20 = delta2.crossProduct(delta0);
  
      const aa01 = cross01.magnitudeSquared();
      const aa12 = cross12.magnitudeSquared();
      const aa20 = cross20.magnitudeSquared();
  
      const cross = cross01.clone(); // This will end up as the biggest cross product
      const v0 = delta0.clone();  // This will end up as one of the two largest delta vectors
      let aaMax = aa01;
      if (aa12 > aaMax) {
        cross.setFrom(cross12);
        aaMax = aa12;
        v0.setFrom(delta1);
      }
      if (aa20 > aaMax) {
        cross.setFrom(cross20);
        aaMax = aa20;
        v0.setFrom(delta2);
      }
  
      if (aaMax === 0.0) {
        // The vectors did not move.  Just accept the zero rotation, with error flag set.
        return result;
      }
  
      v0.normalizeInPlace();
      // V0 is a unit vector perpendicular to the rotation axis.
      // Rotate it.   Its image V1 is also a unit vector, and the angle from V0 to V1 is the quat angle.
      // CrossProduct is axis vector times sine of angle.
      // Dot Product is cosine of angle.
      // V2 is zero in 180 degree case, so we use the Cross from the search as the axis
      //   as direction, being careful to keep sine positive.
      const v1 = this.multiplyVector(v0);
      const v2 = v0.crossProduct(v1);
      const sine = v2.magnitude();
      if (v2.dotProduct(cross) < 0.0)
        cross.scaleInPlace(-1.0);
      const cosine = v0.dotProduct(v1);
      result.angle.setRadians(Math.atan2(sine, cosine));
      result.axis.setFrom(cross);
      result.error = !result.axis.tryNormalizeInPlace();
      return result;
    }
  */
    /**
     * Compute the (unit vector) axis and angle of rotation.
     * @returns Returns with result.ok === true when the conversion succeeded.
     */
    getAxisAndAngleOfRotation() {
        const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];
        // trace = (xx + yy * zz) * (1-c) + 3 * c = 1 + 2c ==> c = (trace-1) / 2
        const skewXY = this.coffs[3] - this.coffs[1]; // == 2sz
        const skewYZ = this.coffs[7] - this.coffs[5]; // == 2sx
        const skewZX = this.coffs[2] - this.coffs[6]; // == 2sy
        const c = (trace - 1.0) / 2.0;
        const s = Geometry_1.Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0;
        const e = c * c + s * s - 1.0;
        if (Math.abs(e) > Geometry_1.Geometry.smallAngleRadians) {
            // the sine and cosine are not a unit circle point.   bad matrix . ..
            return { axis: PointVector_1.Vector3d.create(0, 0, 1), angle: Geometry_1.Angle.createRadians(0), ok: false };
        }
        if (Math.abs(s) < Geometry_1.Geometry.smallAngleRadians) {
            return { axis: PointVector_1.Vector3d.create(0, 0, 1), angle: Geometry_1.Angle.createRadians(0), ok: true };
        }
        const a = 1.0 / (2.0 * s);
        const result = { axis: PointVector_1.Vector3d.create(skewYZ * a, skewZX * a, skewXY * a), angle: Geometry_1.Angle.createAtan2(s, c), ok: true };
        return result;
    }
    /**
     * @returns return a matrix that rotates from vectorA to vectorB.
     */
    static createRotationVectorToVector(vectorA, vectorB, result) {
        return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);
    }
    /**
     * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.
     * @param vectorA initial vector position
     * @param fraction fractional rotation.  1.0 is "all the way"
     * @param vectorB final vector position
     * @param result optional result matrix.
    */
    static createPartialRotationVectorToVector(vectorA, fraction, vectorB, result) {
        let upVector = vectorA.unitCrossProduct(vectorB);
        if (upVector) {
            return RotMatrix.createRotationAroundVector(upVector, Geometry_1.Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));
        }
        // fail if either vector is zero ...
        if (Geometry_1.Geometry.isSmallMetricDistance(vectorA.magnitude())
            || Geometry_1.Geometry.isSmallMetricDistance(vectorB.magnitude()))
            return undefined;
        // nonzero but aligned vectors ...
        if (vectorA.dotProduct(vectorB) > 0.0)
            return RotMatrix.createIdentity(result);
        // nonzero opposing vectors ..
        upVector = RotMatrix.createHeadsUpPerpendicularNearZ(vectorA, upVector);
        return RotMatrix.createRotationAroundVector(upVector, Geometry_1.Angle.createRadians(fraction * Math.PI));
    }
    /** Create a 90 degree rotation around a principal axis */
    static create90DegreeRotationAroundAxis(axisIndex) {
        axisIndex = Geometry_1.Geometry.cyclic3dAxis(axisIndex);
        if (axisIndex === 0) {
            const retVal = RotMatrix.createRowValues(1, 0, 0, 0, 0, -1, 0, 1, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else if (axisIndex === 1) {
            const retVal = RotMatrix.createRowValues(0, 0, 1, 0, 1, 0, -1, 0, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else {
            const retVal = RotMatrix.createRowValues(0, -1, 0, 1, 0, 0, 0, 0, 1);
            retVal.setupInverseTranspose();
            return retVal;
        }
    }
    /** @returns Return (a copy of) the X column */
    columnX(result) { return PointVector_1.Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result); }
    /** @returns Return (a copy of)the Y column */
    columnY(result) { return PointVector_1.Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result); }
    /** @returns Return (a copy of)the Z column */
    columnZ(result) { return PointVector_1.Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result); }
    /** @returns Return the X column magnitude squared */
    columnXMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** @returns Return the Y column magnitude squared */
    columnYMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** @returns Return the Z column magnitude squared */
    columnZMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** @returns Return the X column magnitude */
    columnXMagnitude() { return Math.hypot(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** @returns Return the Y column magnitude */
    columnYMagnitude() { return Math.hypot(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** @returns Return the Z column magnitude */
    columnZMagnitude() { return Math.hypot(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** @returns the dot product of column X with column Y */
    /** @returns Return the X row magnitude squared */
    rowXMagnitude() { return Math.hypot(this.coffs[0], this.coffs[1], this.coffs[2]); }
    /** @returns Return the Y row magnitude squared */
    rowYMagnitude() { return Math.hypot(this.coffs[3], this.coffs[4], this.coffs[5]); }
    /** @returns Return the Z row magnitude squared */
    rowZMagnitude() { return Math.hypot(this.coffs[6], this.coffs[7], this.coffs[8]); }
    /** @returns the dot product of column X with column Y */
    columnXDotColumnY() {
        return this.coffs[0] * this.coffs[1]
            + this.coffs[3] * this.coffs[4]
            + this.coffs[6] * this.coffs[7];
    }
    /** Return (a copy of) the X row */
    rowX(result) { return PointVector_1.Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result); }
    /** Return (a copy of) the Y row */
    rowY(result) { return PointVector_1.Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result); }
    /** Return (a copy of) the Z row */
    rowZ(result) { return PointVector_1.Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result); }
    /** @returns Return the dot product of the vector parameter with the X column. */
    dotColumnX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6]; }
    /** @returns Return the dot product of the vector parameter with the Y column. */
    dotColumnY(vector) { return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7]; }
    /** @returns Return the dot product of the vector parameter with the Z column. */
    dotColumnZ(vector) { return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8]; }
    /** @returns Return the dot product of the vector parameter with the X row. */
    dotRowX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2]; }
    /** @returns Return the dot product of the vector parameter with the Y row. */
    dotRowY(vector) { return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5]; }
    /** @returns Return the dot product of the vector parameter with the Z row. */
    dotRowZ(vector) { return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8]; }
    /** @returns Return the (vector) cross product of the Z column with the vector parameter. */
    columnZCrossVector(vector, result) {
        return Geometry_1.Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);
    }
    /**
     * Replace current rows Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
     * @param i first row index.  must be 0,1,2 (unchecked)
     * @param j second row index. must be 0,1,2 (unchecked)
     * @param c fist coefficient
     * @param s second coefficient
     */
    applyGivensRowOp(i, j, c, s) {
        let ii = 3 * i;
        let jj = 3 * j;
        const limit = ii + 3;
        for (; ii < limit; ii++, jj++) {
            const a = this.coffs[ii];
            const b = this.coffs[jj];
            this.coffs[ii] = a * c + b * s;
            this.coffs[jj] = -a * s + b * c;
        }
    }
    /**
      * Replace current columns Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
      * This is used in compute intensive inner loops -- there is no
      * checking for i,j being 0,1,2
      * @param i first row index.  must be 0,1,2 (unchecked)
      * @param j second row index. must be 0,1,2 (unchecked)
      * @param c fist coefficient
      * @param s second coefficient
      */
    applyGivensColumnOp(i, j, c, s) {
        const limit = i + 9;
        for (; i < limit; i += 3, j += 3) {
            const a = this.coffs[i];
            const b = this.coffs[j];
            this.coffs[i] = a * c + b * s;
            this.coffs[j] = -a * s + b * c;
        }
    }
    /** Rotate so columns i and j become perpendicular */
    applyJacobiColumnRotation(i, j, matrixU) {
        const uDotU = this.coffs[i] * this.coffs[i] + this.coffs[i + 3] * this.coffs[i + 3] + this.coffs[i + 6] * this.coffs[i + 6];
        const vDotV = this.coffs[j] * this.coffs[j] + this.coffs[j + 3] * this.coffs[j + 3] + this.coffs[j + 6] * this.coffs[j + 6];
        const uDotV = this.coffs[i] * this.coffs[j] + this.coffs[i + 3] * this.coffs[j + 3] + this.coffs[i + 6] * this.coffs[j + 6];
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Geometry_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        matrixU.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this as a product C * U where C has mutually perpendicular columns and
     * U is orthogonal.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    factorPerpendicularColumns(matrixC, matrixU) {
        matrixC.setFrom(this);
        matrixU.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrixC.applyJacobiColumnRotation(0, 1, matrixU)
                + matrixC.applyJacobiColumnRotation(0, 2, matrixU)
                + matrixC.applyJacobiColumnRotation(1, 2, matrixU);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("jacobi iterations", iteration);
                return true;
            }
        }
        return false;
    }
    /** Apply a jacobi step to lambda which evolves towards diagonal. */
    applySymmetricJacobi(i, j, lambda) {
        const uDotU = lambda.at(i, i);
        const vDotV = lambda.at(j, j);
        const uDotV = lambda.at(i, j);
        if (Math.abs(uDotV) < 1.0e-15 * (uDotU + vDotV))
            return 0.0;
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Geometry_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        // Factored form is this *lambda * thisTranspose
        // Let Q be the rotation matrix.  Q*QT is inserted, viz
        //          this*Q * QT * lambda * Q*thisTranspose
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
     * The upper triangle is mirrored to lower triangle to enforce symmetry.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    symmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        matrix.coffs[3] = matrix.coffs[1];
        matrix.coffs[6] = matrix.coffs[2];
        matrix.coffs[7] = matrix.coffs[5];
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = leftEigenvectors.applySymmetricJacobi(0, 1, matrix)
                + leftEigenvectors.applySymmetricJacobi(0, 2, matrix)
                + leftEigenvectors.applySymmetricJacobi(1, 2, matrix);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Apply (in place a jacobi update that zeros out this.at(i,j).*/
    applyFastSymmetricJacobiUpdate(i, // row index of zeroed member
    j, // column index of zeroed member
    k, // other row/column index (different from i and j)
    leftEigenVectors) {
        const indexII = 4 * i;
        const indexJJ = 4 * j;
        const indexIJ = 3 * i + j;
        const indexIK = 3 * i + k;
        const indexJK = 3 * j + k;
        const dotUU = this.coffs[indexII];
        const dotVV = this.coffs[indexJJ];
        const dotUV = this.coffs[indexIJ];
        const jacobi = Geometry_1.Angle.trigValuesToHalfAngleTrigValues(dotUU - dotVV, 2.0 * dotUV);
        if (Math.abs(dotUV) < 1.0e-15 * (dotUU + dotVV))
            return 0.0;
        const c = jacobi.c;
        const s = jacobi.s;
        const cc = c * c;
        const ss = s * s;
        const sc2 = 2.0 * c * s;
        this.coffs[indexII] = cc * dotUU + sc2 * dotUV + ss * dotVV;
        this.coffs[indexJJ] = ss * dotUU - sc2 * dotUV + cc * dotVV;
        this.coffs[indexIJ] = 0.0;
        const a = this.coffs[indexIK];
        const b = this.coffs[indexJK];
        this.coffs[indexIK] = a * c + b * s;
        this.coffs[indexJK] = -s * a + c * b;
        this.coffs[3 * j + i] = 0.0;
        this.coffs[3 * k + i] = this.coffs[indexIK];
        this.coffs[3 * k + j] = this.coffs[indexJK];
        leftEigenVectors.applyGivensColumnOp(i, j, c, s);
        return Math.abs(dotUV);
    }
    /**
   * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
   * The upper triangle is mirrored to lower triangle to enforce symmetry.
   * @param matrixC (allocate by caller, computed here)
   * @param factor  (allocate by caller, computed here)
   */
    fastSymmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrix.applyFastSymmetricJacobiUpdate(0, 1, 2, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(0, 2, 1, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(1, 2, 0, leftEigenvectors);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Create a matrix from column vectors. */
    static createColumns(vectorU, vectorV, vectorW, result) {
        return RotMatrix.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z, result);
    }
    /** Install data from xyz parts of Point4d  (w part of Point4d ignored) */
    setColumnsPoint4dXYZ(vectorU, vectorV, vectorW) {
        this.setRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z);
    }
    /**
     * set entries in one column of the matrix.
     * @param columnIndex column index. this is interpreted cyclically.
     * @param value x,yz, values for column.  If undefined, zeros are installed.
     */
    setColumn(columnIndex, value) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        if (value) {
            this.coffs[index] = value.x;
            this.coffs[index + 3] = value.y;
            this.coffs[index + 6] = value.z;
        }
        else {
            this.coffs[index] = 0.0;
            this.coffs[index + 3] = 0.0;
            this.coffs[index + 6] = 0.0;
        }
    }
    /** Set all columns of the matrix. Any undefined vector is zeros. */
    setColumns(vectorX, vectorY, vectorZ) {
        this.setColumn(0, vectorX);
        this.setColumn(1, vectorY);
        this.setColumn(2, vectorZ);
    }
    setRow(columnIndex, value) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        this.coffs[index] = value.x;
        this.coffs[index + 1] = value.y;
        this.coffs[index + 2] = value.z;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** Return a (copy of) a column of the matrix.
     * @param i column index.  Thnis is corrected to 012 by Geoemtry.cyclic3dAxis.
     */
    getColumn(columnIndex, result) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return PointVector_1.Vector3d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], result);
    }
    /** Return a (copy of) a row of the matrix.
     * @param i row index.  Thnis is corrected to 012 by Geoemtry.cyclic3dAxis.
     */
    getRow(columnIndex, result) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return PointVector_1.Vector3d.create(this.coffs[index], this.coffs[index + 1], this.coffs[index + 2], result);
    }
    /** Create a matrix from column vectors, shuffled into place per AxisTriple */
    static createShuffledColumns(vectorU, vectorV, vectorW, axisOrder, result) {
        const target = RotMatrix._create(result);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 0), vectorU);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 1), vectorV);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 2), vectorW);
        return target;
    }
    /** Create a matrix from row vectors. */
    static createRows(vectorU, vectorV, vectorW, result) {
        return RotMatrix.createRowValues(vectorU.x, vectorU.y, vectorU.z, vectorV.x, vectorV.y, vectorV.z, vectorW.x, vectorW.y, vectorW.z, result);
    }
    /** Create a matrix that scales along a specified direction. The scale factor can be negative. for instance scale of -1.0 (negative one) is a mirror. */
    static createDirectionalScale(direction, scale, result) {
        const unit = direction.normalize();
        if (unit) {
            const x = unit.x;
            const y = unit.y;
            const z = unit.z;
            const a = (scale - 1);
            return RotMatrix.createRowValues(1 + a * x * x, a * x * y, a * x * z, a * y * x, 1 + a * y * y, a * y * z, a * z * x, a * z * y, 1 + a * z * z, result);
        }
        return RotMatrix.createUniformScale(scale);
    }
    /* Create a matrix with the indicated column in the (normalized) direction, and the other two columns perpendicular. All columns are normalized.
     * * The direction vector is normalized and appears in column axisIndex
     * * If the direction vector is not close to Z, the "next" column ((axisIndex + 1) mod 3) will be in the XY plane in the direction of (direction cross Z)
     * * If the direction vector is close to Z, the "next" column ((axisIndex + 1) mode 3) will be in the direction of (direction cross Y)
    */
    // static create1Vector(direction: Vector3d, axisIndex: number): RotMatrix;
    // static createFromXYVectors(vectorX: Vector3d, vectorY: Vector3d, axisIndex: number): RotMatrix;
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
        @return the vector result
    */
    multiplyVector(vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return PointVector_1.Vector3d.create((this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z), (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z), (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z), result);
    }
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
        @return the vector result
    */
    multiplyVectorArrayInPlace(data) {
        for (const v of data)
            v.set((this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z), (this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z), (this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z));
    }
    static XYZMinusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return PointVector_1.Point3d.create(origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z), origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z), origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z), result);
    }
    static XYPlusMatrixTimesXY(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        return PointVector_1.Point2d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y, result);
    }
    static XYZPlusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return PointVector_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    static XYZPlusMatrixTimesCoordinates(origin, matrix, x, y, z, result) {
        return PointVector_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static XYZPlusMatrixTimesWeightedCoordinates(origin, matrix, x, y, z, w, result) {
        return Geometry4d_1.Point4d.create(w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, w, result);
    }
    multiplyTransposeVector(vector, result) {
        result = result ? result : new PointVector_1.Vector3d();
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.
        @return the vector result
    */
    multiplyXYZ(x, y, z, result) {
        result = result ? result : new PointVector_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * xyz, place result in (required) return value.
        @param xyz right side
        @param result result.
    */
    multiplyXYZtoXYZ(xyz, result) {
        const x = xyz.x;
        const y = xyz.y;
        const z = xyz.z;
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.
        @return the vector result
    */
    multiplyXY(x, y, result) {
        result = result ? result : new PointVector_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y);
        result.y = (this.coffs[3] * x + this.coffs[4] * y);
        result.z = (this.coffs[6] * x + this.coffs[7] * y);
        return result;
    }
    // origin + this*[x,y,0].  (no nulls allowed !!)
    originPlusMatrixTimesXY(origin, x, y, result) {
        return PointVector_1.Point3d.create(origin.x + this.coffs[0] * x + this.coffs[1] * y, origin.y + this.coffs[3] * x + this.coffs[4] * y, origin.z + this.coffs[6] * x + this.coffs[7] * y, result);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[1] * y + coffs[2] * z);
        xyzData.y = (coffs[3] * x + coffs[4] * y + coffs[5] * z);
        xyzData.z = (coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyTransposeVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[3] * y + coffs[6] * z);
        xyzData.y = (coffs[1] * x + coffs[4] * y + coffs[7] * z);
        xyzData.z = (coffs[2] * x + coffs[5] * y + coffs[8] * z);
    }
    /** Multiply the (x,y,z) * matrix, i.e. the vector (x,y,z) is a row vector on the left.
     *   @return the vector result
     */
    multiplyTransposeXYZ(x, y, z, result) {
        result = result ? result : new PointVector_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverse(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return PointVector_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverseTranspose(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return PointVector_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z), (this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z), (this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Vector3d.
     */
    multiplyInverseXYZAsVector3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return PointVector_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Point3d.
     */
    multiplyInverseXYZAsPoint3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return PointVector_1.Point3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Multiply two matrices.
     *   @return the matrix result
     */
    multiplyMatrixMatrix(other, result) {
        result = result ? result : new RotMatrix();
        multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `this * otherTranspose`
        @return the matrix result
    */
    multiplyMatrixMatrixTranspose(other, result) {
        result = result ? result : new RotMatrix();
        multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `thisTranspose * other`
        @return the matrix result
    */
    multiplyMatrixTransposeMatrix(other, result) {
        result = result ? result : new RotMatrix();
        multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    //   [Q 0][R A] = [QR QA]
    //   [0 1][0 1]   [0  1]
    /** multiply this RotMatrix (considered as a transform with 0 translation) times other Transform.
     * @param other right hand RotMatrix for multiplication.
     * @param result optional preallocated result to reuse.
    */
    multiplyMatrixTransform(other, result) {
        if (!result)
            return Transform.createRefs(this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z), this.multiplyMatrixMatrix(other.matrix));
        // be sure to do the point mulitplication first before aliasing changes the matrix ..
        this.multiplyXYZtoXYZ(other.origin, result.origin);
        this.multiplyMatrixMatrix(other.matrix, result.matrix);
        return result;
    }
    /** return the transposed matrix */
    transpose(result) {
        if (!result)
            result = new RotMatrix();
        copy3x3Transposed(this.coffs, result.coffs);
        if (this.inverseCoffs !== undefined) {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = copy3x3Transposed(this.inverseCoffs, result.inverseCoffs);
        }
        else {
            result.inverseState = this.inverseState; // singular or unknown.
            result.inverseCoffs = undefined;
        }
        return result;
    }
    /** return the transposed matrix */
    transposeInPlace() {
        transpose3x3InPlace(this.coffs);
        if (this.inverseCoffs)
            transpose3x3InPlace(this.inverseCoffs);
    }
    /** return the inverse matrix.  The return is  null if the matrix is singular (has columns that are coplanar or colinear) */
    inverse(result) {
        this.computeCachedInverse(true);
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs)
            return RotMatrix.createRowValues(this.inverseCoffs[0], this.inverseCoffs[1], this.inverseCoffs[2], this.inverseCoffs[3], this.inverseCoffs[4], this.inverseCoffs[5], this.inverseCoffs[6], this.inverseCoffs[7], this.inverseCoffs[8], result);
        return undefined;
    }
    /** copy the transpose of the coffs to the inverseCoffs.
     * * mark the matrix as inverseStored.
     */
    setupInverseTranspose() {
        const coffs = this.coffs;
        this.inverseState = InverseMatrixState.inverseStored;
        this.inverseCoffs = Float64Array.from([coffs[0], coffs[3], coffs[6],
            coffs[1], coffs[4], coffs[7],
            coffs[2], coffs[5], coffs[8]]);
    }
    /* Alternate implementation of computedCachedInverse - more direct addressing of arrays.
       This is indeed 10% faster than using static work areas. */
    // take the cross product of two rows of source.
    // store as a column of dest.
    static indexedRowCrossProduct(source, rowStart0, rowStart1, dest, columnStart) {
        dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];
        dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];
        dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];
    }
    // take the cross product of two columns of source.
    // store as third column in same RotMatrix.
    // This is private because the columnStart values are unchecked raw indices into the coffs
    indexedColumnCrossProductInPlace(colStart0, colStart1, colStart2) {
        const coffs = this.coffs;
        coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];
        coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];
        coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];
    }
    /** Form cross products among axes in axisOrder.
     * For axis order ABC,
     * * form cross product of column A and B, store in C
     * * form cross product of column C and A, store in B.
     * This means that in the final matrix:
     * * column A is strictly parallel to original column A
     * * column B is linear combination of only original A and B
     * * column C is perpenedicular to A and B of both the original and final.
     * * original column C does not participate in the result.
     */
    axisOrderCrossProductsInPlace(axisOrder) {
        switch (axisOrder) {
            case 0 /* XYZ */: {
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                break;
            }
            case 1 /* YZX */: {
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                break;
            }
            case 2 /* ZXY */: {
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                break;
            }
            case 4 /* XZY */: {
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                break;
            }
            case 5 /* YXZ */: {
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                break;
            }
            case 6 /* ZYX */: {
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                break;
            }
        }
    }
    /** Normalize each column in place.
     * * For false return the magnitudes are stored in the originalMagnitudes vector but no columns are altered.
     * @returns Return true if all columns had nonzero lengths.
     * @param originalMagnitudes optional vector to receive original column magnitudes.
     */
    normalizeColumnsInPlace(originalMagnitudes) {
        const ax = this.columnXMagnitude();
        const ay = this.columnYMagnitude();
        const az = this.columnZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    /** Normalize each row in place */
    normalizeRowsInPlace(originalMagnitudes) {
        const ax = this.rowXMagnitude();
        const ay = this.rowYMagnitude();
        const az = this.rowZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    // take the cross product of two rows of source.
    // store as a column of dest.
    static rowColumnDot(coffA, rowStartA, coffB, columnStartB) {
        return coffA[rowStartA] * coffB[columnStartB] + coffA[rowStartA + 1] * coffB[columnStartB + 3] + coffA[rowStartA + 2] * coffB[columnStartB + 6];
    }
    /** compute the inverse of this RotMatrix. The inverse is stored for later use.
     * @returns Return true if the inverse computed.  (False if the columns collapse to a point, line or plane.)
     */
    computeCachedInverse(useCacheIfAvailable) {
        if (useCacheIfAvailable && RotMatrix.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
            RotMatrix.numUseCache++;
            return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        if (this.inverseCoffs === undefined)
            this.inverseCoffs = new Float64Array(9);
        const coffs = this.coffs;
        const inverseCoffs = this.inverseCoffs;
        RotMatrix.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0);
        RotMatrix.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1);
        RotMatrix.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2);
        RotMatrix.numComputeCache++;
        const d = RotMatrix.rowColumnDot(coffs, 0, inverseCoffs, 0);
        if (d === 0.0) {
            this.inverseState = InverseMatrixState.singular;
            this.inverseCoffs = undefined;
            return false;
        }
        const f = 1.0 / d;
        for (let i = 0; i < 9; i++)
            inverseCoffs[i] *= f;
        this.inverseState = InverseMatrixState.inverseStored;
        // verify inverse
        // const p = new Float64Array(9);
        // for (let i = 0; i < 9; i += 3)
        //   for (let j = 0; j < 3; j++)
        //    p[i + j] = RotMatrix.rowColumnDot (coffs, i, inverseCoffs, j);
        return true;
    }
    /* "Classic" inverse implementation with temporary vectors.
      private static rowX: Vector3d = Vector3d.create();
      private static rowY: Vector3d = Vector3d.create();
      private static rowZ: Vector3d = Vector3d.create();
      private static crossXY: Vector3d = Vector3d.create();
      private static crossZX: Vector3d = Vector3d.create();
      private static crossYZ: Vector3d = Vector3d.create();
    private computeCachedInverse(useCacheIfAvailable: boolean) {
        if (useCacheIfAvailable && RotMatrix.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
          RotMatrix.numUseCache++;
          return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        RotMatrix.numComputeCache++;
        const rowX = this.rowX(RotMatrix.rowX);
        const rowY = this.rowY(RotMatrix.rowY);
        const rowZ = this.rowZ(RotMatrix.rowZ);
        const crossXY = rowX.crossProduct(rowY, RotMatrix.crossXY);
        const crossYZ = rowY.crossProduct(rowZ, RotMatrix.crossYZ);
        const crossZX = rowZ.crossProduct(rowX, RotMatrix.crossZX);
        const d = rowX.dotProduct(crossYZ);  // that's the determinant
        if (d === 0.0) {     // better test?
          this.inverseState = InverseMatrixState.singular;
          this.inverseCoffs = undefined;
          return false;
        }
        const f = 1.0 / d;
        this.inverseState = InverseMatrixState.inverseStored;   // Currently just lists that the inverse has been stored... singular case not handled
        this.inverseCoffs = Float64Array.from([crossYZ.x * f, crossZX.x * f, crossXY.x * f,
        crossYZ.y * f, crossZX.y * f, crossXY.y * f,
        crossYZ.z * f, crossZX.z * f, crossXY.z * f]);
        return true;
      }
    */
    static flatIndexOf(row, column) {
        return 3 * Geometry_1.Geometry.cyclic3dAxis(row) + Geometry_1.Geometry.cyclic3dAxis(column);
    }
    /** Get a column by index (0,1,2), packaged as a Point4d with given weight.   Out of range index is interpreted cyclically.  */
    indexedColumnWithWeight(index, weight, result) {
        index = Geometry_1.Geometry.cyclic3dAxis(index);
        return Geometry4d_1.Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);
    }
    /** return the entry at specific row and column */
    at(row, column) {
        return this.coffs[RotMatrix.flatIndexOf(row, column)];
    }
    /** Set the entry at specific row and column */
    setAt(row, column, value) {
        this.coffs[RotMatrix.flatIndexOf(row, column)] = value;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a RotMatrix whose columns are scaled copies of this RotMatrix.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     * */
    scaleColumns(scaleX, scaleY, scaleZ, result) {
        return RotMatrix.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ, this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ, this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ, result);
    }
    /** create a RotMatrix whose columns are scaled copies of this RotMatrix.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     * */
    scaleColumnsInPlace(scaleX, scaleY, scaleZ) {
        this.coffs[0] *= scaleX;
        this.coffs[1] *= scaleY;
        this.coffs[2] *= scaleZ;
        this.coffs[3] *= scaleX;
        this.coffs[4] *= scaleY;
        this.coffs[5] *= scaleZ;
        this.coffs[6] *= scaleX;
        this.coffs[7] *= scaleY;
        this.coffs[8] *= scaleZ;
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {
            // apply reciprocal scales to the ROWS of the inverse .  . .
            const divX = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleX);
            const divY = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleY);
            const divZ = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleZ);
            if (divX !== undefined && divY !== undefined && divZ !== undefined) {
                this.inverseCoffs[0] *= divX;
                this.inverseCoffs[1] *= divX;
                this.inverseCoffs[2] *= divX;
                this.inverseCoffs[3] *= divY;
                this.inverseCoffs[4] *= divY;
                this.inverseCoffs[5] *= divY;
                this.inverseCoffs[6] *= divZ;
                this.inverseCoffs[7] *= divZ;
                this.inverseCoffs[8] *= divZ;
            }
            else
                this.inverseState = InverseMatrixState.singular;
        }
    }
    /** create a RotMatrix whose rows are scaled copies of this RotMatrix.
     * @param scaleX scale factor for row x
     * @param scaleY scale factor for row y
     * @param scaleZ scale factor for row z
     * @param result optional result.
     * */
    scaleRows(scaleX, scaleY, scaleZ, result) {
        return RotMatrix.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX, this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY, this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ, result);
    }
    /**
     * add scaled values from other RotMatrix to this RotMatrix
     * @param other RotMatrix with values to be added
     * @param scale scale factor to apply to th eadded values.
     */
    addScaledInPlace(other, scale) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] += scale * other.coffs[i];
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a RotMatrix whose values are uniformly scaled from this.
     * @param scale scale factor to apply.
     * @param result optional result.
     * @returns Return the new or repopulated matrix
     */
    scale(scale, result) {
        return RotMatrix.createRowValues(this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale, this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale, this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale, result);
    }
    /** Return the determinant of this matrix. */
    determinant() {
        return this.coffs[0] * this.coffs[4] * this.coffs[8]
            - this.coffs[0] * this.coffs[7] * this.coffs[5]
            + this.coffs[3] * this.coffs[7] * this.coffs[2]
            - this.coffs[3] * this.coffs[1] * this.coffs[8]
            + this.coffs[6] * this.coffs[1] * this.coffs[5]
            - this.coffs[6] * this.coffs[4] * this.coffs[2];
    }
    /** Return an estimate of how independent the columns are.  Near zero is bad. */
    // ConditionNumber(): number;
    /** Return the sum of squares of all entries */
    sumSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of squares of diagonal entries */
    sumDiagonalSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i += 4)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of diagonal entries (also known as the trace) */
    sumDiagonal() {
        return this.coffs[0] + this.coffs[4] + this.coffs[8];
    }
    /** Return the Maximum absolute value of any single entry */
    maxAbs() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i]));
        return a;
    }
    /** Return the maximum absolute difference between corresponding entries */
    maxDiff(other) {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));
        return a;
    }
    /** Test if the matrix is (very near to) an identity */
    isIdentity() {
        return this.maxDiff(RotMatrix.identity) < Geometry_1.Geometry.smallAngleRadians;
    }
    /** Test if the off diagonal entries are all nearly zero */
    isDiagonal() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        return Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** Test if the below diagonal entries are all nearly zero */
    isUpperTriangular() {
        const sumAll = this.sumSquares();
        const sumLow = Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);
        return Math.sqrt(sumLow) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** If the matrix is diagonal and all diagonals are within tolerance, return the first diagonal.  Otherwise return undefined.
     */
    sameDiagonalScale() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        if (Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))
            && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[4]) && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))
            return this.coffs[0];
        return undefined;
    }
    /** Sum of squared differences between symmetric pairs */
    sumSkewSquares() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1] - this.coffs[3], this.coffs[2] - this.coffs[6], this.coffs[5] - this.coffs[7]);
    }
    /** Test if the matrix is a pure rotation. */
    isRigid(allowMirror = false) {
        return this.hasPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);
    }
    /** Test if all rows and columns are perpendicular to each other and have equal length.
     * If so, the length (or its negative) is the scale factor from a set of rigid axes to these axes.
     * * result.rigidAxes is the rigid axes (with the scale factor removed)
     * * result.scale is the scale factor
     */
    factorRigidWithSignedScale() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        const ss = product.sameDiagonalScale();
        if (ss === undefined || ss <= 0.0)
            return undefined;
        const s = this.determinant() > 0 ? Math.sqrt(ss) : -Math.sqrt(ss);
        const divS = 1.0 / s;
        const result = { rigidAxes: this.scaleColumns(divS, divS, divS), scale: s };
        return result;
    }
    /** Test if the matrix is shuffles and negates columns. */
    isSignedPermutation() {
        let count = 0;
        for (let row = 0; row < 3; row++)
            for (let col = 0; col < 3; col++) {
                const q = this.at(row, col);
                if (q === 0) {
                }
                else if (q === 1 || q === -1) {
                    // the rest of this row and column should be 0.
                    // "at" will apply cyclic indexing.
                    count++;
                    if (this.at(row + 1, col) !== 0)
                        return false;
                    if (this.at(row + 2, col) !== 0)
                        return false;
                    if (this.at(row, col + 1) !== 0)
                        return false;
                    if (this.at(row, col + 2) !== 0)
                        return false;
                }
                else {
                    return false;
                }
            }
        return count === 3;
    }
    /** Test if all rows and columns are length 1 and are perpendicular to each other.  (I.e. the matrix is either a pure rotation with uniform scale factor of 1 or -1) */
    hasPerpendicularUnitRowsAndColumns() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        return product.isIdentity();
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * vectorA is placed in the first column of the axis order.
     * vectorB is projected perpendicular to vectorA within their plane and placed in the second column.
     */
    static createRigidFromColumns(vectorA, vectorB, axisOrder, result) {
        const vectorA1 = vectorA.normalize();
        if (vectorA1) {
            const vectorC1 = vectorA1.unitCrossProduct(vectorB);
            if (vectorC1) {
                const vectorB1 = vectorC1.unitCrossProduct(vectorA);
                if (vectorB1) {
                    const retVal = RotMatrix.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);
                    retVal.setupInverseTranspose();
                    return retVal;
                }
            }
        }
        return undefined;
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * columns are taken from the source RotMatrix in order indicated by the axis order.
     */
    static createRigidFromRotMatrix(source, axisOrder = 0 /* XYZ */, result) {
        result = source.clone(result);
        result.axisOrderCrossProductsInPlace(axisOrder);
        if (result.normalizeColumnsInPlace())
            return result;
        return undefined;
    }
}
RotMatrix.useCachedInverse = true; // cached inverse can be suppressed for testing.
RotMatrix.numUseCache = 0;
RotMatrix.numComputeCache = 0;
RotMatrix.identity = RotMatrix.createIdentity();
exports.RotMatrix = RotMatrix;
/** A transform is an origin and a RotMatrix.
 *
 * * This describes a coordinate frame with
 * this origin, with the columns of the RotMatrix being the
 * local x,y,z axis directions.
 * *  Beware that for common transformations (e.g. scale about point,
 * rotate around line, mirror across a plane) the "fixed point" that is used
 * when describing the transform is NOT the "origin" stored in the transform.
 * Setup methods (e.g createFixedPointAndMatrix, createScaleAboutPoint)
 * take care of determining the appropriate origin coordinates.
 */
class Transform {
    // Constructor accepts and uses POINTER to content .. no copy here.
    constructor(origin, matrix) { this._origin = origin; this._matrix = matrix; }
    freeze() { Object.freeze(this); Object.freeze(this._origin); this._matrix.freeze(); }
    setFrom(other) { this._origin.setFrom(other._origin), this._matrix.setFrom(other._matrix); }
    /** Set this Transform to be an identity. */
    setIdentity() { this._origin.setZero(); this._matrix.setIdentity(); }
    setFromJSON(json) {
        if (json) {
            if (json instanceof Object && json.origin && json.matrix) {
                this._origin.setFromJSON(json.origin);
                this._matrix.setFromJSON(json.matrix);
                return;
            }
            if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 4)) {
                const data = json;
                this._matrix.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
                this._origin.set(data[0][3], data[1][3], data[2][3]);
                return;
            }
        }
        this.setIdentity();
    }
    /**
     * Test for near equality with other Transform.  Comparison uses the isAlmostEqual methods on
     * the origin and matrix parts.
     * @param other Transform to compare to.
     */
    isAlmostEqual(other) { return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqual(other._matrix); }
    toJSON() {
        // return { origin: this._origin.toJSON(), matrix: this._matrix.toJSON() };
        return [
            [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],
            [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],
            [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],
        ];
    }
    static fromJSON(json) {
        const result = Transform.createIdentity();
        result.setFromJSON(json);
        return result;
    }
    /** Copy the contents of this transform into a new Transform (or to the result, if specified). */
    clone(result) {
        if (result) {
            result._matrix.setFrom(this._matrix);
            result._origin.setFrom(this._origin);
            return result;
        }
        return new Transform(PointVector_1.Point3d.createFrom(this._origin), this._matrix.clone());
    }
    /** @returns Return a copy of this Transform, modified so that its axes are rigid
     */
    cloneRigid(axisOrder = 0 /* XYZ */) {
        const axes0 = RotMatrix.createRigidFromRotMatrix(this.matrix, axisOrder);
        if (!axes0)
            return undefined;
        return new Transform(this.origin.cloneAsPoint3d(), axes0);
    }
    /** Create a copy with the given origin and matrix captured as the Transform origin and RotMatrix. */
    static createRefs(origin, matrix, result) {
        if (result) {
            result._origin = origin;
            result._matrix = matrix;
            return result;
        }
        return new Transform(origin, matrix);
    }
    /**
     * create a Transform with translation provided by x,y,z parts.
     * @param x x part of translation
     * @param y y part of translation
     * @param z z part of translation
     * @param result optional result
     * @returns new or updated transform.
     */
    static createTranslationXYZ(x = 0, y = 0, z = 0, result) {
        return Transform.createRefs(PointVector_1.Vector3d.create(x, y, z), RotMatrix.createIdentity(), result);
    }
    /** Create a matrix with specified translation part.
     * @param XYZ x,y,z parts of the translation.
     * @returns new or updated transform.
     */
    static createTranslation(translation, result) {
        return Transform.createRefs(translation, RotMatrix.createIdentity(), result);
    }
    /** Return a reference to the matrix within the transform.  (NOT a copy) */
    get matrix() { return this._matrix; }
    /** Return a reference to the origin within the transform.  (NOT a copy) */
    get origin() { return this._origin; }
    /** return a (clone of) the origin part of the transform, as a Point3d */
    getOrigin() { return PointVector_1.Point3d.createFrom(this._origin); }
    /** return a (clone of) the origin part of the transform, as a Vector3d */
    getTranslation() { return PointVector_1.Vector3d.createFrom(this._origin); }
    /** test if the transform has 000 origin and identity RotMatrix */
    isIdentity() {
        return this._matrix.isIdentity() && this._origin.isAlmostZero();
    }
    /** Return an identity transform, optionally filling existing transform.  */
    static createIdentity(result) {
        if (result) {
            result._origin.setZero();
            result._matrix.setIdentity();
            return result;
        }
        return Transform.createRefs(PointVector_1.Point3d.createZero(), RotMatrix.createIdentity());
    }
    /** Create by directly installing origin and matrix
     * this is a the appropriate construction when the columns of the matrix are coordinate axes of a local-to-global mapping
     * Note there is a closely related createFixedPointAndMatrix whose point input is the fixed point of the global-to-global transformation.
     */
    static createOriginAndMatrix(origin, matrix, result) {
        return Transform.createRefs(origin ? origin.cloneAsPoint3d() : PointVector_1.Point3d.createZero(), matrix === undefined ? RotMatrix.createIdentity() : matrix.clone(), result);
    }
    /** Create by directly installing origin and columns of the matrix
    */
    static createOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ, result) {
        if (result)
            result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);
        else
            result = Transform.createRefs(PointVector_1.Vector3d.createFrom(origin), RotMatrix.createColumns(vectorX, vectorY, vectorZ));
        return result;
    }
    /** Reinitialize by directly installing origin and columns of the matrix
     */
    setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ) {
        this._origin.setFrom(origin);
        this._matrix.setColumns(vectorX, vectorY, vectorZ);
    }
    /** Create a transform with the specified matrix. Compute an origin (different from the given fixedPoint)
     * so that the fixedPoint maps back to itself.
     */
    static createFixedPointAndMatrix(fixedPoint, matrix, result) {
        const origin = RotMatrix.XYZMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix.clone(), result);
    }
    /** Create a Transform which leaves the fixedPoint unchanged and
     * scales everything else around it by a single scale factor.
     */
    static createScaleAboutPoint(fixedPoint, scale, result) {
        const matrix = RotMatrix.createScale(scale, scale, scale);
        const origin = RotMatrix.XYZMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix, result);
    }
    /** Transform the input 2d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint2d(source, result) {
        return RotMatrix.XYPlusMatrixTimesXY(this._origin, this._matrix, source, result);
    }
    /** Transform the input 3d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint3d(point, result) {
        return RotMatrix.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);
    }
    /** Transform the input point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZ(x, y, z, result) {
        return RotMatrix.XYZPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZW(x, y, z, w, result) {
        return RotMatrix.XYZPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);
    }
    /** for each point:  replace point by Transform*point */
    multiplyPoint3dArrayInPlace(points) {
        let point;
        for (point of points)
            RotMatrix.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);
    }
    /** @returns Return product of the transform's inverse times a point. */
    multiplyInversePoint3d(point, result) {
        return this._matrix.multiplyInverseXYZAsPoint3d(point.x - this._origin.x, point.y - this._origin.y, point.z - this._origin.z, result);
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyInversePoint3dArray(source, result) {
        if (!this._matrix.computeCachedInverse(true))
            return undefined;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        if (result) {
            const n = Transform.matchArrayLengths(source, result, PointVector_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, result[i]);
        }
        result = [];
        for (const p of source)
            result.push(this._matrix.multiplyInverseXYZAsPoint3d(p.x - originX, p.y - originY, p.z - originZ));
        return result;
    }
    /**
      * *  for each point:   multiply    transform * point
      * *  if result is given, resize to match source and replace each corresponding pi
      * *  if result is not given, return a new array.
      */
    multiplyInversePoint3dArrayInPlace(source) {
        if (!this._matrix.computeCachedInverse(true))
            return undefined;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        const n = source.length;
        for (let i = 0; i < n; i++)
            this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, source[i]);
    }
    // modify destination so it has non-null points for the same length as the source.
    // (ASSUME existing elements of dest are non-null, and that parameters are given as either Point2d or Point3d arrays)
    static matchArrayLengths(source, dest, constructionFunction) {
        const numSource = source.length;
        const numDest = dest.length;
        if (numSource > numDest) {
            for (let i = numDest; i < numSource; i++) {
                dest.push(constructionFunction());
            }
        }
        else if (numDest > numSource) {
            dest.length = numSource;
        }
        return numSource;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint2dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, PointVector_1.Point2d.createZero);
            for (let i = 0; i < n; i++)
                RotMatrix.XYPlusMatrixTimesXY(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(RotMatrix.XYPlusMatrixTimesXY(this._origin, this._matrix, p));
        return result;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint3dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, PointVector_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                RotMatrix.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(RotMatrix.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, p));
        return result;
    }
    /** Multiply the vector by the RotMatrix part of the transform.
     *
     * *  The transform's origin is not used.
     * *  Return as new or result by usual optional result convention
     */
    multiplyVector(vector, result) {
        return this._matrix.multiplyVector(vector, result);
    }
    /** Multiply the vector (x,y,z) by the RotMatrix part of the transform.
   *
   * *  The transform's origin is not used.
   * *  Return as new or result by usual optional result convention
   */
    multiplyVectorXYZ(x, y, z, result) {
        return this._matrix.multiplyXYZ(x, y, z, result);
    }
    /** multiply this Transform times other Transform.
     * @param other right hand transform for multiplication.
     * @param result optional preallocated result to reuse.
    */
    multiplyTransformTransform(other, result) {
        if (!result)
            return Transform.createRefs(RotMatrix.XYZPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin), this._matrix.multiplyMatrixMatrix(other._matrix));
        result.setMultiplyTransformTransform(this, other);
        return result;
    }
    /**
     * multiply transformA * transformB, store to calling instance.
     * @param transformA left operand
     * @param transformB right operand
     */
    setMultiplyTransformTransform(transformA, transformB) {
        if (Transform.scratchPoint === undefined)
            Transform.scratchPoint = PointVector_1.Point3d.create();
        RotMatrix.XYZPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, Transform.scratchPoint);
        this._origin.setFrom(Transform.scratchPoint);
        transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);
    }
    //   [Q A][R 0] = [QR A]
    //   [0 1][0 1]   [0  1]
    /** multiply this Transform times other RotMatrix, with other considered to be a Transform with 0 translation.
     * @param other right hand RotMatrix for multiplication.
     * @param result optional preallocated result to reuse.
    */
    multiplyTransformRotMatrix(other, result) {
        if (!result)
            return Transform.createRefs(this._origin.cloneAsPoint3d(), this._matrix.multiplyMatrixMatrix(other));
        this._matrix.multiplyMatrixMatrix(other, result._matrix);
        result._origin.setFrom(this._origin);
        return result;
    }
    /** transform each of the 8 corners of a range. Return the range of the transformed corers */
    multiplyRange(range, result) {
        // snag current values to allow aliasing.
        const lowx = range.low.x;
        const lowy = range.low.y;
        const lowz = range.low.z;
        const highx = range.high.x;
        const highy = range.high.y;
        const highz = range.high.z;
        result = Range_1.Range3d.createNull(result);
        result.extendTransformedXYZ(this, lowx, lowy, lowz);
        result.extendTransformedXYZ(this, highx, lowy, lowz);
        result.extendTransformedXYZ(this, lowx, highy, lowz);
        result.extendTransformedXYZ(this, highx, highy, lowz);
        result.extendTransformedXYZ(this, lowx, lowy, highz);
        result.extendTransformedXYZ(this, highx, lowy, highz);
        result.extendTransformedXYZ(this, lowx, highy, highz);
        result.extendTransformedXYZ(this, highx, highy, highz);
        return result;
    }
    /**
     * @returns Return a Transform which is the inverse of this transform. Return undefined if this Transform's matrix is singular.
     */
    inverse() {
        const matrixInverse = this._matrix.inverse();
        if (!matrixInverse)
            return undefined;
        return Transform.createRefs(matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z), matrixInverse);
    }
    /** Initialize transforms that map each direction of a box (axis aligned) to `[0,1]`.
     * @param min the "000" corner of the box
     * @param max the "111" corner of the box
     * @param npcToGlobal (object created by caller, re-initialized) transform that carries 01 coordinates into the min,max box.
     * @param globalToNpc (object created by caller, re-initialized) transform that carries world coordinates into 01
     */
    static initFromRange(min, max, npcToGlobal, globalToNpc) {
        const diag = max.minus(min);
        if (diag.x === 0.0)
            diag.x = 1.0;
        if (diag.y === 0.0)
            diag.y = 1.0;
        if (diag.z === 0.0)
            diag.z = 1.0;
        const rMatrix = new RotMatrix();
        if (npcToGlobal) {
            RotMatrix.createScale(diag.x, diag.y, diag.z, rMatrix);
            Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);
        }
        if (globalToNpc) {
            const origin = new PointVector_1.Point3d(-min.x / diag.x, -min.y / diag.y, -min.z / diag.z);
            RotMatrix.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);
            Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);
        }
    }
} // endClass Transform
exports.Transform = Transform;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(17);
const Target_1 = __webpack_require__(217);
const GeometryListBuilder_1 = __webpack_require__(220);
const Graphic_1 = __webpack_require__(64);
const IModelConnection_1 = __webpack_require__(120);
const bentleyjs_core_1 = __webpack_require__(0);
const Technique_1 = __webpack_require__(229);
const IModelApp_1 = __webpack_require__(5);
const RenderState_1 = __webpack_require__(82);
const FrameBuffer_1 = __webpack_require__(83);
const RenderBuffer_1 = __webpack_require__(124);
const Texture_1 = __webpack_require__(19);
const GL_1 = __webpack_require__(8);
const Polyline_1 = __webpack_require__(128);
const PointString_1 = __webpack_require__(234);
const Mesh_1 = __webpack_require__(102);
const PointCloud_1 = __webpack_require__(382);
const EdgeOverrides_1 = __webpack_require__(55);
const Material_1 = __webpack_require__(130);
const CachedGeometry_1 = __webpack_require__(29);
const Primitive_1 = __webpack_require__(65);
const ClipVolume_1 = __webpack_require__(235);
/** Describes the rendering capabilities of the host system. */
class Capabilities {
    constructor() {
        this._maxRenderType = 0 /* TextureUnsignedByte */;
        this._maxDepthType = 0 /* RenderBufferUnsignedShort16 */;
        this._maxTextureSize = 0;
        this._maxColorAttachments = 0;
        this._maxDrawBuffers = 0;
        this._maxFragTextureUnits = 0;
        this._maxVertTextureUnits = 0;
        this._maxVertAttribs = 0;
        this._maxVertUniformVectors = 0;
        this._maxVaryingVectors = 0;
        this._maxFragUniformVectors = 0;
        this._extensionMap = {}; // Use this map to store actual extension objects retrieved from GL.
    }
    get maxRenderType() { return this._maxRenderType; }
    get maxDepthType() { return this._maxDepthType; }
    get maxTextureSize() { return this._maxTextureSize; }
    get maxColorAttachments() { return this._maxColorAttachments; }
    get maxDrawBuffers() { return this._maxDrawBuffers; }
    get maxFragTextureUnits() { return this._maxFragTextureUnits; }
    get maxVertTextureUnits() { return this._maxVertTextureUnits; }
    get maxVertAttribs() { return this._maxVertAttribs; }
    get maxVertUniformVectors() { return this._maxVertUniformVectors; }
    get maxVaryingVectors() { return this._maxVaryingVectors; }
    get maxFragUniformVectors() { return this._maxFragUniformVectors; }
    /** These getters check for existence of extension objects to determine availability of features.  In WebGL2, could just return true for some. */
    get supportsNonPowerOf2Textures() { return false; }
    get supportsDrawBuffers() { return this.queryExtensionObject("WEBGL_draw_buffers") !== undefined; }
    get supports32BitElementIndex() { return this.queryExtensionObject("OES_element_index_uint") !== undefined; }
    get supportsTextureFloat() { return this.queryExtensionObject("OES_texture_float") !== undefined; }
    get supportsTextureHalfFloat() { return this.queryExtensionObject("OES_texture_half_float") !== undefined; }
    get supportsShaderTextureLOD() { return this.queryExtensionObject("EXT_shader_texture_lod") !== undefined; }
    /** Queries an extension object if available.  This is necessary for other parts of the system to access some constants within extensions. */
    queryExtensionObject(ext) {
        const extObj = this._extensionMap[ext];
        return (null !== extObj) ? extObj : undefined;
    }
    /** Initializes the capabilities based on a GL context. Must be called first. */
    init(gl) {
        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this._maxFragTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this._maxVertTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._maxVertAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._maxVertUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this._maxVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);
        this._maxFragUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        const extensions = gl.getSupportedExtensions(); // This just retrieves a list of available extensions (not necessarily enabled).
        if (extensions) {
            for (const ext of extensions) {
                if (ext === "WEBGL_draw_buffers" || ext === "OES_element_index_uint" || ext === "OES_texture_float" ||
                    ext === "OES_texture_half_float" || ext === "WEBGL_depth_texture" || ext === "EXT_color_buffer_float" ||
                    ext === "EXT_shader_texture_lod") {
                    const extObj = gl.getExtension(ext); // This call enables the extension and returns a WebGLObject containing extension instance.
                    if (null !== extObj)
                        this._extensionMap[ext] = extObj;
                }
            }
        }
        const dbExt = this.queryExtensionObject("WEBGL_draw_buffers");
        this._maxColorAttachments = dbExt !== undefined ? gl.getParameter(dbExt.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
        this._maxDrawBuffers = dbExt !== undefined ? gl.getParameter(dbExt.MAX_DRAW_BUFFERS_WEBGL) : 1;
        // Determine the maximum color-renderable attachment type.
        if (this.isTextureRenderable(gl, gl.FLOAT))
            this._maxRenderType = 2 /* TextureFloat */;
        else {
            const hfExt = this.queryExtensionObject("OES_texture_half_float");
            this._maxRenderType = (hfExt !== undefined && this.isTextureRenderable(gl, hfExt.HALF_FLOAT_OES)) ? 1 /* TextureHalfFloat */ : 0 /* TextureUnsignedByte */;
        }
        // Determine the maximum depth attachment type.
        this._maxDepthType = this.queryExtensionObject("WEBGL_depth_texture") !== undefined ? 1 /* TextureUnsignedInt32 */ : 0 /* RenderBufferUnsignedShort16 */;
        // Return based on currently-required features.  This must change if the amount used is increased or decreased.
        return this.hasRequiredFeatures && this.hasRequiredDrawTargets && this.hasRequiredTextureUnits;
    }
    static create(gl) {
        const caps = new Capabilities();
        return caps.init(gl) ? caps : undefined;
    }
    /** Determines if a particular texture type is color-renderable on the host system. */
    isTextureRenderable(gl, texType) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, texType, null);
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(fb);
        gl.deleteTexture(tex);
        gl.getError(); // clear any errors
        return fbStatus === gl.FRAMEBUFFER_COMPLETE;
    }
    /** Determines if the required features are supported (list could change).  These are not necessarily extensions (looking toward WebGL2). */
    get hasRequiredFeatures() {
        return this.supportsDrawBuffers && this.supports32BitElementIndex;
    }
    /** Determines if the required number of draw targets are supported (could change). */
    get hasRequiredDrawTargets() {
        return this.maxColorAttachments > 3 && this.maxDrawBuffers > 3;
    }
    /** Determines if the required number of texture units are supported in vertex and fragment shader (could change). */
    get hasRequiredTextureUnits() {
        return this.maxFragTextureUnits > 4 && this.maxVertTextureUnits > 5;
    }
}
exports.Capabilities = Capabilities;
/** Id map holds key value pairs for both materials and textures, useful for caching such objects. */
class IdMap {
    constructor() {
        /** Array of textures without key values (unnamed). */
        this.keylessTextures = [];
        this.materials = new Map();
        this.textures = new Map();
        this.gradients = new bentleyjs_core_1.Dictionary(imodeljs_common_1.Gradient.Symb.compareSymb);
        this.clipVolumes = new Map();
    }
    dispose() {
        const textureArr = Array.from(this.textures.values());
        const gradientArr = this.gradients.extractArrays().values;
        const clipVolumeArr = Array.from(this.clipVolumes.values());
        for (const texture of textureArr)
            bentleyjs_core_1.dispose(texture);
        for (const gradient of gradientArr)
            bentleyjs_core_1.dispose(gradient);
        for (const texture of this.keylessTextures)
            bentleyjs_core_1.dispose(texture);
        for (const clipVolume of clipVolumeArr)
            bentleyjs_core_1.dispose(clipVolume);
        this.textures.clear();
        this.gradients.clear();
        this.clipVolumes.clear();
        this.keylessTextures.length = 0;
    }
    /** Add a material to this IdMap, given that it has a valid key. */
    addMaterial(material) {
        if (material.key)
            this.materials.set(material.key, material);
    }
    /** Add a texture to this IdMap, given that it has a valid key. */
    addTexture(texture) {
        if (texture.key)
            this.textures.set(texture.key, texture);
        else
            this.keylessTextures.push(texture);
    }
    /** Add a texture to this IdMap using gradient symbology. */
    addGradient(gradientSymb, texture) {
        this.gradients.set(gradientSymb, texture);
    }
    /** Find a cached material using its key. If not found, returns undefined. */
    findMaterial(key) {
        return this.materials.get(key);
    }
    /** Find a cached gradient using the gradient symbology. If not found, returns undefined. */
    findGradient(symb) {
        return this.gradients.get(symb);
    }
    /** Find or create a new material given material parameters. This will cache the material if its key is valid. */
    getMaterial(params) {
        if (!params.key)
            return new Material_1.Material(params);
        let material = this.materials.get(params.key);
        if (!material) {
            material = new Material_1.Material(params);
            this.materials.set(params.key, material);
        }
        return material;
    }
    createTexture(params, handle) {
        if (undefined === handle)
            return undefined;
        const texture = new Texture_1.Texture(params, handle);
        this.addTexture(texture);
        return texture;
    }
    /** Attempt to create and return a new texture from an ImageBuffer. This will cache the texture if its key is valid */
    createTextureFromImageBuffer(img, params) {
        return this.createTexture(params, Texture_1.TextureHandle.createForImageBuffer(img, params.type));
    }
    createTextureFromImage(image, hasAlpha, params) {
        return this.createTexture(params, Texture_1.TextureHandle.createForImage(image, hasAlpha, params.type));
    }
    findTexture(key) { return undefined !== key ? this.textures.get(key) : undefined; }
    /** Find or attempt to create a new texture using an ImageBuffer. If a new texture was created, it will be cached provided its key is valid. */
    getTexture(img, params) {
        const tex = this.findTexture(params.key);
        return undefined !== tex ? tex : this.createTextureFromImageBuffer(img, params);
    }
    getTextureFromImage(image, hasAlpha, params) {
        const tex = this.findTexture(params.key);
        return undefined !== tex ? tex : this.createTextureFromImage(image, hasAlpha, params);
    }
    /** Find or attempt to create a new texture using gradient symbology. If a new texture was created, it will be cached using the gradient. */
    getGradient(grad) {
        const existingGrad = this.gradients.get(grad);
        if (existingGrad)
            return existingGrad;
        const image = grad.getImage(0x100, 0x100);
        const textureHandle = Texture_1.TextureHandle.createForImageBuffer(image, 0 /* Normal */);
        if (!textureHandle)
            return undefined;
        const texture = new Texture_1.Texture(Texture_1.Texture.Params.defaults, textureHandle);
        this.addGradient(grad, texture);
        return texture;
    }
    /** Find or cache a new clipping volume using the given clip vector. */
    getClipVolume(clipVector) {
        const existingClipVolume = this.clipVolumes.get(clipVector);
        if (existingClipVolume)
            return existingClipVolume;
        let clipVolume = ClipVolume_1.ClipVolumePlanes.create(clipVector);
        if (!clipVolume)
            clipVolume = ClipVolume_1.ClipMaskVolume.create(clipVector);
        if (!clipVolume)
            return undefined;
        this.clipVolumes.set(clipVector, clipVolume);
        return clipVolume;
    }
}
exports.IdMap = IdMap;
class System extends System_1.RenderSystem {
    constructor(canvas, context, techniques, capabilities) {
        super(canvas);
        this.currentRenderState = new RenderState_1.RenderState();
        this.frameBufferStack = new FrameBuffer_1.FrameBufferStack(); // frame buffers are not owned by the system (only a storage device)
        this.context = context;
        this.techniques = techniques;
        this.capabilities = capabilities;
        this._drawBuffersExtension = capabilities.queryExtensionObject("WEBGL_draw_buffers");
        this.resourceCache = new Map();
        // Make this System a subscriber to the the IModelConnection onClose event
        IModelConnection_1.IModelConnection.onClose.addListener(this.removeIModelMap.bind(this));
    }
    static get instance() { return IModelApp_1.IModelApp.renderSystem; }
    get lineCodeTexture() { return this._lineCodeTexture; }
    setDrawBuffers(attachments) {
        // NB: The WEBGL_draw_buffers member is not exported directly because that type name is not available in some contexts (e.g. test-imodel-service).
        if (undefined !== this._drawBuffersExtension)
            this._drawBuffersExtension.drawBuffersWEBGL(attachments);
    }
    static create() {
        const canvas = document.createElement("canvas");
        if (null === canvas)
            throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Failed to obtain HTMLCanvasElement");
        let context = canvas.getContext("webgl");
        if (null === context) {
            context = canvas.getContext("experimental-webgl"); // IE, Edge...
            if (null === context) {
                throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Failed to obtain WebGL context");
            }
        }
        const techniques = Technique_1.Techniques.create(context);
        if (undefined === techniques) {
            throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Failed to initialize rendering techniques");
        }
        const capabilities = Capabilities.create(context);
        if (undefined === capabilities) {
            throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Failed to initialize rendering capabilities");
        }
        return new System(canvas, context, techniques, capabilities);
    }
    // Note: FrameBuffers inside of the FrameBufferStack are not owned by the System, and are only used as a central storage device
    dispose() {
        bentleyjs_core_1.dispose(this.techniques);
        // We must attempt to dispose of each idmap in the resourceCache (if idmap is already disposed, has no effect)
        this.resourceCache.forEach((idMap) => {
            bentleyjs_core_1.dispose(idMap);
        });
        this.resourceCache.clear();
        IModelConnection_1.IModelConnection.onClose.removeListener(this.removeIModelMap);
    }
    onInitialized() {
        this._lineCodeTexture = Texture_1.TextureHandle.createForData(EdgeOverrides_1.LineCode.size, EdgeOverrides_1.LineCode.count, new Uint8Array(EdgeOverrides_1.LineCode.lineCodeData), false, GL_1.GL.Texture.WrapMode.Repeat, GL_1.GL.Texture.Format.Luminance);
        bentleyjs_core_1.assert(undefined !== this._lineCodeTexture, "System.lineCodeTexture not created.");
    }
    createTarget(canvas) { return new Target_1.OnScreenTarget(canvas); }
    createOffscreenTarget(rect) { return new Target_1.OffScreenTarget(rect); }
    createGraphic(params) { return new GeometryListBuilder_1.PrimitiveBuilder(this, params); }
    createIndexedPolylines(args) {
        if (args.flags.isDisjoint)
            return PointString_1.PointStringPrimitive.create(args);
        else
            return Polyline_1.PolylinePrimitive.create(args);
    }
    createTriMesh(args) { return Mesh_1.MeshGraphic.create(args); }
    createPointCloud(args) { return PointCloud_1.PointCloudGraphic.create(args); }
    createGraphicList(primitives) { return new Graphic_1.GraphicsList(primitives); }
    createBranch(branch, transform, clips) { return new Graphic_1.Branch(branch, transform, clips); }
    createBatch(graphic, features, range) { return new Graphic_1.Batch(graphic, features, range); }
    createSkyBox(params) {
        if (params.isTexturedCube) {
            const cachedGeom = CachedGeometry_1.SkyBoxQuadsGeometry.create(params);
            return cachedGeom !== undefined ? new Primitive_1.SkyBoxPrimitive(cachedGeom) : undefined;
        }
        // ###TODO: Gradient approach
        return undefined;
    }
    applyRenderState(newState) {
        newState.apply(this.currentRenderState);
        this.currentRenderState.copyFrom(newState);
    }
    createDepthBuffer(width, height) {
        // Note: The buffer/texture created here have ownership passed to the caller (system will not dispose of these)
        switch (this.capabilities.maxDepthType) {
            case 0 /* RenderBufferUnsignedShort16 */: {
                return RenderBuffer_1.RenderBuffer.create(width, height);
            }
            case 1 /* TextureUnsignedInt32 */: {
                return Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.DepthComponent, GL_1.GL.Texture.DataType.UnsignedInt);
            }
            default: {
                bentleyjs_core_1.assert(false);
                return undefined;
            }
        }
    }
    /** Returns the corresponding IdMap for an IModelConnection. Creates a new one if it doesn't exist. */
    createIModelMap(imodel) {
        let idMap = this.resourceCache.get(imodel);
        if (!idMap) {
            idMap = new IdMap();
            this.resourceCache.set(imodel, idMap);
        }
        return idMap;
    }
    /** Removes an IModelConnection-IdMap pairing from the system's resource cache. */
    removeIModelMap(imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (idMap === undefined)
            return;
        bentleyjs_core_1.dispose(idMap);
        this.resourceCache.delete(imodel);
    }
    /** Attempt to create a material for the given iModel using a set of material parameters. */
    createMaterial(params, imodel) {
        const idMap = this.getIdMap(imodel);
        const material = idMap.getMaterial(params);
        return material;
    }
    /** Using its key, search for an existing material of an open iModel. */
    findMaterial(key, imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (!idMap)
            return undefined;
        return idMap.findMaterial(key);
    }
    /** Attempt to create a texture for the given iModel using an ImageBuffer. */
    createTextureFromImageBuffer(image, imodel, params) {
        return this.getIdMap(imodel).getTexture(image, params);
    }
    /** Attempt to create a texture for the given iModel using an HTML image element. */
    createTextureFromImage(image, hasAlpha, imodel, params) {
        // if imodel is undefined, caller is responsible for disposing texture. It will not be associated with an IModelConnection
        if (undefined === imodel) {
            const textureHandle = Texture_1.TextureHandle.createForImage(image, hasAlpha, params.type);
            return undefined !== textureHandle ? new Texture_1.Texture(params, textureHandle) : undefined;
        }
        return this.getIdMap(imodel).getTextureFromImage(image, hasAlpha, params);
    }
    /** Attempt to create a texture using gradient symbology. */
    getGradientTexture(symb, imodel) {
        const idMap = this.getIdMap(imodel);
        const texture = idMap.getGradient(symb);
        return texture;
    }
    /** Using its key, search for an existing texture of an open iModel. */
    findTexture(key, imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (!idMap)
            return undefined;
        return idMap.findTexture(key);
    }
    /** Attempt to create a clipping volume for the given iModel using a clip vector. */
    getClipVolume(clipVector, imodel) {
        const idMap = this.getIdMap(imodel);
        return idMap.getClipVolume(clipVector);
    }
    getIdMap(imodel) {
        const map = this.resourceCache.get(imodel);
        return undefined !== map ? map : this.createIModelMap(imodel);
    }
}
System.identityTransform = geometry_core_1.Transform.createIdentity();
exports.System = System;
Object.freeze(System.identityTransform);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
if (typeof (WebGLRenderingContext) === "undefined") {
    global.WebGLRenderingContext = new Proxy({}, { get: () => 0 });
}
var GL;
(function (GL) {
    let BlendEquation;
    (function (BlendEquation) {
        BlendEquation[BlendEquation["Add"] = WebGLRenderingContext.FUNC_ADD] = "Add";
        BlendEquation[BlendEquation["Subtract"] = WebGLRenderingContext.FUNC_SUBTRACT] = "Subtract";
        BlendEquation[BlendEquation["ReverseSubtract"] = WebGLRenderingContext.FUNC_REVERSE_SUBTRACT] = "ReverseSubtract";
        BlendEquation[BlendEquation["Default"] = BlendEquation.Add] = "Default";
    })(BlendEquation = GL.BlendEquation || (GL.BlendEquation = {}));
    let BlendFactor;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = WebGLRenderingContext.ZERO] = "Zero";
        BlendFactor[BlendFactor["One"] = WebGLRenderingContext.ONE] = "One";
        BlendFactor[BlendFactor["SrcColor"] = WebGLRenderingContext.SRC_COLOR] = "SrcColor";
        BlendFactor[BlendFactor["OneMinusSrcColor"] = WebGLRenderingContext.ONE_MINUS_SRC_COLOR] = "OneMinusSrcColor";
        BlendFactor[BlendFactor["DstColor"] = WebGLRenderingContext.DST_COLOR] = "DstColor";
        BlendFactor[BlendFactor["OneMinusDstColor"] = WebGLRenderingContext.ONE_MINUS_DST_COLOR] = "OneMinusDstColor";
        BlendFactor[BlendFactor["SrcAlpha"] = WebGLRenderingContext.SRC_ALPHA] = "SrcAlpha";
        BlendFactor[BlendFactor["OneMinusSrcAlpha"] = WebGLRenderingContext.ONE_MINUS_SRC_ALPHA] = "OneMinusSrcAlpha";
        BlendFactor[BlendFactor["DstAlpha"] = WebGLRenderingContext.DST_ALPHA] = "DstAlpha";
        BlendFactor[BlendFactor["OneMinusDstAlpha"] = WebGLRenderingContext.ONE_MINUS_DST_ALPHA] = "OneMinusDstAlpha";
        BlendFactor[BlendFactor["ConstColor"] = WebGLRenderingContext.CONSTANT_COLOR] = "ConstColor";
        BlendFactor[BlendFactor["OneMinusConstColor"] = WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR] = "OneMinusConstColor";
        BlendFactor[BlendFactor["ConstAlpha"] = WebGLRenderingContext.CONSTANT_ALPHA] = "ConstAlpha";
        BlendFactor[BlendFactor["OneMinusConstAlpha"] = WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA] = "OneMinusConstAlpha";
        BlendFactor[BlendFactor["AlphaSaturate"] = WebGLRenderingContext.SRC_ALPHA_SATURATE] = "AlphaSaturate";
        BlendFactor[BlendFactor["DefaultSrc"] = BlendFactor.One] = "DefaultSrc";
        BlendFactor[BlendFactor["DefaultDst"] = BlendFactor.Zero] = "DefaultDst";
    })(BlendFactor = GL.BlendFactor || (GL.BlendFactor = {}));
    let Buffer;
    (function (Buffer) {
        let Target;
        (function (Target) {
            Target[Target["ArrayBuffer"] = WebGLRenderingContext.ARRAY_BUFFER] = "ArrayBuffer";
            Target[Target["ElementArrayBuffer"] = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER] = "ElementArrayBuffer";
        })(Target = Buffer.Target || (Buffer.Target = {}));
        let Binding;
        (function (Binding) {
            Binding[Binding["ArrayBuffer"] = WebGLRenderingContext.ARRAY_BUFFER_BINDING] = "ArrayBuffer";
            Binding[Binding["ElementArrayBuffer"] = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER_BINDING] = "ElementArrayBuffer";
        })(Binding = Buffer.Binding || (Buffer.Binding = {}));
        let Parameter;
        (function (Parameter) {
            Parameter[Parameter["Size"] = WebGLRenderingContext.BUFFER_SIZE] = "Size";
            Parameter[Parameter["Usage"] = WebGLRenderingContext.BUFFER_USAGE] = "Usage";
        })(Parameter = Buffer.Parameter || (Buffer.Parameter = {}));
        let Usage;
        (function (Usage) {
            Usage[Usage["DynamicDraw"] = WebGLRenderingContext.DYNAMIC_DRAW] = "DynamicDraw";
            Usage[Usage["StaticDraw"] = WebGLRenderingContext.STATIC_DRAW] = "StaticDraw";
            Usage[Usage["StreamDraw"] = WebGLRenderingContext.STREAM_DRAW] = "StreamDraw";
        })(Usage = Buffer.Usage || (Buffer.Usage = {}));
    })(Buffer = GL.Buffer || (GL.Buffer = {}));
    /* Stenciling commented out for now since it is not used */
    // export enum StencilOperation {
    //   Keep = WebGLRenderingContext.KEEP,
    //   Zero = WebGLRenderingContext.ZERO,
    //   Replace = WebGLRenderingContext.REPLACE,
    //   Incr = WebGLRenderingContext.INCR,
    //   IncrWrap = WebGLRenderingContext.INCR_WRAP,
    //   Decr = WebGLRenderingContext.DECR,
    //   DecrWrap = WebGLRenderingContext.DECR_WRAP,
    //   Invert = WebGLRenderingContext.INVERT,
    //   Default = Keep,
    // }
    // export enum StencilFunction {
    //   Never = WebGLRenderingContext.NEVER,
    //   Less = WebGLRenderingContext.LESS,
    //   LEqual = WebGLRenderingContext.LEQUAL,
    //   Greater = WebGLRenderingContext.GREATER,
    //   GEqual = WebGLRenderingContext.GEQUAL,
    //   Equal = WebGLRenderingContext.EQUAL,
    //   NotEqual = WebGLRenderingContext.NOTEQUAL,
    //   Always = WebGLRenderingContext.ALWAYS,
    //   Default = Always,
    // }
    let CullFace;
    (function (CullFace) {
        CullFace[CullFace["Front"] = WebGLRenderingContext.FRONT] = "Front";
        CullFace[CullFace["Back"] = WebGLRenderingContext.BACK] = "Back";
        CullFace[CullFace["FrontAndBack"] = WebGLRenderingContext.FRONT_AND_BACK] = "FrontAndBack";
        CullFace[CullFace["Default"] = CullFace.Back] = "Default";
    })(CullFace = GL.CullFace || (GL.CullFace = {}));
    let DataType;
    (function (DataType) {
        DataType[DataType["Byte"] = WebGLRenderingContext.BYTE] = "Byte";
        DataType[DataType["Short"] = WebGLRenderingContext.SHORT] = "Short";
        DataType[DataType["UnsignedByte"] = WebGLRenderingContext.UNSIGNED_BYTE] = "UnsignedByte";
        DataType[DataType["UnsignedShort"] = WebGLRenderingContext.UNSIGNED_SHORT] = "UnsignedShort";
        DataType[DataType["UnsignedInt"] = WebGLRenderingContext.UNSIGNED_INT] = "UnsignedInt";
        DataType[DataType["Float"] = WebGLRenderingContext.FLOAT] = "Float";
        // WebGL 2 has more data types
        // HalfFloat = WebGLRenderingContext.HALF_FLOAT,
    })(DataType = GL.DataType || (GL.DataType = {}));
    let FrontFace;
    (function (FrontFace) {
        FrontFace[FrontFace["CounterClockwise"] = WebGLRenderingContext.CCW] = "CounterClockwise";
        FrontFace[FrontFace["Clockwise"] = WebGLRenderingContext.CW] = "Clockwise";
        FrontFace[FrontFace["Default"] = FrontFace.CounterClockwise] = "Default";
    })(FrontFace = GL.FrontFace || (GL.FrontFace = {}));
    let DepthFunc;
    (function (DepthFunc) {
        DepthFunc[DepthFunc["Never"] = WebGLRenderingContext.NEVER] = "Never";
        DepthFunc[DepthFunc["Less"] = WebGLRenderingContext.LESS] = "Less";
        DepthFunc[DepthFunc["Equal"] = WebGLRenderingContext.EQUAL] = "Equal";
        DepthFunc[DepthFunc["LessOrEqual"] = WebGLRenderingContext.LEQUAL] = "LessOrEqual";
        DepthFunc[DepthFunc["Greater"] = WebGLRenderingContext.GREATER] = "Greater";
        DepthFunc[DepthFunc["NotEqual"] = WebGLRenderingContext.NOTEQUAL] = "NotEqual";
        DepthFunc[DepthFunc["GreaterOrEqual"] = WebGLRenderingContext.GEQUAL] = "GreaterOrEqual";
        DepthFunc[DepthFunc["Always"] = WebGLRenderingContext.ALWAYS] = "Always";
        DepthFunc[DepthFunc["Default"] = DepthFunc.Less] = "Default";
    })(DepthFunc = GL.DepthFunc || (GL.DepthFunc = {}));
    let Capability;
    (function (Capability) {
        Capability[Capability["Blend"] = WebGLRenderingContext.BLEND] = "Blend";
        Capability[Capability["BlendColor"] = WebGLRenderingContext.BLEND_COLOR] = "BlendColor";
        Capability[Capability["BlendEquationAlpha"] = WebGLRenderingContext.BLEND_EQUATION_ALPHA] = "BlendEquationAlpha";
        Capability[Capability["BlendEquationRGB"] = WebGLRenderingContext.BLEND_EQUATION_RGB] = "BlendEquationRGB";
        Capability[Capability["BlendSrcAlpha"] = WebGLRenderingContext.BLEND_SRC_ALPHA] = "BlendSrcAlpha";
        Capability[Capability["BlendSrcRgb"] = WebGLRenderingContext.BLEND_SRC_RGB] = "BlendSrcRgb";
        Capability[Capability["BlendDstAlpha"] = WebGLRenderingContext.BLEND_DST_ALPHA] = "BlendDstAlpha";
        Capability[Capability["BlendDstRgb"] = WebGLRenderingContext.BLEND_DST_RGB] = "BlendDstRgb";
        Capability[Capability["CullFace"] = WebGLRenderingContext.CULL_FACE] = "CullFace";
        Capability[Capability["CullFaceMode"] = WebGLRenderingContext.CULL_FACE_MODE] = "CullFaceMode";
        Capability[Capability["DepthFunc"] = WebGLRenderingContext.DEPTH_FUNC] = "DepthFunc";
        Capability[Capability["DepthTest"] = WebGLRenderingContext.DEPTH_TEST] = "DepthTest";
        Capability[Capability["DepthWriteMask"] = WebGLRenderingContext.DEPTH_WRITEMASK] = "DepthWriteMask";
        Capability[Capability["FrontFace"] = WebGLRenderingContext.FRONT_FACE] = "FrontFace";
        /* Stenciling commented out for now since it is not used */
        // StencilFrontFunc = WebGLRenderingContext.STENCIL_FUNC,
        // StencilFrontRef = WebGLRenderingContext.STENCIL_REF,
        // StencilFrontValueMask = WebGLRenderingContext.STENCIL_VALUE_MASK,
        // StencilFrontWriteMask = WebGLRenderingContext.STENCIL_WRITEMASK,
        // StencilFrontOpFail = WebGLRenderingContext.STENCIL_FAIL,
        // StencilFrontOpZFail = WebGLRenderingContext.STENCIL_PASS_DEPTH_FAIL,
        // StencilFrontOpZPass = WebGLRenderingContext.STENCIL_PASS_DEPTH_PASS,
        // StencilBackFunc = WebGLRenderingContext.STENCIL_BACK_FUNC,
        // StencilBackRef = WebGLRenderingContext.STENCIL_BACK_REF,
        // StencilBackValueMask = WebGLRenderingContext.STENCIL_BACK_VALUE_MASK,
        // StencilBackWriteMask = WebGLRenderingContext.STENCIL_BACK_WRITEMASK,
        // StencilBackOpFail = WebGLRenderingContext.STENCIL_BACK_FAIL,
        // StencilBackOpZFail = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL,
        // StencilBackOpZPass = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_PASS,
        Capability[Capability["StencilTest"] = WebGLRenderingContext.STENCIL_TEST] = "StencilTest";
        Capability[Capability["StencilWriteMask"] = WebGLRenderingContext.STENCIL_WRITEMASK] = "StencilWriteMask";
    })(Capability = GL.Capability || (GL.Capability = {}));
    let Texture;
    (function (Texture) {
        let Format;
        (function (Format) {
            Format[Format["Rgb"] = WebGLRenderingContext.RGB] = "Rgb";
            Format[Format["Rgba"] = WebGLRenderingContext.RGBA] = "Rgba";
            Format[Format["DepthStencil"] = WebGLRenderingContext.DEPTH_STENCIL] = "DepthStencil";
            Format[Format["Luminance"] = WebGLRenderingContext.LUMINANCE] = "Luminance";
            Format[Format["DepthComponent"] = WebGLRenderingContext.DEPTH_COMPONENT] = "DepthComponent";
        })(Format = Texture.Format || (Texture.Format = {}));
        // This name is unambiguous as it is qualified by the namespace...https://github.com/palantir/tslint/issues/3789
        let DataType;
        (function (DataType) {
            DataType[DataType["Float"] = WebGLRenderingContext.FLOAT] = "Float";
            DataType[DataType["UnsignedByte"] = WebGLRenderingContext.UNSIGNED_BYTE] = "UnsignedByte";
            //    UnsignedInt24_8 = WebGLRenderingContext.UNSIGNED_INT_24_8,
            DataType[DataType["UnsignedInt"] = WebGLRenderingContext.UNSIGNED_INT] = "UnsignedInt";
        })(DataType = Texture.DataType || (Texture.DataType = {}));
        let WrapMode;
        (function (WrapMode) {
            WrapMode[WrapMode["Repeat"] = WebGLRenderingContext.REPEAT] = "Repeat";
            WrapMode[WrapMode["MirroredRepeat"] = WebGLRenderingContext.MIRRORED_REPEAT] = "MirroredRepeat";
            WrapMode[WrapMode["ClampToEdge"] = WebGLRenderingContext.CLAMP_TO_EDGE] = "ClampToEdge";
        })(WrapMode = Texture.WrapMode || (Texture.WrapMode = {}));
    })(Texture = GL.Texture || (GL.Texture = {}));
    let ShaderType;
    (function (ShaderType) {
        ShaderType[ShaderType["Fragment"] = WebGLRenderingContext.FRAGMENT_SHADER] = "Fragment";
        ShaderType[ShaderType["Vertex"] = WebGLRenderingContext.VERTEX_SHADER] = "Vertex";
    })(ShaderType = GL.ShaderType || (GL.ShaderType = {}));
    let ShaderParameter;
    (function (ShaderParameter) {
        ShaderParameter[ShaderParameter["CompileStatus"] = WebGLRenderingContext.COMPILE_STATUS] = "CompileStatus";
    })(ShaderParameter = GL.ShaderParameter || (GL.ShaderParameter = {}));
    let ProgramParameter;
    (function (ProgramParameter) {
        ProgramParameter[ProgramParameter["LinkStatus"] = WebGLRenderingContext.LINK_STATUS] = "LinkStatus";
    })(ProgramParameter = GL.ProgramParameter || (GL.ProgramParameter = {}));
    let PrimitiveType;
    (function (PrimitiveType) {
        PrimitiveType[PrimitiveType["Points"] = WebGLRenderingContext.POINTS] = "Points";
        PrimitiveType[PrimitiveType["Lines"] = WebGLRenderingContext.LINES] = "Lines";
        PrimitiveType[PrimitiveType["Triangles"] = WebGLRenderingContext.TRIANGLES] = "Triangles";
    })(PrimitiveType = GL.PrimitiveType || (GL.PrimitiveType = {}));
    let RenderBuffer;
    (function (RenderBuffer) {
        RenderBuffer.TARGET = WebGLRenderingContext.RENDERBUFFER;
        let Format;
        (function (Format) {
            Format[Format["DepthComponent16"] = WebGLRenderingContext.DEPTH_COMPONENT16] = "DepthComponent16";
            // Currently this is the only supported format
        })(Format = RenderBuffer.Format || (RenderBuffer.Format = {}));
    })(RenderBuffer = GL.RenderBuffer || (GL.RenderBuffer = {}));
    let FrameBuffer;
    (function (FrameBuffer) {
        FrameBuffer.TARGET = WebGLRenderingContext.FRAMEBUFFER;
    })(FrameBuffer = GL.FrameBuffer || (GL.FrameBuffer = {}));
    let BufferBit;
    (function (BufferBit) {
        BufferBit[BufferBit["Color"] = WebGLRenderingContext.COLOR_BUFFER_BIT] = "Color";
        BufferBit[BufferBit["Depth"] = WebGLRenderingContext.DEPTH_BUFFER_BIT] = "Depth";
        BufferBit[BufferBit["Stencil"] = WebGLRenderingContext.STENCIL_BUFFER_BIT] = "Stencil";
    })(BufferBit = GL.BufferBit || (GL.BufferBit = {}));
    GL.POLYGON_OFFSET_FILL = WebGLRenderingContext.POLYGON_OFFSET_FILL;
})(GL = exports.GL || (exports.GL = {}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Manages the mapping between TypeScript and EC Classes/Properties to transform back and forth
 * between TypeScript objects (strongly typed) and raw JSON instances. The raw JSON instances can
 * conform to one or more "application" ECSchemas.
 *
 * The mappings are setup on the TypeScript classes using class decorators: {@link ECJsonTypeMap.classToJson}
 * and TypeScript properties using property decorators: {@link ECJsonTypeMap.propertyToJson}.
 *
 * The following utility methods can then be used to convert between TypeScript and JSON:
 * {@link ECJsonTypeMap.fromJson<T>} is used to convert a JSON instance into an instance of type T.
 * {@link ECJsonTypeMap.toJson<T>} is used to convert an instance of some type T to JSON.
 * The caller passes the application as an argument to these methods to identify the schema of the
 * raw JSON that's being generated or consumed.
 *
 * #### example
 * The BriefcaseManager API requires that a briefcase be fetched from the server (based on the "wsg" ECSChema-s),
 * kept in memory as a strongly typed TypeScript object, and then saved locally in a ECDb cache (based on
 * the ECSchema in the ECDb). The JSON would need to be transformed between WSG, ECDb and in-memory TypeScript
 * objects. Listed below are:
 * 1. the EC-JSON required/sent by WSG
 * 2. the EC-JSON required/sent by ECDb
 * 3. the TypeScript instance
 * 4. the corresponding TypeScript class definition with the class and property decorators to make the required transformations.
 *
 * 1. the EC-JSON required/sent by WSG
 *     const wsgJsonForBriefcase: any = {
 *       instanceId: "5",
 *       schemaName: "iModelScope",
 *       className: "Briefcase",
 *       eTag: "87fgQrN6y3mHD6ciCsPxhCdxCxU=",
 *       properties: {
 *         FileName: "MyTestModel.bim",
 *         FileDescription: null,
 *         FileSize: "1232896",
 *         FileId: "0056da15-2009-4862-b82a-c031cb3902d8",
 *         BriefcaseId: 5,
 *         UserOwned: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *         AcquiredDate: "2017-07-04T18:08:15.77",
 *         IsReadOnly: false,
 *         },
 *       relationshipInstances: [{
 *         className: "FileAccessKey",
 *         relatedInstance: {
 *           className: "AccessKey",
 *           properties: {
 *           DownloadUrl: "https://imodelhubqasa01.blob.core.windows.net/imodelhub-5018f11f-...",
 *           },
 *         },
 *       },
 *       ],
 *     };
 *
 * 2. the EC-JSON required/sent by ECDb
 *     const ecdbJsonForBriefcase: any = {
 *       id: "1",
 *       className: "ServiceStore.LocalBriefcase",
 *       briefcaseId: 5,
 *       userId: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *       isReadOnly: false,
 *       accessMode: 0,
 *       localPathname: "d:/SomePathHere/MyTestModel.bim",
 *       lastAccessedAt: "2017-07-04T18:08:15.77",
 *     };
 *
 * 3. the TypeScript instance
 *     const briefcase: Briefcase = {
 *       id: "5",
 *       federationGuid: "5",
 *       eTag: "87fgQrN6y3mHD6ciCsPxhCdxCxU=",
 *       fileName: "MyTestModel.bim",
 *       fileDescription: null,
 *       fileSize: "1232896",
 *       fileId: "0056da15-2009-4862-b82a-c031cb3902d8",
 *       briefcaseId: 5,
 *       userId: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *       acquiredDate: "2017-07-04T18:08:15.77",
 *       isReadOnly: false,
 *       downloadUrl: "https://imodelhubqasa01.blob.core.windows.net/i...",
 *       accessMode: 0,
 *       localPathname: "%TEMP%iModeljs/imodelName/",
 *       lastAccessedAt: "2017-07-04T18:08:15.77",
 *     };
 *
 * 4. the corresponding TypeScript class definition with the class and property decorators
 *
 *     // Base class for all typed instances mapped to ECInstance-s in an ECDb
 *     export abstract class ECInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("ecdb", "id")
 *       public id: string;
 *
 *       [index: string]: any;
 *     }
 *
 *     // Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository
 *     export abstract class WsgInstance extends ECInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("wsg", "instanceId")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "instanceId")
 *       public federationGuid: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "eTag")
 *       public eTag?: string;
 *     }
 *
 *     // Briefcase
 *     @ECJsonTypeMap.classToJson("wsg", "iModelScope.Briefcase", { schemaPropertyName: "schemaName", classPropertyName: "className" })
 *     @ECJsonTypeMap.classToJson("ecdb", "ServiceStore.LocalBriefcase", {classKeyPropertyName: "className"})
 *     export class Briefcase extends WsgInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
 *       public fileName: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
 *       public fileDescription: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
 *       public fileSize: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
 *       public fileId: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "briefcaseId")
 *       public briefcaseId: number;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.UserOwned")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "userId")
 *       public userOwned: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.AcquiredDate")
 *       public acquiredDate: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.IsReadOnly")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "isReadOnly")
 *       public isReadOnly: boolean;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
 *       public downloadUrl?: string;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "accessMode")
 *       public accessMode: BriefcaseAccessMode;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "localPathname")
 *       public localPathname: string;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "lastAccessedAt")
 *       public lastAccessedAt: Date;
 *     }
 */
// @todo Update example with property type conversions once that's available.
const Logger_1 = __webpack_require__(156);
const Assert_1 = __webpack_require__(93);
const loggingCategory = "ECJson";
const className = "className";
class PropertyEntry {
    constructor(typedPropertyName, propertyAccessString) {
        this.typedPropertyName = typedPropertyName;
        this.propertyAccessString = propertyAccessString;
    }
}
class ApplicationEntry {
    /** Constructor */
    constructor(applicationKey) {
        this.applicationKey = applicationKey;
        this.propertiesByAccessString = new Map();
    }
    getPropertyByAccessString(propertyAccessString) {
        return this.propertiesByAccessString.get(propertyAccessString);
    }
    /** Adds a new entry for a mapped property */
    addProperty(typedPropertyName, propertyAccessString) {
        let propertyEntry = this.getPropertyByAccessString(propertyAccessString);
        if (propertyEntry) {
            const err = `The ECProperty ${propertyAccessString} has already been mapped to another TypeScript property ${propertyEntry.typedPropertyName}`;
            throw new Error(err);
        }
        propertyEntry = new PropertyEntry(typedPropertyName, propertyAccessString);
        this.propertiesByAccessString.set(propertyAccessString, propertyEntry);
    }
}
/** Entry in the registry to capture the mapping between a single EC and TypeScript class */
class ClassEntry {
    /** Constructor */
    constructor(typedConstructor) {
        this.baseClassEntries = new Array();
        this.applicationsByKey = new Map();
        this.typedConstructor = typedConstructor;
    }
    /** Gets the application entry by the key  */
    getApplicationByKey(applicationKey) {
        return this.applicationsByKey.get(applicationKey);
    }
    /** Adds a new entry for a mapped application within a class  */
    addApplication(applicationKey) {
        let applicationEntry = this.getApplicationByKey(applicationKey);
        if (applicationEntry)
            throw new Error(`Internal error: Cannot add the same application twice`);
        applicationEntry = new ApplicationEntry(applicationKey);
        this.applicationsByKey.set(applicationKey, applicationEntry);
        return applicationEntry;
    }
}
/** Manages the mapping between TypeScript and EC Classes/Properties */
class ECJsonTypeMap {
    /** Gets an existing entry for a mapped class from the name of the TypeScript class */
    static getClassByType(typedConstructor) {
        return ECJsonTypeMap.classesByTypedName.get(typedConstructor);
    }
    /** Recursively gathers all class entries for base classes starting with the specified class */
    static gatherBaseClassEntries(baseClassEntries, classEntry) {
        const baseTypedConstructor = Object.getPrototypeOf(classEntry.typedConstructor.prototype).constructor;
        const baseClassEntry = ECJsonTypeMap.getClassByType(baseTypedConstructor);
        if (baseClassEntry) {
            baseClassEntries.push(baseClassEntry);
            this.gatherBaseClassEntries(baseClassEntries, baseClassEntry);
        }
    }
    static addClassPlaceholder(typedConstructor) {
        const classEntry = new ClassEntry(typedConstructor);
        ECJsonTypeMap.classesByTypedName.set(typedConstructor, classEntry);
        ECJsonTypeMap.gatherBaseClassEntries(classEntry.baseClassEntries, classEntry);
        return classEntry;
    }
    /** Adds a new entry for a mapped class */
    static addClass(typedConstructor, applicationKey, classKey, classKeyMapInfo) {
        if (!(classKeyMapInfo.classKeyPropertyName || (classKeyMapInfo.schemaPropertyName && classKeyMapInfo.classPropertyName)))
            throw new Error("Either classKeyPropertyName or schemaPropertyName+classPropertyName have to be supplied to identify how the class information is persisted in JSON");
        let classEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!classEntry) {
            classEntry = this.addClassPlaceholder(typedConstructor);
        }
        let applicationEntry = classEntry.getApplicationByKey(applicationKey);
        if (!applicationEntry) {
            applicationEntry = classEntry.addApplication(applicationKey);
            // will only happen if there are no properties that are mapped to the application - otherwise the property maps will cause the application entry to be added before
        }
        else if (applicationEntry.classKey === classKey) {
            const err = `Duplicate classKeys ${classKey} found on TypeScript class ${typedConstructor.name} for application ${applicationKey}`;
            throw new Error(err);
        }
        applicationEntry.classKey = classKey;
        applicationEntry.classKeyMapInfo = classKeyMapInfo;
        return classEntry;
    }
    /** Adds a new entry for a mapped property */
    static addProperty(typedPropertyName, typedConstructor, applicationKey, propertyAccessString) {
        let classEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!classEntry)
            classEntry = ECJsonTypeMap.addClassPlaceholder(typedConstructor);
        let applicationEntry = classEntry.getApplicationByKey(applicationKey);
        if (!applicationEntry)
            applicationEntry = classEntry.addApplication(applicationKey);
        applicationEntry.addProperty(typedPropertyName, propertyAccessString);
    }
    /** Create a typed instance from an untyped JSON ECInstance  */
    static fromJson(typedConstructor, applicationKey, ecJsonInstance) {
        const mappedClassEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!mappedClassEntry) {
            Logger_1.Logger.logError(loggingCategory, `Type ${typedConstructor.name} is not mapped to an ECClass. Supply the appropriate class decroator`);
            return undefined;
        }
        const lowCaseApplicationKey = applicationKey.toLowerCase();
        const mappedApplicationEntry = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);
        if (!mappedApplicationEntry) {
            Logger_1.Logger.logError(loggingCategory, `Type ${typedConstructor.name} is not mapped for the supplied application.`);
            return undefined;
        }
        let ecJsonClassKey;
        if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName)
            ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName];
        else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName)
            ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] + "." + ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName];
        else {
            Assert_1.assert(false, "Unexpected classKeyMapInfo");
            return undefined;
        }
        if (mappedApplicationEntry.classKey !== ecJsonClassKey) {
            Logger_1.Logger.logError(loggingCategory, `The ClassKey ${mappedApplicationEntry.classKey} was specified to map with ${typedConstructor.name}, but does not match that specified in the JSON: ${ecJsonClassKey} `);
            return undefined;
        }
        let classEntries = Array(mappedClassEntry);
        classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);
        const typedInstance = new typedConstructor();
        classEntries.forEach((classEntry) => {
            const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);
            if (!applicationEntry)
                return;
            applicationEntry.propertiesByAccessString.forEach((propertyEntry, propertyAccessString) => {
                let ecValue = ecJsonInstance;
                const ecNameParts = propertyAccessString.split("."); // e.g., "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId"
                for (let i = 0; i < ecNameParts.length; i++) {
                    const ecNameSubParts = ecNameParts[i].match(/[^\[\]]+/g);
                    if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)
                        return;
                    const subAccessString = ecNameSubParts[0];
                    ecValue = ecValue[subAccessString];
                    if (typeof ecValue === "undefined")
                        return;
                    if (ecNameSubParts.length === 2 && subAccessString === "relationshipInstances" && i < ecNameParts.length - 1) {
                        const nextEcNameSubParts = ecNameParts[i + 1].match(/[^\[\]]+/g);
                        if (!nextEcNameSubParts || nextEcNameSubParts.length !== 2)
                            return;
                        const expectedRelationshipInstanceClass = ecNameSubParts[1];
                        const relatedInstanceAccessString = nextEcNameSubParts[0];
                        const expectedRelatedInstanceClass = nextEcNameSubParts[1];
                        let arrayIndex = 0;
                        let arrayValue;
                        let actualRelatedInstanceClass;
                        while (expectedRelatedInstanceClass !== actualRelatedInstanceClass) {
                            arrayValue = ecValue[arrayIndex++];
                            if (typeof arrayValue === "undefined")
                                return;
                            if (expectedRelationshipInstanceClass === arrayValue[className]) {
                                const relatedInstance = arrayValue[relatedInstanceAccessString];
                                if (relatedInstance !== "undefined")
                                    actualRelatedInstanceClass = relatedInstance[className];
                            }
                        }
                        ecValue = arrayValue[relatedInstanceAccessString];
                        i++;
                    }
                }
                typedInstance[propertyEntry.typedPropertyName] = ecValue;
            });
        });
        return typedInstance;
    }
    /** Create an untyped intance from a typed instance */
    static toJson(applicationKey, typedInstance) {
        const lowCaseApplicationKey = applicationKey.toLowerCase();
        const typedConstructor = Object.getPrototypeOf(typedInstance).constructor;
        const mappedClassEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!mappedClassEntry)
            return undefined;
        const mappedApplicationEntry = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);
        if (!mappedApplicationEntry)
            return undefined;
        const untypedInstance = {};
        if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName) {
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName] = mappedApplicationEntry.classKey;
        }
        else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName) {
            const classKeyParts = mappedApplicationEntry.classKey.split(".", 2);
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] = classKeyParts[0];
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName] = classKeyParts[1];
        }
        else {
            Assert_1.assert(false, "Unexpected classKeyMapInfo");
            return undefined;
        }
        let classEntries = Array(mappedClassEntry);
        classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);
        classEntries.forEach((classEntry) => {
            const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);
            if (!applicationEntry)
                return;
            applicationEntry.propertiesByAccessString.forEach((propertyEntry, propertyAccessString) => {
                const typedValue = typedInstance[propertyEntry.typedPropertyName];
                if (typeof typedValue === "undefined")
                    return;
                const ecNameParts = propertyAccessString.split("."); // e.g., "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId"
                let untypedInstanceCursor = untypedInstance;
                ecNameParts.forEach((ecNamePart, index) => {
                    const ecNameSubParts = ecNamePart.match(/[^\[\]]+/g);
                    if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)
                        return;
                    const accessString = ecNameSubParts[0];
                    const isLastPart = index >= ecNameParts.length - 1;
                    if (ecNameSubParts.length !== 2) {
                        if (!untypedInstanceCursor[accessString])
                            untypedInstanceCursor[accessString] = isLastPart ? typedValue : {};
                        untypedInstanceCursor = untypedInstanceCursor[accessString];
                        return;
                    }
                    const expectedclassName = ecNameSubParts[1];
                    if (accessString === "relationshipInstances") {
                        if (!untypedInstanceCursor[accessString])
                            untypedInstanceCursor[accessString] = [];
                        const nextEcNameSubParts = ecNameParts[index + 1].match(/[^\[\]]+/g);
                        if (!nextEcNameSubParts || nextEcNameSubParts.length !== 2)
                            return;
                        const relatedInstanceAccessString = nextEcNameSubParts[0];
                        const expectedRelatedInstanceClass = nextEcNameSubParts[1];
                        let relationshipCount = 0;
                        while (untypedInstanceCursor[accessString][relationshipCount]
                            && (untypedInstanceCursor[accessString][relationshipCount][className] !== expectedclassName
                                || untypedInstanceCursor[accessString][relationshipCount][relatedInstanceAccessString][className] !== expectedRelatedInstanceClass)) {
                            relationshipCount++;
                        }
                        if (!untypedInstanceCursor[accessString][relationshipCount]) {
                            untypedInstanceCursor[accessString][relationshipCount] = isLastPart ? typedValue : {};
                        }
                        untypedInstanceCursor = untypedInstanceCursor[accessString][relationshipCount];
                    }
                    else {
                        if (accessString !== "relatedInstance" || !untypedInstanceCursor[accessString]
                            || (accessString === "relatedInstance" && untypedInstanceCursor[accessString][className] !== expectedclassName)) {
                            untypedInstanceCursor[accessString] = isLastPart ? typedValue : {};
                        }
                        untypedInstanceCursor = untypedInstanceCursor[accessString];
                    }
                    untypedInstanceCursor[className] = expectedclassName;
                });
            });
        });
        return untypedInstance;
    }
    /**
     * Decorator function for mapping TypeScript classes to JSON
     * @param applicationKey Identifies the application for which the mapping is specified. e.g., "ecdb", "wsg", etc.
     * @param classKey Identifies the ec class backing the JSON instance. (e.g., "ServiceStore.Briefcase" (ecdb) or "iModelScope.Briefcase" (wsg))
     * @param classKeyMapInfo Information on how the class key is persistend in the JSON instance (e.g., as two properties "schemaName" and "className")
     */
    static classToJson(applicationKey, classKey, classKeyMapInfo) {
        return (typedConstructor) => {
            ECJsonTypeMap.addClass(typedConstructor, applicationKey.toLowerCase(), classKey, classKeyMapInfo);
        };
    }
    /**
     * Decorator function for mapping typescript properties to JSON
     * @param applicationKey Identifies the application for which the mapping is specified. e.g., "ecdb", "wsg", etc.
     * @param propertyAccessString Access string for the ECProperty
     */
    static propertyToJson(applicationKey, propertyAccessString) {
        return (object, propertyKey) => {
            ECJsonTypeMap.addProperty(propertyKey, object.constructor, applicationKey.toLowerCase(), propertyAccessString);
        };
    }
}
ECJsonTypeMap.classesByTypedName = new Map();
exports.ECJsonTypeMap = ECJsonTypeMap;
/** Base class for all typed instances mapped to ECInstance-s in an ECDb */
class ECInstance {
}
__decorate([
    ECJsonTypeMap.propertyToJson("ecdb", "id")
], ECInstance.prototype, "ecId", void 0);
exports.ECInstance = ECInstance;
/** Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository */
class WsgInstance extends ECInstance {
}
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "instanceId"),
    ECJsonTypeMap.propertyToJson("ecdb", "wsgId")
], WsgInstance.prototype, "wsgId", void 0);
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "eTag"),
    ECJsonTypeMap.propertyToJson("ecdb", "eTag")
], WsgInstance.prototype, "eTag", void 0);
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "changeState")
], WsgInstance.prototype, "changeState", void 0);
exports.WsgInstance = WsgInstance;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const AnalyticGeometry_1 = __webpack_require__(11);
const GrowableArray_1 = __webpack_require__(37);
const CurvePrimitive_1 = __webpack_require__(12);
/* tslint:disable:variable-name no-empty*/
/* Starting wtih baseIndex and moving index by stepDirection:
If the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.
Return when successful.
(Do nothing if everything is parallel through limits of the array)
*/
function accumulateGoodUnitPerpendicular(points, vectorA, baseIndex, stepDirection, weight, normal, workVector) {
    const n = points.length;
    if (stepDirection > 0) {
        for (let i = baseIndex; i + 1 < n; i++) {
            points.vectorIndexIndex(i + 1, i, workVector);
            vectorA.crossProduct(workVector, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    else {
        if (baseIndex + 1 >= n)
            baseIndex = n - 2;
        for (let i = baseIndex; i >= 0; i--) {
            points.vectorIndexIndex(i, i + 1, workVector);
            vectorA.crossProduct(workVector, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    return false;
}
class LineString3d extends CurvePrimitive_1.CurvePrimitive {
    constructor() {
        super();
        this._points = new GrowableArray_1.GrowableXYZArray();
    }
    isSameGeometryClass(other) { return other instanceof LineString3d; }
    /** return the points array (cloned). */
    get points() { return this._points.getPoint3dArray(); }
    /** Return (reference to) point data in packed GrowableXYZArray. */
    get packedPoints() { return this._points; }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    static flattenArray(arr) {
        return arr.reduce((flat, toFlatten) => {
            return flat.concat(Array.isArray(toFlatten) ? LineString3d.flattenArray(toFlatten) : toFlatten);
        }, []);
    }
    static create(...points) {
        const result = new LineString3d();
        result.addPoints(points);
        return result;
    }
    static createXY(points, z, enforceClosure = false) {
        const result = new LineString3d();
        const xyz = result._points;
        for (const xy of points) {
            xyz.pushXYZ(xy.x, xy.y, z);
        }
        if (enforceClosure && points.length > 1) {
            const distance = xyz.distance(0, xyz.length - 1);
            if (distance !== 0.0) {
                if (Geometry_1.Geometry.isSameCoordinate(0, distance)) {
                    xyz.pop(); // nonzero but small distance -- to be replaced by point 0 exactly.
                    const xyzA = xyz.front();
                    xyz.push(xyzA);
                }
            }
        }
        result.addPoints(points);
        return result;
    }
    addPoints(...points) {
        const toAdd = LineString3d.flattenArray(points);
        for (const p of toAdd) {
            if (p instanceof PointVector_1.Point3d)
                this._points.push(p);
        }
    }
    addPoint(point) {
        this._points.push(point);
    }
    /**
     * If the linestring is not already closed, add a closure point.
     */
    addClosurePoint() {
        const n = this._points.length;
        if (n > 1) {
            if (!Geometry_1.Geometry.isSameCoordinate(0, this._points.distance(0, n - 1)))
                this._points.pushWrap(1);
        }
    }
    popPoint() {
        this._points.pop();
    }
    static createRectangleXY(point0, ax, ay, closed) {
        const ls = LineString3d.create(point0, point0.plusXYZ(ax, 0), point0.plusXYZ(ax, ay), point0.plusXYZ(0, ay));
        if (closed)
            ls.addPoint(point0);
        return ls;
    }
    setFrom(other) {
        this._points.clear();
        let i = 0;
        while (other._points.isIndexValid(i)) {
            this._points.push(other._points.getPoint3dAt(i));
            i++;
        }
    }
    static createPoints(points) {
        const ls = new LineString3d();
        let point;
        for (point of points)
            ls._points.push(point);
        return ls;
    }
    /** Create a LineString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ls = new LineString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ls._points.push(PointVector_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ls;
    }
    clone() {
        const retVal = new LineString3d();
        retVal.setFrom(this);
        return retVal;
    }
    setFromJSON(json) {
        this._points.clear();
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(PointVector_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an LineString3d to a JSON object.
     * @return {*} [[x,y,z],...[x,y,z]]
     */
    toJSON() {
        const value = [];
        let i = 0;
        while (this._points.isIndexValid(i)) {
            value.push(this._points.getPoint3dAt(i).toJSON());
            i++;
        }
        return value;
    }
    static fromJSON(json) {
        const ls = new LineString3d();
        ls.setFromJSON(json);
        return ls;
    }
    fractionToPoint(fraction, result) {
        const n = this._points.length;
        if (n === 0)
            return PointVector_1.Point3d.createZero();
        if (n === 1)
            return PointVector_1.Point3d.createFrom(this._points.getPoint3dAt(0), result);
        const df = 1.0 / (n - 1);
        if (fraction <= df)
            return this._points.interpolate(0, fraction / df, 1, result);
        if (fraction + df >= 1.0)
            return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result);
        const index0 = Math.floor(fraction / df);
        return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result);
    }
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        const n = this._points.length;
        if (n <= 1) {
            result.direction.setZero();
            if (n === 1)
                result.origin.setFrom(this._points.getPoint3dAt(0));
            else
                result.origin.setZero();
            return result;
        }
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        if (fraction <= df) {
            result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
            this._points.interpolate(0, fraction / df, 1, result.origin);
            this._points.vectorIndexIndex(0, 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        if (fraction + df >= 1.0) {
            result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
            this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);
            this._points.vectorIndexIndex(n - 2, n - 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        /* true interior point */
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        const index0 = Math.floor(fraction / df);
        const localFraction = (fraction - index0 * df) / df;
        this._points.interpolate(index0, localFraction, index0 + 1, result.origin);
        this._points.vectorIndexIndex(index0, index0 + 1, result.direction);
        result.direction.scaleInPlace(1.0 / df);
        return result;
    }
    /** Return point and derivative at fraction, with 000 second derivative. */
    fractionToPointAnd2Derivatives(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction);
        result = AnalyticGeometry_1.Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, PointVector_1.Vector3d.createZero(), result);
        return result;
    }
    /**
     * Convert a segment index and local fraction to a global fraction.
     * @param index index of segment being evaluated
     * @param localFraction local fraction within that segment
     */
    segmentIndexAndLocalFractionToGlobalFraction(index, localFraction) {
        const numSegment = this._points.length - 1;
        if (numSegment < 1)
            return 0.0;
        return (index + localFraction) / numSegment;
    }
    /** Return a frenet frame, using nearby points to estimate a plane. */
    fractionToFrenetFrame(fraction, result) {
        const n = this._points.length;
        if (n <= 1) {
            if (n === 1)
                return Transform_1.Transform.createTranslation(this._points.getPoint3dAt(0), result);
            return Transform_1.Transform.createIdentity(result);
        }
        if (n === 2)
            return Transform_1.Transform.createRefs(this._points.interpolate(0, fraction, 1), Transform_1.RotMatrix.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1), 0 /* XYZ */));
        /** 3 or more points. */
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        let baseIndex = 0;
        let localFraction = 0;
        if (fraction <= df) {
            localFraction = fraction / df;
            baseIndex = 0;
        }
        else if (fraction + df >= 1.0) {
            baseIndex = n - 2;
            localFraction = 1.0 - (1.0 - fraction) / df;
        }
        else {
            baseIndex = Math.floor(fraction / df);
            localFraction = fraction * numSegment - baseIndex;
        }
        const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1);
        const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1);
        // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..
        const normal = PointVector_1.Vector3d.create();
        const workVector = PointVector_1.Vector3d.create();
        // try forming normal using both forward and reverse stepping.
        // if at an end segment, only one will succeed.
        // if interior, both produce candidates, both can succeed and will be weighted.
        accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, localFraction, normal, workVector);
        accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (1.0 - localFraction), normal, workVector);
        const matrix = Transform_1.RotMatrix.createRigidFromColumns(normal, vectorA, 2 /* ZXY */);
        if (matrix)
            return Transform_1.Transform.createOriginAndMatrix(origin, matrix, result);
        return Transform_1.Transform.createTranslation(origin, result);
    }
    startPoint() {
        if (this._points.length === 0)
            return PointVector_1.Point3d.createZero();
        return this._points.getPoint3dAt(0);
    }
    pointAt(i, result) {
        return this._points.getPoint3dAt(i, result);
    }
    numPoints() { return this._points.length; }
    endPoint() {
        if (this._points.length === 0)
            return PointVector_1.Point3d.createZero();
        return this._points.getPoint3dAt(this._points.length - 1);
    }
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            let a = this._points.getPoint3dAt(0);
            while (i0 < i1) {
                a = this._points.getPoint3dAt(i0);
                this._points.setAt(i0, this._points.getPoint3dAt(i1));
                this._points.setAt(i1, a);
                i0++;
                i1--;
            }
        }
    }
    tryTransformInPlace(transform) {
        this._points.transformInPlace(transform);
        return true;
    }
    curveLength() { return this._points.sumLengths(); }
    quickLength() { return this.curveLength(); }
    closestPoint(spacePoint, extend, result) {
        result = CurvePrimitive_1.CurveLocationDetail.create(this, result);
        const numPoints = this._points.length;
        if (numPoints > 0) {
            const lastIndex = numPoints - 1;
            result.setFP(1.0, this._points.getPoint3dAt(lastIndex), undefined);
            result.setDistanceTo(spacePoint);
            if (numPoints > 1) {
                let segmentFraction = 0;
                let d = 0;
                const df = 1.0 / lastIndex;
                for (let i = 1; i < numPoints; i++) {
                    segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i));
                    if (segmentFraction < 0) {
                        if (!extend || i > 1)
                            segmentFraction = 0.0;
                    }
                    else if (segmentFraction > 1.0) {
                        if (!extend || i < lastIndex)
                            segmentFraction = 1.0;
                    }
                    this._points.getPoint3dAt(i - 1).interpolate(segmentFraction, this._points.getPoint3dAt(i), result.pointQ);
                    d = result.pointQ.distance(spacePoint);
                    if (d < result.a) {
                        result.setFP((i - 1 + segmentFraction) * df, result.pointQ, undefined, d);
                    }
                }
            }
        }
        return result;
    }
    isInPlane(plane) {
        return this._points.isCloseToPlane(plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** push a hit, fixing up the prior entry if needed.
     * return the incremented counter.
     */
    static pushVertexHit(result, counter, cp, fraction, point) {
        const detail = CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);
        result.push(detail);
        if (counter === 0) {
            detail.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.isolatedAtVertex);
        }
        else if (counter === 1) {
            result[result.length - 2].setIntervalRole(CurvePrimitive_1.CurveIntervalRole.intervalStart);
            detail.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.intervalEnd);
        }
        else {
            result[result.length - 2].setIntervalRole(CurvePrimitive_1.CurveIntervalRole.intervalInterior);
            detail.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.intervalEnd);
        }
    }
    /** find intersections with a plane.
     *  Intersections within segments are recorded as CurveIntervalRole.isolated
     *   Intersections at isolated "on" vertex are recoded as CurveIntervalRole.isolatedAtVertex.
     */
    appendPlaneIntersectionPoints(plane, result) {
        if (this._points.length < 1)
            return 0;
        const initialLength = result.length;
        const n = this._points.length;
        const divisor = n === 1 ? 1.0 : n - 1;
        const pointA = LineString3d.s_workPointA;
        const pointB = LineString3d.s_workPointB;
        const pointC = LineString3d.s_workPointC;
        this._points.getPoint3dAt(0, pointA);
        let hB = 0;
        let numConsecutiveZero = 0;
        let hA = 0;
        let segmentFraction = 0;
        for (let i = 0; i < this._points.length; i++, pointA.setFrom(pointB), hA = hB) {
            this._points.getPoint3dAt(i, pointB);
            hB = Geometry_1.Geometry.correctSmallMetricDistance(plane.altitude(pointB));
            if (hB === 0.0)
                LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);
            else {
                if (hA * hB < 0.0) {
                    segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.
                    pointA.interpolate(segmentFraction, pointB, pointC);
                    const detail = CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);
                    detail.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.isolated);
                    result.push(detail);
                    numConsecutiveZero = 0;
                }
            }
        }
        return result.length - initialLength;
    }
    extendRange(rangeToExtend, transform) { this._points.extendRange(rangeToExtend, transform); }
    isAlmostEqual(other) {
        if (!(other instanceof LineString3d))
            return false;
        if (!GrowableArray_1.GrowableXYZArray.isAlmostEqual(this._points, other._points))
            return false;
        return true;
    }
    /** Append (clone of) one point.
     * BUT ... skip if duplicates the tail of prior points.
     */
    appendStrokePoint(point) {
        const n = this._points.length;
        if (n === 0 || !point.isAlmostEqual(this._points.getPoint3dAt(n - 1)))
            this._points.push(point);
    }
    clear() { this._points.clear(); }
    /** Evaluate a curve at uniform fractions.  Append the evaluations to this linestring.
     * @param curve primitive to evaluate.
     * @param numStrokes number of strokes (edges).
     * @param fraction0 starting fraction coordinate
     * @param fraction1 end fraction coordinate
     * @param include01 if false, points at fraction0 and fraction1 are omitted.
     */
    appendFractionalStrokePoints(curve, numStrokes, fraction0 = 0, fraction1 = 1, include01) {
        if (include01)
            this.appendStrokePoint(curve.fractionToPoint(fraction0));
        if (numStrokes > 1) {
            const df = (fraction1 - fraction0) / numStrokes;
            for (let i = 1; i < numStrokes; i++)
                this.appendStrokePoint(curve.fractionToPoint(fraction0 + i * df));
        }
        if (include01)
            this.appendStrokePoint(curve.fractionToPoint(fraction1));
    }
    appendInterpolatedStrokePoints(numStrokes, point0, point1, include01) {
        if (include01)
            this.appendStrokePoint(point0);
        if (numStrokes > 1) {
            const df = 1.0 / numStrokes;
            for (let i = 1; i < numStrokes; i++)
                this.appendStrokePoint(point0.interpolate(i * df, point1));
        }
        if (include01)
            this.appendStrokePoint(point1);
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        const n = this._points.length;
        const pointA = LineString3d.s_workPointA;
        const pointB = LineString3d.s_workPointB;
        if (n > 0) {
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply minstrokes per primitive.
            if (options && options.hasMaxEdgeLength()) {
                dest.appendStrokePoint(this._points.getPoint3dAt(0));
                for (let i = 1; i < n; i++) {
                    this._points.getPoint3dAt(i - 1, pointA);
                    this._points.getPoint3dAt(i, pointB);
                    const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));
                    if (numStroke > 1)
                        dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);
                    dest.appendStrokePoint(pointB);
                }
            }
            else {
                for (let i = 0; i < n; i++) {
                    dest.appendStrokePoint(this._points.getPoint3dAt(i));
                }
            }
        }
    }
    /** Emit strokable parts of the curve to a caller-supplied handler.
     * If the stroke options does not have a maxEdgeLength, one stroke is emited for each segment of the linestring.
     * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.
     */
    emitStrokableParts(handler, options) {
        const n = this._points.length;
        handler.startCurvePrimitive(this);
        if (n > 1) {
            const df = 1.0 / (n - 1);
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply minstrokes per primitive.
            if (options && options.hasMaxEdgeLength()) {
                for (let i = 1; i < n; i++) {
                    const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAt(i - 1).distance(this._points.getPoint3dAt(i)));
                    handler.announceSegmentInterval(this, this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i), numStroke, (i - 1) * df, i * df);
                }
            }
            else {
                for (let i = 1; i < n; i++) {
                    handler.announceSegmentInterval(this, this._points.getPoint3dAt(i - 1), this._points.getPoint3dAt(i), 1, (i - 1) * df, i * df);
                }
            }
        }
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLineString3d(this);
    }
    // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with
    // linestring because the controller has special case loops through segments?
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        const n = this._points.length;
        if (n < 2)
            return false;
        let globalFractionA = 0.0;
        let globalFractionB = 1.0;
        const capture = (localFraction0, localFraction1) => {
            if (announce)
                announce(Geometry_1.Geometry.interpolate(globalFractionA, localFraction0, globalFractionB), Geometry_1.Geometry.interpolate(globalFractionA, localFraction1, globalFractionB), this);
        };
        const pointA = LineString3d.s_workPointA;
        const pointB = LineString3d.s_workPointB;
        this._points.getPoint3dAt(0, pointA);
        let status = false;
        for (let i = 1; i < n; i++, pointA.setFrom(pointB), globalFractionA = globalFractionB) {
            this._points.getPoint3dAt(i, pointB);
            globalFractionB = i / (n - 1);
            if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))
                status = true;
        }
        return status;
    }
    addResolvedPoint(index, fraction, dest) {
        const n = this._points.length;
        if (n === 0)
            return;
        if (n === 1) {
            this._points.getPoint3dAt(0, LineString3d.s_indexPoint);
            dest.push(LineString3d.s_indexPoint);
            return;
        }
        if (index < 0)
            index = 0;
        if (index >= n) {
            index = n - 1;
            fraction += 1;
        }
        this._points.interpolate(index, fraction, index + 1, LineString3d.s_indexPoint);
        dest.push(LineString3d.s_indexPoint);
    }
    /** Return (if possible) a LineString which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const linestringA = this.clonePartialCurve(fractionB, fractionA);
            if (linestringA)
                linestringA.reverseInPlace();
            return linestringA;
        }
        const n = this._points.length;
        const numEdge = n - 1;
        if (n < 2 || fractionA >= 1.0 || fractionB <= 0.0)
            return undefined;
        if (fractionA < 0)
            fractionA = 0;
        if (fractionB > 1)
            fractionB = 1;
        const gA = fractionA * numEdge;
        const gB = fractionB * numEdge;
        const indexA = Math.floor(gA);
        const indexB = Math.floor(gB);
        const localFractionA = gA - indexA;
        const localFractionB = gB - indexB;
        const result = LineString3d.create();
        this.addResolvedPoint(indexA, localFractionA, result._points);
        for (let index = indexA + 1; index <= indexB; index++) {
            this._points.getPoint3dAt(index, LineString3d.s_workPointA);
            result._points.push(LineString3d.s_workPointA);
        }
        if (!Geometry_1.Geometry.isSmallRelative(localFractionB)) {
            this.addResolvedPoint(indexB, localFractionB, result._points);
        }
        return result;
    }
}
LineString3d.s_workPointA = PointVector_1.Point3d.create();
LineString3d.s_workPointB = PointVector_1.Point3d.create();
LineString3d.s_workPointC = PointVector_1.Point3d.create();
LineString3d.s_indexPoint = PointVector_1.Point3d.create(); // private point for indexAndFractionToPoint.
exports.LineString3d = LineString3d;
/** An AnnotatedLineString3d is a linestring with additional data attached to each point
 * * This is useful in facet construction.
 */
class AnnotatedLineString3d {
}
exports.AnnotatedLineString3d = AnnotatedLineString3d;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
/**
 * A plane defined by
 *
 * * Any point on the plane.
 * * a unit normal.
 */
class Plane3dByOriginAndUnitNormal {
    // constructor captures references !!!
    constructor(origin, normal) {
        this.origin = origin;
        this.normal = normal;
    }
    // This is private because it does not check validity of the unit vector.
    static _create(x, y, z, u, v, w) {
        return new Plane3dByOriginAndUnitNormal(PointVector_1.Point3d.create(x, y, z), PointVector_1.Vector3d.create(u, v, w));
    }
    /**
     * Create a plane parallel to the XY plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createXYPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);
    }
    /**
     * Create a plane parallel to the YZ plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createYZPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);
    }
    /**
     * Create a plane parallel to the ZX plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createZXPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);
    }
    static create(origin, normal, result) {
        const normalized = normal.normalize();
        if (!normalized)
            return undefined;
        if (result) {
            result.set(origin, normalized);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);
    }
    /** Create a plane defined by two points and an in-plane vector.
     * @param pointA any point in the plane
     * @param pointB any other point in the plane
     * @param vector any vector in the plane but not parallel to the vector from pointA to pointB
     */
    static createPointPointVectorInPlane(pointA, pointB, vector) {
        const cross = vector.crossProductStartEnd(pointA, pointB);
        if (cross.tryNormalizeInPlace())
            return new Plane3dByOriginAndUnitNormal(pointA, cross);
        return undefined;
    }
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin) && this.normal.isAlmostEqual(other.normal);
    }
    setFromJSON(json) {
        if (!json) {
            this.origin.set(0, 0, 0);
            this.normal.set(0, 0, 1);
        }
        else {
            this.origin.setFromJSON(json.origin);
            this.normal.setFromJSON(json.normal);
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this.origin.toJSON(), normal: this.normal.toJSON() }; }
    static fromJSON(json) {
        const result = Plane3dByOriginAndUnitNormal.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    /** @returns a reference to the origin. */
    getOriginRef() { return this.origin; }
    /** @returns a reference to the unit normal. */
    getNormalRef() { return this.normal; }
    /** Copy coordinates from the given origin and normal. */
    set(origin, normal) {
        this.origin.setFrom(origin);
        this.normal.setFrom(normal);
    }
    clone(result) {
        if (result) {
            result.set(this.origin, this.normal);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(this.origin.clone(), this.normal.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyPoint3d(result.origin, result.origin);
        transform.matrix.multiplyInverseTranspose(result.normal, result.normal);
        if (result.normal.normalizeInPlace())
            return result;
        return undefined;
    }
    /** Copy data from the given plane. */
    setFrom(source) {
        this.set(source.origin, source.normal);
    }
    /** @returns Return the altitude of spacePoint above or below the plane.  (Below is negative) */
    altitude(spacePoint) { return this.normal.dotProductStartEnd(this.origin, spacePoint); }
    /** @returns return a point at specified (signed) altitude */
    altitudeToPoint(altitude, result) {
        return this.origin.plusScaled(this.normal, altitude, result);
    }
    /** @returns The dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude
     * for a point moving at speed one along the spaceVector.
     */
    velocity(spaceVector) { return this.normal.dotProduct(spaceVector); }
    /** @returns the altitude of a point given as separate x,y,z components. */
    altitudeXYZ(x, y, z) {
        return this.normal.dotProductStartEndXYZ(this.origin, x, y, z);
    }
    /** @returns the altitude of a point given as separate x,y,z,w components. */
    altitudeXYZW(x, y, z, w) {
        return this.normal.dotProductStartEndXYZW(this.origin, x, y, z, w);
    }
    /** @returns Return the projection of spacePoint onto the plane. */
    projectPointToPlane(spacePoint, result) {
        return spacePoint.plusScaled(this.normal, -this.normal.dotProductStartEnd(this.origin, spacePoint), result);
    }
    /** @return Returns true of spacePoint is within distance tolerance of the plane. */
    isPointInPlane(spacePoint) { return Geometry_1.Geometry.isSmallMetricDistance(this.altitude(spacePoint)); }
}
exports.Plane3dByOriginAndUnitNormal = Plane3dByOriginAndUnitNormal;
/** A Ray3d contains
 * * an origin point.
 * * a direction vector.  The vector is NOT required to be normalized.
 *  * an optional weight (number).
 *
 */
class Ray3d {
    // constructor captures references !!!
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
    }
    static _create(x, y, z, u, v, w) {
        return new Ray3d(PointVector_1.Point3d.create(x, y, z), PointVector_1.Vector3d.create(u, v, w));
    }
    static createXAxis() { return Ray3d._create(0, 0, 0, 1, 0, 0); }
    static createYAxis() { return Ray3d._create(0, 0, 0, 0, 1, 0); }
    static createZAxis() { return Ray3d._create(0, 0, 0, 0, 0, 1); }
    static createZero(result) {
        if (result) {
            result.origin.setZero();
            result.direction.setZero();
            return result;
        }
        return new Ray3d(PointVector_1.Point3d.createZero(), PointVector_1.Vector3d.createZero());
    }
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);
    }
    static create(origin, direction, result) {
        if (result) {
            result.set(origin, direction);
            return result;
        }
        return new Ray3d(origin.clone(), direction.clone());
    }
    /** Create from coordinates of the origin and direction. */
    static createXYZUVW(originX, originY, originZ, directionX, directionY, directionZ, result) {
        if (result) {
            result.getOriginRef().set(originX, originY, originZ);
            result.getDirectionRef().set(directionX, directionY, directionZ);
            return result;
        }
        return new Ray3d(PointVector_1.Point3d.create(originX, originY, originZ), PointVector_1.Vector3d.create(directionX, directionY, directionZ));
    }
    /** Capture origin and direction in a new Ray3d. */
    static createCapture(origin, direction) {
        return new Ray3d(origin, direction);
    }
    /** Create from (clones of) origin, direction, and numeric weight. */
    static createPointVectorNumber(origin, direction, a, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setFrom(direction);
            result.a = a;
            return result;
        }
        result = new Ray3d(origin.clone(), direction.clone());
        result.a = a;
        return result;
    }
    /** Create from origin and target.  The direction vector is the full length (non-unit) vector from origin to target. */
    static createStartEnd(origin, target, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setStartEnd(origin, target);
            return result;
        }
        return new Ray3d(origin, PointVector_1.Vector3d.createStartEnd(origin, target));
    }
    /** @returns Return a reference to the ray's origin. */
    getOriginRef() { return this.origin; }
    /** @returns Return a reference to the ray's direction vector. */
    getDirectionRef() { return this.direction; }
    /** copy coordinates from origin and direction. */
    set(origin, direction) {
        this.origin.setFrom(origin);
        this.direction.setFrom(direction);
    }
    /** Clone the ray. */
    clone(result) {
        if (result) {
            result.set(this.origin, this.direction);
            return result;
        }
        return new Ray3d(this.origin.clone(), this.direction.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        return new Ray3d(transform.multiplyPoint3d(this.origin), transform.multiplyVector(this.direction));
    }
    /** Apply a transform in place. */
    transformInPlace(transform) {
        transform.multiplyPoint3d(this.origin, this.origin);
        transform.multiplyVector(this.direction, this.direction);
    }
    /** Copy data from another ray. */
    setFrom(source) { this.set(source.origin, source.direction); }
    /** * fraction 0 is the ray origin.
     * * fraction 1 is at the end of the direction vector when placed at the origin.
     * @returns Return a point at fractional position along the ray.
     */
    fractionToPoint(fraction) { return this.origin.plusScaled(this.direction, fraction); }
    /** @returns Return the dot product of the ray's direction vector with a vector from the ray origin to the space point. */
    dotProductToPoint(spacePoint) { return this.direction.dotProductStartEnd(this.origin, spacePoint); }
    /**
     * @returns Return the fractional coordinate (along the direction vector) of the spacePoint projected to the ray.
     */
    pointToFraction(spacePoint) {
        return Geometry_1.Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin, spacePoint), this.direction.magnitudeSquared(), 0);
    }
    /**
     *
     * @returns Return the spacePoint projected onto the ray.
     */
    projectPointToRay(spacePoint) {
        return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));
    }
    /** Return a transform for rigid axes
     * at ray origin with z in ray direction.  If the direction vector is zero, axes default to identity (from createHeadsUpTriad)
     */
    toRigidZFrame() {
        const axes = Transform_1.RotMatrix.createRigidHeadsUp(this.direction, 2 /* ZXY */);
        return Transform_1.Transform.createOriginAndMatrix(this.origin, axes);
    }
    /**
     * Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d.
     */
    setFromJSON(json) {
        if (!json) {
            this.origin.set(0, 0, 0);
            this.direction.set(0, 0, 1);
            return;
        }
        this.origin.setFromJSON(json.origin);
        this.direction.setFromJSON(json.direction);
    }
    /**
     * try to scale the direction vector to a given magnitude.
     * @returns Returns false if ray direction is a zero vector.
     */
    trySetDirectionMagnitudeInPlace(magnitude = 1.0) {
        if (this.direction.tryNormalizeInPlace()) {
            this.direction.scaleInPlace(magnitude);
            return true;
        }
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    // input a ray and "a" understood as an area.
    // if a is clearly nonzero metric squared and the vector can be normalized, install those and return true.
    // otherwise set ray.z to zero and zero the vector of the ray and return false.
    tryNormalizeInPlaceWithAreaWeight(a) {
        const tolerance = Geometry_1.Geometry.smallMetricDistanceSquared;
        this.a = a;
        if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))
            return true;
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this.origin.toJSON(), direction: this.direction.toJSON() }; }
    static fromJSON(json) {
        const result = Ray3d.createXAxis();
        result.setFromJSON(json);
        return result;
    }
    /** return distance to point in space */
    distance(spacePoint) {
        const uu = this.direction.magnitudeSquared();
        const uv = this.dotProductToPoint(spacePoint);
        const aa = Geometry_1.Geometry.inverseMetricDistanceSquared(uu);
        if (aa)
            return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);
        else
            return Math.sqrt(this.origin.distanceSquared(spacePoint));
    }
    /**
     * Return the intersection of the unbounded ray with a plane.
     * Stores the point of intersection in the result point given as a parameter,
     * and returns the parameter along the ray where the intersection occurs.
     * Returns undefined if the ray and plane are parallel.
     */
    intersectionWithPlane(plane, result) {
        const vectorA = PointVector_1.Vector3d.createStartEnd(plane.getOriginRef(), this.origin);
        const uDotN = this.direction.dotProduct(plane.getNormalRef());
        const aDotN = vectorA.dotProduct(plane.getNormalRef());
        const division = Geometry_1.Geometry.conditionalDivideFraction(-aDotN, uDotN);
        if (!division)
            return undefined;
        if (result) {
            this.origin.plusScaled(this.direction, division, result);
        }
        return division;
    }
}
exports.Ray3d = Ray3d;
/**
 * A Point3dVector3dVector3d is an origin and a pair of vectors.
 * This defines a plane with (possibly skewed) uv coordinates
 */
class Plane3dByOriginAndVectors {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.vectorU.setFrom(vectorU);
            result.vectorV.setFrom(vectorV);
            return result;
        }
        return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /** Capture origin and directions in a new planed. */
    static createCapture(origin, vectorU, vectorV, result) {
        if (!result)
            return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);
        result.origin = origin;
        result.vectorU = vectorU;
        result.vectorV = vectorV;
        return result;
    }
    setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz) {
        this.origin.set(x0, y0, z0);
        this.vectorU.set(ux, uy, uz);
        this.vectorV.set(vx, vy, vz);
        return this;
    }
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    static createOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz, result) {
        if (result)
            return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);
        return new Plane3dByOriginAndVectors(PointVector_1.Point3d.create(x0, y0, z0), PointVector_1.Vector3d.create(ux, uy, uz), PointVector_1.Vector3d.create(vx, vy, vz));
    }
    /** Define a plane by three points in the plane.
     * @param origin origin for the parameterization.
     * @param targetU target point for the vectorU starting at the origin.
     * @param targetV target point for the vectorV originating at the origin.
     * @param result optional result.
     */
    static createOriginAndTargets(origin, targetU, targetV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);
    }
    /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction.
     */
    static createXYPlane(result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);
    }
    /** create a plane from data presented as Float64Arrays.
     * @param origin x,y,z of origin.
     * @param vectorU x,y,z of vectorU
     * @param vectorV x,y,z of vectorV
     */
    static createOriginAndVectorsArrays(origin, vectorU, vectorV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);
    }
    /** create a plane from data presented as Float64Array with weights
     * @param origin x,y,z,w of origin.
     * @param vectorU x,y,z,w of vectorU
     * @param vectorV x,y,z,w of vectorV
     */
    static createOriginAndVectorsWeightedArrays(originw, vectorUw, vectorVw, result) {
        const w = originw[3];
        result = Plane3dByOriginAndVectors.createXYPlane(result);
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return result;
        const dw = 1.0 / w;
        const au = vectorUw[3] * dw * dw;
        const av = vectorVw[3] * dw * dw;
        // for homogeneous function X, with w its weight:
        // (X/w) is the cartesian point.
        // (X/w)' = (X' w - X w')/(w*w)
        //        = X'/w  - (X/w)(w'/w)
        //        = X'/w  - X w'/w^2)
        // The w parts of the formal xyzw sums are identically 0.
        // Here the X' and its w' are taken from each vectorUw and vectorVw
        result.origin.set(originw[0] * dw, originw[1] * dw, originw[2] * dw);
        PointVector_1.Vector3d.add2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originw[0], originw[1], originw[2], -au, result.vectorU);
        PointVector_1.Vector3d.add2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originw[0], originw[1], originw[2], -av, result.vectorV);
        return result;
    }
    /**
     * Evaluate a point a grid coordinates on the plane.
     * * The computed point is `origin + vectorU * u + vectorV * v`
     * @param u coordinate along vectorU
     * @param v coordinate along vectorV
     * @param result optional result destination.
     * @returns Return the computed coordinate.
     */
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    fractionToVector(u, v, result) {
        return PointVector_1.Vector3d.add2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    setFromJSON(json) {
        if (!json || !json.origin || !json.vectorV) {
            this.origin.set(0, 0, 0);
            this.vectorU.set(1, 0, 0);
            this.vectorV.set(0, 1, 0);
        }
        else {
            this.origin.setFromJSON(json.origin);
            this.vectorU.setFromJSON(json.vectorU);
            this.vectorV.setFromJSON(json.vectorV);
        }
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() {
        return {
            origin: this.origin.toJSON(),
            vectorU: this.vectorU.toJSON(),
            vectorV: this.vectorV.toJSON(),
        };
    }
    static fromJSON(json) {
        const result = Plane3dByOriginAndVectors.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
}
exports.Plane3dByOriginAndVectors = Plane3dByOriginAndVectors;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const BezierPolynomials_1 = __webpack_require__(137);
const PointVector_1 = __webpack_require__(4);
const Range_1 = __webpack_require__(21);
const Transform_1 = __webpack_require__(6);
const AnalyticGeometry_1 = __webpack_require__(11);
const Newton_1 = __webpack_require__(138);
const Quadrature_1 = __webpack_require__(106);
/**
 * An enumeration of special conditions being described by a CurveLocationDetail.
 */
var CurveIntervalRole;
(function (CurveIntervalRole) {
    /** This point is an isolated point NOT at a primary vertex. */
    CurveIntervalRole[CurveIntervalRole["isolated"] = 0] = "isolated";
    /**  This point is an isolated vertex hit */
    CurveIntervalRole[CurveIntervalRole["isolatedAtVertex"] = 1] = "isolatedAtVertex";
    /** This is the beginning of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalStart"] = 10] = "intervalStart";
    /** This is an interior point of an interval. */
    CurveIntervalRole[CurveIntervalRole["intervalInterior"] = 11] = "intervalInterior";
    /** This is the end of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalEnd"] = 12] = "intervalEnd";
})(CurveIntervalRole = exports.CurveIntervalRole || (exports.CurveIntervalRole = {}));
/**
 * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.
 */
class CurveLocationDetail {
    constructor() {
        this.pointQ = PointVector_1.Point3d.createZero();
        this.fraction = 0;
        this.point = PointVector_1.Point3d.createZero();
        this.vector = PointVector_1.Vector3d.unitX();
        this.a = 0.0;
    }
    /** Set the (optional) intervalRole field */
    setIntervalRole(value) {
        this.intervalRole = value;
    }
    /** test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */
    isIsolated() {
        return this.intervalRole === undefined
            || this.intervalRole === CurveIntervalRole.isolated
            || this.intervalRole === CurveIntervalRole.isolatedAtVertex;
    }
    /** @returns Return a complete copy */
    clone(result) {
        if (result === this)
            return result;
        result = result ? result : new CurveLocationDetail();
        result.curve = this.curve;
        result.fraction = this.fraction;
        result.point = this.point;
        result.vector = this.vector;
        result.a = this.a;
        return result;
    }
    // Set the fraction, point, with optional vector and number.
    // (curve is unchanged)
    setFP(fraction, point, vector, a) {
        this.fraction = fraction;
        this.point.setFrom(point);
        if (vector)
            this.vector.setFrom(vector);
        else
            this.vector.set(0, 0, 0);
        this.a = a ? a : 0;
    }
    // Set the fraction, point, and vector
    setFR(fraction, ray, a) {
        this.fraction = fraction;
        this.point.setFrom(ray.origin);
        this.vector.setFrom(ray.direction);
        this.a = a ? a : 0;
    }
    /** Set the CurvePrimitive pointer, leaving all other properties untouched.
     */
    setCurve(curve) { this.curve = curve; }
    /** record the distance from the CurveLocationDetail's point to the parameter point. */
    setDistanceTo(point) {
        this.a = this.point.distance(point);
    }
    /** create with a CurvePrimitive pointer but no coordinate data.
     */
    static create(curve, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveFractionPoint(curve, fraction, point, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point = point.clone();
        result.vector.set(0, 0, 0);
        result.a = 0.0;
        return result;
    }
}
exports.CurveLocationDetail = CurveLocationDetail;
/** A pair of CurveLocationDetail. */
class CurveLocationDetailPair {
    constructor() {
        this.detailA = new CurveLocationDetail();
        this.detailB = new CurveLocationDetail();
    }
    /** Create a curve detail pair using references to two CurveLocationDetails */
    static createDetailRef(detailA, detailB, result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = detailA;
        result.detailB = detailB;
        return result;
    }
    /** Make a deep copy of this CurveLocationDetailPair */
    clone(result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = this.detailA.clone();
        result.detailB = this.detailB.clone();
        return result;
    }
}
exports.CurveLocationDetailPair = CurveLocationDetailPair;
/** Queries to be supported by Curve, Surface, and Solid objects */
class GeometryQuery {
    /** return the range of the entire (tree) GeometryQuery */
    range(transform, result) {
        if (result)
            result.setNull();
        const range = result ? result : Range_1.Range3d.createNull();
        this.extendRange(range, transform);
        return range;
    }
    /** try to move the geometry by dx,dy,dz */
    tryTranslateInPlace(dx, dy = 0.0, dz = 0.0) {
        return this.tryTransformInPlace(Transform_1.Transform.createTranslationXYZ(dx, dy, dz));
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    get children() { return undefined; }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        if (this.isSameGeometryClass(other)) {
            const childrenA = this.children;
            const childrenB = other.children;
            if (childrenA && childrenB) {
                if (childrenA.length !== childrenB.length)
                    return false;
                for (let i = 0; i < childrenA.length; i++) {
                    if (!childrenA[i].isAlmostEqual(childrenB[i]))
                        return false;
                }
                return true;
            }
            else if (childrenA || childrenB) {
                return false; // plainly different .
            }
            else {
                // both children null. call it equal?   This class should probably have implemented.
                return true;
            }
        }
        return false;
    }
}
exports.GeometryQuery = GeometryQuery;
/**
 * A curve primitive is bounded
 * A curve primitive maps fractions in 0..1 to points in space.
 * As the fraction proceeds from 0 towards 1, the point moves "forward" along the curve.
 * True distance along the curve is not always strictly proportional to fraction.
 * * LineSegment3d always has proportional fraction and distance
 * * an Arc3d which is true circular has proportional fraction and distance
 * *  A LineString3d is not proportional (except for special case of all segments of equal length)
 * * A Spiral3d is proportional
 * * A BsplineCurve3d is only proportional for special cases.
 *
 * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate an extended curve.
 */
class CurvePrimitive extends GeometryQuery {
    constructor() { super(); }
    /**
     *
     * @param fraction fractional position on the curve
     * @param result optional receiver for the result.
     * @returns Returns a ray whose origin is the curve point and direction is the unit tangent.
     */
    fractionToPointAndUnitTangent(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction, result);
        ray.trySetDirectionMagnitudeInPlace(1.0);
        return ray;
    }
    /** Construct a frenet frame:
     * * origin at the point on the curve
     * * x axis is unit vector along the curve (tangent)
     * * y axis is perpendicular and in the plane of the osculating circle.
     * * z axis perpendicular to those.
     */
    fractionToFrenetFrame(fraction, result) {
        const plane = this.fractionToPointAnd2Derivatives(fraction);
        if (!plane)
            return undefined;
        let axes = Transform_1.RotMatrix.createRigidFromColumns(plane.vectorU, plane.vectorV, 0 /* XYZ */);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        // 2nd derivative not distinct -- do arbitrary headsup ...
        const perpVector = Transform_1.RotMatrix.createRigidHeadsUpFavorXYPlane(plane.vectorU, plane.vectorV);
        axes = Transform_1.RotMatrix.createRigidFromColumns(plane.vectorU, perpVector, 0 /* XYZ */);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        return undefined;
    }
    /**
     *
     * * Curve length is always positive.
     * @returns Returns a (high accuracy) length of the curve.
     * @returns Returns the length of the curve.
     */
    curveLength() {
        const context = new CurveLengthContext();
        this.emitStrokableParts(context);
        return context.getSum();
    }
    /** Search for the curve point that is closest to the spacePoint.
     *
     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.
     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed
     * @param spacePoint point in space
     * @param extend true to extend the curve (if possible)
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, extend) {
        const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);
        this.emitStrokableParts(strokeHandler);
        return strokeHandler.claimResult();
    }
    /**
     * Find intervals of this curvePrimitive that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(_clipper, _announce) {
        // DEFAULT IMPLEMENTATION -- no interior parts
        return false;
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param _fractionA [in] start fraction
     * @param _fractionB [in] end fraction
     */
    clonePartialCurve(_fractionA, _fractionB) {
        return undefined;
    }
    /**
     * Compute intersections with a plane.
     * The intersections are appended to the result array.
     * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a Newton iteration to get
     * high-accuracy intersection points within strokes.
     * Derived classes should override this default implementation if there are easy analytic solutions.
     * @param plane The plane to be intersected.
     * @param result Array to receive intersections
     * @returns Return the number of CurveLocationDetail's added to the result array.
     */
    appendPlaneIntersectionPoints(plane, result) {
        const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);
        const n0 = result.length;
        this.emitStrokableParts(strokeHandler);
        return result.length - n0;
    }
    /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    /** @returns return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */
    endPoint(result) { return this.fractionToPoint(1.0, result); }
}
exports.CurvePrimitive = CurvePrimitive;
/** Intermediate class for managing the parentCurve announcements from an IStrokeHandler */
class NewtonRotRStrokeHandler extends Newton_1.NewtonEvaluatorRtoR {
    constructor() {
        super();
        this.parentCurvePrimitive = undefined;
    }
    /** retain the parentCurvePrimitive */
    startParentCurvePrimitive(curve) { this.parentCurvePrimitive = curve; }
    /** Forget the parentCurvePrimitive */
    endParentCurvePrimitive(_curve) { this.parentCurvePrimitive = undefined; }
}
class AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(plane, intersections) {
        super();
        this.fractionA = 0;
        this.functionA = 0;
        // private derivativeA: number;   <---- Not currently used
        this.functionB = 0;
        this.fractionB = 0;
        this.derivativeB = 0;
        this.numThisCurve = 0;
        this.plane = plane;
        this.intersections = intersections;
        this.startCurvePrimitive(undefined);
        this.ray = AnalyticGeometry_1.Ray3d.createZero();
        this.newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    // Return the first defined curve among: this.parentCurvePrimitive, this.curve;
    effectiveCurve() {
        if (this.parentCurvePrimitive)
            return this.parentCurvePrimitive;
        return this.curve;
    }
    get getDerivativeB() { return this.derivativeB; } // <--- DerivativeB is not currently used anywhere. Provided getter to suppress tslint error
    startCurvePrimitive(curve) {
        this.curve = curve;
        this.fractionA = 0.0;
        this.numThisCurve = 0;
        this.functionA = 0.0;
        // this.derivativeA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this.ray);
            this.announcePointTangent(this.ray.origin, fraction, this.ray.direction);
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {
        const h0 = this.plane.altitude(point0);
        const h1 = this.plane.altitude(point1);
        if (h0 * h1 > 0.0)
            return;
        const fraction01 = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        // let numIntersection = 0;
        if (fraction01 !== undefined) {
            // numIntersection++;
            const fraction = Geometry_1.Geometry.interpolate(fraction0, fraction01, fraction1);
            this.newtonSolver.setX(fraction);
            if (this.newtonSolver.runIterations()) {
                this.announceSolutionFraction(this.newtonSolver.getX());
            }
            // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));
        }
    }
    announceSolutionFraction(fraction) {
        if (this.curve) {
            this.ray = this.curve.fractionToPointAndDerivative(fraction, this.ray);
            this.intersections.push(CurveLocationDetail.createCurveFractionPoint(this.curve, fraction, this.ray.origin));
        }
    }
    evaluate(fraction) {
        const curve = this.effectiveCurve();
        if (!curve)
            return false;
        this.currentF = this.plane.altitude(curve.fractionToPoint(fraction));
        return true;
    }
    searchInterval() {
        if (this.functionA * this.functionB > 0)
            return;
        if (this.functionA === 0)
            this.announceSolutionFraction(this.fractionA);
        if (this.functionB === 0)
            this.announceSolutionFraction(this.fractionB);
        if (this.functionA * this.functionB > 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this.fractionA, this.functionA, this.fractionB, this.functionB);
            if (fraction) {
                this.newtonSolver.setX(fraction);
                if (this.newtonSolver.runIterations())
                    this.announceSolutionFraction(this.newtonSolver.getX());
            }
        }
    }
    evaluateB(xyz, fraction, tangent) {
        this.functionB = this.plane.altitude(xyz);
        this.derivativeB = this.plane.velocity(tangent);
        this.fractionB = fraction;
    }
    announcePointTangent(xyz, fraction, tangent) {
        this.evaluateB(xyz, fraction, tangent);
        if (this.numThisCurve++ > 0)
            this.searchInterval();
        this.functionA = this.functionB;
        this.fractionA = this.fractionB;
        this.fractionA = this.fractionB;
    }
}
class CurveLengthContext {
    tangentMagnitude(fraction) {
        this.ray = this.curve.fractionToPointAndDerivative(fraction, this.ray);
        return this.ray.direction.magnitude();
    }
    getSum() { return this.summedLength; }
    constructor() {
        this.startCurvePrimitive(undefined);
        this.summedLength = 0.0;
        this.ray = AnalyticGeometry_1.Ray3d.createZero();
        const maxGauss = 7;
        this.gaussX = new Float64Array(maxGauss);
        this.gaussW = new Float64Array(maxGauss);
        this.gaussMapper = Quadrature_1.Quadrature.setupGauss5;
    }
    startCurvePrimitive(curve) {
        this.curve = curve;
    }
    startParentCurvePrimitive(_curve) { }
    endParentCurvePrimitive(_curve) { }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 1; i <= numStrokes; i++) {
            const fractionA = Geometry_1.Geometry.interpolate(fraction0, (i - 1) * df, fraction1);
            const fractionB = i === numStrokes ? fraction1 : Geometry_1.Geometry.interpolate(fraction0, (i) * df, fraction1);
            const numGauss = this.gaussMapper(fractionA, fractionB, this.gaussX, this.gaussW);
            for (let k = 0; k < numGauss; k++) {
                this.summedLength += this.gaussW[k] * this.tangentMagnitude(this.gaussX[k]);
            }
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, _fraction0, _fraction1) {
        this.summedLength += point0.distance(point1);
    }
    announcePointTangent(_xyz, _fraction, _tangent) {
        // uh oh -- need to retain point for next interval
    }
}
// context for searching for closest point .. .
class ClosestPointStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(spacePoint, extend) {
        super();
        this.fractionA = 0;
        this.functionA = 0;
        this.functionB = 0;
        this.fractionB = 0;
        this.numThisCurve = 0;
        this.spacePoint = spacePoint;
        this.workPoint = PointVector_1.Point3d.create();
        this.workRay = AnalyticGeometry_1.Ray3d.createZero();
        this.closestPoint = undefined;
        this.extend = extend;
        this.startCurvePrimitive(undefined);
        this.newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    claimResult() {
        if (this.closestPoint) {
            this.newtonSolver.setX(this.closestPoint.fraction);
            this.curve = this.closestPoint.curve;
            if (this.newtonSolver.runIterations())
                this.announceSolutionFraction(this.newtonSolver.getX());
        }
        return this.closestPoint;
    }
    startCurvePrimitive(curve) {
        this.curve = curve;
        this.fractionA = 0.0;
        this.numThisCurve = 0;
        this.functionA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this.workRay);
            this.announceRay(fraction, this.workRay);
        }
    }
    announceCandidate(cp, fraction, point) {
        const distance = this.spacePoint.distance(point);
        if (this.closestPoint && distance > this.closestPoint.a)
            return;
        this.closestPoint = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this.closestPoint);
        this.closestPoint.a = distance;
        if (this.parentCurvePrimitive !== undefined)
            this.closestPoint.curve = this.parentCurvePrimitive;
    }
    announceSegmentInterval(cp, point0, point1, _numStrokes, fraction0, fraction1) {
        let localFraction = this.spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);
        // only consider extending the segment if the immediate caller says we are at endpoints ...
        if (!this.extend)
            localFraction = Geometry_1.Geometry.clampToStartEnd(localFraction, 0.0, 1.0);
        else {
            if (fraction0 !== 0.0)
                localFraction = Math.max(localFraction, 0.0);
            if (fraction1 !== 1.0)
                localFraction = Math.min(localFraction, 1.0);
        }
        this.workPoint = point0.interpolate(localFraction, point1);
        const globalFraction = Geometry_1.Geometry.interpolate(fraction0, localFraction, fraction1);
        this.announceCandidate(cp, globalFraction, this.workPoint);
    }
    searchInterval() {
        if (this.functionA * this.functionB > 0)
            return;
        if (this.functionA === 0)
            this.announceSolutionFraction(this.fractionA);
        if (this.functionB === 0)
            this.announceSolutionFraction(this.fractionB);
        if (this.functionA * this.functionB < 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this.fractionA, this.functionA, this.fractionB, this.functionB);
            if (fraction) {
                this.newtonSolver.setX(fraction);
                if (this.newtonSolver.runIterations())
                    this.announceSolutionFraction(this.newtonSolver.getX());
            }
        }
    }
    evaluateB(fractionB, dataB) {
        this.functionB = dataB.dotProductToPoint(this.spacePoint);
        this.fractionB = fractionB;
    }
    announceSolutionFraction(fraction) {
        if (this.curve)
            this.announceCandidate(this.curve, fraction, this.curve.fractionToPoint(fraction));
    }
    evaluate(fraction) {
        let curve = this.curve;
        if (this.parentCurvePrimitive)
            curve = this.parentCurvePrimitive;
        if (curve) {
            this.workRay = curve.fractionToPointAndDerivative(fraction, this.workRay);
            this.currentF = this.workRay.dotProductToPoint(this.spacePoint);
            return true;
        }
        return false;
    }
    announceRay(fraction, data) {
        this.evaluateB(fraction, data);
        if (this.numThisCurve++ > 0)
            this.searchInterval();
        this.functionA = this.functionB;
        this.fractionA = this.fractionB;
        this.fractionA = this.fractionB;
    }
    announcePointTangent(point, fraction, tangent) {
        this.workRay.set(point, tangent);
        this.announceRay(fraction, this.workRay);
    }
}
/** A Coordinate is a persistable Point3d */
class CoordinateXYZ extends GeometryQuery {
    get point() { return this.xyz; }
    /**
     * @param xyz point to be CAPTURED.
     */
    constructor(xyz) {
        super();
        this.xyz = xyz;
    }
    static create(point) {
        return new CoordinateXYZ(point.clone());
    }
    /** return the range of the point */
    range() { return Range_1.Range3d.create(this.xyz); }
    extendRange(rangeToExtend, transform) {
        if (transform)
            rangeToExtend.extendTransformedXYZ(transform, this.xyz.x, this.xyz.y, this.xyz.z);
        else
            rangeToExtend.extend(this.xyz);
    }
    /** Apply transform to the Coordinate's point. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3d(this.xyz, this.xyz);
        return true;
    }
    /** return a transformed clone.
     */
    cloneTransformed(transform) {
        const result = new CoordinateXYZ(this.xyz.clone());
        result.tryTransformInPlace(transform);
        return result;
    }
    /** return a clone */
    clone() {
        return new CoordinateXYZ(this.xyz.clone());
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    /** test if (other instanceof Coordinate).  */
    isSameGeometryClass(other) {
        return other instanceof CoordinateXYZ;
    }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        return (other instanceof CoordinateXYZ) && this.xyz.isAlmostEqual(other.xyz);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleCoordinateXYZ(this);
    }
}
exports.CoordinateXYZ = CoordinateXYZ;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
// import { Geometry, Angle, AngleSweep } from "../Geometry";
// import { Point3d, Vector3d, RotMatrix } from "../PointVector";
const Geometry_1 = __webpack_require__(3);
const CurvePrimitive_1 = __webpack_require__(12);
const CurveSearches_1 = __webpack_require__(248);
const LineString3d_1 = __webpack_require__(10);
/**
 * * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:
 * * * `Path` - a sequence of `CurvePrimitive` joining head-to-tail (but not required to close, and not enclosing a planar area)
 * * * `Loop` - a sequence of coplanar `CurvePrimitive` joining head-to-tail, and closing from last to first so that they enclose a planar area.
 * * * `ParityRegion` -- a colletion of coplanar `Loop`s, with "in/out" classification by parity rules
 * * * `UnionRegion` -- a colletion of coplanar `Loop`s, with "in/out" classification by union rules
 * * * `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.
 */
class CurveCollection extends CurvePrimitive_1.GeometryQuery {
    constructor() {
        super(...arguments);
        /* tslint:disable:variable-name no-empty*/
        // Only used by the Loop class, which is needed during a check in DGNJS writing
        this.isInner = false;
    }
    /** Return the sum of the lengths of all contained curves. */
    sumLengths() { return CurveSearches_1.SumLengthsContext.sumLengths(this); }
    /** return the max gap between adjacent primitives in Path and Loop collctions.
     *
     * * In a Path, gaps are computed between consecutive primitives.
     * * In a Loop, gaps are comptued between consecutvie primtives and between last and first.
     * * gaps are NOT computed between consecutive CurvePrimitives in "unstructured" collections.  The type is "unstructured" so gaps should not be semantically meaningful.
     */
    maxGap() { return CurveSearches_1.GapSearchContext.maxGap(this); }
    /** return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */
    hasNonLinearPrimitives() { return CurveSearches_1.CountLinearPartsSearchContext.hasNonLinearPrimitives(this); }
    tryTransformInPlace(transform) { return CurveSearches_1.TransformInPlaceContext.tryTransformInPlace(this, transform); }
    clone() {
        return CurveSearches_1.CloneCurvesContext.clone(this);
    }
    cloneTransformed(transform) {
        return CurveSearches_1.CloneCurvesContext.clone(this, transform);
    }
    /** Return true for planar region types:
     * * `Loop`
     * * `ParityRegion`
     * * `UnionRegion`
     */
    isAnyRegionType() {
        return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 5 || this.dgnBoundaryType() === 4;
    }
    /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail
     */
    isOpenPath() {
        return this.dgnBoundaryType() === 1;
    }
    /** Return true for a single-loop planar region type, i.e. `Loop`.
     * * This is _not- a test for physical closure of a `Path`
     */
    isClosedPath() {
        return this.dgnBoundaryType() === 2;
    }
    /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed)
     */
    extendRange(rangeToExtend, transform) {
        const children = this.children;
        if (children) {
            for (const c of children) {
                c.extendRange(rangeToExtend, transform);
            }
        }
    }
    /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.
     * @returns Returns undefined if there is any type mismatch between the two collections.
     */
    static mutatePartners(collectionA, collectionB, primitiveMutator) {
        if (!collectionA.isSameGeometryClass(collectionB))
            return undefined;
        if (collectionA instanceof CurveChain && collectionB instanceof CurveChain) {
            const chainA = collectionA;
            const chainB = collectionB;
            const chainC = chainA.cloneEmptyPeer();
            const childrenA = chainA.children;
            const childrenB = chainB.children;
            if (childrenA.length !== childrenA.length)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const newChild = primitiveMutator(childrenA[i], childrenB[i]);
                if (!newChild)
                    return undefined;
                chainC.children.push(newChild);
            }
            return chainC;
        }
        else if (collectionA instanceof CurveCollection && collectionB instanceof CurveCollection) {
            const collectionC = collectionA.cloneEmptyPeer();
            const childrenA = collectionA.children;
            const childrenB = collectionB.children;
            const childrenC = collectionC.children;
            if (!childrenA || !childrenB || !childrenC)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const childA = childrenA[i];
                const childB = childrenB[i];
                if (childA instanceof CurvePrimitive_1.CurvePrimitive && childB instanceof CurvePrimitive_1.CurvePrimitive) {
                    const newPrimitive = primitiveMutator(childA, childB);
                    if (!newPrimitive)
                        return undefined;
                    childrenC.push(newPrimitive);
                }
                else if (childA instanceof CurveCollection && childB instanceof CurveCollection) {
                    const newChild = this.mutatePartners(childA, childB, primitiveMutator);
                    if (!newChild)
                        return undefined;
                    if (newChild instanceof CurveCollection)
                        childrenC.push(newChild);
                }
            }
            return collectionC;
        }
        return undefined;
    }
}
exports.CurveCollection = CurveCollection;
/** Shared base class for use by both open and closed paths.
 * A curveChain contains curvePrimitives.
 */
class CurveChain extends CurveCollection {
    constructor() { super(); this._curves = []; }
    // _curves should be initialized in ctor.  But it doesn't happen.
    get children() {
        if (this._curves === undefined)
            this._curves = [];
        return this._curves;
    }
    getPackedStrokes(options) {
        const tree = this.cloneStroked(options);
        if (tree instanceof CurveChain) {
            const children = tree.children;
            if (children.length === 1) {
                const ls = children[0];
                if (ls instanceof LineString3d_1.LineString3d)
                    return ls.packedPoints;
            }
        }
        return undefined;
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return strokes;
    }
    tryAddChild(child) {
        if (child instanceof CurvePrimitive_1.CurvePrimitive) {
            this._curves.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._curves.length)
            return this._curves[i];
        return undefined;
    }
    extendRange(range, transform) {
        for (const curve of this._curves)
            curve.extendRange(range, transform);
    }
}
exports.CurveChain = CurveChain;
/**
 * * A `Path` object is a collection of curves that join head-to-tail to form a path.
 * * A `Path` object does not bound a planar region.
 */
class Path extends CurveChain {
    isSameGeometryClass(other) { return other instanceof Path; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announcePath(this, indexInParent);
    }
    constructor() { super(); }
    static create(...curves) {
        const result = new Path();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Path.create(strokes);
    }
    dgnBoundaryType() { return 1; }
    cyclicCurvePrimitive(index) {
        if (index >= 0 && index < this.children.length)
            return this.children[index];
        return undefined;
    }
    cloneEmptyPeer() { return new Path(); }
    dispatchToGeometryHandler(handler) {
        return handler.handlePath(this);
    }
}
exports.Path = Path;
/**
 * A `Loop` is a curve chain that is the boundary of a closed (planar) loop.
 */
class Loop extends CurveChain {
    constructor() {
        super();
        this.isInner = false;
    }
    isSameGeometryClass(other) { return other instanceof Loop; }
    static create(...curves) {
        const result = new Loop();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    static createPolygon(points) {
        const linestring = LineString3d_1.LineString3d.create(points);
        linestring.addClosurePoint();
        return Loop.create(linestring);
    }
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Loop.create(strokes);
    }
    dgnBoundaryType() { return 2; } // (2) all "Loop" become "outer"
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceLoop(this, indexInParent);
    }
    cyclicCurvePrimitive(index) {
        const n = this.children.length;
        if (n >= 1) {
            index = Geometry_1.Geometry.modulo(index, this.children.length);
            return this.children[index];
        }
        return undefined;
    }
    cloneEmptyPeer() { return new Loop(); }
    dispatchToGeometryHandler(handler) {
        return handler.handleLoop(this);
    }
}
exports.Loop = Loop;
/**
 * * A `ParityRegion` is a collection of `Loop` objects.
 * * The loops collectively define a planar region.
 * * A point is "in" the composite region if it is "in" an odd number of the loops.
 */
class ParityRegion extends CurveCollection {
    isSameGeometryClass(other) { return other instanceof ParityRegion; }
    get children() { return this._children; }
    constructor() { super(); this._children = []; }
    static create(...data) {
        const result = new ParityRegion();
        for (const child of data) {
            result.children.push(child);
        }
        return result;
    }
    dgnBoundaryType() { return 4; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceParityRegion(this, indexInParent);
    }
    clone() {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childClone = child.clone();
            if (childClone instanceof Loop)
                clone.children.push(childClone);
        }
        return clone;
    }
    cloneStroked(options) {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    cloneEmptyPeer() { return new ParityRegion(); }
    tryAddChild(child) {
        if (child instanceof Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleParityRegion(this);
    }
}
exports.ParityRegion = ParityRegion;
/**
 * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.
 * * The composite is the union of the contained regions.
 * * A point is "in" the composite if it is "in" one or more of the contained regions.
 */
class UnionRegion extends CurveCollection {
    isSameGeometryClass(other) { return other instanceof UnionRegion; }
    get children() { return this._children; }
    constructor() { super(); this._children = []; }
    static create(...data) {
        const result = new UnionRegion();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    dgnBoundaryType() { return 5; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceUnionRegion(this, indexInParent);
    }
    cloneStroked(options) {
        const clone = new UnionRegion();
        let child;
        for (child of this._children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    cloneEmptyPeer() { return new UnionRegion(); }
    tryAddChild(child) {
        if (child instanceof ParityRegion || child instanceof Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleUnionRegion(this);
    }
}
exports.UnionRegion = UnionRegion;
/**
 * * A `BagOfCurves` object is a collection of `AnyCurve` objects.
 * * A `BagOfCurves` is not a planar region.
 */
class BagOfCurves extends CurveCollection {
    isSameGeometryClass(other) { return other instanceof BagOfCurves; }
    constructor() { super(); this._children = []; }
    get children() { return this._children; }
    static create(...data) {
        const result = new BagOfCurves();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    dgnBoundaryType() { return 0; }
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceBagOfCurves(this, indexInParent);
    }
    cloneStroked(options) {
        const clone = new BagOfCurves();
        let child;
        for (child of this.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive) {
                const ls = LineString3d_1.LineString3d.create();
                child.emitStrokes(ls, options);
                if (ls)
                    clone.children.push(ls);
            }
            else if (child instanceof CurveCollection) {
                const childStrokes = child.cloneStroked(options);
                if (childStrokes)
                    clone.children.push(childStrokes);
            }
        }
        return clone;
    }
    cloneEmptyPeer() { return new BagOfCurves(); }
    tryAddChild(child) {
        this._children.push(child);
        return true;
    }
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBagOfCurves(this);
    }
}
exports.BagOfCurves = BagOfCurves;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const IModelApp_1 = __webpack_require__(5);
const imodeljs_common_1 = __webpack_require__(2);
const FuzzySearch_1 = __webpack_require__(205);
var BeCursor;
(function (BeCursor) {
    BeCursor["Default"] = "default";
    BeCursor["CrossHair"] = "crosshair";
    BeCursor["OpenHand"] = "grab";
    BeCursor["ClosedHand"] = "grabbing";
    BeCursor["Rotate"] = "move";
    BeCursor["Arrow"] = "default";
    BeCursor["NotAllowed"] = "not-allowed";
    BeCursor["Text"] = "text";
    BeCursor["Busy"] = "wait";
    BeCursor["Dynamics"] = "move";
})(BeCursor = exports.BeCursor || (exports.BeCursor = {}));
class BeButtonState {
    constructor() {
        this._downUorPt = new geometry_core_1.Point3d();
        this._downRawPt = new geometry_core_1.Point3d();
        this.downTime = 0;
        this.isDown = false;
        this.isDoubleClick = false;
        this.isDragging = false;
        this.inputSource = 0 /* Unknown */;
    }
    get downRawPt() { return this._downRawPt; }
    set downRawPt(pt) { this._downRawPt.setFrom(pt); }
    get downUorPt() { return this._downUorPt; }
    set downUorPt(pt) { this._downUorPt.setFrom(pt); }
    init(downUorPt, downRawPt, downTime, isDown, isDoubleClick, isDragging, source) {
        this.downUorPt = downUorPt;
        this.downRawPt = downRawPt;
        this.downTime = downTime;
        this.isDown = isDown;
        this.isDoubleClick = isDoubleClick;
        this.isDragging = isDragging;
        this.inputSource = source;
    }
}
exports.BeButtonState = BeButtonState;
class BeButtonEvent {
    constructor() {
        this._point = new geometry_core_1.Point3d();
        this._rawPoint = new geometry_core_1.Point3d();
        this._viewPoint = new geometry_core_1.Point3d();
        this.coordsFrom = 0 /* User */; // how were the coordinate values in point generated?
        this.keyModifiers = 0 /* None */;
        this.isDoubleClick = false;
        this.isDown = false;
        this.button = 0 /* Data */;
        this.inputSource = 0 /* Unknown */;
        this.actualInputSource = 0 /* Unknown */;
    }
    get isValid() { return this.viewport !== undefined; }
    get point() { return this._point; }
    set point(pt) { this._point.setFrom(pt); }
    get rawPoint() { return this._rawPoint; }
    set rawPoint(pt) { this._rawPoint.setFrom(pt); }
    get viewPoint() { return this._viewPoint; }
    set viewPoint(pt) { this._viewPoint.setFrom(pt); }
    invalidate() { this.viewport = undefined; }
    initEvent(point, rawPoint, viewPt, vp, from, keyModifiers, button = 0 /* Data */, isDown = true, doubleClick = false, source = 0 /* Unknown */) {
        this.point = point;
        this.rawPoint = rawPoint;
        this.viewPoint = viewPt;
        this.viewport = vp;
        this.coordsFrom = from;
        this.keyModifiers = keyModifiers;
        this.isDoubleClick = doubleClick;
        this.isDown = isDown;
        this.button = button;
        this.inputSource = source;
        this.actualInputSource = source;
    }
    getDisplayPoint() { return new geometry_core_1.Point2d(this._viewPoint.x, this._viewPoint.y); }
    get isControlKey() { return 0 !== (this.keyModifiers & 1 /* Control */); }
    get isShiftKey() { return 0 !== (this.keyModifiers & 4 /* Shift */); }
    get isAltKey() { return 0 !== (this.keyModifiers & 8 /* Alt */); }
    setFrom(src) {
        this.point = src.point;
        this.rawPoint = src.rawPoint;
        this.viewPoint = src.viewPoint;
        this.viewport = src.viewport;
        this.coordsFrom = src.coordsFrom;
        this.keyModifiers = src.keyModifiers;
        this.isDoubleClick = src.isDoubleClick;
        this.isDown = src.isDown;
        this.button = src.button;
        this.inputSource = src.inputSource;
        this.actualInputSource = src.actualInputSource;
    }
    clone(result) {
        result = result ? result : new BeButtonEvent();
        result.setFrom(this);
        return result;
    }
    /**
     * Get the anchor point for a Zoom operation, based on this button event, by supplying a point
     * for the result.
     * @return boolean value of whether the point comes from an AccuSnap location
     */
    getTargetPoint(result) {
        let isSnap;
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            isSnap = true;
            result.setFrom(IModelApp_1.IModelApp.tentativePoint.getPoint());
        }
        else if (IModelApp_1.IModelApp.accuSnap.isHot()) {
            isSnap = false;
            result.setFrom(this.rawPoint);
        }
        else {
            isSnap = 0 /* User */ !== this.coordsFrom;
            result.setFrom(isSnap ? this.point : this.rawPoint);
        }
        return isSnap;
    }
}
exports.BeButtonEvent = BeButtonEvent;
/** Describes a "gesture" input originating from a touch-input device. */
class GestureInfo {
    constructor() {
        this.gestureId = 0 /* None */;
        this.numberTouches = 0;
        this.previousNumberTouches = 0; // Only meaningful for GestureId::SingleFingerMove and GestureId::MultiFingerMove
        this.touches = [new geometry_core_1.Point2d(), new geometry_core_1.Point2d(), new geometry_core_1.Point2d()];
        this.ptsLocation = new geometry_core_1.Point2d(); // Location of centroid
        this.distance = 0; // Only meaningful on motion with multiple touches
        this.isEndGesture = false;
        this.isFromMouse = false;
    }
    getViewPoint(vp) {
        const screenRect = vp.viewRect;
        return new geometry_core_1.Point3d(this.ptsLocation.x - screenRect.left, this.ptsLocation.y - screenRect.top, 0.0);
    }
    init(gestureId, centerX, centerY, distance, touchPoints, isEnding, isFromMouse, prevNumTouches) {
        this.gestureId = gestureId;
        this.numberTouches = Math.min(touchPoints.length, 3);
        this.previousNumberTouches = prevNumTouches;
        this.isEndGesture = isEnding;
        this.isFromMouse = isFromMouse;
        this.ptsLocation.x = Math.floor(centerX);
        this.ptsLocation.y = Math.floor(centerY);
        this.distance = distance;
        for (let i = 0; i < this.numberTouches; ++i) {
            this.touches[i].x = Math.floor(touchPoints[i].x);
            this.touches[i].y = Math.floor(touchPoints[i].y);
        }
    }
    copyFrom(src) {
        this.gestureId = src.gestureId;
        this.numberTouches = src.numberTouches;
        this.previousNumberTouches = src.previousNumberTouches;
        this.isEndGesture = src.isEndGesture;
        this.ptsLocation.x = src.ptsLocation.x;
        this.ptsLocation.y = src.ptsLocation.y;
        this.distance = src.distance;
        for (let i = 0; i < this.numberTouches; ++i) {
            this.touches[i].x = src.touches[i].x;
            this.touches[i].y = src.touches[i].y;
        }
        this.isFromMouse = src.isFromMouse;
    }
    clone(result) {
        result = result ? result : new GestureInfo();
        result.copyFrom(this);
        return result;
    }
}
exports.GestureInfo = GestureInfo;
/** Specialization of ButtonEvent describing a gesture event originating from touch input. */
class BeGestureEvent extends BeButtonEvent {
    setFrom(src) {
        super.setFrom(src);
        this.gestureInfo = src.gestureInfo;
    }
    clone(result) {
        result = result ? result : new BeGestureEvent();
        result.setFrom(this);
        return result;
    }
}
exports.BeGestureEvent = BeGestureEvent;
/** Information about movement of the mouse wheel. */
class BeWheelEvent extends BeButtonEvent {
    constructor(wheelDelta = 0) {
        super();
        this.wheelDelta = wheelDelta;
    }
    setFrom(src) {
        super.setFrom(src);
        this.wheelDelta = src.wheelDelta;
    }
    clone(result) {
        result = result ? result : new BeWheelEvent();
        result.setFrom(this);
        return result;
    }
}
exports.BeWheelEvent = BeWheelEvent;
/**
 * Base Tool class for handling user input events from Viewports.
 * @see [Tools]($docs/learning/frontend/tools.md)
 */
class Tool {
    constructor(..._args) { }
    static getKeyinKey() { return this.namespace.name + ":tools." + this.toolId + ".keyin"; }
    static getFlyoverKey() { return this.namespace.name + ":tools." + this.toolId + ".flyover"; }
    static getDescriptionKey() { return this.namespace.name + ":tools." + this.toolId + ".description"; }
    /**
     * Register this Tool class with the ToolRegistry.
     * @param namespace optional namespace to supply to ToolRegistry.register. If undefined, use namespace from superclass.
     */
    static register(namespace) { IModelApp_1.IModelApp.tools.register(this, namespace); }
    /**
     * Get the localized keyin string for this Tool class. This returns the value of "tools." + this.toolId + ".keyin" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json")
     */
    static get keyin() { return this._keyin ? this._keyin : (this._keyin = IModelApp_1.IModelApp.i18n.translate(this.getKeyinKey())); }
    /**
     * Get the localized flyover for this Tool class. This returns the value of "tools." + this.toolId + ".flyover" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json"). If that key is not in the localization namespace,
     * the keyin property is returned.
     */
    static get flyover() { return this._flyover ? this._flyover : (this._flyover = IModelApp_1.IModelApp.i18n.translate([this.getFlyoverKey(), this.getKeyinKey()])); }
    /**
     * Get the localized description for this Tool class. This returns the value of "tools." + this.toolId + ".description" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json"). If that key is not in the localization namespace,
     * the flyover property is returned.
     */
    static get description() { return this._description ? this._description : (this._description = IModelApp_1.IModelApp.i18n.translate([this.getDescriptionKey(), this.getFlyoverKey(), this.getKeyinKey()])); }
    /**
     * Get the toolId string for this Tool class. This string is used to identify the Tool in the ToolRegistry and is used to localize
     * the keyin, description, etc. from the current locale.
     */
    get toolId() { return this.constructor.toolId; }
    /** Get the localized keyin string from this Tool's class */
    get keyin() { return this.constructor.keyin; }
    /** Get the localized flyover string from this Tool's class */
    get flyover() { return this.constructor.flyover; }
    /** Get the localized description string from this Tool's class */
    get description() { return this.constructor.description; }
    /**
     * Run this instance of a Tool. Subclasses should override to perform some action.
     * @returns `true` if the tool executed successfully.
     */
    run(..._arg) { return true; }
}
/** If true, this Tool will not appear in the list from [[ToolRegistry.getToolList]]. */
Tool.hidden = false;
/** The unique string that identifies this tool. */
Tool.toolId = "";
exports.Tool = Tool;
/**
 * A Tool that may be installed, via [[ToolAdmin]], to handle user input. The ToolAdmin manages the currently installed ViewingTool, PrimitiveTool,
 * InputCollector, and IdleTool. Each must derive from this class and there may only be one of each type installed at a time.
 */
class InteractiveTool extends Tool {
    /** Override to execute additional logic when tool is installed. Return false to prevent this tool from becoming active */
    onInstall() { return true; }
    /** Override to execute additional logic after tool becomes active */
    onPostInstall() { }
    /** Override Call to reset tool to initial state */
    onReinitialize() { }
    /** Invoked when the tool becomes no longer active, to perform additional cleanup logic */
    onCleanup() { }
    /** Notification of a ViewTool or InputCollector starting and this tool is being suspended.
     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    onSuspend() { }
    /** Notification of a vViewTool or InputCollector exiting and this tool is being unsuspended.
     *  @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    onUnsuspend() { }
    /**
     * Called to allow an active tool to display non-element decorations in overlay mode.
     * This method is NOT called while the tool is suspended by a viewing tool or input collector.
     */
    decorate(_context) { }
    /**
     * Called to allow a suspended tool to display non-element decorations in overlay mode.
     * This method is ONLY called when the tool is suspended by a viewing tool or input collector.
     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    decorateSuspended(_context) { }
    /** Invoked when the reset button is pressed.
     * @return false by default. Sub-classes may ascribe special meaning to this status.
     * @note To support right-press menus, a tool should put its reset event processing in onResetButtonUp instead of onResetButtonDown.
     */
    onResetButtonDown(_ev) { return false; }
    /** Invoked when the reset button is released.
     * @return false by default. Sub-classes may ascribe special meaning to this status.
     */
    onResetButtonUp(_ev) { return false; }
    /** Invoked when the data button is pressed.
     * @return false by default. Sub-classes may ascribe special meaning to this status.
     */
    onDataButtonDown(_ev) { return false; }
    /** Invoked when the data button is released.
     * @return false by default. Sub-classes may ascribe special meaning to this status.
     */
    onDataButtonUp(_ev) { return false; }
    /** Invoked when the middle mouse button is pressed.
     * @return true if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    onMiddleButtonDown(_ev) { return false; }
    /** Invoked when the middle mouse button is released.
     * @return true if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    onMiddleButtonUp(_ev) { return false; }
    /** Invoked when the cursor is moving */
    onModelMotion(_ev) { }
    /** Invoked when the cursor is not moving */
    onModelNoMotion(_ev) { }
    /** Invoked when the cursor was previously moving, and has stopped moving. */
    onModelMotionStopped(_ev) { }
    /** Invoked when the cursor begins moving while a button is depressed.
     * @return false by default. Sub-classes may ascribe special meaning to this status.
     */
    onModelStartDrag(_ev) { return false; }
    /** Invoked when the button is released after onModelStartDrag.
     * @note default placement tool behavior is to treat press, drag, and release of data button the same as click, click by calling onDataButtonDown.
     */
    onModelEndDrag(ev) { if (0 /* Data */ !== ev.button)
        return false; if (ev.isDown)
        return this.onDataButtonDown(ev); const downEv = ev.clone(); downEv.isDown = true; return this.onDataButtonDown(downEv); }
    /** Invoked when the mouse wheel moves.
     * @return true if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    onMouseWheel(_ev) { return false; }
    /** Called when Control, Shift, or Alt qualifier keys are pressed or released.
     * @param _wentDown up or down key event
     * @param _key One of VirtualKey.Control, VirtualKey.Shift, or VirtualKey.Alt
     * @return true to refresh view decorations or update dynamics.
     */
    onModifierKeyTransition(_wentDown, _key) { return false; }
    /** Called when keys are pressed or released.
     * @param wentDown up or down key event
     * @param key One of VirtualKey enum values
     * @param shiftIsDown the shift key is down
     * @param ctrlIsDown  the control key is down
     * @return true to prevent further processing of this event
     * @note In case of Shift, Control and Alt key, onModifierKeyTransition is used.
     */
    onKeyTransition(_wentDown, _key, _shiftIsDown, _ctrlIsDown) { return false; }
    onEndGesture(_ev) { return false; }
    onSingleFingerMove(_ev) { return false; }
    onMultiFingerMove(_ev) { return false; }
    onTwoFingerTap(_ev) { return false; }
    onPressAndTap(_ev) { return false; }
    onSingleTap(_ev) { return false; }
    onDoubleTap(_ev) { return false; }
    onLongPress(_ev) { return false; }
    onTouchMotionPaused() { return false; }
    isCompatibleViewport(vp, _isSelectedViewChange) { return !!vp; }
    isValidLocation(_ev, _isButtonEvent) { return true; }
    /** Implemented by direct subclasses to handle when the tool becomes no longer active. Generally not overridden by other subclasses */
    /** Invoked when the dimensions of the tool's viewport change */
    onViewportResized() { }
    /**
     * Invoked just before the locate tooltip is displayed to retrieve the info text. Allows the tool to override the default description.
     * @param hit The HitDetail whose info is needed.
     * @param _delimiter Use this string to break lines of the description.
     * @return the string to describe the hit.
     * @note If you override this method, you may decide whether to call your superclass' implementation or not (it is not required).
     * The default implementation shows hit description
     */
    //  public getInfoString(hit: HitDetail, _delimiter: string): string { return hit.hitDescription ? hit.hitDescription : ""; } // NEEDSWORK
    getInfoString(_hit, _delimiter) { return ""; }
    /**   * Fill the supplied button event from the current cursor location.   */
    getCurrentButtonEvent(ev) { IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev); }
    /** Call to find out if dynamics are currently active. */
    isDynamicsStarted() { return IModelApp_1.IModelApp.viewManager.inDynamicsMode; }
    /** Call to initialize dynamics mode. While dynamics are active onDynamicFrame will be called. Dynamics are typically only used by a PrimitiveTool that creates or modifies geometric elements. */
    beginDynamics() { IModelApp_1.IModelApp.toolAdmin.beginDynamics(); }
    /** Call to terminate dynamics mode. */
    endDynamics() { IModelApp_1.IModelApp.toolAdmin.endDynamics(); }
    /** Called to allow tool to display dynamic elements. */
    onDynamicFrame(_ev, _context) { }
}
exports.InteractiveTool = InteractiveTool;
class InputCollector extends InteractiveTool {
    run() {
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        // An input collector can only suspend a primitive tool, don't install if a viewing tool is active...
        if (undefined !== toolAdmin.activeViewTool || !toolAdmin.onInstallTool(this))
            return false;
        toolAdmin.startInputCollector(this);
        toolAdmin.setInputCollector(this);
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    exitTool() { IModelApp_1.IModelApp.toolAdmin.exitInputCollector(); }
    onResetButtonUp(_ev) { this.exitTool(); return true; }
}
exports.InputCollector = InputCollector;
/**
 * The ToolRegistry holds a mapping between toolId and Tool class. This provides the mechanism to
 * find Tools by their toolId, and also a way to iterate over the collection of Tools available.
 */
class ToolRegistry {
    constructor() {
        this.tools = new Map();
    }
    /**
     * Un-register a Tool class.
     * @param toolId the toolId of a previously registered tool to unRegister.
     */
    unRegister(toolId) { this.tools.delete(toolId); this._keyinList = undefined; }
    /**
     * Register a Tool class. This establishes a connection between the toolId of the class and the class itself.
     * @param toolClass the subclass of Tool to register.
     * @param namespace the namespace for the localized strings for this tool. If undefined, use namespace from superclass.
     */
    register(toolClass, namespace) {
        if (namespace)
            toolClass.namespace = namespace;
        if (toolClass.toolId.length === 0)
            return; // must be an abstract class, ignore it
        if (!toolClass.namespace)
            throw new imodeljs_common_1.IModelError(-1, "Tools must have a namespace");
        this.tools.set(toolClass.toolId, toolClass);
        this._keyinList = undefined; // throw away the current keyinList so we'll produce a new one when asked.
    }
    /**
     * register all the Tool classes found in a module.
     * @param modelObj the module to search for subclasses of Tool.
     */
    registerModule(moduleObj, namespace) {
        for (const thisMember in moduleObj) {
            if (!thisMember)
                continue;
            const thisTool = moduleObj[thisMember];
            if (thisTool.prototype instanceof Tool) {
                this.register(thisTool, namespace);
            }
        }
    }
    /** Look up a tool by toolId */
    find(toolId) { return this.tools.get(toolId); }
    /**
     * Look up a tool by toolId and, if found, create an instance with the supplied arguments.
     * @param toolId the toolId of the tool
     * @param args arguments to pass to the constructor.
     * @returns an instance of the registered Tool class, or undefined if toolId is not registered.
     */
    create(toolId, ...args) {
        const toolClass = this.find(toolId);
        return toolClass ? new toolClass(...args) : undefined;
    }
    /**
     * Look up a tool by toolId and, if found, create an instance with the supplied arguments and run it.
     * @param toolId toolId of the immediate tool
     * @param args arguments to pass to the constructor, and to run.
     * @return true if the tool was found and successfully run.
     */
    run(toolId, ...args) {
        const tool = this.create(toolId, ...args);
        return !!tool && tool.run(...args);
    }
    /** Get a list of Tools currently registered, excluding hidden tools */
    getToolList() {
        if (this._keyinList === undefined) {
            this._keyinList = [];
            for (const thisTool of this.tools.values()) {
                if (!thisTool.hidden)
                    this._keyinList.push(thisTool);
            }
        }
        return this._keyinList;
    }
    /**
     * Find a tool by its localized keyin using a FuzzySearch
     * @param keyin the localized keyin string of the tool.
     * @returns the tool class, if an exact match is found.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     */
    findPartialMatches(keyin) {
        const toolList = this.getToolList();
        const searcher = new FuzzySearch_1.FuzzySearch();
        const searchResults = searcher.search(toolList, ["keyin"], keyin);
        return searchResults;
    }
    /**
     * Find a tool by its localized keyin. If found (via exact match), execute the tool with the supplied arguments.
     * @param keyin the localized keyin string of the tool to run.
     * @param args the arguments for the tool. Note: these argument are passed to both the constructor and the tools' run method.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     */
    executeExactMatch(keyin, ...args) {
        const foundClass = this.findExactMatch(keyin);
        return foundClass ? new foundClass(...args).run(...args) : false;
    }
    /**
     * Find a tool by its localized keyin.
     * @param keyin the localized keyin string of the tool.
     * @returns the tool class, if an exact match is found.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     */
    findExactMatch(keyin) {
        const commandList = this.getToolList();
        for (const thisTool of commandList) {
            if (thisTool.keyin === keyin)
                return thisTool;
        }
        return undefined;
    }
}
exports.ToolRegistry = ToolRegistry;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module iModels */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
var bentleyjs_core_2 = __webpack_require__(0);
exports.BentleyError = bentleyjs_core_2.BentleyError;
/** The error type thrown by this module. See [[IModelStatus]] for `errorNumber` values. */
class IModelError extends bentleyjs_core_1.BentleyError {
    constructor(errorNumber, message, log, category, getMetaData) {
        super(errorNumber, message, log, category, getMetaData);
    }
}
exports.IModelError = IModelError;
class ServerError extends IModelError {
    constructor(errorNumber, message, log) {
        super(errorNumber, message, log);
        this.name = "Server error (" + errorNumber + ")";
    }
}
exports.ServerError = ServerError;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const MeshPrimitives_1 = __webpack_require__(43);
const ImageUtil_1 = __webpack_require__(72);
const IModelApp_1 = __webpack_require__(5);
/**
 * A RenderPlan holds a Frustum and the render settings for displaying a RenderScene into a RenderTarget.
 */
class RenderPlan {
    constructor(vp) {
        const view = vp.view;
        const style = view.displayStyle;
        this.is3d = view.is3d();
        this.viewFlags = style.viewFlags;
        this.frustum = vp.getFrustum();
        this.fraction = vp.frustFraction;
        this.bgColor = view.backgroundColor;
        this.monoColor = style.getMonochromeColor();
        this.hiliteSettings = vp.hilite;
        this.aaLines = vp.wantAntiAliasLines;
        this.aaText = vp.wantAntiAliasText;
        this.activeVolume = view.getViewClip();
        this.hline = style.is3d() ? style.getHiddenLineParams() : undefined;
        this.lights = undefined; // view.is3d() ? view.getLights() : undefined
    }
}
exports.RenderPlan = RenderPlan;
/** A renderer-specific object that can be placed into a display list. */
class RenderGraphic {
}
exports.RenderGraphic = RenderGraphic;
/** Interface adopted by a type which can apply a clipping volume to a Target. */
class RenderClipVolume {
}
exports.RenderClipVolume = RenderClipVolume;
/** A graphic used for decorations, optionally with symbology overrides. */
class Decoration {
    constructor(graphic, overrides) {
        this.graphic = graphic;
        this.overrides = overrides;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.graphic);
    }
}
exports.Decoration = Decoration;
class DecorationList {
    constructor() { this.list = []; }
    dispose() {
        for (const decoration of this.list)
            bentleyjs_core_1.dispose(decoration);
        this.list.length = 0;
    }
    add(graphic, ovrs) {
        this.list.push(new Decoration(graphic, ovrs));
    }
}
exports.DecorationList = DecorationList;
/**
 * A set of GraphicLists of various types of RenderGraphics that are "decorated" into the RenderTarget,
 * in addition to the Scene.
 */
class Decorations {
    // Getters & Setters - dispose of members before resetting
    get skyBox() { return this._skyBox; }
    set skyBox(skyBox) {
        bentleyjs_core_1.dispose(this._skyBox);
        this._skyBox = skyBox;
    }
    get viewBackground() { return this._viewBackground; }
    set viewBackground(viewBackground) {
        bentleyjs_core_1.dispose(this._viewBackground); // no effect if already disposed
        this._viewBackground = viewBackground;
    }
    get normal() { return this._normal; }
    set normal(normal) {
        if (this._normal)
            for (const graphic of this._normal)
                bentleyjs_core_1.dispose(graphic);
        this._normal = normal;
    }
    get world() { return this._world; }
    set world(world) {
        bentleyjs_core_1.dispose(this._world); // no effect if already disposed
        this._world = world;
    }
    get worldOverlay() { return this._worldOverlay; }
    set worldOverlay(worldOverlay) {
        bentleyjs_core_1.dispose(this._worldOverlay); // no effect if already disposed
        this._worldOverlay = worldOverlay;
    }
    get viewOverlay() { return this._viewOverlay; }
    set viewOverlay(viewOverlay) {
        bentleyjs_core_1.dispose(this._viewOverlay); // no effect if already disposed
        this._viewOverlay = viewOverlay;
    }
    dispose() {
        this._skyBox = bentleyjs_core_1.dispose(this._skyBox);
        this._viewBackground = bentleyjs_core_1.dispose(this._viewBackground);
        this._world = bentleyjs_core_1.dispose(this._world);
        this._worldOverlay = bentleyjs_core_1.dispose(this._worldOverlay);
        this._viewOverlay = bentleyjs_core_1.dispose(this._viewOverlay);
        if (this._normal)
            for (const graphic of this._normal)
                bentleyjs_core_1.dispose(graphic);
        this._normal = undefined;
    }
}
exports.Decorations = Decorations;
class GraphicBranch {
    constructor() {
        this.entries = [];
        this._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides();
    }
    add(graphic) {
        this.entries.push(graphic);
    }
    addRange(graphics) {
        graphics.forEach(this.add);
    }
    getViewFlags(flags, out) { return this._viewFlagOverrides.apply(flags.clone(out)); }
    setViewFlags(flags) { this._viewFlagOverrides.overrideAll(flags); }
    setViewFlagOverrides(ovr) { this._viewFlagOverrides.copyFrom(ovr); }
    clear() {
        this.entries.length = 0;
    }
    get isEmpty() { return 0 === this.entries.length; }
}
exports.GraphicBranch = GraphicBranch;
/** Describes aspects of a pixel as read from a RenderTarget. */
var Pixel;
(function (Pixel) {
    class Data {
        constructor(elementId, distanceFraction = -1.0, type = 0 /* Unknown */, planarity = 0 /* Unknown */) {
            this.elementId = elementId;
            this.distanceFraction = distanceFraction;
            this.type = type;
            this.planarity = planarity;
        }
    }
    Pixel.Data = Data;
})(Pixel = exports.Pixel || (exports.Pixel = {}));
/**
 * A RenderTarget holds the current scene, the current set of dynamic RenderGraphics, and the current decorators.
 * When frames are composed, all of those RenderGraphics are rendered, as appropriate.
 *
 * A RenderTarget holds a reference to a RenderSystem.
 *
 * Every Viewport holds a reference to a RenderTarget.
 */
class RenderTarget {
    static get frustumDepth2d() { return 1.0; } // one meter
    static get maxDisplayPriority() { return (1 << 23) - 32; }
    static get displayPriorityFactor() { return this.frustumDepth2d / (this.maxDisplayPriority + 1); }
    static depthFromDisplayPriority(priority) { return this.displayPriorityFactor * priority; }
    createGraphic(params) { return this.renderSystem.createGraphic(params); }
}
exports.RenderTarget = RenderTarget;
class SkyBoxCreateParams {
    get isTexturedCube() { return !this._isGradient; }
    get isGradient() { return this._isGradient; }
    constructor(isGradient, front, back, top, bottom, left, right) {
        this._isGradient = isGradient;
        this.front = front;
        this.back = back;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }
    static createForTexturedCube(front, back, top, bottom, left, right) {
        return new SkyBoxCreateParams(false, front, back, top, bottom, left, right);
    }
    static createForGradient() {
        // ###TODO
        return new SkyBoxCreateParams(true);
    }
}
exports.SkyBoxCreateParams = SkyBoxCreateParams;
/**
 * A RenderSystem is the renderer-specific factory for creating RenderGraphics, RenderTexture, and RenderMaterials.
 */
class RenderSystem {
    get isPainting() { return !!this._nowPainting; }
    checkPainting(target) { return target === this._nowPainting; }
    startPainting(target) { bentleyjs_core_1.assert(!this.isPainting); this._nowPainting = target; }
    nowPainting() { this._nowPainting = undefined; }
    isValid() { return this.canvas !== undefined; }
    constructor(canvas) { this.canvas = canvas; }
    /** Find a previously-created Material by key. Returns null if no such material exists. */
    findMaterial(_key, _imodel) { return undefined; }
    /** Create a RenderMaterial from parameters */
    createMaterial(_params, _imodel) { return undefined; }
    // /** Create a Viewlet from parameters */
    // public abstract createViewlet(branch: GraphicBranch, plan: Plan, position: ViewletPosition): Graphic;
    /** Create a triangle mesh primitive */
    createTriMesh(_args) { return undefined; }
    /** Create an indexed polyline primitive */
    createIndexedPolylines(_args) { return undefined; }
    // /** Create a point cloud primitive */
    createPointCloud(_args, _imodel) { return undefined; }
    /** Attempt to create a clipping volume for the given iModel using a clip vector. */
    getClipVolume(_clipVector, _imodel) { return undefined; }
    /** Create a tile primitive */
    createTile(tileTexture, corners) {
        const rasterTile = new MeshPrimitives_1.MeshArgs();
        // corners
        // [0] [1]
        // [2] [3]
        rasterTile.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.create(...corners)));
        for (let i = 0; i < 4; ++i)
            rasterTile.points.add(corners[i]);
        rasterTile.vertIndices = [0, 1, 2, 2, 1, 3];
        rasterTile.textureUv = [
            new geometry_core_1.Point2d(0.0, 0.0),
            new geometry_core_1.Point2d(1.0, 0.0),
            new geometry_core_1.Point2d(0.0, 1.0),
            new geometry_core_1.Point2d(1.0, 1.0),
        ];
        rasterTile.texture = tileTexture;
        rasterTile.isPlanar = true;
        return this.createTriMesh(rasterTile);
    }
    /** Create a Graphic for a sky box which encompasses the entire scene, rotating with the camera.  See SkyBoxCreateParams. */
    createSkyBox(_params) { return undefined; }
    /** Get or create a Texture from a RenderTexture element. Note that there is a cache of textures stored on an IModel, so this may return a pointer to a previously-created texture. */
    findTexture(_key, _imodel) { return undefined; }
    /** Create a new Texture from gradient symbology. */
    getGradientTexture(_symb, _imodel) { return undefined; }
    /** Create a new Texture from an ImageBuffer. */
    createTextureFromImageBuffer(_image, _imodel, _params) { return undefined; }
    /** Create a new Texture from an HTML image. Typically the image was extracted from a binary representation of a jpeg or png via ImageUtil.extractImage() */
    createTextureFromImage(_image, _hasAlpha, _imodel, _params) { return undefined; }
    /** Create a new Texture from an ImageSource. */
    async createTextureFromImageSource(source, imodel, params) {
        return ImageUtil_1.ImageUtil.extractImage(source).then((image) => IModelApp_1.IModelApp.hasRenderSystem ? this.createTextureFromImage(image, 2 /* Png */ === source.format, imodel, params) : undefined);
    }
    // /** Create a Light from Light.Parameters */
    // public abstract createLight(params: LightingParameters, direction: Vector3d, location: Point3d): Light;
    onInitialized() { }
}
exports.RenderSystem = RenderSystem;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(9));
__export(__webpack_require__(68));
__export(__webpack_require__(165));
__export(__webpack_require__(275));
__export(__webpack_require__(276));
__export(__webpack_require__(32));
__export(__webpack_require__(69));
__export(__webpack_require__(186));
__export(__webpack_require__(114));
__export(__webpack_require__(304));
__export(__webpack_require__(111));
__export(__webpack_require__(31));
__export(__webpack_require__(23));
__export(__webpack_require__(305));
__export(__webpack_require__(187));
__export(__webpack_require__(306));
__export(__webpack_require__(307));
__export(__webpack_require__(115));
__export(__webpack_require__(308));
__export(__webpack_require__(189));


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
const RenderFlags_1 = __webpack_require__(24);
const debugPrint_1 = __webpack_require__(219);
/** Associate texture data with a WebGLTexture from a canvas, image, OR a bitmap. */
function loadTextureImageData(handle, params, bytes, element) {
    const tex = handle.getHandle();
    const gl = System_1.System.instance.context;
    // Use tightly packed data
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    // Bind the texture object; make sure we do not interfere with other active textures
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    // send the texture data
    if (undefined !== element) {
        gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.format, params.dataType, element);
    }
    else {
        const pixelData = undefined !== bytes ? bytes : null;
        gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.width, params.height, 0, params.format, params.dataType, pixelData);
    }
    if (params.useMipMaps) {
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapMode);
    gl.bindTexture(gl.TEXTURE_2D, null);
}
function loadTextureFromBytes(handle, params, bytes) { loadTextureImageData(handle, params, bytes); }
/** Wrapper class for a WebGL texture handle and parameters specific to an individual texture. */
class Texture extends imodeljs_common_1.RenderTexture {
    constructor(params, texture) {
        super(params);
        this.texture = texture;
    }
    /** Free this object in the WebGL wrapper. */
    dispose() {
        bentleyjs_core_1.dispose(this.texture);
    }
    get hasTranslucency() { return GL_1.GL.Texture.Format.Rgba === this.texture.format; }
}
exports.Texture = Texture;
/** Parameters used internally to define how to create a texture for use with WebGL. */
class TextureCreateParams {
    constructor(width, height, format, dataType, wrapMode, loadImageData, useMipMaps, interpolate, dataBytes) {
        this.width = width;
        this.height = height;
        this.format = format;
        this.dataType = dataType;
        this.wrapMode = wrapMode;
        this.loadImageData = loadImageData;
        this.useMipMaps = useMipMaps;
        this.interpolate = interpolate;
        this.dataBytes = dataBytes;
    }
    static createForData(width, height, data, preserveData = false, wrapMode = GL_1.GL.Texture.WrapMode.ClampToEdge, format = GL_1.GL.Texture.Format.Rgba) {
        return new TextureCreateParams(width, height, format, GL_1.GL.Texture.DataType.UnsignedByte, wrapMode, (tex, params) => loadTextureFromBytes(tex, params, data), undefined, undefined, preserveData ? data : undefined);
    }
    static createForImageBuffer(image, type) {
        const props = this.getImageProperties(0 /* Rgba */ === image.format, type);
        return new TextureCreateParams(image.width, image.height, props.format, GL_1.GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTextureFromBytes(tex, params, image.data), props.useMipMaps, props.interpolate);
    }
    static createForAttachment(width, height, format, dataType) {
        return new TextureCreateParams(width, height, format, dataType, GL_1.GL.Texture.WrapMode.ClampToEdge, (tex, params) => loadTextureFromBytes(tex, params), undefined, undefined);
    }
    static createForImage(image, hasAlpha, type) {
        const props = this.getImageProperties(hasAlpha, type);
        let targetWidth = image.naturalWidth;
        let targetHeight = image.naturalHeight;
        const caps = System_1.System.instance.capabilities;
        if (1 /* Glyph */ === type) {
            targetWidth = imodeljs_common_1.nextHighestPowerOfTwo(targetWidth);
            targetHeight = imodeljs_common_1.nextHighestPowerOfTwo(targetHeight);
        }
        else if (!caps.supportsNonPowerOf2Textures && (!imodeljs_common_1.isPowerOfTwo(targetWidth) || !imodeljs_common_1.isPowerOfTwo(targetHeight))) {
            if (GL_1.GL.Texture.WrapMode.ClampToEdge === props.wrapMode) {
                // NPOT are supported but not mipmaps
                // Probably on poor hardware so I choose to disable mipmaps for lower memory usage over quality. If quality is required we need to resize the image to a pow of 2.
                // Above comment is not necessarily true - WebGL doesn't support NPOT mipmapping, only supporting base NPOT caps
                props.useMipMaps = undefined;
            }
            else if (GL_1.GL.Texture.WrapMode.Repeat === props.wrapMode) {
                targetWidth = imodeljs_common_1.nextHighestPowerOfTwo(targetWidth);
                targetHeight = imodeljs_common_1.nextHighestPowerOfTwo(targetHeight);
            }
        }
        let element = image;
        if (targetWidth !== image.naturalWidth || targetHeight !== image.naturalHeight) {
            // Resize so dimensions are powers-of-two
            const canvas = document.createElement("canvas");
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
            element = canvas;
        }
        return new TextureCreateParams(targetWidth, targetHeight, props.format, GL_1.GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTextureImageData(tex, params, undefined, element), props.useMipMaps, props.interpolate);
    }
    static getImageProperties(isTranslucent, type) {
        const isSky = 3 /* SkyBox */ === type;
        const isTile = 2 /* TileSection */ === type;
        const wrapMode = 0 /* Normal */ === type ? GL_1.GL.Texture.WrapMode.Repeat : GL_1.GL.Texture.WrapMode.ClampToEdge;
        const useMipMaps = (!isSky && !isTile) ? true : undefined;
        const interpolate = true;
        const format = isTranslucent ? GL_1.GL.Texture.Format.Rgba : GL_1.GL.Texture.Format.Rgb;
        return { format, wrapMode, useMipMaps, interpolate };
    }
}
TextureCreateParams.placeholderParams = new TextureCreateParams(1, 1, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte, GL_1.GL.Texture.WrapMode.ClampToEdge, (_tex, _params) => undefined);
/** Wraps a WebGLTextureHandle */
class TextureHandle {
    constructor(glTexture, params) {
        this._glTexture = glTexture;
        this.width = params.width;
        this.height = params.height;
        this.format = params.format;
        this.dataType = params.dataType;
        this.dataBytes = params.dataBytes;
        if (TextureHandle.wantDebugIds) {
            glTexture._debugId = ++TextureHandle._debugId;
            TextureHandle._debugId %= TextureHandle._maxDebugId;
        }
        params.loadImageData(this, params);
    }
    getHandle() { return this._glTexture; }
    /** Binds texture handle (if available) associated with an instantiation of this class to specified texture unit. */
    bind(texUnit) {
        if (undefined === this._glTexture)
            return false;
        TextureHandle.bindTexture(texUnit, this._glTexture);
        return true;
    }
    /** Binds specified texture handle to specified texture unit. */
    static bindTexture(texUnit, glTex) {
        bentleyjs_core_1.assert(!(glTex instanceof TextureHandle));
        const gl = System_1.System.instance.context;
        gl.activeTexture(texUnit);
        gl.bindTexture(gl.TEXTURE_2D, glTex !== undefined ? glTex : null);
        if (this.wantDebugIds)
            debugPrint_1.debugPrint("Texture Unit " + (texUnit - RenderFlags_1.TextureUnit.Zero) + " = " + (glTex ? glTex._debugId : "null"));
    }
    /** Binds this texture to a uniform sampler2D */
    bindSampler(uniform, unit) {
        if (undefined !== this._glTexture)
            TextureHandle.bindSampler(uniform, this._glTexture, unit);
    }
    /** Binds the specified texture to a uniform sampler2D */
    static bindSampler(uniform, tex, unit) {
        bentleyjs_core_1.assert(!(tex instanceof TextureHandle));
        this.bindTexture(unit, tex);
        uniform.setUniform1i(unit - RenderFlags_1.TextureUnit.Zero);
    }
    update(updater) {
        if (0 === this.width || 0 === this.height || undefined === this.dataBytes || 0 === this.dataBytes.length) {
            bentleyjs_core_1.assert(false);
            return false;
        }
        if (!updater.modified)
            return false;
        const tex = this.getHandle();
        if (undefined === tex)
            return false;
        const gl = System_1.System.instance.context;
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this.format, this.dataType, this.dataBytes);
        return true;
    }
    get isDisposed() { return this._glTexture === undefined; }
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteTexture(this._glTexture);
            this._glTexture = undefined;
        }
    }
    static create(params) {
        const glTex = System_1.System.instance.context.createTexture();
        return null !== glTex ? new TextureHandle(glTex, params) : undefined;
    }
    /** Create a texture for use as a color attachment for rendering */
    static createForAttachment(width, height, format, dataType) {
        return this.create(TextureCreateParams.createForAttachment(width, height, format, dataType));
    }
    /** Create a texture to hold non-image data */
    static createForData(width, height, data, wantPreserveData = false, wrapMode = GL_1.GL.Texture.WrapMode.ClampToEdge, format = GL_1.GL.Texture.Format.Rgba) {
        return this.create(TextureCreateParams.createForData(width, height, data, wantPreserveData, wrapMode, format));
    }
    /** Create a texture from a bitmap */
    static createForImageBuffer(image, type) {
        bentleyjs_core_1.assert(imodeljs_common_1.isPowerOfTwo(image.width) && imodeljs_common_1.isPowerOfTwo(image.height), "###TODO: Resize image dimensions to powers-of-two if necessary");
        return this.create(TextureCreateParams.createForImageBuffer(image, type));
    }
    static createForImage(image, hasAlpha, type) {
        return this.create(TextureCreateParams.createForImage(image, hasAlpha, type));
    }
}
// Set following to true to assign sequential numeric identifiers to WebGLTexture objects.
// This helps in debugging issues in which e.g. the same texture is bound as an input and output.
TextureHandle.wantDebugIds = false;
TextureHandle._debugId = 0;
TextureHandle._maxDebugId = 0xffffff;
exports.TextureHandle = TextureHandle;
class TextureDataUpdater {
    constructor(data) {
        this.modified = false;
        this.data = data;
    }
    setByteAtIndex(index, byte) {
        bentleyjs_core_1.assert(index < this.data.length);
        if (byte !== this.data[index]) {
            this.data[index] = byte;
            this.modified = true;
        }
    }
    setOvrFlagsAtIndex(index, value) {
        bentleyjs_core_1.assert(index < this.data.length);
        if (value !== this.data[index]) {
            this.data[index] = value;
            this.modified = true;
        }
    }
    getByteAtIndex(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    getFlagsAtIndex(index) { return this.getByteAtIndex(index); }
}
exports.TextureDataUpdater = TextureDataUpdater;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(81);
const RenderFlags_1 = __webpack_require__(24);
const Decode_1 = __webpack_require__(85);
const LookupTable_1 = __webpack_require__(230);
const initializeVertLUTCoords = `
  g_vertexLUTIndex = decodeUInt32(a_pos);
  g_vertexBaseCoords = compute_vert_coords(g_vertexLUTIndex);
`;
const unquantizePosition = `
vec4 unquantizePosition(vec3 pos, vec3 origin, vec3 scale) { return vec4(origin + scale * pos, 1.0); }
`;
const unquantizeVertexPosition = `
vec4 unquantizeVertexPosition(vec3 pos, vec3 origin, vec3 scale) { return unquantizePosition(pos, origin, scale); }
`;
const unquantizeVertexPositionFromLUT = `
vec4 unquantizeVertexPosition(vec3 encodedIndex, vec3 origin, vec3 scale) {
  // Need to read 2 rgba values to obtain 6 16-bit integers for position
  vec2 tc = g_vertexBaseCoords;
  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  g_featureIndexCoords = tc;

  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));

  // Might as well decode the color index since we already read it...may not end up being used.
  // (NOTE = If this is a textured mesh, the normal is stored where the color index would otherwise be...)
  g_vertexData2 = enc2.zw;

  return unquantizePosition(qpos, origin, scale);
}
`;
const scratchMVPMatrix = new Matrix_1.Matrix4();
function addModelViewProjectionMatrix(vert) {
    vert.addUniform("u_mvp", 8 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_mvp", (uniform, params) => {
            const mvp = params.projectionMatrix.clone(scratchMVPMatrix);
            mvp.multiplyBy(params.modelViewMatrix);
            uniform.setMatrix4(mvp);
        });
    });
}
exports.addModelViewProjectionMatrix = addModelViewProjectionMatrix;
function addProjectionMatrix(vert) {
    vert.addUniform("u_proj", 8 /* Mat4 */, (prog) => {
        prog.addProgramUniform("u_proj", (uniform, params) => {
            uniform.setMatrix4(params.projectionMatrix);
        });
    });
}
exports.addProjectionMatrix = addProjectionMatrix;
function addModelViewMatrix(vert) {
    vert.addUniform("u_mv", 8 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_mv", (uniform, params) => {
            uniform.setMatrix4(params.modelViewMatrix);
        });
    });
}
exports.addModelViewMatrix = addModelViewMatrix;
function addNormalMatrix(vert) {
    vert.addUniform("u_nmx", 7 /* Mat3 */, (prog) => {
        prog.addGraphicUniform("u_nmx", (uniform, params) => {
            const rotMat = params.modelViewMatrix.getRotation();
            if (undefined !== rotMat)
                uniform.setMatrix3(rotMat);
        });
    });
}
exports.addNormalMatrix = addNormalMatrix;
const scratchLutParams = new Float32Array(4);
function addPositionFromLUT(vert) {
    vert.addGlobal("g_vertexLUTIndex", 3 /* Float */);
    vert.addGlobal("g_vertexBaseCoords", 4 /* Vec2 */);
    vert.addGlobal("g_vertexData2", 4 /* Vec2 */);
    vert.addGlobal("g_featureIndexCoords", 4 /* Vec2 */);
    vert.addFunction(Decode_1.GLSLDecode.uint32);
    vert.addFunction(Decode_1.GLSLDecode.uint16);
    vert.addFunction(unquantizeVertexPositionFromLUT);
    vert.addUniform("u_vertLUT", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_vertLUT", (uniform, params) => {
            params.geometry.lut.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.VertexLUT);
        });
    });
    vert.addUniform("u_vertParams", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_vertParams", (uniform, params) => {
            const lutGeom = params.geometry;
            const lut = lutGeom.lut;
            const lutParams = scratchLutParams;
            lutParams[0] = lut.texture.width;
            lutParams[1] = lut.texture.height;
            lutParams[2] = lut.numRgbaPerVertex;
            lutParams[3] = lut.numVertices;
            uniform.setUniform4fv(lutParams);
        });
    });
    LookupTable_1.addLookupTable(vert, "vert", "u_vertParams.z");
    vert.addInitializer(initializeVertLUTCoords);
}
function addPosition(vert, fromLUT) {
    vert.addFunction(unquantizePosition);
    vert.addAttribute("a_pos", 5 /* Vec3 */, (prog) => {
        prog.addAttribute("a_pos", (attr, params) => { params.geometry.bindVertexArray(attr); });
    });
    vert.addUniform("u_qScale", 5 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qScale", (uniform, params) => {
            uniform.setUniform3fv(params.geometry.qScale);
        });
    });
    vert.addUniform("u_qOrigin", 5 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qOrigin", (uniform, params) => {
            uniform.setUniform3fv(params.geometry.qOrigin);
        });
    });
    if (!fromLUT) {
        vert.addFunction(unquantizeVertexPosition);
    }
    else {
        addPositionFromLUT(vert);
    }
}
exports.addPosition = addPosition;
function addAlpha(vert) {
    vert.addUniform("u_hasAlpha", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_hasAlpha", (uniform, params) => {
            uniform.setUniform1f(4 /* Translucent */ === params.geometry.getRenderPass(params.target) ? 1.0 : 0.0);
        });
    });
}
exports.addAlpha = addAlpha;
var GLSLVertex;
(function (GLSLVertex) {
    GLSLVertex.earlyDiscard = `
  if (checkForEarlyDiscard(rawPosition)) {
    // This vertex belongs to a triangle which should not be rendered. Produce a degenerate triangle.
    // Also place it outside NDC range (for GL_POINTS)
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }

`;
    GLSLVertex.discard = `
  if (checkForDiscard()) {
    // This vertex belongs to a triangle which should not be rendered. Produce a degenerate triangle.
    // Also place it outside NDC range (for GL_POINTS)
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }

`;
    GLSLVertex.computeLineWeight = "\nfloat ComputeLineWeight() { return u_lineWeight; }\n";
    GLSLVertex.computeLineCode = "\nfloat ComputeLineCode() { return u_lineCode; }\n";
})(GLSLVertex = exports.GLSLVertex || (exports.GLSLVertex = {}));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
class RangeBase {
    /** @return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */
    static npcScaleFactor(low, high) { return (high <= low) ? 0.0 : 1.0 / (high - low); }
    static isExtremeValue(x) { return Math.abs(x) >= RangeBase.EXTREME_POSITIVE; }
    static isExtremePoint3d(xyz) { return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z); }
    static isExtremePoint2d(xy) { return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y); }
    /**
     * * Both low,high pairs have order expectations:  The condition `high > low` means null interval.
     * * If there is interval overlap, the distance is zero.
     * @returns The min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.
     * @param lowA low of interval A
     * @param highA high of interval A
     * @param lowB low of interval B
     * @param highB high of interval B
     */
    static rangeToRangeAbsoluteDistance(lowA, highA, lowB, highB) {
        if (highA < lowA)
            return RangeBase.EXTREME_POSITIVE;
        if (highB < lowB)
            return RangeBase.EXTREME_POSITIVE;
        if (highB < lowA)
            return lowA - highB;
        if (highB <= highA)
            return 0.0;
        if (lowB <= highA)
            return 0.0;
        return lowB - highA;
    }
    static coordinateToRangeAbsoluteDistance(x, low, high) {
        if (high < low)
            return RangeBase.EXTREME_POSITIVE;
        if (x < low)
            return low - x;
        if (x > high)
            return x - high;
        return 0.0;
    }
}
RangeBase.EXTREME_POSITIVE = 1.0e200;
RangeBase.EXTREME_NEGATIVE = -1.0e200;
exports.RangeBase = RangeBase;
class Range3d extends RangeBase {
    /** Set this transform to values that indicate it has no contents. */
    setNull() {
        this.low.x = RangeBase.EXTREME_POSITIVE;
        this.low.y = RangeBase.EXTREME_POSITIVE;
        this.low.z = RangeBase.EXTREME_POSITIVE;
        this.high.x = RangeBase.EXTREME_NEGATIVE;
        this.high.y = RangeBase.EXTREME_NEGATIVE;
        this.high.z = RangeBase.EXTREME_NEGATIVE;
    }
    freeze() { Object.freeze(this); Object.freeze(this.low); Object.freeze(this.high); }
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z); }
    toFloat64Array() { return Range3d.toFloat64Array(this); }
    /**
     * Construct a Range3d from an array of double-precision values
     * @param f64 the array, which should contain exactly 6 values in this order: lowx, lowy, lowz, highx, highy, highz
     * @return a new Range3d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 6)
            throw new Error("invalid array");
        return new Range3d(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);
    }
    /**
     * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range3d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    // explicit ctor - no enforcement of value relationships
    constructor(lowx = RangeBase.EXTREME_POSITIVE, lowy = RangeBase.EXTREME_POSITIVE, lowz = RangeBase.EXTREME_POSITIVE, highx = RangeBase.EXTREME_NEGATIVE, highy = RangeBase.EXTREME_NEGATIVE, highz = RangeBase.EXTREME_NEGATIVE) {
        super();
        this.low = PointVector_1.Point3d.create(lowx, lowy, lowz);
        this.high = PointVector_1.Point3d.create(highx, highy, highz);
    }
    /** @returns Returns true if this and other have equal low and high point x,y,z parts */
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull() && other.isNull());
    }
    /** copy low and high values from other. */
    setFrom(other) { this.low.setFrom(other.low); this.high.setFrom(other.high); }
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return Range3d.createXYZXYZOrCorrectToNull(other.low.x, other.low.y, other.low.z, other.high.x, other.high.y, other.high.z, result);
    }
    setFromJSON(json) {
        if (!json)
            return;
        this.setNull();
        if (Array.isArray(json)) {
            const point = PointVector_1.Point3d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = PointVector_1.Point3d.fromJSON(json.low);
        const high = PointVector_1.Point3d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    /** Return a JSON object */
    toJSON() { return { low: this.low.toJSON(), high: this.high.toJSON() }; }
    static fromJSON(json) {
        const result = new Range3d();
        result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(xA, yA, zA, xB, yB, zB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.low.z = zA;
        this.high.x = xB;
        this.high.y = yB;
        this.high.z = zB;
        if (correctToNull) {
            if (this.low.x > this.high.x
                || this.low.y > this.high.y
                || this.low.z > this.high.z)
                this.setNull();
        }
    }
    clone(result) {
        result = result ? result : new Range3d();
        result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);
        return result;
    }
    /** @returns Return a range initialized to have no content. */
    static createNull(result) {
        result = result ? result : new Range3d();
        result.setNull();
        return result;
    }
    /** Extend (modify in place) so that the range is large enough to include the supplied points. */
    extend(...point) {
        let p;
        for (p of point)
            this.extendPoint(p);
    }
    /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */
    static create(...point) {
        const result = Range3d.createNull();
        let p;
        for (p of point)
            result.extendPoint(p);
        return result;
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformed(transform, ...point) {
        const result = Range3d.createNull();
        let p;
        for (p of point)
            result.extendTransformedXYZ(transform, p.x, p.y, p.z);
        return result;
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformedArray(transform, points) {
        const result = Range3d.createNull();
        result.extendArray(points, transform);
        return result;
    }
    /** create a Range3d enclosing the points after inverse transform. */
    static createInverseTransformedArray(transform, points) {
        const result = Range3d.createNull();
        result.extendInverseTransformedArray(points, transform);
        return result;
    }
    /** Set the range to be a single point supplied as x,y,z values */
    setXYZ(x, y, z) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
        this.low.z = this.high.z = z;
    }
    /** Create a single point range */
    static createXYZ(x, y, z, result) {
        result = result ? result : new Range3d();
        result.setDirect(x, y, z, x, y, z, false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */
    static createXYZXYZ(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new Range3d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */
    static createXYZXYZOrCorrectToNull(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new Range3d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);
        return result;
    }
    /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */
    static createRange2d(range, z = 0, result) {
        const retVal = result ? result : new Range3d();
        retVal.setNull();
        retVal.extendXYZ(range.low.x, range.low.y, z);
        retVal.extendXYZ(range.high.x, range.high.y, z);
        return retVal;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new Range3d();
        result.setNull();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** extend a range around an array of points (optionally transformed) */
    extendArray(points, transform) {
        if (Array.isArray(points))
            if (transform)
                for (const point of points)
                    this.extendTransformedXYZ(transform, point.x, point.y, point.z);
            else
                for (const point of points)
                    this.extendXYZ(point.x, point.y, point.z);
        else if (transform)
            for (let i = 0; i < points.length; i++)
                this.extendTransformedXYZ(transform, points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
        else
            for (let i = 0; i < points.length; i++)
                this.extendXYZ(points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
    }
    /** extend a range around an array of points (optionally transformed) */
    extendInverseTransformedArray(points, transform) {
        if (Array.isArray(points))
            for (const point of points)
                this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);
        else
            for (let i = 0; i < points.length; i++)
                this.extendInverseTransformedXYZ(transform, points.getPoint3dAt(i).x, points.getPoint3dAt(i).y, points.getPoint3dAt(i).z);
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        const coffs = transform.matrix.coffs;
        this.extendXYZ(origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendInverseTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        if (!transform.matrix.computeCachedInverse(true))
            return false;
        const coffs = transform.matrix.inverseCoffs;
        const xx = x - origin.x;
        const yy = y - origin.y;
        const zz = z - origin.z;
        this.extendXYZ(coffs[0] * xx + coffs[3] * yy + coffs[6] * zz, coffs[1] * xx + coffs[4] * yy + coffs[7] * zz, coffs[2] * xx + coffs[5] * yy + coffs[8] * zz);
        return true;
    }
    /** Extend the range by the two transforms applied to xyz */
    extendTransformTransformedXYZ(transformA, transformB, x, y, z) {
        const origin = transformB.origin;
        const coffs = transformB.matrix.coffs;
        this.extendTransformedXYZ(transformA, origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y
            || this.high.z < this.low.z;
    }
    /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    static isNull(data) {
        return data.high.x < data.low.x
            || data.high.y < data.low.y
            || data.high.z < data.low.z;
    }
    /** Test of the range contains a single point. */
    isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y
            && this.high.z === this.low.z;
    }
    /** @returns Return the length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /** @returns Return the length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /** @returns Return the length of the box in the z direction */
    zLength() { const a = this.high.z - this.low.z; return a > 0.0 ? a : 0.0; }
    /** @returns Return the largest of the x,y, z lengths of the range. */
    maxLength() { return Math.max(this.xLength(), this.yLength(), this.zLength()); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /** @returns Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /** @returns Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, fractionZ, result) {
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /** @returns Return a point given by fractional positions on the XYZ axes.
     * * Returns undefined if the range is null.
     */
    localXYZToWorld(fractionX, fractionY, fractionZ, result) {
        if (this.isNull())
            return undefined;
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /** @returns Return a point given by fractional positions on the XYZ axes.
     * * Returns undefined if the range is null.
     */
    localToWorld(xyz, result) {
        return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);
    }
    /** Replace fractional coordinates by world coordinates.
     * @return false if null range.
     */
    localToWorldArrayInPlace(points) {
        if (this.isNull())
            return false;
        for (const p of points)
            this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);
        return false;
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocal(point, result) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return undefined;
        return PointVector_1.Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocalArrayInPlace(point) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return false;
        for (const p of point)
            PointVector_1.Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);
        return true;
    }
    /** @returns Return an array with the 8 corners on order wth "x varies fastest, then y, then z" */
    corners() {
        return [
            PointVector_1.Point3d.create(this.low.x, this.low.y, this.low.z),
            PointVector_1.Point3d.create(this.high.x, this.low.y, this.low.z),
            PointVector_1.Point3d.create(this.low.x, this.high.y, this.low.z),
            PointVector_1.Point3d.create(this.high.x, this.high.y, this.low.z),
            PointVector_1.Point3d.create(this.low.x, this.low.y, this.high.z),
            PointVector_1.Point3d.create(this.high.x, this.low.y, this.high.z),
            PointVector_1.Point3d.create(this.low.x, this.high.y, this.high.z),
            PointVector_1.Point3d.create(this.high.x, this.high.y, this.high.z)
        ];
    }
    /** @returns Return the largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull())
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** @returns true if the x direction size is nearly zero */
    isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** @returns true if the y direction size is nearly zero */
    isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** @returns true if the z direction size is nearly zero */
    isAlmostZeroZ() { return Geometry_1.Geometry.isSmallMetricDistance(this.zLength()); }
    /** Test if a point given as x,y,z is within the range. */
    containsXYZ(x, y, z) {
        return x >= this.low.x
            && y >= this.low.y
            && z >= this.low.z
            && x <= this.high.x
            && y <= this.high.y
            && z <= this.high.z;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXYZ(point.x, point.y, point.z); }
    /** Test if the x,y coordinates of a point are within the range. */
    containsPointXY(point) {
        return point.x >= this.low.x
            && point.y >= this.low.y
            && point.x <= this.high.x
            && point.y <= this.high.y;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.low.z >= this.low.z
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y
            && other.high.z <= this.high.z;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || this.low.z > other.high.z
            || other.low.x > this.high.x
            || other.low.y > this.high.y
            || other.low.z > this.high.z);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull())
            return RangeBase.EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y), RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)), RangeBase.EXTREME_POSITIVE);
    }
    /** @returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y), RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)), RangeBase.EXTREME_POSITIVE);
    }
    /** Expand this range by distances a (possibly signed) in all directions */
    extendXYZ(x, y, z) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
        if (z < this.low.z)
            this.low.z = z;
        if (z > this.high.z)
            this.high.z = z;
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXYZ(point.x, point.y, point.z); }
    /** Expand this range to include a transformed point. */
    extendTransformedPoint(transform, point) {
        this.extendTransformedXYZ(transform, point.x, point.y, point.z);
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range3d.isNull(other)) {
            this.extendXYZ(other.low.x, other.low.y, other.low.z);
            this.extendXYZ(other.high.x, other.high.y, other.high.z);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range3d.createNull(result);
        return Range3d.createXYZXYZOrCorrectToNull(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull())
            return other.clone(result);
        if (other.isNull())
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range3d.createXYZXYZOrCorrectToNull(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull()) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            const zMid = 0.5 * (this.low.z + this.high.z);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.high.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.high.z);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
            this.low.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.low.z);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.low.z - delta, this.high.x + delta, this.high.y + delta, this.high.z + delta, true);
    }
}
exports.Range3d = Range3d;
class Range1d extends RangeBase {
    setNull() {
        this.low = RangeBase.EXTREME_POSITIVE;
        this.high = RangeBase.EXTREME_NEGATIVE;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(low, high, correctToNull) {
        this.low = low;
        this.high = high;
        if (correctToNull && low > high)
            this.setNull();
    }
    // explicit ctor - no enforcement of value relationships
    constructor(low = RangeBase.EXTREME_POSITIVE, high = RangeBase.EXTREME_NEGATIVE) {
        super();
        this.low = low;
        this.high = high; // duplicates set_direct, but compiler is not convinced they are set.
        this.set_direct(low, high);
    }
    /** @returns Returns true if this and other have equal low and high parts */
    isAlmostEqual(other) {
        return (Geometry_1.Geometry.isSameCoordinate(this.low, other.low) && Geometry_1.Geometry.isSameCoordinate(this.high, other.high))
            || (this.isNull() && other.isNull());
    }
    /** copy contents from other Range1d. */
    setFrom(other) { this.low = other.low; this.high = other.high; }
    /** Convert from a JSON object of one of these forms:
     *
     * *  Any array of numbers: `[value,value, value]`
     * *  An object with low and high as properties: `{low:lowValue, high: highValue}`
     */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            let value;
            for (value of json) {
                const v = value;
                if (v)
                    this.extendX(v);
            }
        }
        else if (json.low && json.low && json.high && json.high) {
            this.setNull();
            this.extendX(json.low);
            this.extendX(json.high);
        }
    }
    static fromJSON(json) {
        const result = new Range1d();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    /** Convert to a JSON object of form
     * ```
     *    [lowValue,highValue]
     * ```
     */
    toJSON() { if (this.isNull())
        return new Array();
    else
        return [this.low, this.high]; }
    // internal use only -- directly set both lwo and high coordinates, without tests.
    set_direct(low, high) {
        this.low = low;
        this.high = high;
    }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    clone(result) {
        result = result ? result : new Range1d();
        result.set_direct(this.low, this.high);
        return result;
    }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    static createFrom(other, result) {
        result = result ? result : new Range1d();
        result.set_direct(other.low, other.high);
        return result;
    }
    /** Create a range with no content.
     * @param result optional result.
     */
    static createNull(result) {
        result = result ? result : new Range1d();
        result.setNull();
        return result;
    }
    /**
     * Set this range to be a single value.
     * @param x value to use as both low and high.
     */
    setX(x) { this.low = this.high = x; }
    /** Create a single point box */
    static createX(x, result) {
        result = result ? result : new Range1d();
        result.set_direct(x, x);
        return result;
    }
    /** Create a box from two values. Values are reversed if needed
     * @param xA first value
     * @param xB second value
     */
    static createXX(xA, xB, result) {
        result = result ? result : new Range1d();
        result.set_direct(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a box from two values, but null range if the values are reversed
     * @param xA first value
     * @param xB second value
     */
    static createXXOrCorrectToNull(xA, xB, result) {
        if (xB < xA)
            return Range1d.createNull(result);
        result = result ? result : new Range1d();
        result.set_direct(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a range containing all the values in an array.
     * @param points array of points to be contained in the range.
     * @param result optional result.
     */
    static createArray(points, result) {
        result = result ? result : new Range1d();
        let x;
        for (x of points)
            result.extendX(x);
        return result;
    }
    /** extend to include an array of values */
    extendArray(points) {
        let x;
        for (x of points)
            this.extendX(x);
    }
    /** Test if the box has high<low Note that a range around a single point is NOT null. */
    isNull() {
        return this.high < this.low;
    }
    /** Test of the range contains a single point. */
    isSinglePoint() {
        return this.high === this.low;
    }
    /** @returns Return the length of the range in the x direction */
    length() { const a = this.high - this.low; return a > 0.0 ? a : 0.0; }
    /** return a point given by fractional positions within the range. This is done with no check for isNull !!! */
    fractionToPoint(fraction) {
        return Geometry_1.Geometry.interpolate(this.low, fraction, this.high);
    }
    /** @returns Return the largest absolute value among the box limits. */
    maxAbs() {
        if (this.isNull())
            return 0.0;
        return Math.max(Math.abs(this.low), Math.abs(this.high));
    }
    /** Test if the x direction size is nearly zero */
    isAlmostZeroLength() { return Geometry_1.Geometry.isSmallMetricDistance(this.length()); }
    /** Test if a number is within the range. */
    containsX(x) {
        return x >= this.low
            && x <= this.high;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low >= this.low
            && other.high <= this.high;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low > other.high || other.low > this.high);
    }
    /** @returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);
    }
    /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */
    distanceToX(x) {
        if (this.isNull())
            return RangeBase.EXTREME_POSITIVE;
        return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);
    }
    /** Expand this range by a single coordinate */
    extendX(x) {
        if (x < this.low)
            this.low = x;
        if (x > this.high)
            this.high = x;
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!other.isNull()) {
            this.extendX(other.low);
            this.extendX(other.high);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range1d.createNull(result);
        return Range1d.createXXOrCorrectToNull(Math.max(this.low, other.low), Math.min(this.high, other.high), result);
    }
    /** Return the union of ranges. */
    /** Return the intersection of ranges. */
    union(other, result) {
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range1d.createXX(Math.min(this.low, other.low), Math.max(this.high, other.high), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull()) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low + this.high);
            this.high = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high);
            this.low = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low - delta, this.high + delta, true);
    }
}
exports.Range1d = Range1d;
class Range2d extends RangeBase {
    setNull() {
        this.low.x = RangeBase.EXTREME_POSITIVE;
        this.low.y = RangeBase.EXTREME_POSITIVE;
        this.high.x = RangeBase.EXTREME_NEGATIVE;
        this.high.y = RangeBase.EXTREME_NEGATIVE;
    }
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y); }
    toFloat64Array() { return Range2d.toFloat64Array(this); }
    /**
     * Construct a Range2d from an array of double-precision values
     * @param f64 the array, which should contain exactly 4 values in this order: lowx, lowy, highx, highy
     * @return a new Range2d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 6)
            throw new Error("invalid array");
        return new Range3d(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);
    }
    /**
     * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range2d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    // explicit ctor - no enforcement of value relationships
    constructor(lowx = Range2d.EXTREME_POSITIVE, lowy = Range2d.EXTREME_POSITIVE, highx = Range2d.EXTREME_NEGATIVE, highy = Range2d.EXTREME_NEGATIVE) {
        super();
        this.low = PointVector_1.Point2d.create(lowx, lowy);
        this.high = PointVector_1.Point2d.create(highx, highy);
    }
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull() && other.isNull());
    }
    setFrom(other) {
        this.low.set(other.low.x, other.low.y);
        this.high.set(other.high.x, other.high.y);
    }
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return Range2d.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result);
    }
    /** treat any array of numbers as numbers to be inserted !!! */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            const point = PointVector_1.Point2d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = PointVector_1.Point2d.fromJSON(json.low);
        const high = PointVector_1.Point2d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    freeze() { Object.freeze(this.low); Object.freeze(this.high); }
    toJSON() { return this.isNull() ? [] : [this.low.toJSON(), this.high.toJSON()]; }
    static fromJSON(json) {
        const result = new Range2d();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, without tests.
    setDirect(xA, yA, xB, yB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.high.x = xB;
        this.high.y = yB;
        if (correctToNull) {
            if (this.low.x > this.high.x || this.low.y > this.high.y)
                this.setNull();
        }
    }
    /** @returns return a clone of this range (or copy to optional result) */
    clone(result) {
        result = result ? result : new Range2d();
        result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);
        return result;
    }
    /** create a range with no content. */
    static createNull(result) {
        result = result ? result : new Range2d();
        result.setNull();
        return result;
    }
    /** Set low and hight to a single xy value. */
    setXY(x, y) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
    }
    /** Create a single point box */
    static createXY(x, y, result) {
        result = result ? result : new Range2d();
        result.setDirect(x, y, x, y, false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */
    static createXYXY(xA, yA, xB, yB, result) {
        result = result ? result : new Range2d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */
    static createXYXYOrCorrectToNull(xA, yA, xB, yB, result) {
        if (xA > xB || yA > yB)
            return Range2d.createNull(result);
        result = result ? result : new Range2d();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), true);
        return result;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new Range2d();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */
    isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y;
    }
    /** Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a single point is NOT null. */
    static isNull(range) {
        return range.high.x < range.low.x
            || range.high.y < range.low.y;
    }
    /** Test of the range contains a single point. */
    isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y;
    }
    /** Length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /** Length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /** return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, result) {
        return this.low.interpolateXY(fractionX, fractionY, this.high, result);
    }
    /** Largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull())
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** Test if the x direction size is nearly zero */
    isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** Test if the y direction size is nearly zero */
    isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** Test if a point given as x,y is within the range. */
    containsXY(x, y) {
        return x >= this.low.x
            && y >= this.low.y
            && x <= this.high.x
            && y <= this.high.y;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXY(point.x, point.y); }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || other.low.x > this.high.x
            || other.low.y > this.high.y);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull())
            return Range2d.EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)), Range2d.EXTREME_POSITIVE);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)), Range2d.EXTREME_POSITIVE);
    }
    /** Expand this range by distances a (possibly signed) in all directions */
    extendXY(x, y) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXY(point.x, point.y); }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range2d.isNull(other)) {
            this.extendXY(other.low.x, other.low.y);
            this.extendXY(other.high.x, other.high.y);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range2d.createNull(result);
        return Range2d.createXYXY(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull())
            return Range2d.createFrom(other, result);
        if (Range2d.isNull(other))
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range2d.createXYXY(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull()) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.high.x + delta, this.high.y + delta, true);
    }
}
exports.Range2d = Range2d;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Geometry4d_1 = __webpack_require__(46);
const AnalyticGeometry_1 = __webpack_require__(11);
const IndexedXYZCollection_1 = __webpack_require__(133);
class NumberArray {
    /** return the sum of values in an array,   The summation is done with correction terms which
     * improves last-bit numeric accuracy.
     */
    static PreciseSum(data) {
        const n = data.length;
        if (n === 0)
            return 0.0;
        let sum = data[0];
        let c = 0.0;
        let y;
        let t;
        for (let i = 1; i < n; i++) {
            y = data[i] - c;
            t = sum + y;
            c = (t - sum) - y;
            sum = t;
        }
        return sum;
    }
    /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */
    static isExactEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (dataA[i] !== dataB[i])
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /** Return true if arrays have identical counts and entries equal within tolerance */
    static isAlmostEqual(dataA, dataB, tolerance) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (Math.abs(dataA[i] - dataB[i]) >= tolerance)
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /** return the sum of numbers in an array.  Note that "PreciseSum" may be more accurate. */
    static sum(data) {
        let sum = 0;
        for (const x of data) {
            sum += x;
        }
        return sum;
    }
    static isCoordinateInArray(x, data) {
        if (data) {
            for (const y of data) {
                if (Geometry_1.Geometry.isSameCoordinate(x, y))
                    return true;
            }
        }
        return false;
    }
    static MaxAbsArray(values) {
        const arrLen = values.length;
        if (arrLen === 0) {
            return 0.0;
        }
        let a = Math.abs(values[0]);
        for (let i = 1; i < arrLen; i++) {
            const b = Math.abs(values[i]);
            if (a < b) {
                a = b;
            }
        }
        return a;
    }
    static MaxAbsTwo(a1, a2) {
        a1 = Math.abs(a1);
        a2 = Math.abs(a2);
        return (a1 > a2) ? a1 : a2;
    }
    static maxAbsDiff(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
    static maxAbsDiffFloat64(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
}
exports.NumberArray = NumberArray;
class Point2dArray {
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++) {
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            }
            return true;
        }
        return (!dataA && !dataB);
    }
    /**
     * @returns return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => p.clone());
    }
}
exports.Point2dArray = Point2dArray;
class Vector3dArray {
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            return true;
        }
        return (!dataA && !dataB);
    }
    /**
     * @returns return an array containing clones of the Vector3d data[]
     * @param data source data
     */
    static cloneVector3dArray(data) {
        return data.map((p) => PointVector_1.Vector3d.create(p.x, p.y, p.z));
    }
}
exports.Vector3dArray = Vector3dArray;
class Point4dArray {
    /** pack each point and its corresponding weight into a buffer of xyzwxyzw... */
    static packPointsAndWeightsToFloat64Array(points, weights, result) {
        result = result ? result : new Float64Array(4 * points.length);
        let i = 0;
        let k = 0;
        for (k = 0; k < points.length; k++) {
            result[i++] = points[k].x;
            result[i++] = points[k].y;
            result[i++] = points[k].z;
            result[i++] = weights[k];
        }
        return result;
    }
    static packToFloat64Array(data, result) {
        result = result ? result : new Float64Array(4 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
            result[i++] = p.w;
        }
        return result;
    }
    /** unpack from xyzwxyzw... to array of Point4d */
    static unpackToPoint4dArray(data) {
        const result = [];
        for (let i = 0; i + 3 < data.length; i += 4) {
            result.push(Geometry4d_1.Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));
        }
        return result;
    }
    /** unpack from xyzwxyzw... array to array of Point3d and array of weight.
     */
    static unpackFloat64ArrayToPointsAndWeights(data, points, weights, pointFormatter = PointVector_1.Point3d.create) {
        points.length = 0;
        weights.length = 0;
        for (let i = 0; i + 3 < data.length; i += 4) {
            points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));
            weights.push(data[i + 3]);
        }
    }
    /**
     * Multiply (and replace) each block of 4 values as a Point4d.
     * @param transform transform to apply
     * @param xyzw array of x,y,z,w points.
     */
    static multiplyInPlace(transform, xyzw) {
        const numXYZW = xyzw.length;
        const xyzw1 = Point4dArray.s_workPoint4d;
        for (let i = 0; i + 3 < numXYZW; i += 4) {
            transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);
            xyzw[i] = xyzw1.x;
            xyzw[i + 1] = xyzw1.y;
            xyzw[i + 2] = xyzw1.z;
            xyzw[i + 3] = xyzw1.w;
        }
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            for (const xyzw of data) {
                if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 4) {
                if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)
                    return false;
            }
        }
        return true;
    }
}
Point4dArray.s_workPoint4d = Geometry4d_1.Point4d.create();
exports.Point4dArray = Point4dArray;
class Point3dArray {
    static packToFloat64Array(data) {
        const result = new Float64Array(3 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
        }
        return result;
    }
    static unpackNumbersToPoint3dArray(data) {
        const result = [];
        for (let i = 0; i + 2 < data.length; i += 3) {
            result.push(PointVector_1.Point3d.create(data[i], data[i + 1], data[i + 2]));
        }
        return result;
    }
    /**
     * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArrays(data, numPerBlock) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        while (i < n) {
            // there is at least one more value for a block
            const row = [];
            i1 = i + numPerBlock;
            if (i1 > n)
                i1 = n;
            for (; i < i1; i++) {
                row.push(data[i]);
            }
            result.push(row);
        }
        return result;
    }
    /**
     * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArraysIJK(data, numPerBlock, numPerRow) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        let i2;
        while (i < n) {
            const row = [];
            i2 = i + numPerBlock * numPerRow;
            while (i < i2) {
                const block = [];
                i1 = i + numPerBlock;
                if (i1 > n)
                    i1 = n;
                for (; i < i1; i++) {
                    block.push(data[i]);
                }
                row.push(block);
            }
            result.push(row);
        }
        return result;
    }
    static multiplyInPlace(transform, xyz) {
        const xyz1 = PointVector_1.Point3d.create();
        const numXYZ = xyz.length;
        for (let i = 0; i + 2 < numXYZ; i += 3) {
            transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);
            xyz[i] = xyz1.x;
            xyz[i + 1] = xyz1.y;
            xyz[i + 2] = xyz1.z;
        }
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** return simple average of all coordinates.   (000 if empty array) */
    static centroid(points, result) {
        result = PointVector_1.Point3d.create(0, 0, 0, result);
        const p = PointVector_1.Point3d.create();
        if (points.length > 0) {
            for (let i = 0; i < points.length; i++) {
                points.atPoint3dIndex(i, p);
                result.x += p.x;
                result.y += p.y;
                result.z += p.z;
            }
            result.scaleInPlace(1.0 / points.length);
        }
        return result;
    }
    /** Return the index of the point most distant from spacePoint */
    static vectorToMostDistantPoint(points, spacePoint, farVector) {
        if (points.length === 0)
            return -1;
        let dMax = -1;
        let d;
        let result = -1;
        for (let i = 0; i < points.length; i++) {
            d = spacePoint.distance(points[i]);
            if (d > dMax) {
                spacePoint.vectorTo(points[i], farVector);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */
    static vectorToPointWithMaxCrossProductMangitude(points, spacePoint, vector, farVector) {
        if (points.length === 0)
            return -1;
        let dMax = -1;
        let d;
        let result = -1;
        let vectorAB; // to be reused in loop !!!
        for (let i = 0; i < points.length; i++) {
            vectorAB = spacePoint.vectorTo(points[i], vectorAB);
            d = vectorAB.crossProductMagnitude(vector);
            if (d > dMax) {
                farVector.setFrom(vectorAB);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** Return the index of the closest point in the array (full xyz) */
    static closestPointIndex(data, spacePoint) {
        let index = -1;
        let dMin = Number.MAX_VALUE;
        let d;
        const x0 = spacePoint.x;
        const y0 = spacePoint.y;
        const z0 = spacePoint.z;
        for (let i = 0; i < data.length; i++) {
            d = Geometry_1.Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);
            if (d < dMin) {
                index = i;
                dMin = d;
            }
        }
        return index;
    }
    /** return true iff all points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            let xyz;
            for (xyz of data) {
                if (Math.abs(plane.altitude(xyz)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 3) {
                if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                    return false;
            }
        }
        return true;
    }
    static sumLengths(data) {
        let sum = 0.0;
        if (Array.isArray(data)) {
            const n = data.length - 1;
            for (let i = 0; i < n; i++)
                sum += data[i].distance(data[i + 1]);
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 5 < numXYZ; i += 3) {
                sum += Math.hypot(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
            }
        }
        return sum;
    }
    /**
     * @returns return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint3dArray(data) {
        return data.map((p) => PointVector_1.Point3d.create(p.x, p.y, p.z));
    }
    /**
     * @returns return an array containing Point2d with xy parts of each Point3d
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => PointVector_1.Point2d.create(p.x, p.y));
    }
}
exports.Point3dArray = Point3dArray;
/** Static class for operations that treat an array of points as a polygon (with area!) */
class PolygonOps {
    /** Sum areas of triangles from points[0] to each far edge.
    * * Consider triangles from points[0] to each edge.
    * * Sum the areas(absolute, without regard to orientation) all these triangles.
    * @returns sum of absolute triangle areas.
    */
    static sumTriangleAreas(points) {
        let s = 0.0;
        const n = points.length;
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = PointVector_1.Vector3d.create();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                s += vector0.crossProductMagnitude(vector1);
                vector0.setFrom(vector1);
            }
        }
        s *= 0.5;
        // console.log ("polygon area ", s, points);
        return s;
    }
    /** Sum areas of triangles from points[0] to each far edge.
    * * Consider triangles from points[0] to each edge.
    * * Sum the areas(absolute, without regard to orientation) all these triangles.
    * @returns sum of absolute triangle areas.
    */
    static sumTriangleAreasXY(points) {
        let s = 0.0;
        const n = points.length;
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = PointVector_1.Vector3d.create();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                s += vector0.crossProductXY(vector1);
                vector0.setFrom(vector1);
            }
        }
        s *= 0.5;
        // console.log ("polygon area ", s, points);
        return s;
    }
    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */
    static areaNormalGo(points, result) {
        if (!result)
            result = new PointVector_1.Vector3d();
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
        }
        else if (n >= 3) {
            result.setZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);
            }
        }
        // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE
        result.scaleInPlace(0.5);
        return result;
    }
    static areaNormal(points, result) {
        if (!result)
            result = PointVector_1.Vector3d.create();
        PolygonOps.areaNormalGo(new Point3dArrayCarrier(points), result);
        return result;
    }
    /** return the area of the polygon (assuming planar) */
    static area(points) {
        return PolygonOps.areaNormal(points).magnitude();
    }
    /** return the projected XY area of the polygon (assuming planar) */
    static areaXY(points) {
        let area = 0.0;
        for (let i = 1; i + 1 < points.length; i++)
            area += points[0].crossProductToPointsXY(points[i], points[i + 1]);
        return 0.5 * area;
    }
    static centroidAreaNormal(points) {
        const n = points.length;
        if (n === 3) {
            const normal = points[0].crossProductToPoints(points[1], points[2]);
            const a = 0.5 * normal.magnitude();
            const result = AnalyticGeometry_1.Ray3d.createCapture(Point3dArray.centroid(new Point3dArrayCarrier(points)), normal);
            if (result.tryNormalizeInPlaceWithAreaWeight(a))
                return result;
            return undefined;
        }
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = PointVector_1.Vector3d.create();
            let cross = PointVector_1.Vector3d.create();
            const centroidSum = PointVector_1.Vector3d.createZero();
            const normalSum = PointVector_1.Vector3d.createZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                cross = vector0.crossProduct(vector1, cross);
                normalSum.addInPlace(cross); // this grows to twice the area
                const b = cross.magnitude() / 6.0;
                centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);
                vector0.setFrom(vector1);
            }
            const area = 0.5 * normalSum.magnitude();
            const inverseArea = Geometry_1.Geometry.conditionalDivideFraction(1, area);
            if (inverseArea !== undefined) {
                const result = AnalyticGeometry_1.Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea, origin), normalSum);
                result.tryNormalizeInPlaceWithAreaWeight(area);
                return result;
            }
        }
        return undefined;
    }
    // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...
    // Returns undefined if given point array less than 3 or if not safe to divide at any point
    static centroidAndArea(points, centroid) {
        let area = 0.0;
        centroid.set(0, 0);
        if (points.length < 3)
            return undefined;
        const origin = points[0];
        let vectorSum = PointVector_1.Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions
        let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions
        for (let i = 1; i + 1 < points.length; i++) {
            const vector0 = origin.vectorTo(points[i]);
            const vector1 = origin.vectorTo(points[i + 1]);
            const tempArea = vector0.crossProduct(vector1);
            vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));
            areaSum += tempArea;
        }
        area = areaSum * 0.5;
        const a = Geometry_1.Geometry.conditionalDivideFraction(1.0, 6.0 * area);
        if (a === undefined) {
            centroid.setFrom(origin);
            return undefined;
        }
        centroid.setFrom(origin.plusScaled(vectorSum, a));
        return area;
    }
    /**
     *
     * @param points array of points around the polygon.  This is assumed to NOT have closure edge.
     * @param result caller-allocated result vector.
     */
    static unitNormal(points, result) {
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
            return result.normalizeInPlace();
        }
        if (n === 4) {
            // cross product of diagonals is more stable than from single of the points . . .
            points.vectorIndexIndex(0, 2, PolygonOps.s_vector0);
            points.vectorIndexIndex(1, 3, PolygonOps.s_vector1);
            PolygonOps.s_vector0.crossProduct(PolygonOps.s_vector1, result);
            return result.normalizeInPlace();
        }
        // more than 4 points  ... no shortcuts ...
        PolygonOps.areaNormalGo(points, result);
        return result.normalizeInPlace();
    }
    /** Return the matrix of area products of a polygon with respect to an origin.
     * The polygon is assumed to be planar and non-self-intersecting.
     */
    static addSecondMomentAreaProducts(points, origin, moments) {
        const unitNormal = PolygonOps.s_normal;
        if (PolygonOps.unitNormal(points, unitNormal)) {
            // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons
            // sum correctly.
            const vector01 = PolygonOps.s_vector0;
            const vector02 = PolygonOps.s_vector1;
            const placement = PolygonOps.s_matrixA;
            const matrixAB = PolygonOps.s_matrixB;
            const matrixABC = PolygonOps.s_matrixC;
            const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps.s_vectorOrigin);
            const numPoints = points.length;
            let detJ = 0;
            for (let i2 = 2; i2 < numPoints; i2++) {
                points.vectorIndexIndex(0, i2 - 1, vector01);
                points.vectorIndexIndex(0, i2, vector02);
                detJ = unitNormal.tripleProduct(vector01, vector02);
                placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);
                placement.multiplyMatrixMatrix(PolygonOps.s_triangleMomentWeights, matrixAB);
                matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);
                moments.addScaledInPlace(matrixABC, detJ);
            }
        }
    }
    /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.
     *
     * *  For a polygon without self intersections, this is a convexity and orientation test: all positive is convex and counterclockwise,
     * all negative is convex and clockwise
     * *  Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex
     * *  Returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero turns
     */
    static testXYPolygonTurningDirections(pPointArray) {
        // Reduce count by trailing duplicates; leaves iLast at final index
        let numPoint = pPointArray.length;
        let iLast = numPoint - 1;
        while (iLast > 1 && pPointArray[iLast].x === pPointArray[0].x && pPointArray[iLast].y === pPointArray[0].y) {
            numPoint = iLast--;
        }
        if (numPoint > 2) {
            let vector0 = PointVector_1.Point2d.create(pPointArray[iLast].x - pPointArray[iLast - 1].x, pPointArray[iLast].y - pPointArray[iLast - 1].y);
            const vector1 = PointVector_1.Point2d.create(pPointArray[0].x - pPointArray[iLast].x, pPointArray[0].y - pPointArray[iLast].y);
            const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;
            // In a convex polygon, all successive-vector cross products will
            // have the same sign as the base area, hence all products will be
            // positive.
            for (let i1 = 1; i1 < numPoint; i1++) {
                vector0 = vector1.clone();
                PointVector_1.Point2d.create(pPointArray[i1].x - pPointArray[i1 - 1].x, pPointArray[i1].y - pPointArray[i1 - 1].y, vector1);
                const currArea = vector0.x * vector1.y - vector0.y * vector1.x;
                if (currArea * baseArea <= 0.0)
                    return 0;
            }
            // Fall out with all signs same as base area
            return baseArea > 0.0 ? 1 : -1;
        }
        return 0;
    }
    /**
     * Classify a point with respect to a polygon.
     * Returns 1 if point is "in" by parity, 0 if "on", -1 if "out", -2 if nothing worked.
     */
    static parity(pPoint, pPointArray, tol = 0.0) {
        let parity;
        const x = pPoint.x;
        const y = pPoint.y;
        const numPoint = pPointArray.length;
        if (numPoint < 2)
            return (Math.abs(x - pPointArray[0].x) <= tol && Math.abs(y - pPointArray[0].y) <= tol) ? 0 : -1;
        // Try really easy ways first...
        parity = PolygonOps.parityYTest(pPoint, pPointArray, tol);
        if (parity !== undefined)
            return parity;
        parity = PolygonOps.parityXTest(pPoint, pPointArray, tol);
        if (parity !== undefined)
            return parity;
        // Is test point within tol of one of the polygon points in x and y?
        for (let i = 0; i < numPoint; i++)
            if (Math.abs(x - pPointArray[i].x) <= tol && Math.abs(y - pPointArray[i].y) <= tol)
                return 0;
        // Nothing easy worked. Try some ray casts
        const maxTheta = 10.0;
        let theta = 0.276234342921378;
        const dTheta = theta;
        while (theta < maxTheta) {
            parity = PolygonOps.parityVectorTest(pPoint, theta, pPointArray, tol);
            if (parity !== undefined)
                return parity;
            theta += dTheta;
        }
        return -2;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using only the y
     * coordinate for the tests.
     *
     * *  Return undefined (failure, could not determine answer) if any polygon point has the same y-coord as test point
     * *  Goal is to execute the simplest cases as fast as possible, and fail promptly for others
     */
    static parityYTest(pPoint, pPointArray, tol) {
        // Var names h, crossing to allow closest code correspondence between x,y code
        const numPoint = pPointArray.length;
        const crossing0 = pPoint.x;
        const h = pPoint.y;
        let h0 = h - pPointArray[numPoint - 1].y;
        let h1;
        let crossing;
        let s;
        let numLeft = 0;
        if (Math.abs(h0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, h0 = h1) {
            h1 = h - pPointArray[i].y;
            if (Math.abs(h1) <= tol)
                return undefined;
            if (h0 * h1 < 0.0) {
                s = -h0 / (h1 - h0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                crossing = pPointArray[i0].x + s * (pPointArray[i].x - pPointArray[i0].x);
                if (Math.abs(crossing - crossing0) <= tol)
                    return 0;
                else if (crossing < crossing0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using only the x
     * coordinate for the tests.
     *
     * *  Return undefined (failure, could not determine answer) if any polygon point has the same x coordinate as the test point
     * *  Goal is to execute the simplest cases as fast as possible, and fail promptly for others
     */
    static parityXTest(pPoint, pPointArray, tol) {
        // Var names h, crossing to allow closest code correspondence between x,y code
        const numPoint = pPointArray.length;
        const crossing0 = pPoint.y;
        const h = pPoint.x;
        let h0 = h - pPointArray[numPoint - 1].x;
        let h1;
        let crossing;
        let s;
        let numLeft = 0;
        if (Math.abs(h0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, h0 = h1) {
            h1 = h - pPointArray[i].x;
            if (Math.abs(h1) <= tol)
                return undefined;
            if (h0 * h1 < 0.0) {
                s = -h0 / (h1 - h0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                crossing = pPointArray[i0].y + s * (pPointArray[i].y - pPointArray[i0].y);
                if (Math.abs(crossing - crossing0) <= tol)
                    return 0;
                else if (crossing < crossing0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
    /**
     * Classify a point with respect to a polygon defined by the xy parts of the points, using a given ray cast
     * direction.
     *
     * *  Return false (failure, could not determine answer) if any polygon point is on the ray
     */
    static parityVectorTest(pPoint, theta, pPointArray, tol) {
        const numPoint = pPointArray.length;
        let v1;
        let u0;
        let u1;
        let u;
        let s;
        let numLeft = 0;
        const tangent = PointVector_1.Vector2d.create(Math.cos(theta), Math.sin(theta));
        const normal = PointVector_1.Vector2d.create(-tangent.y, tangent.x);
        let v0 = normal.dotProductStartEnd(pPoint, pPointArray[numPoint - 1]);
        if (Math.abs(v0) <= tol)
            return undefined;
        let i0;
        for (let i = 0; i < numPoint; i++, v0 = v1) {
            v1 = normal.dotProductStartEnd(pPoint, pPointArray[i]);
            if (Math.abs(v1) <= tol)
                return undefined;
            if (v0 * v1 < 0.0) {
                s = -v0 / (v1 - v0);
                i0 = i - 1;
                if (i0 < 0)
                    i0 = numPoint - 1;
                u0 = tangent.dotProductStartEnd(pPoint, pPointArray[i0]);
                u1 = tangent.dotProductStartEnd(pPoint, pPointArray[i]);
                u = u0 + s * (u1 - u0);
                if (Math.abs(u) <= tol)
                    return 0;
                else if (u < 0.0)
                    numLeft++;
            }
        }
        return (numLeft & 0x01) ? 1 : -1;
    }
}
/** These values are the integrated area moment products [xx,xy,xz, x]
 * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)
 */
PolygonOps.s_triangleMomentWeights = Geometry4d_1.Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);
// statics for shared reuse.
// many methods use these.
// only use them in "leaf" methods that are certain not to call other users . . .
PolygonOps.s_vector0 = PointVector_1.Vector3d.create();
PolygonOps.s_vector1 = PointVector_1.Vector3d.create();
PolygonOps.s_vectorOrigin = PointVector_1.Vector3d.create();
PolygonOps.s_normal = PointVector_1.Vector3d.create();
PolygonOps.s_matrixA = Geometry4d_1.Matrix4d.createIdentity();
PolygonOps.s_matrixB = Geometry4d_1.Matrix4d.createIdentity();
PolygonOps.s_matrixC = Geometry4d_1.Matrix4d.createIdentity();
exports.PolygonOps = PolygonOps;
/**
 * Helper object to access members of a Point3d[] in geometric calculations.
*/
class Point3dArrayCarrier extends IndexedXYZCollection_1.IndexedXYZCollection {
    /** CAPTURE caller supplied array ... */
    constructor(data) {
        super();
        this.data = data;
    }
    isValidIndex(index) {
        return index >= 0 && index < this.data.length;
    }
    /**
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    atPoint3dIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return PointVector_1.Point3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /**
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    atVector3dIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return PointVector_1.Vector3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /**
     * @param indexA index of point within the array
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    vectorIndexIndex(indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return PointVector_1.Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin origin for vector
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if index is out of bounds
     */
    vectorXYAndZIndex(origin, indexB, result) {
        if (this.isValidIndex(indexB))
            return PointVector_1.Vector3d.createStartEnd(origin, this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin origin for vector
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    crossProductXYAndZIndexIndex(origin, indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return PointVector_1.Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
   * @param originIndex index of origin
   * @param indexA index of first target within the array
   * @param indexB index of second target within the array
   * @param result caller-allocated vector.
   * @returns return true if indexA, indexB both valid
   */
    crossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return PointVector_1.Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * @param origin index of origin
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns return true if indexA, indexB both valid
     */
    accumulateCrossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        const data = this.data;
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            result.addCrossProductToTargetsInPlace(data[originIndex].x, data[originIndex].y, data[originIndex].z, data[indexA].x, data[indexA].y, data[indexA].z, data[indexB].x, data[indexB].y, data[indexB].z);
    }
    /**
     * read-only property for number of XYZ in the collection.
     */
    get length() {
        return this.data.length;
    }
}
exports.Point3dArrayCarrier = Point3dArrayCarrier;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
// import { stringify, IStringifyOptions } from "qs";
const sarequest = __webpack_require__(254);
const deepAssign = __webpack_require__(48);
const qs_1 = __webpack_require__(260);
const bentleyjs_core_1 = __webpack_require__(0);
const Config_1 = __webpack_require__(31);
const loggingCategory = "imodeljs-clients.Request";
/** Error object that's thrown/rejected if the Request fails due to a network error, or
 * if the status is *not* in the range of 200-299 (inclusive)
 */
class ResponseError extends bentleyjs_core_1.BentleyError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, undefined, undefined, getMetaData);
    }
    /**
     * Parses error from server's response
     * @param response Http response from the server.
     * @returns Parsed error.
     */
    static parse(response, log = true) {
        const error = new ResponseError(ResponseError.parseHttpStatus(response.status / 100));
        if (!response) {
            error.message = "Couldn't get response object.";
            return error;
        }
        if (response.response) {
            if (response.response.error) {
                error.name = response.response.error.name || error.name;
                error.description = response.response.error.message;
            }
            if (response.response.res) {
                error.message = response.response.res.statusMessage;
            }
            if (response.response.body && Object.keys(response.response.body).length > 0) {
                error._data = {};
                deepAssign(error._data, response.response.body);
            }
            else {
                error._data = response.response.text;
            }
        }
        error.status = response.status || response.statusCode;
        error.name = response.code || response.name || error.name;
        error.message = error.message || response.message || response.statusMessage;
        if (log)
            error.log();
        return error;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error returned by request
     * @param response Response returned by request
     */
    static shouldRetry(error, response) {
        if (error !== undefined && error !== null) {
            if ((error.status === undefined || error.status === null) && (error.res === undefined || error.res === null)) {
                return true;
            }
        }
        return (response !== undefined && response.statusType === 94212 /* ServerError */);
    }
    static parseHttpStatus(status) {
        switch (status) {
            case 1:
                return 94209 /* Info */;
            case 2:
                return 0 /* Success */;
            case 3:
                return 94210 /* Redirection */;
            case 4:
                return 94211 /* ClientError */;
            case 5:
                return 94212 /* ServerError */;
            default:
                return 0 /* Success */;
        }
    }
    logMessage() {
        return `${this.status} ${this.name}: ${this.message}`;
    }
    /**
     * Logs this error
     */
    log() {
        bentleyjs_core_1.Logger.logError(loggingCategory, this.logMessage(), this.getMetaData());
    }
}
exports.ResponseError = ResponseError;
// @todo The purpose of this wrapper is to allow us to easily replace this with another
// module that will rid us of NodeJs dependency.The alternate HTTP module is currently
// being written and allow working in desktop environments also.
/**
 * Wrapper around HTTP request utility
 * @param url Server URL to address the request
 * @param options Options to pass to the request
 * @returns Resolves to the response from the server
 * @throws ResponseError if the request fails due to network issues, or if the
 * returned status is *outside* the range of 200-299 (inclusive)
 */
async function request(url, options) {
    const proxyUrl = Config_1.Config.devCorsProxyServer ? Config_1.Config.devCorsProxyServer + url : url;
    let sareq = sarequest(options.method, proxyUrl).retry(4, options.retryCallback);
    if (options.headers) {
        sareq = sareq.set(options.headers);
    }
    let queryStr = "";
    if (options.qs) {
        const stringifyOptions = { delimiter: "&", encode: false };
        queryStr = qs_1.stringify(options.qs, stringifyOptions);
        sareq = sareq.query(queryStr);
    }
    if (options.auth) {
        sareq = sareq.auth(options.auth.user, options.auth.password);
    }
    if (options.accept) {
        sareq = sareq.accept(options.accept);
    }
    if (options.body) {
        sareq = sareq.send(options.body);
    }
    if (options.timeout) {
        sareq = sareq.timeout(options.timeout);
    }
    else {
        sareq = sareq.timeout(10000);
    }
    if (options.responseType) {
        sareq = sareq.responseType(options.responseType);
    }
    if (options.redirects) {
        sareq = sareq.redirects(options.redirects);
    }
    else {
        sareq = sareq.redirects(0);
    }
    if (options.buffer) {
        sareq.buffer(options.buffer);
    }
    if (options.parser) {
        sareq.parse(options.parser);
    }
    if (options.agent) {
        sareq.agent(options.agent);
    }
    if (options.progressCallback) {
        sareq.on("progress", (event) => {
            if (event) {
                options.progressCallback({
                    loaded: event.loaded,
                    total: event.total,
                    percent: event.percent,
                });
            }
        });
    }
    const errorCallback = options.errorCallback ? options.errorCallback : ResponseError.parse;
    if (options.readStream) {
        if (Config_1.Config.isBrowser()) {
            throw new Error("This option is not supported on browsers");
        }
        return new Promise((resolve, reject) => {
            sareq = sareq.type("blob");
            options
                .readStream
                .pipe(sareq)
                .on("error", (error) => {
                const parsedError = errorCallback(error);
                reject(parsedError);
            })
                .on("end", () => {
                const retResponse = {
                    status: 201,
                    header: undefined,
                    body: undefined,
                };
                resolve(retResponse);
            });
        });
    }
    if (options.stream) {
        if (Config_1.Config.isBrowser()) {
            throw new Error("This option is not supported on browsers");
        }
        return new Promise((resolve, reject) => {
            sareq
                .on("response", (res) => {
                if (res.statusCode !== 200) {
                    const parsedError = errorCallback(res);
                    reject(parsedError);
                    return;
                }
            })
                .pipe(options.stream)
                .on("error", (error) => {
                const parsedError = errorCallback(error);
                reject(parsedError);
            })
                .on("finish", () => {
                const retResponse = {
                    status: 200,
                    header: undefined,
                    body: undefined,
                };
                resolve(retResponse);
            });
        });
    }
    // console.log("%s %s %s", url, options.method, queryStr);
    /*
    * Note:
    * Javascript's fetch returns status.OK if error is between 200-299 inclusive, and doesn't reject in this case.
    * Fetch only rejects if there's some network issue (permissions issue or similar)
    * Superagent rejects network issues, and errors outside the range of 200-299. We are currently using
    * superagent, but my plan is to switch to JavaScript's fetch library.
    */
    return sareq
        .then((response) => {
        const retResponse = {
            body: response.body,
            header: response.header,
            status: response.status,
        };
        return Promise.resolve(retResponse);
    })
        .catch((error) => {
        const parsedError = errorCallback(error);
        return Promise.reject(parsedError);
    });
}
exports.request = request;
/**
 * fetch array buffer from HTTP request
 * @param url server URL to address the request
 */
async function getArrayBuffer(url) {
    const options = {
        method: "GET",
        responseType: "arraybuffer",
    };
    const data = await request(url, options);
    return data.body;
}
exports.getArrayBuffer = getArrayBuffer;
/**
 * fetch json from HTTP request
 * @param url server URL to address the request
 */
async function getJson(url) {
    const options = {
        method: "GET",
        responseType: "json",
    };
    const data = await request(url, options);
    return data.body;
}
exports.getJson = getJson;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/** Reserved texture units for specific sampler variables, to avoid conflicts between shader components which each have their own textures. */
var TextureUnit;
(function (TextureUnit) {
    // For shaders which know exactly which textures will be used
    TextureUnit[TextureUnit["Zero"] = WebGLRenderingContext.TEXTURE0] = "Zero";
    TextureUnit[TextureUnit["One"] = WebGLRenderingContext.TEXTURE1] = "One";
    TextureUnit[TextureUnit["Two"] = WebGLRenderingContext.TEXTURE2] = "Two";
    TextureUnit[TextureUnit["Three"] = WebGLRenderingContext.TEXTURE3] = "Three";
    TextureUnit[TextureUnit["Four"] = WebGLRenderingContext.TEXTURE4] = "Four";
    TextureUnit[TextureUnit["Five"] = WebGLRenderingContext.TEXTURE5] = "Five";
    TextureUnit[TextureUnit["Six"] = WebGLRenderingContext.TEXTURE6] = "Six";
    TextureUnit[TextureUnit["Seven"] = WebGLRenderingContext.TEXTURE7] = "Seven";
    TextureUnit[TextureUnit["ClipMask"] = TextureUnit.Zero] = "ClipMask";
    TextureUnit[TextureUnit["FeatureSymbology"] = TextureUnit.One] = "FeatureSymbology";
    TextureUnit[TextureUnit["SurfaceTexture"] = TextureUnit.Two] = "SurfaceTexture";
    TextureUnit[TextureUnit["LineCode"] = TextureUnit.Two] = "LineCode";
    TextureUnit[TextureUnit["ElementId"] = TextureUnit.Three] = "ElementId";
    TextureUnit[TextureUnit["PickElementId0"] = TextureUnit.Four] = "PickElementId0";
    TextureUnit[TextureUnit["PickElementId1"] = TextureUnit.Five] = "PickElementId1";
    TextureUnit[TextureUnit["PickDepthAndOrder"] = TextureUnit.Six] = "PickDepthAndOrder";
    TextureUnit[TextureUnit["VertexLUT"] = TextureUnit.Seven] = "VertexLUT";
    // WIP - Image lighting (won't work if device limited to 8 textures).
    TextureUnit[TextureUnit["DiffuseMap"] = WebGLRenderingContext.TEXTURE8] = "DiffuseMap";
    TextureUnit[TextureUnit["IBLSpecular"] = WebGLRenderingContext.TEXTURE9] = "IBLSpecular";
    TextureUnit[TextureUnit["BRDFLUT"] = WebGLRenderingContext.TEXTURE10] = "BRDFLUT";
    TextureUnit[TextureUnit["EnvironmentMap"] = WebGLRenderingContext.TEXTURE11] = "EnvironmentMap";
    TextureUnit[TextureUnit["AnimationLUT"] = WebGLRenderingContext.TEXTURE12] = "AnimationLUT";
})(TextureUnit = exports.TextureUnit || (exports.TextureUnit = {}));
function isPlanar(order) { return order >= 8 /* PlanarBit */; }
exports.isPlanar = isPlanar;
function isSurface(order) { return order <= 2 /* Surface */ || order === 10 /* PlanarSurface */; }
exports.isSurface = isSurface;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
/* ###TODO: IBL
import { Matrix3 } from "../Matrix";
*/
function addWindowToTexCoords(frag) {
    const windowCoordsToTexCoords = `\nvec2 windowCoordsToTexCoords(vec2 wc) { return wc * u_invScreenSize; }\n`;
    frag.addFunction(windowCoordsToTexCoords);
    frag.addUniform("u_invScreenSize", 4 /* Vec2 */, (prog) => {
        prog.addProgramUniform("u_invScreenSize", (uniform, params) => {
            const rect = params.target.viewRect;
            const invScreenSize = [1.0 / rect.width, 1.0 / rect.height];
            uniform.setUniform2fv(invScreenSize);
        });
    });
}
exports.addWindowToTexCoords = addWindowToTexCoords;
function addWhiteOnWhiteReversal(frag) {
    frag.addUniform("u_reverseWhiteOnWhite", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_reverseWhiteOnWhite", (uniform, params) => {
            const bgColor = params.target.bgColor.clone();
            bgColor.setAlpha(255);
            const doReversal = (bgColor.equals(imodeljs_common_1.ColorDef.white) && params.geometry.wantWoWReversal(params)) ? 1.0 : 0.0;
            uniform.setUniform1f(doReversal);
        });
    });
    frag.set(9 /* ReverseWhiteOnWhite */, reverseWhiteOnWhite);
}
exports.addWhiteOnWhiteReversal = addWhiteOnWhiteReversal;
/* ###TODO: IBL
export function addNormalMatrixF(frag: FragmentShaderBuilder) {
  frag.addUniform("u_nmx", VariableType.Mat3, (prog) => {
    prog.addGraphicUniform("u_nmx", (uniform, params) => {
      const rotMat: Matrix3 | undefined = params.modelViewMatrix.getRotation();
      if (undefined !== rotMat)
        uniform.setMatrix3(rotMat);
    });
  });
}
*/
const reverseWhiteOnWhite = `
  if (u_reverseWhiteOnWhite > 0.5) {
    // Account for erroneous interpolation from varying vec3(1.0)...
    const vec3 white = vec3(1.0);
    const vec3 epsilon = vec3(0.0001);
    vec3 color = baseColor.a > 0.0 ? baseColor.rgb / baseColor.a : baseColor.rgb; // revert premultiplied alpha
    vec3 delta = (color + epsilon) - white;
    if (delta.x > 0.0 && delta.y > 0.0 && delta.z > 0.0)
      baseColor.rgb = vec3(0.0);
  }
  return baseColor;
`;
var GLSLFragment;
(function (GLSLFragment) {
    GLSLFragment.assignFragColor = "FragColor = baseColor;";
    GLSLFragment.assignFragColorNoAlpha = "FragColor = vec4(baseColor.rgb, 1.0);";
    GLSLFragment.assignFragData = `
  FragColor0 = baseColor;
  FragColor1 = v_element_id0;
  FragColor2 = v_element_id1;

  float linearDepth = computeLinearDepth(v_eyeSpace.z);
  FragColor3 = vec4(u_renderOrder * 0.0625, encodeDepthRgb(linearDepth)); // near=1, far=0
`;
    GLSLFragment.revertPreMultipliedAlpha = `
vec4 revertPreMultipliedAlpha(vec4 rgba) {
  if (0.0 < rgba.a)
    rgba.rgb /= rgba.a;
  return rgba;
}
`;
    GLSLFragment.applyPreMultipliedAlpha = `
vec4 applyPreMultipliedAlpha(vec4 rgba) {
  rgba.rgb *= rgba.a;
  return rgba;
}
`;
    GLSLFragment.adjustPreMultipliedAlpha = `
vec4 adjustPreMultipliedAlpha(vec4 rgba, float newAlpha) {
  float oldAlpha = rgba.a;
  if (0.0 < oldAlpha)
    rgba.rgb /= oldAlpha;

  rgba.rgb *= newAlpha;
  rgba.a = newAlpha;
  return rgba;
}
`;
    GLSLFragment.computeLinearDepth = `
float computeLinearDepth(float eyeSpaceZ) {
  float eyeZ = -eyeSpaceZ;
  float near = u_frustum.x, far = u_frustum.y;
  float depthRange = far - near;
  float linearDepth = (eyeZ - near) / depthRange;
  return 1.0 - linearDepth;
}
`;
})(GLSLFragment = exports.GLSLFragment || (exports.GLSLFragment = {}));


/***/ }),
/* 26 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcRegistry_1 = __webpack_require__(33);
/** RPC interface management is concerned with coordination of access and configuration for RPC interfaces. */
class RpcManager {
    /**
     * Initializes an RPC interface class.
     * @note This function must be called on the frontend and on the backend for each RPC interface class used by an application.
     */
    static initializeInterface(definition) {
        RpcRegistry_1.RpcRegistry.instance.initializeRpcInterface(definition);
    }
    /** Terminates an RPC interface class. */
    static terminateInterface(definition) {
        RpcRegistry_1.RpcRegistry.instance.terminateRpcInterface(definition);
    }
    /** Returns the RPC client instance for the frontend. */
    static getClientForInterface(definition) {
        return RpcRegistry_1.RpcRegistry.instance.getClientForInterface(definition);
    }
    /** Registers the RPC implementation class for the backend. */
    static registerImpl(definition, implementation) {
        RpcRegistry_1.RpcRegistry.instance.registerImpl(definition, implementation);
    }
    /** Supply the instance of the RPC interface implementation class for the backend (optional). */
    static supplyImplInstance(definition, instance) {
        RpcRegistry_1.RpcRegistry.instance.supplyImplInstance(definition, instance);
    }
    /** Unregisters the RPC implementation class for the backend. */
    static unregisterImpl(definition) {
        RpcRegistry_1.RpcRegistry.instance.unregisterImpl(definition);
    }
    /**
     * Describes the RPC interfaces and endpoints that are currently available from the backend.
     * @note Some endpoints may be marked incompatible if the frontend expected a different interface declaration than the backend supplied. RPC operations against an incompatible interface will fail.
     */
    static describeAvailableEndpoints() {
        return RpcRegistry_1.RpcRegistry.instance.describeAvailableEndpoints();
    }
}
exports.RpcManager = RpcManager;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const RpcInvocation_1 = __webpack_require__(117);
const RpcMarshaling_1 = __webpack_require__(118);
/** RPC protocol event types. */
var RpcProtocolEvent;
(function (RpcProtocolEvent) {
    RpcProtocolEvent[RpcProtocolEvent["RequestCreated"] = 0] = "RequestCreated";
    RpcProtocolEvent[RpcProtocolEvent["ResponseLoaded"] = 1] = "ResponseLoaded";
    RpcProtocolEvent[RpcProtocolEvent["ResponseLoading"] = 2] = "ResponseLoading";
    RpcProtocolEvent[RpcProtocolEvent["ConnectionErrorReceived"] = 3] = "ConnectionErrorReceived";
    RpcProtocolEvent[RpcProtocolEvent["UnknownErrorReceived"] = 4] = "UnknownErrorReceived";
    RpcProtocolEvent[RpcProtocolEvent["BackendErrorReceived"] = 5] = "BackendErrorReceived";
    RpcProtocolEvent[RpcProtocolEvent["ConnectionAborted"] = 6] = "ConnectionAborted";
    RpcProtocolEvent[RpcProtocolEvent["AcknowledgementReceived"] = 7] = "AcknowledgementReceived";
    RpcProtocolEvent[RpcProtocolEvent["RequestReceived"] = 8] = "RequestReceived";
    RpcProtocolEvent[RpcProtocolEvent["BackendResponseCreated"] = 9] = "BackendResponseCreated";
    RpcProtocolEvent[RpcProtocolEvent["BackendReportedPending"] = 10] = "BackendReportedPending";
    RpcProtocolEvent[RpcProtocolEvent["BackendReportedNotFound"] = 11] = "BackendReportedNotFound";
    RpcProtocolEvent[RpcProtocolEvent["BackendErrorOccurred"] = 12] = "BackendErrorOccurred";
    RpcProtocolEvent[RpcProtocolEvent["AcknowledgementCreated"] = 13] = "AcknowledgementCreated";
    RpcProtocolEvent[RpcProtocolEvent["ReleaseResources"] = 14] = "ReleaseResources";
})(RpcProtocolEvent = exports.RpcProtocolEvent || (exports.RpcProtocolEvent = {}));
/** An application protocol for an RPC interface. */
class RpcProtocol {
    /** Constructs a protocol. */
    constructor(configuration) {
        /** Events raised by the protocol. See [[RpcProtocolEvent]] */
        this.events = new bentleyjs_core_1.BeEvent();
        /** The RPC invocation class for this protocol. */
        this.invocationType = RpcInvocation_1.RpcInvocation;
        /** The name of the request id header. */
        this.requestIdHeaderName = "X-RequestId";
        this.configuration = configuration;
        this.events.addListener((type, object) => RpcProtocol.events.raiseEvent(type, object));
    }
    /** The name of the authorization header. */
    get authorizationHeaderName() { return this.configuration.applicationAuthorizationKey; }
    /** Override to supply the status corresponding to a protocol-specific code value. */
    getStatus(code) {
        return code;
    }
    /** Override to supply the protocol-specific code corresponding to a status value. */
    getCode(status) {
        return status;
    }
    /** Override to supply the protocol-specific method value for an RPC operation. */
    supplyMethodForOperation(_operation) {
        return "";
    }
    /** Override to supply the protocol-specific path value for an RPC operation. */
    supplyPathForOperation(operation, _request) {
        return JSON.stringify(operation);
    }
    /** Override to supply the operation for a protocol-specific path value. */
    getOperationFromPath(path) {
        return JSON.parse(path);
    }
    /** Override to supply error objects for protocol events. */
    supplyErrorForEvent(_event, _object) {
        return new Error();
    }
    /** Obtains the implementation result on the backend for an RPC operation request. */
    fulfill(request) {
        return new (this.invocationType)(this, request).fulfillment;
    }
    /** Serializes a request. */
    serialize(request) {
        return {
            id: request.id,
            authorization: this.configuration.applicationAuthorizationValue || "",
            operation: {
                interfaceDefinition: request.operation.interfaceDefinition.name,
                operationName: request.operation.operationName,
                interfaceVersion: request.operation.interfaceVersion,
            },
            method: this.supplyMethodForOperation(request.operation),
            path: this.supplyPathForOperation(request.operation, request),
            parameters: RpcMarshaling_1.RpcMarshaling.serialize(request.operation, request.protocol, request.parameters),
        };
    }
    /** @hidden @internal */
    onRpcClientInitialized(_definition, _client) { }
    /** @hidden @internal */
    onRpcImplInitialized(_definition, _impl) { }
    /** @hidden @internal */
    onRpcClientTerminated(_definition, _client) { }
    /** @hidden @internal */
    onRpcImplTerminated(_definition, _impl) { }
}
/** Events raised by all protocols. See [[RpcProtocolEvent]] */
RpcProtocol.events = new bentleyjs_core_1.BeEvent();
exports.RpcProtocol = RpcProtocol;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const Handle_1 = __webpack_require__(36);
const EdgeOverrides_1 = __webpack_require__(55);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
const Texture_1 = __webpack_require__(19);
/** Represents a geometric primitive ready to be submitted to the GPU for rendering. */
class CachedGeometry {
    // Returns the edge/line weight used to render this geometry
    _getLineWeight(_params) { return 0; }
    // Returns the edge/line pattern used to render this geometry
    _getLineCode(_params) { return EdgeOverrides_1.LineCode.solid; }
    // Returns true if this is a lit surface
    get isLitSurface() { return false; }
    // Intended to be overridden by specific subclasses
    get material() { return undefined; }
    get polylineBuffers() { return undefined; }
    set uniformFeatureIndices(value) { bentleyjs_core_1.assert(undefined !== value); } // silence 'unused variable' warning...
    get featuresInfo() { return undefined; }
    get debugString() { return ""; }
    get isEdge() {
        switch (this.renderOrder) {
            case 4 /* Edge */:
            case 5 /* Silhouette */:
            case 12 /* PlanarEdge */:
            case 13 /* PlanarSilhouette */:
                return true;
            default:
                return false;
        }
    }
    wantWoWReversal(params) {
        return !params.isOverlayPass && this._wantWoWReversal(params.target);
    }
    getLineCode(params) {
        return params.target.currentViewFlags.showStyles() ? this._getLineCode(params) : EdgeOverrides_1.LineCode.solid;
    }
    getLineWeight(params) {
        if (!params.target.currentViewFlags.showWeights()) {
            return 1.0;
        }
        const minWeight = 1;
        let weight = this._getLineWeight(params);
        weight = Math.max(weight, minWeight);
        weight = Math.min(weight, 31.0);
        bentleyjs_core_1.assert(Math.floor(weight) === weight);
        return weight;
    }
}
exports.CachedGeometry = CachedGeometry;
// Geometry which is drawn using indices into a look-up texture of vertex data, via gl.drawArrays()
class LUTGeometry extends CachedGeometry {
    // Override this if your color varies based on the target
    getColor(_target) { return this.lut.colorInfo; }
    get qOrigin() { return this.lut.qOrigin; }
    get qScale() { return this.lut.qScale; }
    constructor() { super(); }
}
exports.LUTGeometry = LUTGeometry;
// Parameters used to construct an IndexedGeometry
class IndexedGeometryParams {
    constructor(positions, indices, numIndices) {
        this.positions = positions;
        this.indices = indices;
        this.numIndices = numIndices;
    }
    static create(positions, qparams, indices) {
        const posBuf = Handle_1.QBufferHandle3d.create(qparams, positions);
        const indBuf = Handle_1.BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ElementArrayBuffer, indices);
        if (undefined === posBuf || undefined === indBuf) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        bentleyjs_core_1.assert(!posBuf.isDisposed && !indBuf.isDisposed);
        return new IndexedGeometryParams(posBuf, indBuf, indices.length);
    }
    static createFromList(positions, indices) {
        return IndexedGeometryParams.create(positions.toTypedArray(), positions.params, indices);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.positions);
        bentleyjs_core_1.dispose(this.indices);
    }
}
exports.IndexedGeometryParams = IndexedGeometryParams;
/** A geometric primitive which is rendered using gl.drawElements() with one or more vertex buffers indexed by an index buffer. */
class IndexedGeometry extends CachedGeometry {
    _wantWoWReversal(_target) { return false; }
    constructor(params) {
        super();
        this._params = params;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._params);
    }
    bindVertexArray(attr) {
        attr.enableArray(this._params.positions, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0);
    }
    draw() {
        this._params.indices.bind(GL_1.GL.Buffer.Target.ElementArrayBuffer);
        System_1.System.instance.context.drawElements(GL_1.GL.PrimitiveType.Triangles, this._params.numIndices, GL_1.GL.DataType.UnsignedInt, 0);
    }
    get qOrigin() { return this._params.positions.origin; }
    get qScale() { return this._params.positions.scale; }
}
exports.IndexedGeometry = IndexedGeometry;
/** A geometric primitive representative of a set of clipping planes to clip a volume of space. */
class ClipMaskGeometry extends IndexedGeometry {
    constructor(indices, vertices) {
        super(IndexedGeometryParams.create(vertices.toTypedArray(), vertices.params, indices));
    }
    getTechniqueId(_target) { return 14 /* ClipMask */; }
    getRenderPass(_target) { return 255 /* None */; }
    get renderOrder() { return 2 /* Surface */; }
}
exports.ClipMaskGeometry = ClipMaskGeometry;
class SkyBoxSides {
}
SkyBoxSides.front = 0.0;
SkyBoxSides.back = 0.2;
SkyBoxSides.top = 0.4;
SkyBoxSides.bottom = 0.6;
SkyBoxSides.left = 0.8;
SkyBoxSides.right = 1.0;
// a cube of quads in normalized device coordinates for skybox rendering techniques
class SkyBoxQuads {
    constructor() {
        const skyBoxSz = 1.0;
        const qVerts = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromNormalizedRange());
        this.sides = new Float32Array(36);
        this.uvs = new Float32Array(36 * 2);
        // NB: After applying the rotation matrix in the shader, Back becomes (Bottom), etc.
        // See the notes in the parens below.
        // Back (Bottom after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 0], 0); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 2); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 0], 4); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 6); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 8); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 0], 10); // back lower left - 2
        this.sides.set([SkyBoxSides.bottom, SkyBoxSides.bottom, SkyBoxSides.bottom, SkyBoxSides.bottom, SkyBoxSides.bottom, SkyBoxSides.bottom], 0);
        // Front (Top after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 1], 12); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 14); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 1], 16); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 18); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 20); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 1], 22); // front lower left - 6
        this.sides.set([SkyBoxSides.top, SkyBoxSides.top, SkyBoxSides.top, SkyBoxSides.top, SkyBoxSides.top, SkyBoxSides.top], 6);
        // Top (Front after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 24); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 26); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 28); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 30); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 32); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 34); // back upper right - 1
        this.sides.set([SkyBoxSides.front, SkyBoxSides.front, SkyBoxSides.front, SkyBoxSides.front, SkyBoxSides.front, SkyBoxSides.front], 12);
        // Bottom (Back after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 36); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 38); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 40); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 42); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 44); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 46); // front lower left - 6
        this.sides.set([SkyBoxSides.back, SkyBoxSides.back, SkyBoxSides.back, SkyBoxSides.back, SkyBoxSides.back, SkyBoxSides.back], 18);
        // Left (Right after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 48); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 50); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 52); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 54); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 56); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 58); // back lower left - 2
        this.sides.set([SkyBoxSides.right, SkyBoxSides.right, SkyBoxSides.right, SkyBoxSides.right, SkyBoxSides.right, SkyBoxSides.right], 24);
        // Right (Left after rotation)
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz));
        this.uvs.set([0, 1], 60); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 62); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 64); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));
        this.uvs.set([0, 0], 66); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));
        this.uvs.set([1, 0], 68); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));
        this.uvs.set([1, 1], 70); // back lower right - 3
        this.sides.set([SkyBoxSides.left, SkyBoxSides.left, SkyBoxSides.left, SkyBoxSides.left, SkyBoxSides.left, SkyBoxSides.left], 30);
        this.vertices = qVerts.toTypedArray();
        this.vertexParams = qVerts.params;
    }
    createParams() {
        return SkyBoxGeometryParams.create(this.vertices, this.vertexParams, this.uvs, this.sides);
    }
}
// Parameters used to construct an SkyBox
class SkyBoxGeometryParams {
    constructor(positions, uvs, sides) {
        this.positions = positions;
        this.uvs = uvs;
        this.sides = sides;
    }
    static create(positions, qparams, uvs, sides) {
        const posBuf = Handle_1.QBufferHandle3d.create(qparams, positions);
        const uvBuf = Handle_1.BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ArrayBuffer, uvs);
        const sideBuf = Handle_1.BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ArrayBuffer, sides);
        if (undefined === posBuf || undefined === uvBuf || undefined === sideBuf) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        bentleyjs_core_1.assert(!posBuf.isDisposed && !sideBuf.isDisposed);
        return new SkyBoxGeometryParams(posBuf, uvBuf, sideBuf);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.positions);
        bentleyjs_core_1.dispose(this.sides);
    }
}
exports.SkyBoxGeometryParams = SkyBoxGeometryParams;
(function (SkyBoxQuads) {
    let _skyBoxQuads;
    function getInstance() {
        if (undefined === _skyBoxQuads)
            _skyBoxQuads = new SkyBoxQuads();
        return _skyBoxQuads;
    }
    SkyBoxQuads.getInstance = getInstance;
})(SkyBoxQuads || (SkyBoxQuads = {}));
// Geometry used for view-space rendering techniques.
class SkyBoxQuadsGeometry extends CachedGeometry {
    constructor(ndxGeomParams, sbxCreateParams) {
        super();
        this.front = sbxCreateParams.front;
        this.back = sbxCreateParams.back;
        this.top = sbxCreateParams.top;
        this.bottom = sbxCreateParams.bottom;
        this.left = sbxCreateParams.left;
        this.right = sbxCreateParams.right;
        this._techniqueId = 15 /* SkyBox */;
        this._params = ndxGeomParams;
    }
    static create(sbxCreateParams) {
        const sbxGeomParams = SkyBoxQuads.getInstance().createParams();
        return undefined !== sbxGeomParams ? new SkyBoxQuadsGeometry(sbxGeomParams, sbxCreateParams) : undefined;
    }
    getTechniqueId(_target) { return this._techniqueId; }
    getRenderPass(_target) { return 9 /* SkyBox */; }
    get renderOrder() { return 2 /* Surface */; }
    bindVertexArray(attr) {
        attr.enableArray(this._params.positions, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0);
    }
    bindTexCoordArray(attr) {
        attr.enableArray(this._params.uvs, 2, GL_1.GL.DataType.Float, false, 0, 0);
    }
    bindSideArray(attr) {
        attr.enableArray(this._params.sides, 1, GL_1.GL.DataType.Float, false, 0, 0);
    }
    draw() {
        System_1.System.instance.context.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, 36);
    }
    get qOrigin() { return this._params.positions.origin; }
    get qScale() { return this._params.positions.scale; }
    dispose() {
        bentleyjs_core_1.dispose(this._params);
    }
    _wantWoWReversal(_target) { return false; }
}
exports.SkyBoxQuadsGeometry = SkyBoxQuadsGeometry;
// A quad with its corners mapped to the dimensions as the viewport, used for special rendering techniques.
class ViewportQuad {
    constructor() {
        this.indices = new Uint32Array(6);
        const pt = new geometry_core_1.Point3d(-1, -1, 0);
        const vertices = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromNormalizedRange());
        vertices.add(pt);
        pt.x = 1;
        vertices.add(pt);
        pt.y = 1;
        vertices.add(pt);
        pt.x = -1;
        vertices.add(pt);
        this.vertices = vertices.toTypedArray();
        this.vertexParams = vertices.params;
        this.indices[0] = 0;
        this.indices[1] = 1;
        this.indices[2] = 2;
        this.indices[3] = 0;
        this.indices[4] = 2;
        this.indices[5] = 3;
    }
    createParams() {
        return IndexedGeometryParams.create(this.vertices, this.vertexParams, this.indices);
    }
}
(function (ViewportQuad) {
    let _viewportQuad;
    function getInstance() {
        if (undefined === _viewportQuad)
            _viewportQuad = new ViewportQuad();
        return _viewportQuad;
    }
    ViewportQuad.getInstance = getInstance;
})(ViewportQuad || (ViewportQuad = {}));
// Geometry used for view-space rendering techniques.
class ViewportQuadGeometry extends IndexedGeometry {
    constructor(params, techniqueId) {
        super(params);
        this._techniqueId = techniqueId;
    }
    static create(techniqueId) {
        const params = ViewportQuad.getInstance().createParams();
        return undefined !== params ? new ViewportQuadGeometry(params, techniqueId) : undefined;
    }
    getTechniqueId(_target) { return this._techniqueId; }
    getRenderPass(_target) { return 3 /* OpaqueGeneral */; }
    get renderOrder() { return 2 /* Surface */; }
}
exports.ViewportQuadGeometry = ViewportQuadGeometry;
// Geometry used for view-space rendering techniques which involve sampling one or more textures.
class TexturedViewportQuadGeometry extends ViewportQuadGeometry {
    constructor(params, techniqueId, textures) {
        super(params, techniqueId);
        this._textures = textures;
        // TypeScript compiler will happily accept TextureHandle (or any other type) in place of WebGLTexture.
        // There is no such 'type' as WebGLTexture at run-time.
        for (const texture of this._textures) {
            bentleyjs_core_1.assert(!(texture instanceof Texture_1.TextureHandle));
        }
    }
}
exports.TexturedViewportQuadGeometry = TexturedViewportQuadGeometry;
// Geometry used during the 'composite' pass to apply transparency and/or hilite effects.
class CompositeGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(opaque, accum, reveal, hilite) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params) {
            return undefined;
        }
        return new CompositeGeometry(params, [opaque, accum, reveal, hilite]);
    }
    get opaque() { return this._textures[0]; }
    get accum() { return this._textures[1]; }
    get reveal() { return this._textures[2]; }
    get hilite() { return this._textures[3]; }
    // Invoked each frame to determine the appropriate Technique to use.
    update(flags) { this._techniqueId = this.determineTechnique(flags); }
    determineTechnique(flags) {
        switch (flags) {
            case 2 /* Hilite */: return 6 /* CompositeHilite */;
            case 1 /* Translucent */: return 7 /* CompositeTranslucent */;
            default: return 8 /* CompositeHiliteAndTranslucent */;
        }
    }
    constructor(params, textures) {
        super(params, 6 /* CompositeHilite */, textures);
        bentleyjs_core_1.assert(4 === this._textures.length);
    }
}
exports.CompositeGeometry = CompositeGeometry;
// Geometry used to ping-pong the pick buffer data in between opaque passes.
class CopyPickBufferGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(idLow, idHigh, depthAndOrder) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined !== params) {
            return new CopyPickBufferGeometry(params, [idLow, idHigh, depthAndOrder]);
        }
        else {
            return undefined;
        }
    }
    get elemIdLow() { return this._textures[0]; }
    get elemIdHigh() { return this._textures[1]; }
    get depthAndOrder() { return this._textures[2]; }
    constructor(params, textures) {
        super(params, 10 /* CopyPickBuffers */, textures);
    }
}
exports.CopyPickBufferGeometry = CopyPickBufferGeometry;
class SingleTexturedViewportQuadGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(texture, techId) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params) {
            return undefined;
        }
        return new SingleTexturedViewportQuadGeometry(params, texture, techId);
    }
    get texture() { return this._textures[0]; }
    set texture(texture) { this._textures[0] = texture; }
    constructor(params, texture, techId) {
        super(params, techId, [texture]);
    }
}
exports.SingleTexturedViewportQuadGeometry = SingleTexturedViewportQuadGeometry;
class PolylineBuffers {
    constructor(indices, prevIndices, nextIndicesAndParams, distances) {
        this.indices = indices;
        this.prevIndices = prevIndices;
        this.nextIndicesAndParams = nextIndicesAndParams;
        this.distances = distances;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.indices);
        bentleyjs_core_1.dispose(this.prevIndices);
        bentleyjs_core_1.dispose(this.nextIndicesAndParams);
        bentleyjs_core_1.dispose(this.distances);
    }
}
exports.PolylineBuffers = PolylineBuffers;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 |  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ShaderProgram_1 = __webpack_require__(125);
const Vertex_1 = __webpack_require__(20);
var Convert;
(function (Convert) {
    function typeToString(type) {
        switch (type) {
            case 0 /* Boolean */: return "bool";
            case 1 /* Int */: return "int";
            case 2 /* UInt */: return "uint";
            case 3 /* Float */: return "float";
            case 4 /* Vec2 */: return "vec2";
            case 5 /* Vec3 */: return "vec3";
            case 6 /* Vec4 */: return "vec4";
            case 7 /* Mat3 */: return "mat3";
            case 8 /* Mat4 */: return "mat4";
            case 9 /* Sampler2D */: return "sampler2D";
            case 10 /* SamplerCube */: return "samplerCube";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.typeToString = typeToString;
    function scopeToString(scope) {
        switch (scope) {
            case 0 /* Global */: return "";
            case 1 /* Varying */: return "varying";
            case 2 /* Uniform */: return "uniform";
            case 3 /* Attribute */: return "attribute";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.scopeToString = scopeToString;
    function precisionToString(precision) {
        switch (precision) {
            case 0 /* Default */: return "";
            case 1 /* Low */: return "lowp";
            case 2 /* Medium */: return "mediump";
            case 3 /* High */: return "highp";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.precisionToString = precisionToString;
})(Convert || (Convert = {}));
/** Represents a variable within a fragment or vertex shader. */
class ShaderVariable {
    constructor(name, type, scope, precision, isConst, addBinding, value) {
        this.isConst = false; // for global variables only
        this._addBinding = addBinding;
        this.name = name;
        this.value = value;
        this.type = type;
        this.scope = scope;
        this.precision = precision;
        this.isConst = isConst;
    }
    static create(name, type, scope, addBinding, precision = 0 /* Default */) {
        return new ShaderVariable(name, type, scope, precision, false, addBinding, undefined);
    }
    static createGlobal(name, type, value, isConst = false) {
        return new ShaderVariable(name, type, 0 /* Global */, 0 /* Default */, isConst, undefined, value);
    }
    get hasBinding() { return undefined !== this._addBinding; }
    addBinding(prog) {
        if (undefined !== this._addBinding)
            this._addBinding(prog);
    }
    get typeName() { return Convert.typeToString(this.type); }
    get scopeName() { return Convert.scopeToString(this.scope); }
    get precisionName() { return Convert.precisionToString(this.precision); }
    /** Constructs the single-line declaration of this variable */
    buildDeclaration() {
        const parts = new Array();
        if (this.isConst)
            parts.push("const");
        const scopeName = this.scopeName;
        if (0 < scopeName.length)
            parts.push(scopeName);
        const precisionName = this.precisionName;
        if (0 < precisionName.length)
            parts.push(precisionName);
        parts.push(this.typeName);
        parts.push(this.name);
        if (undefined !== this.value && 0 < this.value.length) {
            parts.push("=");
            parts.push(this.value);
        }
        return parts.join(" ") + ";";
    }
}
exports.ShaderVariable = ShaderVariable;
/**
 * Represents the set of variables defined and used within a fragment or vertex shader.
 * If the same variable is used in both the fragment and vertex shader (e.g., a varying variable), it should be defined in both ShaderBuilders' ShaderVariables object.
 */
class ShaderVariables {
    constructor() {
        this._list = new Array();
    }
    /** Find an existing variable with the specified name */
    find(name) { return this._list.find((v) => v.name === name); }
    /** Add a new variable, if a variable with the same name does not already exist. */
    addVariable(v) {
        const found = this.find(v.name);
        if (undefined !== found) {
            bentleyjs_core_1.assert(found.type === v.type);
            // assume same binding etc...
        }
        else {
            this._list.push(v);
        }
    }
    addUniform(name, type, binding, precision = 0 /* Default */) {
        this.addVariable(ShaderVariable.create(name, type, 2 /* Uniform */, binding, precision));
    }
    addAttribute(name, type, binding) {
        this.addVariable(ShaderVariable.create(name, type, 3 /* Attribute */, binding));
    }
    addVarying(name, type) {
        this.addVariable(ShaderVariable.create(name, type, 1 /* Varying */));
    }
    addGlobal(name, type, value, isConst = false) {
        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst));
    }
    addConstant(name, type, value) {
        this.addGlobal(name, type, value, true);
    }
    /** Constructs the lines of glsl code declaring all of the variables. */
    buildDeclarations() {
        let decls = "";
        for (const v of this._list) {
            decls += v.buildDeclaration() + "\n";
        }
        return decls;
    }
    /**
     * For every uniform and attribute variable not contained in the optional 'predefined' list, invokes the associated binding function
     * to add the corresponding Uniform or Attribute object to the ShaderProgram.
     */
    addBindings(prog, predefined) {
        for (const v of this._list) {
            // Some variables exist in both frag and vert shaders - only add them to the program once.
            if (v.hasBinding && (undefined === predefined || undefined === predefined.find(v.name))) {
                v.addBinding(prog);
            }
        }
    }
    get length() { return this._list.length; }
}
exports.ShaderVariables = ShaderVariables;
/** Convenience API for assembling glsl source code. */
class SourceBuilder {
    constructor() {
        this.source = "";
    }
    /* Append the specified string to the glsl source */
    add(what) { this.source += what; }
    /* Append a new-line to the glsl source */
    newline() { this.add("\n"); }
    /* Append the specified string to the glsl source, followed by a new-line */
    addline(what) { this.add(what); this.newline(); }
    /**
     * Construct a function definition given the function signature and body. For example:
     * buildFunctionDefintion("float average(float a, float b)", "\n  return (a + b) / 2.0;\n");
     * will produce:
     *  "float average(float a, float b) {
     *     return (a + b) / 2.0;
     *   }"
     * For an inline function:
     * buildFunctionDefintion("float average(float a, float b)", "return (a + b) / 2.0;");
     * will produce:
     *  "float average(float a, float b) { return (a + b) / 2.0; }"
     */
    static buildFunctionDefinition(declaration, implementation) {
        // If implementation does not start with a newline then assume it is an inline function & add spaces between braces.
        if ("\n" === implementation.charAt(0))
            return declaration + " {" + implementation + "}\n\n";
        else
            return declaration + " { " + implementation + " }\n\n";
    }
    /** Constructs a function definition as described by buildFunctionDefinition() and appends it to the glsl source. */
    addFunction(declaration, implementation) { this.add(SourceBuilder.buildFunctionDefinition(declaration, implementation)); }
    /** Constructs the definition of the main() function using the supplied function body and appends it to the glsl source. */
    addMain(implementation) { this.addFunction("void main()", implementation); }
}
exports.SourceBuilder = SourceBuilder;
/*
 * Represents a fragment or vertex shader under construction. The shader consists of a set of defined variables,
 * plus a set of code snippets which can be concatenated together to form the shader source.
 */
class ShaderBuilder extends ShaderVariables {
    constructor(maxComponents) {
        super(); // dumb but required. superclass has no explicit constructor.
        this._components = new Array();
        this._functions = new Array();
        this._extensions = new Array();
        this.headerComment = "";
        this._components.length = maxComponents;
    }
    addComponent(index, component) {
        bentleyjs_core_1.assert(index < this._components.length);
        // assume if caller is replacing an existing component, they know what they're doing...
        this._components[index] = component;
    }
    getComponent(index) {
        bentleyjs_core_1.assert(index < this._components.length);
        return this._components[index];
    }
    addFunction(declarationOrFull, implementation) {
        let def = declarationOrFull;
        if (undefined !== implementation) {
            def = SourceBuilder.buildFunctionDefinition("\n" + declarationOrFull, implementation);
        }
        if (undefined === this.findFunction(def)) {
            this._functions.push(def);
        }
    }
    replaceFunction(existing, replacement) {
        const index = this._functions.indexOf(existing);
        if (-1 !== index) {
            this._functions[index] = replacement;
        }
        bentleyjs_core_1.assert(-1 !== index);
        return -1 !== index;
    }
    findFunction(func) {
        return this._functions.find((f) => f === func);
    }
    addExtension(extName) {
        if (-1 === this._extensions.indexOf(extName)) {
            this._extensions.push(extName);
        }
    }
    buildPreludeCommon(isFrag = false, isLit = false) {
        const src = new SourceBuilder();
        src.addline("#version 100");
        src.addline("#define TEXTURE texture2D");
        // Header comment
        src.newline();
        if ("" !== this.headerComment) {
            src.addline(this.headerComment);
            src.newline();
        }
        // Extensions
        let needMultiDrawBuffers = false;
        for (const ext of this._extensions) {
            if (ext === "GL_EXT_draw_buffers") {
                needMultiDrawBuffers = true;
            }
            src.addline("#extension " + ext + " : enable");
        }
        // Default precisions
        src.addline("precision highp float;");
        src.addline("precision highp int;");
        src.newline();
        // Variable declarations
        src.add(this.buildDeclarations());
        if (isFrag) {
            src.addline("#define FragColor gl_FragColor");
            if (needMultiDrawBuffers) {
                src.addline("#define FragColor0 gl_FragData[0]");
                src.addline("#define FragColor1 gl_FragData[1]");
                src.addline("#define FragColor2 gl_FragData[2]");
                src.addline("#define FragColor3 gl_FragData[3]");
            }
            if (isLit) {
                /* ###TODO: Source Lighting
                // ###TODO: May end up needing to change this to 8 for unrolled lighting loop...see ShaderBuilder.cpp...
                const maxShaderLights = 64;
                src.addline("const int kMaxShaderLights = " + maxShaderLights);
                src.addline("#define LightColor(i) u_lightData[i*3+0].rgb");
                src.addline("#define LightAtten1(i) u_lightData[i*3+0].a");
                src.addline("#define LightPos(i) u_lightData[i*3+1].xyz");
                src.addline("#define cosHTheta(i) u_lightData[i*3+1].w");
                src.addline("#define LightDir(i) u_lightData[i*3+2].xyz");
                src.addline("#define cosHPhi(i) u_lightData[i*3+2].w");
                */
            }
        }
        // Functions
        for (const func of this._functions) {
            src.add(func);
        }
        if (0 !== this._functions.length)
            src.newline();
        return src;
    }
}
exports.ShaderBuilder = ShaderBuilder;
/** Assembles the source code for a vertex shader from a set of modular components. */
class VertexShaderBuilder extends ShaderBuilder {
    constructor(positionFromLUT) {
        super(6 /* COUNT */);
        this._computedVarying = new Array();
        this._initializers = new Array();
        Vertex_1.addPosition(this, positionFromLUT);
    }
    buildPrelude() { return this.buildPreludeCommon(); }
    set(id, component) { this.addComponent(id, component); }
    get(id) { return this.getComponent(id); }
    addInitializer(initializer) { this._initializers.push(initializer); }
    addComputedVarying(name, type, computation) {
        this.addVarying(name, type);
        this._computedVarying.push(computation);
    }
    buildSource() {
        const prelude = this.buildPrelude();
        const main = new SourceBuilder();
        main.newline();
        const computePosition = this.get(3 /* ComputePosition */);
        bentleyjs_core_1.assert(undefined !== computePosition);
        if (undefined !== computePosition) {
            prelude.addFunction("vec4 computePosition(vec4 rawPos)", computePosition);
        }
        // Initialization logic that should occur at start of main() - primarily global variables whose values
        // are too complex to compute inline or which depend on uniforms and/or other globals.
        for (const init of this._initializers) {
            main.addline("  {" + init + "  }\n");
        }
        main.addline("  vec4 rawPosition = unquantizeVertexPosition(a_pos, u_qOrigin, u_qScale);");
        const checkForEarlyDiscard = this.get(0 /* CheckForEarlyDiscard */);
        if (undefined !== checkForEarlyDiscard) {
            prelude.addFunction("bool checkForEarlyDiscard(vec4 rawPos)", checkForEarlyDiscard);
            main.add(Vertex_1.GLSLVertex.earlyDiscard);
        }
        const computeFeatureOverrides = this.get(1 /* ComputeFeatureOverrides */);
        if (undefined !== computeFeatureOverrides) {
            prelude.addFunction("void computeFeatureOverrides()", computeFeatureOverrides);
            main.addline("  computeFeatureOverrides();");
        }
        const checkForDiscard = this.get(2 /* CheckForDiscard */);
        if (undefined !== checkForDiscard) {
            prelude.addFunction("bool checkForDiscard()", checkForDiscard);
            main.add(Vertex_1.GLSLVertex.discard);
        }
        const calcClipDist = this.get(4 /* CalcClipDist */);
        if (undefined !== calcClipDist) {
            prelude.addFunction("void calcClipDist(vec4 rawPos)", calcClipDist);
            main.addline("  calcClipDist(rawPosition);");
        }
        const compElemId = this.get(5 /* AddComputeElementId */);
        if (undefined !== compElemId) {
            main.addline("  computeElementId();");
        }
        main.addline("  gl_Position = computePosition(rawPosition);");
        for (const comp of this._computedVarying) {
            main.addline("  " + comp);
        }
        prelude.addMain(main.source);
        return prelude.source;
    }
}
exports.VertexShaderBuilder = VertexShaderBuilder;
/** Assembles the source code for a fragment shader from a set of modular components. */
class FragmentShaderBuilder extends ShaderBuilder {
    constructor() {
        super(14 /* COUNT */);
    }
    set(id, component) { this.addComponent(id, component); }
    get(id) { return this.getComponent(id); }
    addDrawBuffersExtension() { this.addExtension("GL_EXT_draw_buffers"); }
    buildSource() {
        const applyLighting = this.get(7 /* ApplyLighting */);
        const prelude = this.buildPrelude(undefined !== applyLighting);
        const computeBaseColor = this.get(1 /* ComputeBaseColor */);
        bentleyjs_core_1.assert(undefined !== computeBaseColor);
        if (undefined !== computeBaseColor) {
            prelude.addFunction("vec4 computeBaseColor()", computeBaseColor);
        }
        const main = new SourceBuilder();
        main.newline();
        const checkForEarlyDiscard = this.get(0 /* CheckForEarlyDiscard */);
        if (undefined !== checkForEarlyDiscard) {
            prelude.addFunction("bool checkForEarlyDiscard()", checkForEarlyDiscard);
            main.addline("  if (checkForEarlyDiscard()) { discard; return; }");
        }
        const applyClipping = this.get(10 /* ApplyClipping */);
        if (undefined !== applyClipping) {
            prelude.addFunction("void applyClipping()", applyClipping);
            main.addline("  applyClipping();");
        }
        main.addline("  vec4 baseColor = computeBaseColor();");
        const applyMaterialOverrides = this.get(2 /* ApplyMaterialOverrides */);
        if (undefined !== applyMaterialOverrides) {
            prelude.addFunction("vec4 applyMaterialOverrides(vec4 baseColor)", applyMaterialOverrides);
            main.addline("  baseColor = applyMaterialOverrides(baseColor);");
        }
        const applyFeatureColor = this.get(3 /* ApplyFeatureColor */);
        if (undefined !== applyFeatureColor) {
            prelude.addFunction("vec4 applyFeatureColor(vec4 baseColor)", applyFeatureColor);
            main.addline("  baseColor = applyFeatureColor(baseColor);");
        }
        const finalize = this.get(4 /* FinalizeBaseColor */);
        if (undefined !== finalize) {
            prelude.addFunction("vec4 finalizeBaseColor(vec4 baseColor)", finalize);
            main.addline("  baseColor = finalizeBaseColor(baseColor);");
        }
        const checkForDiscard = this.get(5 /* CheckForDiscard */);
        if (undefined !== checkForDiscard) {
            prelude.addFunction("bool checkForDiscard(vec4 baseColor)", checkForDiscard);
            main.addline("  if (checkForDiscard(baseColor)) { discard; return; }");
        }
        const discardByAlpha = this.get(6 /* DiscardByAlpha */);
        if (undefined !== discardByAlpha) {
            prelude.addFunction("bool discardByAlpha(float alpha)", discardByAlpha);
            main.addline("  if (discardByAlpha(baseColor.a)) { discard; return; }");
        }
        if (undefined !== applyLighting) {
            prelude.addFunction("vec4 applyLighting(vec4 baseColor)", applyLighting);
            main.addline("  baseColor = applyLighting(baseColor);");
        }
        const applyMonochrome = this.get(8 /* ApplyMonochrome */);
        if (undefined !== applyMonochrome) {
            prelude.addFunction("vec4 applyMonochrome(vec4 baseColor)", applyMonochrome);
            main.addline("  baseColor = applyMonochrome(baseColor);");
        }
        const reverseWoW = this.get(9 /* ReverseWhiteOnWhite */);
        if (undefined !== reverseWoW) {
            prelude.addFunction("vec4 reverseWhiteOnWhite(vec4 baseColor)", reverseWoW);
            main.addline("  baseColor = reverseWhiteOnWhite(baseColor);");
        }
        const applyFlash = this.get(11 /* ApplyFlash */);
        if (undefined !== applyFlash) {
            prelude.addFunction("vec4 applyFlash(vec4 baseColor)", applyFlash);
            main.addline("  baseColor = applyFlash(baseColor);");
        }
        const applyDebug = this.get(12 /* ApplyDebugColor */);
        if (undefined !== applyDebug) {
            prelude.addFunction("vec4 applyDebugColor(vec4 baseColor)", applyDebug);
            main.addline("  baseColor = applyDebugColor(baseColor);");
        }
        const assignFragData = this.get(13 /* AssignFragData */);
        bentleyjs_core_1.assert(undefined !== assignFragData);
        if (undefined !== assignFragData) {
            prelude.addFunction("void assignFragData(vec4 baseColor)", assignFragData);
            main.addline("  assignFragData(baseColor);");
        }
        prelude.addMain(main.source);
        return prelude.source;
    }
    buildPrelude(isLit) { return this.buildPreludeCommon(true, isLit); }
}
exports.FragmentShaderBuilder = FragmentShaderBuilder;
/**
 * Assembles vertex and fragment shaders from a set of modular components to produce a compiled ShaderProgram.
 * Be very careful with components which use samplers to ensure that no conflicts exist with texture units used by other components (see TextureUnit enum).
 */
class ProgramBuilder {
    constructor(positionFromLUT) {
        this.vert = new VertexShaderBuilder(positionFromLUT);
        this.frag = new FragmentShaderBuilder();
    }
    addVariable(v, which) {
        if (which & 1 /* Fragment */) {
            this.frag.addVariable(v);
        }
        if (which & 2 /* Vertex */) {
            this.vert.addVariable(v);
        }
    }
    addUniform(name, type, binding, which = 3 /* Both */) {
        this.addVariable(ShaderVariable.create(name, type, 2 /* Uniform */, binding), which);
    }
    addAttribute(name, type, binding, which = 3 /* Both */) {
        this.addVariable(ShaderVariable.create(name, type, 3 /* Attribute */, binding), which);
    }
    addVarying(name, type) {
        this.addVariable(ShaderVariable.create(name, type, 1 /* Varying */), 3 /* Both */);
    }
    addGlobal(name, type, which = 3 /* Both */, value, isConst = false) {
        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst), which);
    }
    addInlineComputedVarying(name, type, inlineComputation) {
        this.frag.addVarying(name, type);
        this.vert.addComputedVarying(name, type, inlineComputation);
    }
    addFunctionComputedVarying(name, type, funcName, funcBody) {
        let funcDecl = "\n" + Convert.typeToString(type) + " " + funcName + "()";
        funcDecl = SourceBuilder.buildFunctionDefinition(funcDecl, funcBody);
        const funcCall = funcName + "()";
        this.addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDecl);
    }
    addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDef) {
        this.vert.addFunction(funcDef);
        const computation = name + " = " + funcCall + ";";
        this.addInlineComputedVarying(name, type, computation);
    }
    /** Assembles the vertex and fragment shader code and returns a ready-to-compile shader program */
    buildProgram(gl) {
        const prog = new ShaderProgram_1.ShaderProgram(gl, this.vert.buildSource(), this.frag.buildSource(), this.vert.headerComment);
        this.vert.addBindings(prog);
        this.frag.addBindings(prog, this.vert);
        return prog;
    }
}
exports.ProgramBuilder = ProgramBuilder;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** Information on the host used for REST queries. */
class Host {
    constructor(name, version, guid, deviceId, description, relyingPartyUri) {
        this.name = name;
        this.version = version;
        this.guid = guid;
        this.deviceId = deviceId;
        this.description = description;
        this.relyingPartyUri = relyingPartyUri;
    }
}
exports.Host = Host;
var RuntimeEnv;
(function (RuntimeEnv) {
    RuntimeEnv[RuntimeEnv["Uninitialized"] = 0] = "Uninitialized";
    RuntimeEnv[RuntimeEnv["Browser"] = 1] = "Browser";
    RuntimeEnv[RuntimeEnv["Server"] = 2] = "Server";
})(RuntimeEnv = exports.RuntimeEnv || (exports.RuntimeEnv = {}));
// @todo Needs to be refactored for the service
/** Common configuration related utliities */
class Config {
    /** Returns true if the code is currently executing in a browser, or false if it is executing on the server */
    static isBrowser() {
        return (typeof window !== "undefined");
    }
    static get devCorsProxyServer() {
        return Config._devCorsProxyServer;
    }
    static set devCorsProxyServer(url) {
        Config._devCorsProxyServer = url.replace(/\/?$/, "/");
    }
}
Config.host = new Host("ConnectClientJsApi", "1.0", "ConnectClientJsApiGuid", "ConnectClientJsApiDeviceId", "JavaScript Client API for various Bentley Connect services", "https://connect-wsg20.bentley.com");
exports.Config = Config;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const Request_1 = __webpack_require__(23);
const ECJsonTypeMap_1 = __webpack_require__(9);
const bentleyjs_core_1 = __webpack_require__(0);
const Client_1 = __webpack_require__(68);
const ImsClients_1 = __webpack_require__(111);
const loggingCategory = "imodeljs-clients.Clients";
/**
 * Error that was returned by a WSG based service.
 */
class WsgError extends Request_1.ResponseError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, getMetaData);
    }
    /**
     * Attempt to parse the error from the response.
     * Attempts to parse error data in a format that is returned by WSG services.
     * This method only accesses data that was parsed by parent class to avoid dependencies on
     * http libraries.
     * @param response Response from the server.
     * @returns Parsed error.
     */
    static parse(response, log = true) {
        const responseError = Request_1.ResponseError.parse(response, false);
        const wsgError = new WsgError(98305 /* Unknown */);
        deepAssign(wsgError, responseError);
        if (wsgError._data) {
            if (typeof wsgError._data === "object") {
                if (wsgError._data.errorMessage || wsgError._data.errorId) {
                    wsgError.message = wsgError._data.errorMessage || wsgError.message;
                    wsgError.name = wsgError._data.errorId || wsgError.name;
                    wsgError.description = wsgError._data.errorDescription || wsgError.description;
                    wsgError.errorNumber = WsgError.getWSStatusId(wsgError.name ? wsgError.name : "");
                    if (log)
                        wsgError.log();
                    return wsgError;
                }
            }
            else {
                if (wsgError.status === 302 && wsgError._data.indexOf("ims.bentley.com") >= 0) {
                    const authenticationError = new Client_1.AuthenticationError(98319 /* LoginRequired */);
                    deepAssign(authenticationError, responseError);
                    authenticationError.name = "Authentication Error";
                    authenticationError.message = "Authentication Error - Check if the accessToken is valid";
                    return authenticationError;
                }
            }
        }
        if (log)
            responseError.log();
        return responseError;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error
     * @param response Response
     */
    static shouldRetry(error, response) {
        if (response === undefined || response === null) {
            return super.shouldRetry(error, response);
        }
        if (super.parseHttpStatus(response.statusType) === 0 /* Success */) {
            return false;
        }
        const parsedError = WsgError.parse({ response }, false);
        if (!(parsedError instanceof WsgError)) {
            return super.shouldRetry(error, response);
        }
        const errorCodesToRetry = [98306 /* LoginFailed */,
            98307 /* SslRequired */,
            98308 /* NotEnoughRights */,
            98309 /* RepositoryNotFound */,
            98310 /* SchemaNotFound */,
            98311 /* ClassNotFound */,
            98312 /* PropertyNotFound */,
            98313 /* InstanceNotFound */,
            98314 /* FileNotFound */,
            98315 /* NotSupported */,
            98316 /* NoServerLicense */,
            98317 /* NoClientLicense */,
            98318 /* TooManyBadLoginAttempts */,
            94212 /* ServerError */,
            94211 /* ClientError */,
            98305 /* Unknown */];
        const errorStatus = WsgError.getErrorStatus(parsedError.name !== undefined ?
            WsgError.getWSStatusId(parsedError.name) : 98305 /* Unknown */, response.statusType);
        return errorCodesToRetry.includes(errorStatus);
    }
    /**
     * Gets error status from current WSError and HTTP Status type
     * @param error Error returned by request
     * @param response Response returned by request
     */
    static getErrorStatus(errorId, httpStatusType) {
        if (98305 /* Unknown */ !== errorId) {
            return errorId;
        }
        if (super.parseHttpStatus(httpStatusType) === 94212 /* ServerError */) {
            return 94212 /* ServerError */;
        }
        if (super.parseHttpStatus(httpStatusType) === 94211 /* ClientError */) {
            return 94211 /* ClientError */;
        }
        return 98305 /* Unknown */;
    }
    /**
     * Get WSError from error string
     * @param error error to be returned in WSError enum
     */
    static getWSStatusId(error) {
        switch (error) {
            case "LoginFailed":
                return 98306 /* LoginFailed */;
            case "SslRequired":
                return 98307 /* SslRequired */;
            case "NotEnoughRights":
                return 98308 /* NotEnoughRights */;
            case "DatasourceNotFound":
                return 98309 /* RepositoryNotFound */;
            case "RepositoryNotFound":
                return 98309 /* RepositoryNotFound */;
            case "SchemaNotFound":
                return 98310 /* SchemaNotFound */;
            case "ClassNotFound":
                return 98311 /* ClassNotFound */;
            case "PropertyNotFound":
                return 98312 /* PropertyNotFound */;
            case "LinkTypeNotFound":
                return 98311 /* ClassNotFound */;
            case "ObjectNotFound":
                return 98313 /* InstanceNotFound */;
            case "InstanceNotFound":
                return 98313 /* InstanceNotFound */;
            case "FileNotFound":
                return 98314 /* FileNotFound */;
            case "NotSupported":
                return 98315 /* NotSupported */;
            case "NoServerLicense":
                return 98316 /* NoServerLicense */;
            case "NoClientLicense":
                return 98317 /* NoClientLicense */;
            case "TooManyBadLoginAttempts":
                return 98318 /* TooManyBadLoginAttempts */;
            default:
                return 98305 /* Unknown */;
        }
    }
    /**
     * Logs this error
     */
    log() {
        bentleyjs_core_1.Logger.logError(loggingCategory, this.logMessage(), this.getMetaData());
    }
}
exports.WsgError = WsgError;
/**
 * Provider for wsg RequestOptions, used by WsgClient to set defaults.
 */
class DefaultWsgRequestOptionsProvider extends Client_1.DefaultRequestOptionsProvider {
    /**
     * Creates an instance of DefaultWsgRequestOptionsProvider and sets up the default options.
     */
    constructor() {
        super();
        this.defaultOptions.errorCallback = WsgError.parse;
        this.defaultOptions.retryCallback = WsgError.shouldRetry;
    }
}
exports.DefaultWsgRequestOptionsProvider = DefaultWsgRequestOptionsProvider;
/**
 * Base class for Client implementations of services that are based on WSG
 */
class WsgClient extends Client_1.Client {
    /**
     * Creates an instance of Client.
     * @param deploymentEnv Deployment environment
     * @param apiVersion ApiVersion if the service supports it
     * @param relyingPartyUri Relying party URI if required by the service.
     */
    constructor(deploymentEnv, apiVersion, relyingPartyUri) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
        this.apiVersion = apiVersion;
        this.relyingPartyUri = relyingPartyUri;
        this.apiVersion = apiVersion;
        this.relyingPartyUri = relyingPartyUri;
    }
    /**
     * Augments request options with defaults returned by the DefaultWsgRequestOptionsProvider.
     * @note that the options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!WsgClient._defaultWsgRequestOptionsProvider)
            WsgClient._defaultWsgRequestOptionsProvider = new DefaultWsgRequestOptionsProvider();
        return WsgClient._defaultWsgRequestOptionsProvider.assignOptions(options);
    }
    /**
     * Gets the URL of the service.
     * Attempts to discover and cache the URL from the URL Discovery Service. If not
     * found uses the default URL provided by client implementations. Note that for consistency
     * sake, the URL is stripped of any trailing "/"
     * @param excludeApiVersion Pass true to optionally exclude the API version from the URL.
     * @returns URL for the service
     */
    async getUrl(excludeApiVersion) {
        if (this.url) {
            return Promise.resolve(this.url);
        }
        return super.getUrl()
            .then((url) => {
            this.url = url;
            if (!excludeApiVersion) {
                this.url += "/" + this.apiVersion;
            }
            return Promise.resolve(this.url); // TODO: On the server this really needs a lifetime!!
        });
    }
    /**
     * Gets the (delegation) access token to acess the service
     * @param authTokenInfo Access token.
     * @returns Resolves to the (delegation) access token.
     */
    async getAccessToken(authorizationToken) {
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient(this.deploymentEnv);
        return imsClient.getToken(authorizationToken, this.relyingPartyUri);
    }
    /** used by clients to delete strongly typed instances through the standard WSG REST API */
    async deleteInstance(token, relativeUrlPath, instance, requestOptions) {
        const url = await this.getUrl() + relativeUrlPath;
        const untypedInstance = instance ? ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", instance) : undefined;
        const options = {
            method: "DELETE",
            headers: { authorization: token.toTokenString() },
            body: {
                instance: untypedInstance,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        return Request_1.request(url, options).then(() => Promise.resolve());
    }
    /**
     * Used by clients to post strongly typed instances through standard WSG REST API
     * @param typedConstructor Used by clients to post a strongly typed instance through the REST API that's expected to return a standard response.
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Strongly typed instance to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instance that's returned back from the server.
     */
    async postInstance(typedConstructor, token, relativeUrlPath, instance, requestOptions) {
        const url = await this.getUrl() + relativeUrlPath;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Sending POST request to ${url}`);
        const untypedInstance = ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", instance);
        const options = {
            method: "POST",
            headers: { authorization: token.toTokenString() },
            body: {
                instance: untypedInstance,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        const res = await Request_1.request(url, options);
        if (!res.body || !res.body.changedInstance || !res.body.changedInstance.instanceAfterChange) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));
        }
        const ecJsonInstance = res.body.changedInstance.instanceAfterChange;
        const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
        // console.log(JSON.stringify(res.body.instances));
        if (!typedInstance) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`));
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Successful POST request to ${url}`);
        return Promise.resolve(typedInstance);
    }
    /**
     * Used by clients to post multiple strongly typed instances through standard WSG REST API
     * @param typedConstructor Used by clients to post a strongly typed instances through the REST API that's expected to return a standard response.
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instances Strongly typed instances to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instances that's returned back from the server.
     */
    async postInstances(typedConstructor, token, relativeUrlPath, instances, requestOptions) {
        const url = await this.getUrl() + relativeUrlPath;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Sending POST request to ${url}`);
        const untypedInstances = instances.map((value) => ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", value));
        const options = {
            method: "POST",
            headers: { authorization: token.toTokenString() },
            body: {
                instances: untypedInstances,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        const res = await Request_1.request(url, options);
        if (!res.body || !res.body.changedInstances) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));
        }
        const changedInstances = res.body.changedInstances.map((value) => {
            const untypedInstance = value.instanceAfterChange;
            if (!untypedInstance) {
                throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);
            }
            const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", untypedInstance);
            if (!typedInstance) {
                throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);
            }
            return typedInstance;
        });
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Successful POST request to ${url}`);
        return Promise.resolve(changedInstances);
    }
    // @todo Use lower level utilities instead of the node based Request API.
    // @todo Deseriaize stream directly to the type, instead of creating an intermediate JSON object.
    /**
     * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param typedConstructor Constructor function for the type
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async getInstances(typedConstructor, token, relativeUrlPath, queryOptions) {
        const url = await this.getUrl() + relativeUrlPath;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Sending GET request to ${url}`);
        const options = {
            method: "GET",
            headers: { authorization: token.toTokenString() },
            qs: queryOptions,
            accept: "application/json",
        };
        await this.setupOptionDefaults(options);
        const res = await Request_1.request(url, options);
        if (!res.body || !res.body.hasOwnProperty("instances")) {
            return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));
        }
        // console.log(JSON.stringify(res.body.instances));
        const typedInstances = new Array();
        for (const ecJsonInstance of res.body.instances) {
            const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
            if (typedInstance) {
                typedInstances.push(typedInstance);
            }
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Successful GET request to ${url}`);
        return Promise.resolve(typedInstances);
    }
    getQueryRequestBody(queryOptions) {
        const addPart = (query, key, value) => {
            if (query !== "")
                query += "&";
            query += `${key}=${value}`;
            return query;
        };
        let result = "";
        if (queryOptions.$filter) {
            result = addPart(result, "$filter", queryOptions.$filter);
        }
        if (queryOptions.$orderby) {
            result = addPart(result, "$orderby", queryOptions.$orderby);
        }
        if (queryOptions.$select) {
            result = addPart(result, "$select", queryOptions.$select);
        }
        if (queryOptions.$skip) {
            result = addPart(result, "$skip", queryOptions.$skip.toString(10));
        }
        if (queryOptions.$top) {
            result = addPart(result, "$top", queryOptions.$top.toString(10));
        }
        return result;
    }
    /**
     * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param typedConstructor Constructor function for the type
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async postQuery(typedConstructor, token, relativeUrlPath, queryOptions) {
        const url = `${await this.getUrl()}${relativeUrlPath}$query`;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Sending GET request to ${url}`);
        const options = {
            method: "POST",
            headers: { authorization: token.toTokenString() },
            body: this.getQueryRequestBody(queryOptions),
        };
        await this.setupOptionDefaults(options);
        const res = await Request_1.request(url, options);
        if (!res.body || !res.body.hasOwnProperty("instances")) {
            return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));
        }
        // console.log(JSON.stringify(res.body.instances));
        const typedInstances = new Array();
        for (const ecJsonInstance of res.body.instances) {
            const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
            if (typedInstance) {
                typedInstances.push(typedInstance);
            }
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Successful GET request to ${url}`);
        return Promise.resolve(typedInstances);
    }
}
exports.WsgClient = WsgClient;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcOperation_1 = __webpack_require__(71);
const RpcControl_1 = __webpack_require__(59);
const IModelError_1 = __webpack_require__(16);
const bentleyjs_core_1 = __webpack_require__(0);
// tslint:disable:ban-types
/** @hidden @internal */
exports.REGISTRY = Symbol.for("@bentley/imodeljs-common/RpcRegistry");
/** @hidden @internal */
exports.OPERATION = Symbol.for("@bentley/imodeljs-common/RpcOperation");
/** @hidden @internal */
exports.POLICY = Symbol.for("@bentley/imodeljs-common/RpcOperationPolicy");
/** @hidden @internal */
exports.INSTANCE = Symbol.for("@bentley/imodeljs-common/RpcInterface/__instance__");
/** @hidden @internal */
exports.CURRENT_REQUEST = Symbol.for("@bentley/imodeljs-common/RpcRequest/__current__");
/** @hidden @internal */
exports.CURRENT_INVOCATION = Symbol.for("@bentley/imodeljs-common/RpcInvocation/__current__");
/** @hidden @internal */
class RpcRegistry {
    constructor() {
        this.definitionClasses = new Map();
        this.proxies = new Map();
        this.implementations = new Map();
        this.suppliedImplementations = new Map();
        this.implementationClasses = new Map();
        this.types = new Map();
        this.id = (() => {
            let i = 0;
            return () => ++i;
        })();
    }
    static get instance() {
        if (!RpcRegistry._instance) {
            const globalObj = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
            if (!globalObj[exports.REGISTRY])
                globalObj[exports.REGISTRY] = new RpcRegistry();
            RpcRegistry._instance = globalObj[exports.REGISTRY];
        }
        return RpcRegistry._instance;
    }
    lookupInterfaceDefinition(name) {
        if (!this.definitionClasses.has(name))
            throw new IModelError_1.IModelError(32768 /* ERROR */, `RPC interface "${name}" is not initialized.`);
        return this.definitionClasses.get(name);
    }
    describeAvailableEndpoints() {
        const requests = [];
        for (const channel of RpcControl_1.RpcControlChannel.channels) {
            requests.push(channel.describeEndpoints());
        }
        return Promise.all(requests).then((responses) => {
            const endpoints = responses.reduce((a, b) => a.concat(b), []);
            for (const endpoint of endpoints) {
                const definition = this.definitionClasses.get(endpoint.interfaceName);
                endpoint.compatible = (definition && definition.version === endpoint.interfaceVersion) ? true : false;
            }
            return endpoints;
        });
    }
    getClientForInterface(definition) {
        let instance = this.proxies.get(definition.name);
        if (!instance)
            instance = this.instantiateClient(definition);
        return instance;
    }
    getImplForInterface(definition) {
        let instance = this.implementations.get(definition.name);
        if (!instance)
            instance = this.instantiateImpl(definition);
        return instance;
    }
    lookupImpl(interfaceName) {
        const definition = this.lookupInterfaceDefinition(interfaceName);
        return this.getImplForInterface(definition);
    }
    registerImpl(definition, implementation) {
        this.unregisterImpl(definition);
        this.implementationClasses.set(definition.name, implementation);
    }
    unregisterImpl(definition) {
        this.implementationClasses.delete(definition.name);
        const impl = this.implementations.get(definition.name);
        if (impl) {
            impl.configuration.onRpcImplTerminated(definition, impl);
            this.implementations.delete(definition.name);
        }
    }
    supplyImplInstance(definition, instance) {
        this.suppliedImplementations.set(definition.name, instance);
    }
    isRpcInterfaceInitialized(definition) {
        return this.definitionClasses.has(definition.name);
    }
    initializeRpcInterface(definition) {
        if (this.definitionClasses.has(definition.name))
            return;
        this.definitionClasses.set(definition.name, definition);
        this.configureOperations(definition);
        this.registerTypes(definition);
    }
    terminateRpcInterface(definition) {
        this.purgeTypes(definition);
        this.unregisterImpl(definition);
        this.purgeClient(definition);
        this.definitionClasses.delete(definition.name);
    }
    instantiateImpl(definition) {
        this.checkInitialized(definition);
        const registeredImplementation = this.implementationClasses.get(definition.name);
        if (!registeredImplementation)
            throw new IModelError_1.IModelError(32768 /* ERROR */, `An RPC interface implementation class for "${definition.name}" is not registered.`);
        if (definition.prototype.configurationSupplier)
            registeredImplementation.prototype.configurationSupplier = definition.prototype.configurationSupplier;
        const implementation = this.suppliedImplementations.get(definition.name) || new registeredImplementation();
        if (!(implementation instanceof registeredImplementation))
            throw new IModelError_1.IModelError(32768 /* ERROR */, `Invalid RPC interface implementation.`);
        this.implementations.set(definition.name, implementation);
        implementation.configuration.onRpcImplInitialized(definition, implementation);
        return implementation;
    }
    instantiateClient(definition) {
        this.checkInitialized(definition);
        const proxy = new definition();
        this.proxies.set(definition.name, proxy);
        Object.getOwnPropertyNames(definition.prototype).forEach((operationName) => {
            if (operationName === "constructor")
                return;
            proxy[operationName] = proxy[operationName].bind(proxy, operationName);
        });
        proxy.configuration.onRpcClientInitialized(definition, proxy);
        return proxy;
    }
    checkInitialized(definition) {
        if (!this.definitionClasses.has(definition.name))
            throw new IModelError_1.IModelError(32768 /* ERROR */, `RPC interface "${definition.name}" is not initialized.`);
    }
    configureOperations(definition) {
        Object.getOwnPropertyNames(definition.prototype).forEach((operationName) => {
            if (operationName === "constructor")
                return;
            const proto = definition.prototype;
            if (!proto[operationName][exports.OPERATION]) {
                const policy = definition[exports.POLICY] || new RpcOperation_1.RpcOperationPolicy();
                proto[operationName][exports.OPERATION] = new RpcOperation_1.RpcOperation(definition, operationName, policy);
            }
        });
    }
    registerTypes(definition) {
        definition.types().forEach((type) => {
            this.registerType(definition, type, true);
        });
        for (const type of [Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, bentleyjs_core_1.BentleyError, IModelError_1.IModelError, IModelError_1.ServerError]) {
            this.registerType(definition, type, false);
        }
    }
    registerType(definition, type, throwIfRegistered) {
        const name = `${definition.name}_${type.name}`;
        if (this.types.has(name)) {
            if (throwIfRegistered)
                throw new IModelError_1.IModelError(32768 /* ERROR */, `Class "${name}" is already registered for RPC interface type marshaling.`);
            else
                return;
        }
        this.types.set(name, type);
    }
    purgeClient(definition) {
        const proxy = this.proxies.get(definition.name);
        if (proxy) {
            proxy.configuration.onRpcClientTerminated(definition, proxy);
            this.proxies.delete(definition.name);
        }
    }
    purgeTypes(definition) {
        const keyPrefix = `${definition.name}_`;
        for (const key of this.types.keys()) {
            if (key.indexOf(keyPrefix) !== -1) {
                this.types.delete(key);
            }
        }
    }
}
exports.RpcRegistry = RpcRegistry;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module iModels */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const Primitives_1 = __webpack_require__(116);
const IModelError_1 = __webpack_require__(16);
const Cartographic_1 = __webpack_require__(194);
/** A token that identifies a specific instance of an iModel to be operated on */
class IModelToken {
    /** Constructor */
    constructor(
    /** Key used for identifying the iModel on the backend */
    key, 
    /** Context (Project, Asset, or other infrastructure) in which the iModel exists - must be defined if the iModel exists in the Hub or in a non-Connect infrastructure. */
    contextId, 
    /** Guid of the iModel - must be defined if the iModel exists in the Hub */
    iModelId, 
    /** Id of the last ChangeSet that was applied to the iModel - must be defined if the iModel exists in the Hub */
    changeSetId) {
        this.key = key;
        this.contextId = contextId;
        this.iModelId = iModelId;
        this.changeSetId = changeSetId;
    }
}
exports.IModelToken = IModelToken;
/** The position and orientation of an iModel on the earth in [ECEF](https://en.wikipedia.org/wiki/ECEF) (Earth Centered Earth Fixed) coordinates */
class EcefLocation {
    /** Get the transform from iModel Spatial coordinates to ECEF from this EcefLocation */
    getTransform() { return geometry_core_1.Transform.createOriginAndMatrix(this.origin, this.orientation.toRotMatrix()); }
    /** Construct a new EcefLocation. Once constructed, it is frozen and cannot be modified. */
    constructor(props) {
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.orientation = geometry_core_1.YawPitchRollAngles.fromJSON(props.orientation);
        this.origin.freeze(); // may not be modified
        this.orientation.freeze(); // may not be modified
    }
}
exports.EcefLocation = EcefLocation;
/** Represents an iModel in JavaScript. */
class IModel {
    /** @hidden */
    constructor(iModelToken) { this.token = iModelToken; }
    /**
     * The volume, in spatial coordinates, inside which the entire project is contained.
     * @note The object returned from this method is frozen. You *must* make a copy before you do anything that might attempt to modify it.
     */
    get projectExtents() { return this._projectExtents; }
    set projectExtents(extents) {
        this._projectExtents = extents.clone();
        this._projectExtents.ensureMinLengths(1.0); // don't allow any axis of the project extents to be less than 1 meter.
        this._projectExtents.freeze();
    }
    /** An offset to be applied to all spatial coordinates. */
    get globalOrigin() { return this._globalOrigin; }
    /** The [EcefLocation]($docs/learning/glossary#ecefLocation) of the iModel in Earth Centered Earth Fixed coordinates. */
    get ecefLocation() { return this._ecefLocation; }
    /** Set the [EcefLocation]($docs/learning/glossary#ecefLocation) for this iModel. */
    setEcefLocation(ecef) {
        this._ecefLocation = new EcefLocation(ecef);
        this._ecefTrans = undefined;
    }
    /** @hidden */
    toJSON() {
        const out = {};
        out.name = this.name;
        out.rootSubject = this.rootSubject;
        out.projectExtents = this.projectExtents.toJSON();
        out.globalOrigin = this.globalOrigin.toJSON();
        out.ecefLocation = this.ecefLocation;
        out.iModelToken = this.iModelToken;
        return out;
    }
    /** The token that can be used to find this iModel instance. */
    get iModelToken() { return this.token; }
    /** @hidden */
    initialize(name, props) {
        this.name = name;
        this.rootSubject = props.rootSubject;
        this.projectExtents = Primitives_1.AxisAlignedBox3d.fromJSON(props.projectExtents);
        this._globalOrigin = geometry_core_1.Point3d.fromJSON(props.globalOrigin);
        this._globalOrigin.freeze(); // cannot be modified
        if (props.ecefLocation)
            this.setEcefLocation(props.ecefLocation);
    }
    /** Get the default subCategoryId for the supplied categoryId */
    static getDefaultSubCategoryId(categoryId) { return categoryId.isValid() ? new bentleyjs_core_1.Id64([categoryId.getLow() + 1, categoryId.getHigh()]) : new bentleyjs_core_1.Id64(); }
    /** True if this iModel has an [EcefLocation]($docs/learning/glossary#ecefLocation). */
    get isGeoLocated() { return undefined !== this._ecefLocation; }
    /** Get the Transform from this iModel's Spatial coordinates to ECEF coordinates using its [[IModel.ecefLocation]].
     * @throws IModelError if [[isGeoLocated]] is false.
     */
    getEcefTransform() {
        if (undefined === this._ecefLocation)
            throw new IModelError_1.IModelError(65602 /* NoGeoLocation */, "iModel is not GeoLocated");
        if (this._ecefTrans === undefined) {
            this._ecefTrans = this._ecefLocation.getTransform();
            this._ecefTrans.freeze();
        }
        return this._ecefTrans;
    }
    /**
     * Convert a point in this iModel's Spatial coordinates to an ECEF point using its [[IModel.ecefLocation]].
     * @param spatial A point in the iModel's spatial coordinates
     * @param result If defined, use this for output
     * @returns A Point3d in ECEF coordinates
     * @throws IModelError if [[isGeoLocated]] is false.
     */
    spatialToEcef(spatial, result) { return this.getEcefTransform().multiplyPoint3d(spatial, result); }
    /**
     * Convert a point in ECEF coordinates to a point in this iModel's Spatial coordinates using its [[ecefLocation]].
     * @param ecef A point in ECEF coordinates
     * @param result If defined, use this for output
     * @returns A Point3d in this iModel's spatial coordinates
     * @throws IModelError if [[isGeoLocated]] is false.
     * @note The resultant point will only be meaningful if the ECEF coordinate is close on the earth to the iModel.
     */
    ecefToSpatial(ecef, result) { return this.getEcefTransform().multiplyInversePoint3d(ecef, result); }
    /**
     * Convert a point in this iModel's Spatial coordinates to a [[Cartographic]]  using its [[IModel.ecefLocation]].
     * @param spatial A point in the iModel's spatial coordinates
     * @param result If defined, use this for output
     * @returns A Cartographic location
     * @throws IModelError if [[isGeoLocated]] is false.
     */
    spatialToCartographic(spatial, result) { return Cartographic_1.Cartographic.fromEcef(this.spatialToEcef(spatial), result); }
    /**
     * Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using its [[IModel.ecefLocation]].
     * @param cartographic A cartographic location
     * @param result If defined, use this for output
     * @returns A point in this iModel's spatial coordinates
     * @throws IModelError if [[isGeoLocated]] is false.
     * @note The resultant point will only be meaningful if the ECEF coordinate is close on the earth to the iModel.
     */
    cartographicToSpatial(cartographic, result) { return this.ecefToSpatial(cartographic.toEcef(result), result); }
}
/** The Id of the repository model. */
IModel.repositoryModelId = new bentleyjs_core_1.Id64("0x1");
/** The Id of the root subject element. */
IModel.rootSubjectId = new bentleyjs_core_1.Id64("0x1");
/** The Id of the dictionary model. */
IModel.dictionaryId = new bentleyjs_core_1.Id64("0x10");
exports.IModel = IModel;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
function assertComponent(c) { bentleyjs_core_1.assert(1.0 >= c && 0.0 <= c); }
function assertRgb(rgb) {
    assertComponent(rgb.red);
    assertComponent(rgb.green);
    assertComponent(rgb.blue);
}
function assertRgba(rgba) {
    assertComponent(rgba.red);
    assertComponent(rgba.green);
    assertComponent(rgba.blue);
    assertComponent(rgba.alpha);
}
/** An RGB color with components in the range [0, 1]. */
class FloatRgb {
    /** Construct from red, green, and blue components. */
    constructor(red, green, blue) {
        this._value = new Float32Array(3);
        this._value[0] = red;
        this._value[1] = green;
        this._value[2] = blue;
        assertRgb(this);
    }
    /** Create a FloatRgb using a ColorDef. */
    static fromColorDef(def) {
        const c = def.colors;
        return new FloatRgb(c.r / 255.0, c.g / 255.0, c.b / 255.0);
    }
    get red() { return this._value[0]; }
    get green() { return this._value[1]; }
    get blue() { return this._value[2]; }
    bind(uniform) { uniform.setUniform3fv(this._value); }
}
exports.FloatRgb = FloatRgb;
class Rgba {
    constructor(r, g, b, a) {
        this._value = new Float32Array(4);
        this._value[0] = r;
        this._value[1] = g;
        this._value[2] = b;
        this._value[3] = a;
        assertRgba(this);
    }
    get red() { return this._value[0]; }
    get green() { return this._value[1]; }
    get blue() { return this._value[2]; }
    get alpha() { return this._value[3]; }
    get hasTranslucency() { return 1.0 !== this.alpha; }
    equals(rhs) {
        return this.red === rhs.red && this.green === rhs.green && this.blue === rhs.blue && this.alpha === rhs.alpha;
    }
    bind(uniform) { uniform.setUniform4fv(this._value); }
}
exports.Rgba = Rgba;
/** An RGBA color with components in the range [0, 1]. */
class FloatRgba extends Rgba {
    /** Construct a FloatRgba from red, green, blue, and alpha components */
    constructor(red, green, blue, alpha) {
        super(red, green, blue, alpha);
    }
    /** Produce a FloatRgba from a FloatPreMulRgba by reversing the pre-multiplication */
    static fromPreMulRgba(src) {
        const f = 0.0 !== src.alpha ? 1.0 / src.alpha : 0.0;
        return new FloatRgba(src.red * f, src.green * f, src.blue * f, src.alpha);
    }
    /** Create a FloatRgba using a FloatRgb.
     * @param rgb A FloatRgb used to set the red, green, and blue variables in the new FloatRgba.
     * @param alpha A Number used to set the alpha variable in the new FloatRgba.
     * @returns Returns the newly created FloatRgba
     */
    static fromRgb(rgb, alpha = 1.0) {
        return new FloatRgba(rgb.red, rgb.green, rgb.blue, alpha);
    }
    /** Create a FloatRgba using a ColorDef.
     * @param def A ColorDef used to create a new FloatRgba.
     * @param transparency Optionally overrides the transparency value (0-255) specified by the ColorDef.
     * @returns Returns the newly created FloatRgba
     */
    static fromColorDef(def, transparency) {
        const c = def.colors;
        if (undefined !== transparency) {
            c.t = transparency;
        }
        return new FloatRgba(c.r / 255.0, c.g / 255.0, c.b / 255.0, (255.0 - c.t) / 255.0);
    }
    /** Create a FloatRgba using a ColorDef and an alpha value..
     * @param def A ColorDef used to create a new FloatRgba. Its transparency value is ignored.
     * @param alpha Alpha value from 0.0 (transparent) to 1.0 (opaque)
     * @returns Returns the newly created FloatRgba
     */
    static fromColorDefAndAlpha(def, alpha) {
        const c = def.colors;
        return new FloatRgba(c.r / 255.0, c.g / 255.0, c.b / 255.0, alpha);
    }
}
exports.FloatRgba = FloatRgba;
/** An RGBA color with  with components in the range [0, 1], wherein the red, green, and blue components are pre-multiplied by the alpha component. */
class FloatPreMulRgba extends Rgba {
    /** Create a FloatPreMulRgba using a ColorDef.
     * @param src A FloatRgba used to create a new FloatPreMulRgba.
     * @returns Returns the newly created FloatPreMulRgba
     */
    static fromRgba(src) {
        return new FloatPreMulRgba(src.red * src.alpha, src.green * src.alpha, src.blue * src.alpha, src.alpha);
    }
    /** Create a FloatPreMulRgba using a ColorDef.
     * @param src A ColorDef used to create a new FloatPreMulRgba.
     * @returns Returns the newly created FloatPreMulRgba
     */
    static fromColorDef(src) {
        const c = src.colors;
        const a = (255.0 - c.t) / 255.0;
        return new FloatPreMulRgba(c.r * a / 255.0, c.g * a / 255.0, c.b * a / 255.0, a);
    }
    constructor(r, g, b, a) {
        super(r, g, b, a);
    }
}
exports.FloatPreMulRgba = FloatPreMulRgba;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
/**
 * A handle to a WebGLBuffer, such as a vertex or index buffer.
 * The WebGLBuffer is allocated by the constructor and should be freed by a call to dispose().
 */
class BufferHandle {
    /** Allocates the WebGLBuffer using the supplied context. Free the WebGLBuffer using dispose() */
    constructor() {
        const glBuffer = System_1.System.instance.context.createBuffer();
        // gl.createBuffer() returns WebGLBuffer | null...
        if (null !== glBuffer) {
            this._glBuffer = glBuffer;
        }
        else {
            this._glBuffer = undefined;
        }
        bentleyjs_core_1.assert(!this.isDisposed);
    }
    get isDisposed() { return this._glBuffer === undefined; }
    /** Frees the WebGL buffer */
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteBuffer(this._glBuffer);
            this._glBuffer = undefined;
        }
    }
    /** Binds this buffer to the specified target */
    bind(target) {
        if (undefined !== this._glBuffer) {
            System_1.System.instance.context.bindBuffer(target, this._glBuffer);
        }
    }
    /** Sets the specified target to be bound to no buffer */
    static unbind(target) { System_1.System.instance.context.bindBuffer(target, null); }
    /** Binds this buffer to the specified target and sets the buffer's data store. */
    bindData(target, data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        this.bind(target);
        System_1.System.instance.context.bufferData(target, data, usage);
        BufferHandle.unbind(target);
    }
    /** Creates a BufferHandle and binds its data */
    static createBuffer(target, data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        const handle = new BufferHandle();
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(target, data, usage);
        return handle;
    }
    /** Creates a BufferHandle and binds its data */
    static createArrayBuffer(data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        return BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ArrayBuffer, data, usage);
    }
    isBound(binding) { return System_1.System.instance.context.getParameter(binding) === this._glBuffer; }
}
exports.BufferHandle = BufferHandle;
function setScale(index, value, array) {
    array[index] = 0.0 !== value ? 1.0 / value : value;
}
/**
 * Converts 2d quantization parameters to a format appropriate for submittal to the GPU.
 * params[0] = origin.x
 * params[1] = origin.y
 * params[2] = scale.x
 * params[3] = scale.y
 */
function qparams2dToArray(params) {
    const arr = new Float32Array(4);
    arr[0] = params.origin.x;
    arr[1] = params.origin.y;
    setScale(2, params.scale.x, arr);
    setScale(3, params.scale.y, arr);
    return arr;
}
exports.qparams2dToArray = qparams2dToArray;
function qorigin3dToArray(qorigin) {
    const origin = new Float32Array(3);
    origin[0] = qorigin.x;
    origin[1] = qorigin.y;
    origin[2] = qorigin.z;
    return origin;
}
exports.qorigin3dToArray = qorigin3dToArray;
function qscale3dToArray(qscale) {
    const scale = new Float32Array(3);
    setScale(0, qscale.x, scale);
    setScale(1, qscale.y, scale);
    setScale(2, qscale.z, scale);
    return scale;
}
exports.qscale3dToArray = qscale3dToArray;
/** Converts 3d quantization params to a pair of Float32Arrays */
function qparams3dToArray(params) {
    const origin = qorigin3dToArray(params.origin);
    const scale = qscale3dToArray(params.scale);
    return { origin, scale };
}
exports.qparams3dToArray = qparams3dToArray;
/** A handle to a WebGLBuffer intended to hold quantized 2d points */
class QBufferHandle2d extends BufferHandle {
    constructor(params) {
        super();
        this.params = qparams2dToArray(params);
    }
    static create(params, data) {
        const handle = new QBufferHandle2d(params);
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(GL_1.GL.Buffer.Target.ArrayBuffer, data);
        return handle;
    }
}
exports.QBufferHandle2d = QBufferHandle2d;
/* A handle to a WebGLBuffer intended to hold quantized 3d points */
class QBufferHandle3d extends BufferHandle {
    constructor(params) {
        super();
        this.origin = qorigin3dToArray(params.origin);
        this.scale = qscale3dToArray(params.scale);
    }
    static create(params, data) {
        const handle = new QBufferHandle3d(params);
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(GL_1.GL.Buffer.Target.ArrayBuffer, data);
        return handle;
    }
}
exports.QBufferHandle3d = QBufferHandle3d;
/** A handle to the location of an attribute within a shader program */
class AttributeHandle {
    constructor(glId) { this._glId = glId; }
    static create(program, name, required = false) {
        const glId = System_1.System.instance.context.getAttribLocation(program, name);
        if (-1 === glId) {
            bentleyjs_core_1.assert(!required, "getAttribLocation failed for " + name);
            return undefined;
        }
        return new AttributeHandle(glId);
    }
    setVertexAttribPointer(size, type, normalized, stride, offset) {
        System_1.System.instance.context.vertexAttribPointer(this._glId, size, type, normalized, stride, offset);
    }
    enableVertexAttribArray() { System_1.System.instance.context.enableVertexAttribArray(this._glId); }
    disableVertexAttribArray() { System_1.System.instance.context.disableVertexAttribArray(this._glId); }
    enableArray(buffer, size, type, normalized, stride, offset) {
        buffer.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        this.setVertexAttribPointer(size, type, normalized, stride, offset);
        this.enableVertexAttribArray();
        BufferHandle.unbind(GL_1.GL.Buffer.Target.ArrayBuffer);
    }
}
exports.AttributeHandle = AttributeHandle;
/** A handle to the location of a uniform within a shader program */
class UniformHandle {
    constructor(location) { this._location = location; }
    static create(program, name, required = true) {
        const location = System_1.System.instance.context.getUniformLocation(program, name);
        if (null === location) {
            bentleyjs_core_1.assert(!required, "getUniformLocation failed for " + name);
            return undefined;
        }
        return new UniformHandle(location);
    }
    setUniformMatrix4fv(transpose, data) { System_1.System.instance.context.uniformMatrix4fv(this._location, transpose, data); }
    setUniformMatrix3fv(transpose, data) { System_1.System.instance.context.uniformMatrix3fv(this._location, transpose, data); }
    setMatrix3(mat) { this.setUniformMatrix3fv(false, mat.data); }
    setMatrix4(mat) { this.setUniformMatrix4fv(false, mat.data); }
    setUniform1fv(data) { System_1.System.instance.context.uniform1fv(this._location, data); }
    setUniform2fv(data) { System_1.System.instance.context.uniform2fv(this._location, data); }
    setUniform3fv(data) { System_1.System.instance.context.uniform3fv(this._location, data); }
    setUniform4fv(data) { System_1.System.instance.context.uniform4fv(this._location, data); }
    setUniform1i(data) { System_1.System.instance.context.uniform1i(this._location, data); }
    setUniform1f(data) { System_1.System.instance.context.uniform1f(this._location, data); }
}
exports.UniformHandle = UniformHandle;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module ArraysAndInterfaces */
Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const IndexedXYZCollection_1 = __webpack_require__(133);
class GrowableFloat64Array {
    constructor(initialCapacity = 8) {
        this.data = new Float64Array(initialCapacity);
        this.inUse = 0;
    }
    static compare(a, b) {
        return a - b;
    }
    get length() {
        return this.inUse;
    }
    /**
     * Set the value at specified index.
     * @param index index of entry to set
     * @param value value to set
     */
    setAt(index, value) {
        this.data[index] = value;
    }
    /**
     * Move the value at index i to index j.
     * @param i source index
     * @param j destination index.
     */
    move(i, j) {
        this.data[j] = this.data[i];
    }
    push(toPush) {
        if (this.inUse + 1 < this.data.length) {
            this.data[this.inUse] = toPush;
            this.inUse++;
        }
        else {
            // Make new array (double size), copy values, then push toPush
            const newData = new Float64Array(this.inUse * 2);
            for (let i = 0; i < this.inUse; i++) {
                newData[i] = this.data[i];
            }
            this.data = newData;
            this.data[this.inUse] = toPush;
            this.inUse++;
        }
    }
    /** Push a `numToCopy` consecutive values starting at `copyFromIndex` to the end of the array. */
    pushBlockCopy(copyFromIndex, numToCopy) {
        const newLength = this.inUse + numToCopy;
        this.ensureCapacity(newLength);
        const limit = copyFromIndex + numToCopy;
        for (let i = copyFromIndex; i < limit; i++)
            this.data[this.inUse++] = this.data[i];
    }
    /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */
    clear() {
        while (this.inUse > 0)
            this.pop();
    }
    capacity() {
        return this.data.length;
    }
    ensureCapacity(newCapacity) {
        if (newCapacity > this.capacity()) {
            const oldInUse = this.inUse;
            const newData = new Float64Array(newCapacity);
            for (let i = 0; i < oldInUse; i++)
                newData[i] = this.data[i];
            this.data = newData;
        }
    }
    /**
     * * If newLength is less than current (active) length, just set (active) length.
     * * If newLength is greater, ensureCapacity (newSize) and pad with padValue up to newSize;
     * @param newLength new data count
     * @param padValue value to use for padding if the length increases.
     */
    resize(newLength, padValue = 0) {
        // quick out for easy case ...
        if (newLength <= this.inUse) {
            this.inUse = newLength;
            return;
        }
        const oldLength = this.inUse;
        this.ensureCapacity(newLength);
        for (let i = oldLength; i < newLength; i++)
            this.data[i] = padValue;
        this.inUse = newLength;
    }
    pop() {
        // Could technically access outside of array, if filled and then reduced using pop (similar to C
        // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten
        if (this.inUse > 0) {
            this.inUse--;
        }
    }
    at(index) {
        return this.data[index];
    }
    front() {
        return this.data[0];
    }
    back() {
        return this.data[this.inUse - 1];
    }
    reassign(index, value) {
        this.data[index] = value;
    }
    /**
     * * Sort the array entries.
     * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays
     * @param compareMethod comparison method
     */
    sort(compareMethod = GrowableFloat64Array.compare) {
        for (let i = 0; i < this.inUse; i++) {
            for (let j = i + 1; j < this.inUse; j++) {
                const tempI = this.data[i];
                const tempJ = this.data[j];
                if (compareMethod(tempI, tempJ) > 0) {
                    this.data[i] = tempJ;
                    this.data[j] = tempI;
                }
            }
        }
    }
    /**
     * * compress out values not within the [a,b] interval.
     * * Note that if a is greater than b all values are rejected.
     * @param a low value for accepted interval
     * @param b high value for accepted interval
     */
    restrictToInterval(a, b) {
        const data = this.data;
        const n = data.length;
        let numAccept = 0;
        let q = 0;
        for (let i = 0; i < n; i++) {
            q = data[i];
            if (q >= a && q <= b)
                data[numAccept++] = q;
        }
        this.inUse = numAccept;
    }
    /**
     * * For each index `i0 <= i < i1` overwrite `data[i+1]` by `f0*data[i]+f1*data[i+1]
     * * This is the essential step of a bezier polynomial subdivision step
     * @param i0 first index to update
     * @param i1 one beyond last index to update.
     * @param f0 left scale
     * @param f1 right scale
     */
    overwriteWithScaledCombinations(i0, i1, f0, f1) {
        // work right to left for simplest overwrite
        for (let i = i1; i > i0; i--) {
            this.data[i] = f0 * this.data[i - 1] + f1 * this.data[i];
        }
    }
    /**
     * @returns Return the weighted sum `data[i0+i]*weights[i]`.
     * @param i0 first index of data
     * @param weights array of weights.
     * @note The length of the weight array is the number of summed terms.
     */
    weightedSum(i0, weights) {
        let i = i0;
        let sum = 0.0;
        const data = this.data;
        for (const w of weights)
            sum += w * data[i++];
        return sum;
    }
    /**
     * @returns Return the weighted sum `(data[i0+i] - data[i])*weights[i]`.
     * @param i0 first index of data
     * @param weights array of weights.
     * @note The length of the weight array is the number of summed terms.
     */
    weightedDifferenceSum(i0, weights) {
        let i = i0;
        let sum = 0.0;
        const data = this.data;
        for (const w of weights) {
            sum += w * (data[i + 1] - data[i]);
            i++;
        }
        return sum;
    }
}
exports.GrowableFloat64Array = GrowableFloat64Array;
/**
 * Array of contiguous doubles, indexed by block number and index within block.
 * * This is essentially a rectangular matrix, with each block being a row of the matrix.
 */
class GrowableBlockedArray {
    constructor(blockSize, initialBlocks = 8) {
        this.data = new Float64Array(initialBlocks * blockSize);
        this.inUse = 0;
        this.blockSize = blockSize;
    }
    /** computed property: length (in blocks, not doubles) */
    get numBlocks() { return this.inUse; }
    /** property: number of data values per block */
    get numPerBlock() { return this.blockSize; }
    /**
     * Return a single value indexed within a blcok
     * @param blockIndex index of block to read
     * @param indexInBlock  offset within the block
     */
    getWithinBlock(blockIndex, indexWithinBlock) {
        return this.data[blockIndex * this.blockSize + indexWithinBlock];
    }
    /** clear the block count to zero, but maintain the allocated memory */
    clear() { this.inUse = 0; }
    /** Return the capacity in blocks (not doubles) */
    blockCapacity() {
        return this.data.length / this.blockSize;
    }
    /** ensure capacity (in blocks, not doubles) */
    ensureBlockCapacity(blockCapacity) {
        if (blockCapacity > this.blockCapacity()) {
            const newData = new Float64Array(blockCapacity * this.blockSize);
            for (let i = 0; i < this.data.length; i++) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
    }
    /**
     * Return the starting index of a block of (zero-initialized) doubles at the end.
     *
     * * this.data is reallocated if needed to include the new block.
     * * The inUse count is incremented to include the new block.
     * * The returned block is an index to the Float64Array (not a block index)
     */
    newBlockIndex() {
        const index = this.blockSize * this.inUse;
        if (this.blockSize * (index + 1) > this.data.length)
            this.ensureBlockCapacity(2 * this.inUse);
        this.inUse++;
        for (let i = index; i < index + this.blockSize; i++)
            this.data[i] = 0.0;
        return index;
    }
    /** reduce the block count by one. */
    popBlock() {
        if (this.inUse > 0)
            this.inUse--;
    }
    /** convert a block index to the simple index to the underlying Float64Array. */
    blockIndexToDoubleIndex(blockIndex) { return this.blockSize * blockIndex; }
    /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */
    checkedComponent(blockIndex, componentIndex) {
        if (blockIndex >= this.inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this.blockSize)
            return undefined;
        return this.data[this.blockSize * blockIndex + componentIndex];
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(blockIndex, componentIndex) {
        return this.data[this.blockSize * blockIndex + componentIndex];
    }
    /** compre two blocks in simple lexical order.
     * @param data data array
     * @param blockSize number of items to compare
     * @param ia raw index (not block index) of first block
     * @param ib raw index (not block index) of second block
     */
    static compareLexicalBlock(data, blockSize, ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < blockSize; i++) {
            ax = data[ia + i];
            bx = data[ib + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical(compareBlocks = GrowableBlockedArray.compareLexicalBlock) {
        const n = this.inUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        const data = this.data;
        const blockSize = this.blockSize;
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);
        });
        // console.log (n, numCompare);
        return result;
    }
    distanceBetweenBlocks(blockIndexA, blockIndexB) {
        let dd = 0.0;
        let iA = this.blockIndexToDoubleIndex(blockIndexA);
        let iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this.data;
        for (let i = 0; i < this.blockSize; i++) {
            a = data[iA++] - data[iB++];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
    distanceBetweenSubBlocks(blockIndexA, blockIndexB, iBegin, iEnd) {
        let dd = 0.0;
        const iA = this.blockIndexToDoubleIndex(blockIndexA);
        const iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this.data;
        for (let i = iBegin; i < iEnd; i++) {
            a = data[iA + i] - data[iB + i];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
}
exports.GrowableBlockedArray = GrowableBlockedArray;
/** Use a Float64Array to pack xyz coordinates. */
class GrowableXYZArray extends IndexedXYZCollection_1.IndexedXYZCollection {
    /** Construct a new GrowablePoint3d array.
     * @param numPoints [in] initial capacity.
     */
    constructor(numPoints = 8) {
        super();
        this.data = new Float64Array(numPoints * 3); // 8 Points to start (3 values each)
        this.inUse = 0;
        this.capacity = numPoints;
    }
    /** @returns Return the number of points in use. */
    get length() { return this.inUse; }
    /** @returns Return the number of float64 in use. */
    get float64Length() { return this.inUse * 3; }
    /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchnaged. */
    ensureCapacity(pointCapacity) {
        if (pointCapacity > this.capacity) {
            const newData = new Float64Array(pointCapacity * 3);
            const numCopy = this.length * 3;
            for (let i = 0; i < numCopy; i++)
                newData[i] = this.data[i];
            this.data = newData;
            this.capacity = pointCapacity;
        }
    }
    /** Resize the actual point count, preserving excess capacity. */
    resize(pointCount) {
        if (pointCount < this.length) {
            this.inUse = pointCount >= 0 ? pointCount : 0;
        }
        else if (pointCount > this.capacity) {
            const newArray = new Float64Array(pointCount * 3);
            // Copy contents
            for (let i = 0; i < this.data.length; i += 3) {
                newArray[i] = this.data[i];
                newArray[i + 1] = this.data[i + 1];
                newArray[i + 2] = this.data[i + 2];
            }
            this.data = newArray;
            this.capacity = pointCount;
        }
    }
    /**
     * Make a copy of the (active) points in this array.
     * (The clone does NOT get excess capacity)
     */
    clone() {
        const newPoints = new GrowableXYZArray(this.length);
        const numValue = this.length * 3;
        const newData = newPoints.data;
        const data = this.data;
        for (let i = 0; i < numValue; i++)
            newData[i] = data[i];
        newPoints.inUse = this.length;
        return newPoints;
    }
    static create(data) {
        const newPoints = new GrowableXYZArray(data.length);
        for (const p of data)
            newPoints.push(p);
        return newPoints;
    }
    /** push a point to the end of the array */
    push(toPush) {
        this.pushXYZ(toPush.x, toPush.y, toPush.z);
    }
    /** push all points of an array */
    pushAll(points) {
        for (const p of points)
            this.push(p);
    }
    /**
     * Replicate numWrap xyz values from the front of the array as new values at the end.
     * @param numWrap number of xyz values to replicate
     */
    pushWrap(numWrap) {
        if (this.inUse > 0) {
            let k;
            for (let i = 0; i < numWrap; i++) {
                k = 3 * i;
                this.pushXYZ(this.data[k], this.data[k + 1], this.data[k + 2]);
            }
        }
    }
    pushXYZ(x, y, z) {
        const index = this.inUse * 3;
        if (index >= this.data.length)
            this.ensureCapacity(this.length * 2);
        this.data[index] = x;
        this.data[index + 1] = y;
        this.data[index + 2] = z;
        this.inUse++;
    }
    /** Remove one point from the back. */
    pop() {
        if (this.inUse > 0)
            this.inUse--;
    }
    /**
     * Test if index is valid for an xyz (point or vector) withibn this array
     * @param index xyz index to test.
     */
    isIndexValid(index) {
        if (index >= this.inUse || index < 0)
            return false;
        return true;
    }
    /**
     * Clear all xyz data, but leave capacity unchanged.
     */
    clear() {
        this.inUse = 0;
    }
    /**
     * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use atPoint3dIndex to have validity test.
     * @param pointIndex index to access
     * @param result optional result
     */
    getPoint3dAt(pointIndex, result) {
        const index = 3 * pointIndex;
        return PointVector_1.Point3d.create(this.data[index], this.data[index + 1], this.data[index + 2], result);
    }
    /** copy xyz into strongly typed Point3d */
    atPoint3dIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        if (pointIndex >= 0 && pointIndex < this.inUse) {
            if (!result)
                result = PointVector_1.Point3d.create();
            result.x = this.data[index];
            result.y = this.data[index + 1];
            result.z = this.data[index + 2];
            return result;
        }
        return undefined;
    }
    /** copy xyz into strongly typed Point3d */
    atVector3dIndex(vectorIndex, result) {
        const index = 3 * vectorIndex;
        if (vectorIndex >= 0 && vectorIndex < this.inUse) {
            if (!result)
                result = PointVector_1.Vector3d.create();
            result.x = this.data[index];
            result.y = this.data[index + 1];
            result.z = this.data[index + 2];
            return result;
        }
        return undefined;
    }
    /**
     * Read coordinates from source array, place them at indexe within this array.
     * @param destIndex point index where coordinats are to be placed in this array
     * @param source source array
     * @param sourceIndex point index in source array
     * @returns true if destIndex and sourceIndex are both valid.
     */
    transferFromGrowableXYZArray(destIndex, source, sourceIndex) {
        if (destIndex < this.length && sourceIndex < source.length) {
            const i = destIndex * 3;
            const j = sourceIndex * 3;
            this.data[i] = source.data[j];
            this.data[i + 1] = source.data[j + 1];
            this.data[i + 2] = source.data[j + 2];
            return true;
        }
        return false;
    }
    /**
     * push coordinates from the source array to the end of this array.
     * @param source source array
     * @param sourceIndex xyz index within the source
     * @returns true if sourceIndex is valid.
     */
    pushFromGrowableXYZArray(source, sourceIndex) {
        if (sourceIndex < source.length) {
            const j = sourceIndex * 3;
            this.pushXYZ(source.data[j], source.data[j + 1], source.data[j + 2]);
            return true;
        }
        return false;
    }
    /**
     * @returns Return the first point, or undefined if the array is empty.
     */
    front(result) {
        if (this.inUse === 0)
            return undefined;
        return this.getPoint3dAt(0, result);
    }
    /**
     * @returns Return the last point, or undefined if the array is empty.
     */
    back(result) {
        if (this.inUse - 1 < 0)
            return undefined;
        return this.getPoint3dAt(this.inUse - 1, result);
    }
    /**
     * Set the coordinates of a single point.
     * @param pointIndex index of point to set
     * @param value coordinates to set
     */
    setAt(pointIndex, value) {
        if (pointIndex < 0 || pointIndex >= this.inUse)
            return false;
        let index = pointIndex * 3;
        this.data[index++] = value.x;
        this.data[index++] = value.y;
        this.data[index] = value.z;
        return true;
    }
    /**
     * Set the coordinates of a single point given as coordintes
     * @param pointIndex index of point to set
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     */
    setCoordinates(pointIndex, x, y, z) {
        if (pointIndex < 0 || pointIndex >= this.inUse)
            return false;
        let index = pointIndex * 3;
        this.data[index++] = x;
        this.data[index++] = y;
        this.data[index] = z;
        return true;
    }
    /**
     * @returns Copy all points into a simple array of Point3d
     */
    getPoint3dArray() {
        const result = [];
        const data = this.data;
        const n = this.length;
        for (let i = 0; i < n; i++) {
            result.push(PointVector_1.Point3d.create(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]));
        }
        return result;
    }
    /** multiply each point by the transform, replace values. */
    transformInPlace(transform) {
        const data = this.data;
        const nDouble = this.float64Length;
        const coffs = transform.matrix.coffs;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 3 <= nDouble; i += 3) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;
        }
    }
    /** multiply each point by the transform, replace values. */
    tryTransformInverseInPlace(transform) {
        const data = this.data;
        const nDouble = this.float64Length;
        const matrix = transform.matrix;
        matrix.computeCachedInverse(true);
        const coffs = matrix.inverseCoffs;
        if (!coffs)
            return false;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 3 <= nDouble; i += 3) {
            x = data[i] - x0;
            y = data[i + 1] - y0;
            z = data[i + 2] - z0;
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;
        }
        return true;
    }
    extendRange(rangeToExtend, transform) {
        const numDouble = this.float64Length;
        const data = this.data;
        if (transform) {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);
        }
        else {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);
        }
    }
    sumLengths() {
        let sum = 0.0;
        const n = 3 * (this.inUse - 1); // Length already takes into account what specifically is in use
        const data = this.data;
        for (let i = 0; i < n; i += 3)
            sum += Geometry_1.Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
        return sum;
    }
    isCloseToPlane(plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const numCoordinate = 3 * this.inUse;
        const data = this.data;
        for (let i = 0; i < numCoordinate; i += 3)
            if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                return false;
        return true;
    }
    /** Compute a point at fractional coordinate between points i and j */
    interpolate(i, fraction, j, result) {
        if (i >= 0 && i < this.inUse) {
            const fraction0 = 1.0 - fraction;
            const data = this.data;
            i = 3 * i;
            j = 3 * j;
            return PointVector_1.Point3d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2], result);
        }
        return undefined;
    }
    /** Sum the signed areas of the projection to xy plane */
    areaXY() {
        let area = 0.0;
        const n = this.data.length - 6; // at least two points needed !!!!
        if (n > 2) {
            const x0 = this.data[0];
            const y0 = this.data[1];
            let dx1 = this.data[3] - x0;
            let dy1 = this.data[4] - y0;
            let dx2 = 0;
            let dy2 = 0;
            for (let i = 6; i < n; i += 3, dx1 = dx2, dy1 = dy2) {
                dx2 = this.data[i] - x0;
                dy2 = this.data[i + 1] - y0;
                area += Geometry_1.Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);
            }
        }
        return 0.5 * area;
    }
    /** Compute a vector from index target i to indexed target j  */
    vectorIndexIndex(i, j, result) {
        const n = this.inUse;
        if (i < 0 || i >= n)
            return undefined;
        if (j < 0 || j >= n)
            return undefined;
        if (!result)
            result = PointVector_1.Vector3d.create();
        const data = this.data;
        i = 3 * i;
        j = 3 * j;
        result.x = data[j] - data[i];
        result.y = data[j + 1] - data[i + 1];
        result.z = data[j + 2] - data[i + 2];
        return result;
    }
    /** Compute a vector from origin to indexed target j */
    vectorXYAndZIndex(origin, j, result) {
        if (j >= 0 && j < this.inUse) {
            const data = this.data;
            j = 3 * j;
            return PointVector_1.Vector3d.create(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, result);
        }
        return undefined;
    }
    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */
    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this.data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2], data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2], result);
        return undefined;
    }
    /**
     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.
     * * accumulate it to the result.
     */
    accumulateCrossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this.data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            result.addCrossProductToTargetsInPlace(data[i], data[i + 1], data[i + 2], data[j], data[j + 1], data[j + 2], data[k], data[k + 1], data[k + 2]);
        return undefined;
    }
    /** Compute the cross product of vectors from from origin to indexed targets i and j */
    crossProductXYAndZIndexIndex(origin, targetAIndex, targetBIndex, result) {
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this.data;
        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z, result);
        return undefined;
    }
    /** Return the distance between two points in the array. */
    distance(i, j) {
        if (i >= 0 && i < this.inUse && j >= 0 && j <= this.inUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseXYZ(this.data[j0] - this.data[i0], this.data[j0 + 1] - this.data[i0 + 1], this.data[j0 + 2] - this.data[i0 + 2]);
        }
        return 0.0;
    }
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA.getPoint3dAt(i).isAlmostEqual(dataB.getPoint3dAt(i)))
                    return false;
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical() {
        const n = this.inUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return this.compareLexicalBlock(blockIndexA, blockIndexB);
        });
        // console.log (n, numCompare);
        return result;
    }
    /** compare two blocks in simple lexical order. */
    compareLexicalBlock(ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < 3; i++) {
            ax = this.data[ia * 3 + i];
            bx = this.data[ib * 3 + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(pointIndex, componentIndex) {
        return this.data[3 * pointIndex + componentIndex];
    }
}
exports.GrowableXYZArray = GrowableXYZArray;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const BezierPolynomials_1 = __webpack_require__(137);
const PointVector_1 = __webpack_require__(4);
const AnalyticGeometry_1 = __webpack_require__(11);
const CurvePrimitive_1 = __webpack_require__(12);
const LineString3d_1 = __webpack_require__(10);
/* tslint:disable:variable-name no-empty*/
/**
 * A LineSegment3d is:
 *
 * * A 3d line segment represented by
 *
 * ** startPoint
 * ** endPoint
 * parameterized with fraction 0 at the start and fraction 1 at the end, i.e. either of these equivalent forms:
 *
 * **  `X(f) = startPoint + f * (endPoint - startPoint)`
 * ** `X(f) = (1-f)*startPoint  + f * endPoint`
 */
class LineSegment3d extends CurvePrimitive_1.CurvePrimitive {
    isSameGeometryClass(other) { return other instanceof LineSegment3d; }
    get point0Ref() { return this._point0; }
    get point1Ref() { return this._point1; }
    constructor(point0, point1) { super(); this._point0 = point0; this._point1 = point1; }
    /** Set the start and endpoints by capturing input references. */
    setRefs(point0, point1) { this._point0 = point0; this._point1 = point1; }
    /** Set the start and endponits by cloning the input parameters. */
    set(point0, point1) { this._point0 = point0.clone(); this._point1 = point1.clone(); }
    /** copy (clone) data from other */
    setFrom(other) { this._point0.setFrom(other._point0); this._point1.setFrom(other._point1); }
    /** @returns Return a (clone of) the start point. */
    startPoint(result) {
        if (result) {
            result.setFrom(this._point0);
            return result;
        }
        return this._point0.clone();
    }
    /** @returns Return a (clone of) the end point. */
    endPoint(result) {
        if (result) {
            result.setFrom(this._point1);
            return result;
        }
        return this._point1.clone();
    }
    /** @returns Return the point at fractional position along the line segment. */
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        result.direction.setStartEnd(this._point0, this._point1);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the line segment
     * * x axis is the first derivative, i.e. along the line segment
     * * y axis is the second derivative, i.e. 000
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        result = result ? result : AnalyticGeometry_1.Plane3dByOriginAndVectors.createXYPlane();
        result.vectorU.setStartEnd(this._point0, this._point1);
        result.vectorV.set(0, 0, 0);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Clone the LineSegment3d */
    clone() { return LineSegment3d.create(this._point0, this._point1); }
    /** Clone and apply transform to the clone. */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    /** Create with start and end points.  The ponit contents are cloned into the LineSegment3d. */
    static create(point0, point1, result) {
        if (result) {
            result.set(point0, point1); // and this will clone them !!
            return result;
        }
        return new LineSegment3d(point0.clone(), point1.clone());
    }
    /** create a LineSegment3d from xy coordinates of start and end, with common z.
     * @param x0 start point x coordinate.
     * @param y0 start point y coordinate.
     * @param x1 end point x coordinate.
     * @param y1 end point y coordinate.
     * @param z z coordinate to use for both points.
     * @param result optional existing LineSegment to be reinitiazlized.
     */
    static createXYXY(x0, y0, x1, y1, z = 0, result) {
        if (result) {
            result._point0.set(x0, y0, z);
            result._point1.set(x1, y1, z);
            return result;
        }
        return new LineSegment3d(PointVector_1.Point3d.create(x0, y0, z), PointVector_1.Point3d.create(x1, y1, z));
    }
    /** @returns Return the point at fractional position along the line segment. */
    fractionToPoint(fraction, result) { return this._point0.interpolate(fraction, this._point1, result); }
    curveLength() { return this._point0.distance(this._point1); }
    quickLength() { return this.curveLength(); }
    /**
     * @param spacePoint point in space
     * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on the unbounded line that contains the bounded segment.
     * @returns Returns a curve location detail with both xyz and fractional coordinates of the closest point.
     */
    closestPoint(spacePoint, extend, result) {
        let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);
        if (!extend) {
            if (fraction > 1.0)
                fraction = 1.0;
            else if (fraction < 0.0)
                fraction = 0.0;
        }
        result = CurvePrimitive_1.CurveLocationDetail.create(this, result);
        result.fraction = fraction;
        this._point0.interpolate(fraction, this._point1, result.point);
        this._point0.vectorTo(this._point1, result.vector);
        result.a = result.point.distance(spacePoint);
        return result;
    }
    reverseInPlace() {
        const a = this._point0;
        this._point0 = this._point1;
        this._point1 = a;
    }
    tryTransformInPlace(transform) {
        this._point0 = transform.multiplyPoint3d(this._point0, this._point0);
        this._point1 = transform.multiplyPoint3d(this._point1, this._point1);
        return true;
    }
    isInPlane(plane) {
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point0))
            && Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point1));
    }
    appendPlaneIntersectionPoints(plane, result) {
        const h0 = plane.altitude(this._point0);
        const h1 = plane.altitude(this._point1);
        const fraction = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        let numIntersection = 0;
        if (fraction !== undefined) {
            numIntersection++;
            result.push(CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));
        }
        return numIntersection;
    }
    /**
     * Extend a range to include the (optionally transformed) line segment
     * @param range range to extend
     * @param transform optional transform to apply to the end points
     */
    extendRange(range, transform) {
        if (transform) {
            range.extendTransformedPoint(transform, this._point0);
            range.extendTransformedPoint(transform, this._point1);
        }
        else {
            range.extendPoint(this._point0);
            range.extendPoint(this._point1);
        }
    }
    /**
     * Construct a line from either of these json forms:
     *
     * * object with named start and end:
     * `{startPoint: pointValue, endPoint: pointValue}`
     * * array of two point values:
     * `[pointValue, pointValue]`
     * The point values are any values accepted by the Point3d method setFromJSON.
     * @param json data to parse.
     */
    setFromJSON(json) {
        if (!json) {
            this._point0.set(0, 0, 0);
            this._point1.set(1, 0, 0);
            return;
        }
        else if (json.startPoint && json.endPoint) {
            this._point0.setFromJSON(json.startPoint);
            this._point1.setFromJSON(json.endPoint);
        }
        else if (Array.isArray(json)
            && json.length > 1) {
            this._point0.setFromJSON(json[0]);
            this._point1.setFromJSON(json[1]);
        }
    }
    /**
     * Place the lineSegment3d start and points in a json object
     * @return {*} [[x,y,z],[x,y,z]]
     */
    toJSON() { return [this._point0.toJSON(), this._point1.toJSON()]; }
    static fromJSON(json) {
        const result = new LineSegment3d(PointVector_1.Point3d.createZero(), PointVector_1.Point3d.create());
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof LineSegment3d) {
            const ls = other;
            return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        dest.appendStrokePoint(this._point0);
        if (options) {
            let numStroke = 1;
            if (options.maxEdgeLength)
                numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
            dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0, false);
        }
        dest.appendStrokePoint(this._point1);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        handler.startCurvePrimitive(this);
        const tangent = this._point0.vectorTo(this._point1);
        let numStroke = 1;
        if (options) {
            if (options.maxEdgeLength)
                numStroke = options.applyMaxEdgeLength(numStroke, tangent.magnitude());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
        }
        handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLineSegment3d(this);
    }
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1, announce ? (fraction0, fraction1) => announce(fraction0, fraction1, this) : undefined);
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        return LineString3d_1.LineString3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));
    }
}
exports.LineSegment3d = LineSegment3d;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurvePrimitive_1 = __webpack_require__(12);
/**
 * Base class for SolidPrimitve variants.
 *
 * * Base class holds capped flag for all derived classes.
 */
class SolidPrimitive extends CurvePrimitive_1.GeometryQuery {
    constructor(capped) { super(); this._capped = capped; }
    /** Ask if this is a capped solid */
    get capped() { return this._capped; }
    /** Set the capped flag */
    set capped(capped) { this._capped = capped; }
}
exports.SolidPrimitive = SolidPrimitive;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(271)
var ieee754 = __webpack_require__(272)
var isArray = __webpack_require__(166)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Base class for iModel Hub Query objects. */
class Query {
    constructor() {
        this._query = {};
    }
    /** Method used by iModel Hub handlers to translate this query into request's QueryOptions. */
    getQueryOptions() {
        return this._query;
    }
    /** Add a part of the filter to currently set filter. */
    addFilter(filter, operator = "and") {
        if (!this._query.$filter) {
            this._query.$filter = "";
        }
        else {
            this._query.$filter += `+${operator}+`;
        }
        this._query.$filter += filter;
    }
    /**
     * Set filter to the specified filter string.
     * This resets all previously set filters.
     * @param filter Filter string to set for the query.
     * @returns This query.
     */
    filter(filter) {
        this._query.$filter = filter;
        return this;
    }
    /** Add a part of the select to currently set select. */
    addSelect(select) {
        if (this._query.$select) {
            this._query.$select += ",";
        }
        this._query.$select += select;
        return this;
    }
    /**
     * Set select to specified select string.
     * This resets all previously set selects.
     * @param select Select string to set for the query.
     * @returns This query.
     */
    select(select) {
        this._query.$select = select;
        return this;
    }
    /**
     * Select only top entries from the query.
     * This is applied after @see skip parameter.
     * @param n Number of top entries to select.
     * @returns This query.
     */
    top(n) {
        this._query.$top = n;
        return this;
    }
    /**
     * Skip first entries in the query.
     * This is applied before @see top parameter.
     * @param n Number of entries to skip.
     * @returns This query.
     */
    skip(n) {
        this._query.$skip = n;
        return this;
    }
    /**
     * Set order for the query.
     * This resets any other orders set.
     * @param orderBy Order string to set.
     * @returns This query.
     */
    orderBy(orderBy) {
        this._query.$orderby = orderBy;
        return this;
    }
}
exports.Query = Query;
/** Query for instances with string based instance ids. */
class InstanceIdQuery extends Query {
    /**
     * Query single instance by its id.
     * @param id Id of the instance to query.
     * @returns This query.
     */
    byId(id) {
        this._byId = id;
        return this;
    }
    /**
     * Used by iModel Hub handlers to get the id that is queried.
     * @returns Value that was set with byId method.
     */
    getId() {
        return this._byId;
    }
}
exports.InstanceIdQuery = InstanceIdQuery;
/**
 * Adds select for the download URL to the query.
 * @param query Query options where the select should be changed.
 */
function addSelectFileAccessKey(query) {
    if (!query.$select)
        query.$select = "*";
    query.$select += ",FileAccessKey-forward-AccessKey.DownloadURL";
}
exports.addSelectFileAccessKey = addSelectFileAccessKey;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const RpcProtocol_1 = __webpack_require__(28);
const RpcMarshaling_1 = __webpack_require__(118);
const RpcRegistry_1 = __webpack_require__(33);
const RpcControl_1 = __webpack_require__(59);
const IModelError_1 = __webpack_require__(16);
/** The status of an RPC operation request. */
var RpcRequestStatus;
(function (RpcRequestStatus) {
    RpcRequestStatus[RpcRequestStatus["Unknown"] = 0] = "Unknown";
    RpcRequestStatus[RpcRequestStatus["Created"] = 1] = "Created";
    RpcRequestStatus[RpcRequestStatus["Submitted"] = 2] = "Submitted";
    RpcRequestStatus[RpcRequestStatus["Provisioning"] = 3] = "Provisioning";
    RpcRequestStatus[RpcRequestStatus["Pending"] = 4] = "Pending";
    RpcRequestStatus[RpcRequestStatus["Resolved"] = 5] = "Resolved";
    RpcRequestStatus[RpcRequestStatus["Rejected"] = 6] = "Rejected";
    RpcRequestStatus[RpcRequestStatus["Enqueued"] = 7] = "Enqueued";
    RpcRequestStatus[RpcRequestStatus["Acknowledged"] = 8] = "Acknowledged";
    RpcRequestStatus[RpcRequestStatus["Finalized"] = 9] = "Finalized";
    RpcRequestStatus[RpcRequestStatus["Disposed"] = 10] = "Disposed";
    RpcRequestStatus[RpcRequestStatus["NotFound"] = 11] = "NotFound";
})(RpcRequestStatus = exports.RpcRequestStatus || (exports.RpcRequestStatus = {}));
/** RPC request event types. */
var RpcRequestEvent;
(function (RpcRequestEvent) {
    RpcRequestEvent[RpcRequestEvent["StatusChanged"] = 0] = "StatusChanged";
    RpcRequestEvent[RpcRequestEvent["PendingUpdateReceived"] = 1] = "PendingUpdateReceived";
})(RpcRequestEvent = exports.RpcRequestEvent || (exports.RpcRequestEvent = {}));
/** A RPC operation request. */
class RpcRequest {
    /** Constructs an RPC request. */
    constructor(client, operation, parameters) {
        this._resolve = () => undefined;
        this._reject = () => undefined;
        this._created = 0;
        this._lastSubmitted = 0;
        this._lastUpdated = 0;
        this._status = RpcRequestStatus.Unknown;
        this._extendedStatus = "";
        this._connecting = false;
        this._active = true;
        this._created = new Date().getTime();
        this.client = client;
        this.protocol = client.configuration.protocol;
        this.operation = client.constructor.prototype[operation][RpcRegistry_1.OPERATION];
        this.parameters = parameters;
        this.retryInterval = this.operation.policy.retryInterval(client.configuration);
        this.response = new Promise((resolve, reject) => { this._resolve = resolve; this._reject = reject; });
        this.id = this.operation.policy.requestId(this);
        this.protocol.events.addListener(this.handleProtocolEvent, this);
        this.setStatus(RpcRequestStatus.Created);
        this.operation.policy.requestCallback(this);
    }
    /** The aggregate operations profile of all active RPC interfaces. */
    static get aggregateLoad() { return RpcControl_1.aggregateLoad; }
    /**
     * The request for the current RPC operation.
     * @note The return value of this function is only reliable if program control was received from a RPC interface class member function that directly returns the result of calling RpcInterface.forward.
     */
    static current(context) {
        return context[RpcRegistry_1.CURRENT_REQUEST];
    }
    /** The status of this request. */
    get status() { return this._status; }
    /** Extended status information for this request (if available). */
    get extendedStatus() { return this._extendedStatus; }
    /** The last submission for this request. */
    get lastSubmitted() { return this._lastSubmitted; }
    /** The last status update received for this request. */
    get lastUpdated() { return this._lastUpdated; }
    /** Whether this request is finalized. */
    get finalized() { return this.status === RpcRequestStatus.Finalized; }
    /** Whether a connection is active for this request. */
    get connecting() { return this._connecting; }
    /** Whether this request is pending. */
    get pending() {
        switch (this.status) {
            case RpcRequestStatus.Submitted:
            case RpcRequestStatus.Provisioning:
            case RpcRequestStatus.Pending: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /** The elapsed time for this request. */
    get elapsed() {
        return this._lastUpdated - this._created;
    }
    /** Finds the first parameter of a given type if present. */
    findParameterOfType(constructor) {
        for (const param of this.parameters) {
            if (param instanceof constructor)
                return param;
        }
        return undefined;
    }
    /** Override to initialize the request communication channel. */
    initializeChannel() { }
    /** Override to send the request. */
    send() { }
    /** Override to set request header values. */
    setHeader(_name, _value) { }
    /** Override to supply response status code. */
    getResponseStatusCode() { return 0; }
    /** Override to supply response text. */
    getResponseText() { return ""; }
    setLastUpdatedTime() { this._lastUpdated = new Date().getTime(); }
    /* @hidden @internal */
    submit() {
        if (!this._active)
            return;
        this._lastSubmitted = new Date().getTime();
        if (this.status === RpcRequestStatus.Created || this.status === RpcRequestStatus.NotFound) {
            this.setStatus(RpcRequestStatus.Submitted);
        }
        try {
            this._connecting = true;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.RequestCreated, this);
            this.initializeChannel();
            this.setHeaders();
            this.send();
        }
        catch (e) {
            this._connecting = false;
            this.reject(e);
        }
    }
    handleProtocolEvent(event, object) {
        if (object !== this)
            return;
        switch (event) {
            case RpcProtocol_1.RpcProtocolEvent.ResponseLoaded: {
                this._connecting = false;
                return this.handleResponse();
            }
            case RpcProtocol_1.RpcProtocolEvent.AcknowledgementReceived: {
                return this.acknowledge();
            }
            case RpcProtocol_1.RpcProtocolEvent.BackendErrorReceived: {
                this._connecting = false;
                return;
            }
            case RpcProtocol_1.RpcProtocolEvent.ConnectionAborted:
            case RpcProtocol_1.RpcProtocolEvent.ConnectionErrorReceived:
            case RpcProtocol_1.RpcProtocolEvent.UnknownErrorReceived: {
                this._connecting = false;
                return this.reject(this.protocol.supplyErrorForEvent(event, this));
            }
        }
    }
    handleResponse() {
        const code = this.getResponseStatusCode();
        const status = this.protocol.getStatus(code);
        switch (status) {
            case RpcRequestStatus.Resolved: {
                const result = RpcMarshaling_1.RpcMarshaling.deserialize(this.operation, this.protocol, this.getResponseText());
                return this.resolve(result);
            }
            case RpcRequestStatus.Rejected: {
                this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendErrorReceived, this);
                const localError = new Error();
                const error = RpcMarshaling_1.RpcMarshaling.deserialize(this.operation, this.protocol, this.getResponseText());
                localError.name = error.name;
                localError.message = error.message;
                const localStack = localError.stack;
                const remoteStack = error.stack;
                error.stack = `${localStack}\n${remoteStack}`;
                return this.reject(error);
            }
            case RpcRequestStatus.Provisioning:
            case RpcRequestStatus.Pending: {
                return this.setPending(status, this.getResponseText());
            }
            case RpcRequestStatus.NotFound: {
                const response = RpcMarshaling_1.RpcMarshaling.deserialize(this.operation, this.protocol, this.getResponseText());
                this.setStatus(status);
                let resubmitted = false;
                RpcRequest.notFoundHandlers.raiseEvent(this, response, () => {
                    if (resubmitted)
                        throw new IModelError_1.IModelError(32768 /* ERROR */, `Already resubmitted using this handler.`);
                    resubmitted = true;
                    this.submit();
                }, (reason) => this.reject(reason));
                return;
            }
        }
    }
    resolve(value) {
        if (!this._active)
            return;
        this._active = false;
        this.setLastUpdatedTime();
        this._resolve(value);
        this.setStatus(RpcRequestStatus.Resolved);
        if (this.operation.policy.requiresAcknowledgement) {
            this.enqueue();
        }
        else {
            this.finalize();
        }
    }
    reject(reason) {
        if (!this._active)
            return;
        this._active = false;
        this.setLastUpdatedTime();
        this._reject(reason);
        this.setStatus(RpcRequestStatus.Rejected);
        this.finalize();
    }
    enqueue() {
        this.setStatus(RpcRequestStatus.Enqueued);
    }
    acknowledge() {
        this.setStatus(RpcRequestStatus.Acknowledged);
        this.finalize();
    }
    finalize() {
        this.setStatus(RpcRequestStatus.Finalized);
    }
    /** @hidden @internal */
    dispose() {
        this.setStatus(RpcRequestStatus.Disposed);
    }
    setPending(status, extendedStatus) {
        if (!this._active)
            return;
        this.setLastUpdatedTime();
        this._extendedStatus = extendedStatus;
        this.setStatus(status);
        RpcRequest.events.raiseEvent(RpcRequestEvent.PendingUpdateReceived, this);
    }
    setHeaders() {
        this.setHeader(this.protocol.requestIdHeaderName, this.id);
        if (this.protocol.authorizationHeaderName) {
            this.setHeader(this.protocol.authorizationHeaderName, this.protocol.configuration.applicationAuthorizationValue);
        }
    }
    setStatus(status) {
        if (this._status === status)
            return;
        this._status = status;
        RpcRequest.events.raiseEvent(RpcRequestEvent.StatusChanged, this);
    }
}
/** Events raised by RpcRequest. See [[RpcRequestEvent]] */
RpcRequest.events = new bentleyjs_core_1.BeEvent();
/** Resolvers for "not found" requests. See [[RpcRequestNotFoundHandler]] */
RpcRequest.notFoundHandlers = new bentleyjs_core_1.BeEvent();
exports.RpcRequest = RpcRequest;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const DisplayParams_1 = __webpack_require__(60);
const ColorMap_1 = __webpack_require__(208);
const Primitives_1 = __webpack_require__(61);
/* Information needed to draw a set of indexed polylines using a shared vertex buffer. */
class PolylineArgs {
    constructor(points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull())), polylines = [], pointParams, is2d = false, isPlanar = false) {
        this.colors = new imodeljs_common_1.ColorIndex();
        this.features = new imodeljs_common_1.FeatureIndex();
        this.width = 0;
        this.linePixels = 0 /* Solid */;
        this.points = points;
        this.polylines = polylines;
        if (undefined === pointParams) {
            this.pointParams = imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull());
        }
        else {
            this.pointParams = pointParams;
        }
        this.flags = new imodeljs_common_1.PolylineFlags(is2d, isPlanar);
    }
    get isValid() { return this.polylines.length !== 0; }
    reset() {
        this.flags.initDefaults();
        this.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull()));
        this.polylines = [];
        this.colors.reset();
        this.features.reset();
    }
    init(mesh) {
        this.reset();
        if (undefined === mesh.polylines)
            return;
        this.width = mesh.displayParams.width;
        this.linePixels = mesh.displayParams.linePixels;
        this.flags.is2d = mesh.is2d;
        this.flags.isPlanar = mesh.isPlanar;
        this.flags.isDisjoint = 2 /* Point */ === mesh.type;
        if (DisplayParams_1.DisplayParams.RegionEdgeType.Outline === mesh.displayParams.regionEdgeType) {
            // This polyline is behaving as the edges of a region surface.
            if (undefined === mesh.displayParams.gradient || mesh.displayParams.gradient.isOutlined)
                this.flags.setIsNormalEdge();
            else
                this.flags.setIsOutlineEdge(); // edges only displayed if fill undisplayed...
        }
        mesh.polylines.forEach((polyline) => {
            const indexedPolyline = new imodeljs_common_1.PolylineData();
            if (indexedPolyline.init(polyline)) {
                this.polylines.push(indexedPolyline);
            }
        });
        if (!this.isValid) {
            return false;
        }
        this.finishInit(mesh);
        return true;
    }
    finishInit(mesh) {
        this.pointParams = mesh.points.params;
        this.points = mesh.points;
        mesh.colorMap.toColorIndex(this.colors, mesh.colors);
        mesh.toFeatureIndex(this.features);
    }
}
exports.PolylineArgs = PolylineArgs;
// The vertices of the edges are shared with those of the surface
class MeshArgsEdges {
    constructor() {
        this.edges = new imodeljs_common_1.EdgeArgs();
        this.silhouettes = new imodeljs_common_1.SilhouetteEdgeArgs();
        this.polylines = new imodeljs_common_1.PolylineEdgeArgs();
        this.width = 0;
        this.linePixels = 0 /* Solid */;
    }
    clear() {
        this.edges.clear();
        this.silhouettes.clear();
        this.polylines.clear();
        this.width = 0;
        this.linePixels = 0 /* Solid */;
    }
    get isValid() { return this.edges.isValid || this.silhouettes.isValid || this.polylines.isValid; }
}
exports.MeshArgsEdges = MeshArgsEdges;
/* A carrier of information needed to describe a triangle mesh and its edges. */
class MeshArgs {
    constructor() {
        this.edges = new MeshArgsEdges();
        this.colors = new imodeljs_common_1.ColorIndex();
        this.features = new imodeljs_common_1.FeatureIndex();
        this.fillFlags = imodeljs_common_1.FillFlags.None;
        this.isPlanar = false;
        this.is2d = false;
    }
    clear() {
        this.edges.clear();
        this.vertIndices = undefined;
        this.points = undefined;
        this.normals = undefined;
        this.textureUv = undefined;
        this.texture = undefined;
        this.colors.reset();
        this.features.reset();
        this.material = undefined;
        this.fillFlags = imodeljs_common_1.FillFlags.None;
        this.isPlanar = this.is2d = false;
    }
    init(mesh) {
        this.clear();
        if (undefined === mesh.triangles || mesh.triangles.isEmpty)
            return false;
        bentleyjs_core_1.assert(0 < mesh.points.length);
        this.vertIndices = mesh.triangles.indices;
        this.points = mesh.points;
        if (!mesh.displayParams.ignoreLighting && 0 < mesh.normals.length)
            this.normals = mesh.normals;
        if (0 < mesh.uvParams.length)
            this.textureUv = mesh.uvParams;
        mesh.colorMap.toColorIndex(this.colors, mesh.colors);
        mesh.toFeatureIndex(this.features);
        this.material = mesh.displayParams.material;
        if (undefined !== mesh.displayParams.textureMapping)
            this.texture = mesh.displayParams.textureMapping.texture;
        this.fillFlags = mesh.displayParams.fillFlags;
        this.isPlanar = mesh.isPlanar;
        this.is2d = mesh.is2d;
        this.edges.width = mesh.displayParams.width;
        this.edges.linePixels = mesh.displayParams.linePixels;
        const meshEdges = mesh.edges;
        if (undefined === meshEdges)
            return true;
        this.edges.edges.init(mesh.edges);
        this.edges.silhouettes.init(mesh.edges);
        const polylines = [];
        meshEdges.polylines.forEach((meshPolyline) => {
            const polyline = new imodeljs_common_1.PolylineData();
            if (polyline.init(meshPolyline)) {
                polylines.push(polyline);
            }
        });
        this.edges.polylines.init(polylines);
        return true;
    }
}
exports.MeshArgs = MeshArgs;
class MeshGraphicArgs {
    constructor() {
        this.polylineArgs = new PolylineArgs();
        this.meshArgs = new MeshArgs();
    }
}
exports.MeshGraphicArgs = MeshGraphicArgs;
class Mesh {
    /**
     * @param props
     *    props.displayParams: DisplayParams
     *    props.features?: Mesh.Features | undefined
     *    props.type: Mesh.PrimitiveType
     *    props.range: Range3d
     *    props.is2d: boolean
     *    props.isPlanar: boolean
     */
    constructor(props) {
        this.normals = [];
        this.uvParams = [];
        this.colorMap = new ColorMap_1.ColorMap(); // used to be called ColorTable
        this.colors = new Uint16Array();
        const { displayParams, features, type, range, is2d, isPlanar } = props;
        this._data = 0 /* Mesh */ === type ? new Primitives_1.TriangleList() : new imodeljs_common_1.MeshPolylineList();
        this.displayParams = displayParams;
        this.features = features;
        this.type = type;
        this.is2d = is2d;
        this.isPlanar = isPlanar;
        this.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(range));
    }
    static create(props) { return new Mesh(props); }
    get triangles() { return 0 /* Mesh */ === this.type ? this._data : undefined; }
    get polylines() { return 0 /* Mesh */ !== this.type ? this._data : undefined; }
    toFeatureIndex(index) {
        if (undefined !== this.features)
            this.features.toFeatureIndex(index);
    }
    getGraphics(args, system) {
        if (undefined !== this.triangles && this.triangles.length !== 0) {
            if (args.meshArgs.init(this))
                return system.createTriMesh(args.meshArgs);
        }
        else if (undefined !== this.polylines && this.polylines.length !== 0 && args.polylineArgs.init(this)) {
            return system.createIndexedPolylines(args.polylineArgs);
        }
        return undefined;
    }
    addPolyline(poly) {
        const { type, polylines } = this;
        bentleyjs_core_1.assert(1 /* Polyline */ === type || 2 /* Point */ === type);
        bentleyjs_core_1.assert(undefined !== polylines);
        if (1 /* Polyline */ === type && poly.indices.length < 2)
            return;
        if (undefined !== polylines)
            polylines.push(poly);
    }
    addTriangle(triangle) {
        const { triangles, type } = this;
        bentleyjs_core_1.assert(0 /* Mesh */ === type);
        bentleyjs_core_1.assert(undefined !== triangles);
        if (undefined !== triangles)
            triangles.addTriangle(triangle);
    }
    addVertex(props) {
        const { position, normal, uvParam, fillColor } = props;
        this.points.push(position);
        if (undefined !== normal)
            this.normals.push(normal);
        if (undefined !== uvParam)
            this.uvParams.push(uvParam);
        this.colorMap.insert(fillColor);
        return this.points.length - 1;
    }
}
exports.Mesh = Mesh;
(function (Mesh) {
    class Features {
        constructor(table) {
            this._indices = [];
            this.uniform = 0;
            this.initialized = false;
            this.table = table;
        }
        get indices() { return this._indices; }
        add(feat, numVerts) {
            const index = this.table.insert(feat);
            if (!this.initialized) {
                // First feature - uniform.
                this.uniform = index;
                this.initialized = true;
            }
            else if (0 < this.indices.length) {
                // Already non-uniform
                this.indices.push(index);
            }
            else {
                // Second feature - back-fill uniform for existing verts
                while (this.indices.length < numVerts - 1)
                    this.indices.push(this.uniform);
                this.indices.push(index);
            }
        }
        setIndices(indices) {
            this._indices.length = 0;
            this.uniform = 0;
            this.initialized = 0 < indices.length;
            bentleyjs_core_1.assert(0 < indices.length);
            if (1 === indices.length)
                this.uniform = indices[0];
            else if (1 < indices.length)
                this._indices = indices;
        }
        toFeatureIndex(index) {
            if (!this.initialized) {
                index.type = 0 /* Empty */;
            }
            else if (this.indices.length === 0) {
                index.type = 1 /* Uniform */;
                index.featureID = this.uniform;
            }
            else {
                index.type = 2 /* NonUniform */;
                index.featureIDs = new Uint32Array(this._indices);
            }
        }
    }
    Mesh.Features = Features;
})(Mesh = exports.Mesh || (exports.Mesh = {}));
class MeshList extends Array {
    constructor(features, ...args) {
        super(...args);
        if (undefined !== features)
            this.features = features;
    }
}
exports.MeshList = MeshList;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const Tool_1 = __webpack_require__(15);
const ViewContext_1 = __webpack_require__(96);
const TileTree_1 = __webpack_require__(62);
const LegacyMath_1 = __webpack_require__(75);
const imodeljs_common_1 = __webpack_require__(2);
const IModelApp_1 = __webpack_require__(5);
const System_1 = __webpack_require__(17);
const FeatureSymbology_1 = __webpack_require__(73);
/** Viewport synchronization flags */
class SyncFlags {
    constructor() {
        this.decorations = false;
        this.scene = false;
        this.renderPlan = false;
        this.controller = false;
        this.rotatePoint = false;
        this.redrawPending = false;
    }
    get isValidDecorations() { return this.decorations; }
    get isValidScene() { return this.scene; }
    get isValidController() { return this.controller; }
    get isValidRenderPlan() { return this.renderPlan; }
    get isValidRotatePoint() { return this.rotatePoint; }
    get isRedrawPending() { return this.redrawPending; }
    invalidateDecorations() { this.decorations = false; }
    invalidateScene() { this.scene = false; this.invalidateDecorations(); }
    invalidateRenderPlan() { this.renderPlan = false; this.invalidateScene(); }
    invalidateController() { this.controller = false; this.invalidateRenderPlan(); }
    invalidateRotatePoint() { this.rotatePoint = false; }
    invalidateRedrawPending() { this.redrawPending = false; }
    setValidDecorations() { this.decorations = true; }
    setValidScene() { this.scene = true; }
    setValidController() { this.controller = true; }
    setValidRenderPlan() { this.renderPlan = true; }
    setValidRotatePoint() { this.rotatePoint = true; }
    setRedrawPending() { this.redrawPending = true; }
    initFrom(other) { this.decorations = other.decorations; this.scene = other.scene; this.renderPlan = other.renderPlan; this.controller = other.controller; this.rotatePoint = other.rotatePoint; this.redrawPending = other.redrawPending; }
}
exports.SyncFlags = SyncFlags;
/** A rectangle in integer view coordinates with (0,0) corresponding to the top-left corner of the view.
 *
 * Increasing **x** moves from left to right, and increasing **y** moves from top to bottom.
 */
class ViewRect {
    /** Construct a new ViewRect. */
    constructor(left = 0, top = 0, right = 0, bottom = 0) { this.init(left, top, right, bottom); }
    /** The leftmost side of this ViewRect.  */
    get left() { return this._left; }
    set left(val) { this._left = Math.floor(val); }
    /** The topmost side of this ViewRect. */
    get top() { return this._top; }
    set top(val) { this._top = Math.floor(val); }
    /** The rightmost side of this ViewRect. */
    get right() { return this._right; }
    set right(val) { this._right = Math.floor(val); }
    /** The bottommost side of this ViewRect. */
    get bottom() { return this._bottom; }
    set bottom(val) { this._bottom = Math.floor(val); }
    /** True if this ViewRect has an area > 0. */
    get isNull() { return this.right <= this.left || this.bottom <= this.top; }
    /** True if `!isNull` */
    get isValid() { return !this.isNull; }
    /** The width (right-left) of this ViewRect. */
    get width() { return this.right - this.left; }
    set width(width) { this.right = this.left + width; }
    /** The height (bottom-top) of this ViewRect. */
    get height() { return this.bottom - this.top; }
    set height(height) { this.bottom = this.top + height; }
    /** The aspect ratio (width/height) of this ViewRect. */
    get aspect() { return this.isNull ? 1.0 : this.width / this.height; }
    /** The area (width*height) of this ViewRect. */
    get area() { return this.isNull ? 0 : this.width * this.height; }
    /** Initialize this ViewRect from its left/top/right/bottom parameters. */
    init(left, top, right, bottom) { this.left = left; this.bottom = bottom, this.right = right; this.top = top; }
    /** Initialize this ViewRect from two points.
     * @param topLeft The top-left corner.
     * @param bottomRight The bottom-right corner.
     */
    initFromPoints(topLeft, bottomRight) { this.init(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
    /** Initialize this ViewRect from a range.
     * @param input The Range to use. `input.low` defines the top-left and `input.high` defines the bottom-right.
     */
    initFromRange(input) { this.initFromPoints(input.low, input.high); }
    /** Return true is this ViewRect is exactly equal to another ViewRect.
     * @param other The other ViewRect to compare
     */
    equals(other) { return this.left === other.left && this.right === other.right && this.bottom === other.bottom && this.top === other.top; }
    /** Initialize this ViewRect from another ViewRect. */
    copyFrom(other) { this.init(other.left, other.top, other.right, other.bottom); }
    /** Duplicate this ViewRect.
     * @param result Optional ViewRect for result. If undefined, a new ViewRect is created.
     */
    clone(result) {
        if (undefined !== result) {
            result.copyFrom(this);
            return result;
        }
        return new ViewRect(this.left, this.top, this.right, this.bottom);
    }
    /** Inset this ViewRect by the same value in all directions.
     * @param offset The distance to inset this ViewRect. Positive values will make this ViewRect smaller and negative values will make it larger.
     * @note The inset operation can cause a previously valid ViewRect to become invalid.
     */
    inset(offset) { this.left += offset; this.top += offset; this.right -= offset; this.bottom -= offset; }
    /** Inset this ViewRect by a percentage of its current width.
     * @param percent The percentage of this ViewRect's width to inset in all directions.
     * @note The ViewRect will become smaller (or larger, if percent is negative) by `percent * width * 2` in each direction, since each side is moved by that distance.
     * @see [[inset]]
     */
    insetByPercent(percent) { this.inset(this.width * percent); }
    /** Determine if this ViewRect is entirely contained within the bounds of another ViewRect. */
    isContained(other) { return this.left >= other.left && this.right <= other.right && this.bottom <= other.bottom && this.top >= other.top; }
    /** Return true if the supplied point is contained in this ViewRect.
     * @param point The point to test.
     * @note if the point is exactly on the left or top edges, this method returns true. If the point is exactly on the right or bottom edge, it returns false.
     */
    containsPoint(point) { return point.x >= this.left && point.x < this.right && point.y >= this.top && point.y < this.bottom; }
    /** Return the rectangle that is the overlap (intersection) of this ViewRect and another ViewRect. */
    overlaps(other, overlap) {
        const maxOrgX = Math.max(this.left, other.left);
        const maxOrgY = Math.max(this.top, other.top);
        const minCrnX = Math.min(this.right, other.right);
        const minCrnY = Math.min(this.bottom, other.bottom);
        if (maxOrgX > minCrnX || maxOrgY > minCrnY)
            return false;
        if (undefined !== overlap) {
            overlap.left = maxOrgX;
            overlap.right = minCrnX;
            overlap.top = maxOrgY;
            overlap.bottom = minCrnY;
        }
        return true;
    }
    /** Return a ViewRect that is the overlap (intersection) of this ViewRect and another ViewRect.
     * If the two ViewRects are equal, their value is the result. Otherwise, the result will always be smaller than either of them.
     */
    computeOverlap(other, out) {
        const result = undefined !== out ? out : new ViewRect();
        return this.overlaps(other, result) ? result : undefined;
    }
}
exports.ViewRect = ViewRect;
/**
 * The minimum and maximum values for the z-depth of a rectangle of screen space.
 *
 * Values are in [[CoordSystem.Npc]] so they will be between 0 and 1.0.
 */
class DepthRangeNpc {
    /**
     * @param minimum The lowest (closest to back) value.
     * @param maximum The highest (closest to the front) value.
     */
    constructor(minimum = 0, maximum = 1.0) {
        this.minimum = minimum;
        this.maximum = maximum;
    }
    /** The value at the middle (halfway between the minimum and maximum) of this depth */
    middle() { return this.minimum + ((this.maximum - this.minimum) / 2.0); }
}
exports.DepthRangeNpc = DepthRangeNpc;
/** Object to animate a Frustum transition of a viewport. The Viewport will show as many frames as necessary during the supplied duration. */
class Animator {
    /** Construct a new Animator.
     * @param totalTime The duration of the animation.
     * @param viewport The Viewport to animate.
     * @param startFrustum The Viewport's starting Frustum at the beginning of the animation.
     * @param endFrustum The Viewport's ending Frustum after the animation.
     */
    constructor(totalTime, viewport, startFrustum, endFrustum) {
        this.totalTime = totalTime;
        this.viewport = viewport;
        this.startFrustum = startFrustum;
        this.endFrustum = endFrustum;
        this.currFrustum = new imodeljs_common_1.Frustum();
    }
    interpolateFrustum(fraction) {
        for (let i = 0; i < 8 /* CORNER_COUNT */; ++i) {
            this.startFrustum.points[i].interpolate(fraction, this.endFrustum.points[i], this.currFrustum.points[i]);
        }
        this.viewport.setupViewFromFrustum(this.currFrustum);
    }
    moveToTime(time) {
        const fraction = time / this.totalTime.milliseconds;
        this.interpolateFrustum(fraction);
    }
    /**
     * Move to the appropriate frame, based on the current time, for the current animation.
     * @return true when finished
     */
    animate() {
        const currTime = bentleyjs_core_1.BeTimePoint.now();
        if (!this.startTime)
            this.startTime = currTime;
        const totalTimeMillis = this.totalTime.milliseconds;
        const endTime = this.startTime.milliseconds + totalTimeMillis;
        if (endTime <= currTime.milliseconds) {
            this.moveToTime(totalTimeMillis);
            return true;
        }
        let done = false;
        let index = currTime.milliseconds - this.startTime.milliseconds;
        if (index > totalTimeMillis) {
            done = true;
            index = totalTimeMillis;
        }
        this.moveToTime(index);
        return done;
    }
    /** Abort this animation, moving to the final frame. */
    interrupt() {
        if (this.startTime)
            this.moveToTime(this.totalTime.milliseconds); // We've been interrupted after animation began. Skip to the final animation state
    }
}
/**
 * A ViewportAnimator that animated decorations. While the animator is
 * active, decorations will be invalidated on each frame. The animator's
 * animateDecorations() function will be invoked to update any animation state; then
 * decorations will be re-requested and rendered.
 */
class DecorationAnimator {
    constructor(duration) {
        this.start = bentleyjs_core_1.BeTimePoint.now();
        this.stop = this.start.plus(duration);
    }
    /**
     * Override to update animation state, which can then be used on the next call to produce decorations.
     * @param viewport The viewport being animated
     * @param durationPercent The ratio of duration elapsed, in [0.0,1.0]
     * @returns RemoveMe.Yes to immediately remove this animator, RemoveMe::No to continue animating until duration elapsed or animator interrupted.
     * If this animator is interrupted, this function will be immediately invoked with durationPercent=1.0.
     */
    animateDecorations(_viewport, _durationPercent) { return 0 /* No */; }
    animate(vp) {
        vp.invalidateDecorations();
        const total = this.stop.milliseconds - this.start.milliseconds;
        const elapsed = bentleyjs_core_1.BeTimePoint.now().milliseconds - this.start.milliseconds;
        const ratio = Math.min(elapsed / total, 1.0);
        const removeMe = this.animateDecorations(vp, ratio);
        return (1 /* Yes */ === removeMe || ratio === 1.0) ? 1 /* Yes */ : 0 /* No */;
    }
    onInterrupted(vp) {
        vp.invalidateDecorations();
        this.animateDecorations(vp, 1.0);
    }
}
exports.DecorationAnimator = DecorationAnimator;
/**
 * A Viewport renders one or more Models onto an `HTMLCanvasElement`.
 *
 * It holds a [[ViewState]] object that defines its viewing parameters. [[ViewTool]]s may
 * modify the ViewState object. Changes to the ViewState are only reflected in a Viewport after the
 * [[synchWithView]] method is called.
 *
 * As changes to ViewState are made, Viewports also hold a stack of *previous copies* of it, to allow
 * for undo/redo (i.e. *View Previous* and *View Next*) of viewing tools.
 */
class Viewport {
    /** Construct a new Viewport
     * @param canvas The HTMLCanvasElement for the new Viewport
     * @param view a fully loaded (see discussion at [[ViewState.load]]) ViewState
     */
    constructor(canvas, viewState) {
        this.canvas = canvas;
        this._doContinuousRendering = false;
        this.zClipAdjusted = false; // were the view z clip planes adjusted due to front/back clipping off?
        this.viewCorners = new geometry_core_1.Range3d();
        /** Current flash intensity from [0..1] */
        this.flashIntensity = 0;
        /** The length of time that the flash intensity will increase (in seconds) */
        this.flashDuration = 0;
        /** @hidden */
        this.frustFraction = 1.0;
        /** The number of entries in the view undo/redo buffer. */
        this.maxUndoSteps = 20;
        this.forwardStack = [];
        this.backStack = [];
        /** @hidden */
        this.sync = new SyncFlags();
        /** View origin, potentially expanded */
        this.viewOrigin = new geometry_core_1.Point3d();
        /** View delta, potentially expanded */
        this.viewDelta = new geometry_core_1.Vector3d();
        /** View origin (from ViewState, unexpanded) */
        this.viewOriginUnexpanded = new geometry_core_1.Point3d();
        /** View delta (from ViewState, unexpanded) */
        this.viewDeltaUnexpanded = new geometry_core_1.Vector3d();
        /** View rotation matrix (copied from ViewState) */
        this.rotMatrix = new geometry_core_1.RotMatrix();
        /** @hidden */
        this.worldToViewMap = geometry_core_1.Map4d.createIdentity();
        /** @hidden */
        this.worldToNpcMap = geometry_core_1.Map4d.createIdentity();
        /** Event called whenever this viewport is synchronized with its ViewState. */
        this.onViewChanged = new bentleyjs_core_1.BeEvent();
        /** The settings that control how elements are hilited in this Viewport. */
        this.hilite = new imodeljs_common_1.Hilite.Settings();
        this._viewRange = new ViewRect();
        this.target = IModelApp_1.IModelApp.renderSystem.createTarget(canvas);
        this.changeView(viewState);
        this.setCursor();
        this.saveViewUndo();
    }
    static get2dFrustumDepth() { return geometry_core_1.Constant.oneMeter; }
    /**
     * Determine whether the Grid display is currently enabled in this Viewport.
     * @return true if the grid display is on.
     */
    get isGridOn() { return this.viewFlags.showGrid(); }
    /** The [ViewFlags]($common) that determine how this Viewport is rendered.  */
    get viewFlags() { return this.view.viewFlags; }
    /** @hidden */
    get wantAntiAliasLines() { return 2 /* Off */; }
    /** @hidden */
    get wantAntiAliasText() { return 0 /* Detect */; }
    /** The iModel of this Viewport */
    get iModel() { return this.view.iModel; }
    /** @hidden */
    isPointAdjustmentRequired() { return this.view.is3d(); }
    /** @hidden */
    isSnapAdjustmentRequired() { return IModelApp_1.IModelApp.toolAdmin.acsPlaneSnapLock && this.view.is3d(); }
    /** @hidden */
    isContextRotationRequired() { return IModelApp_1.IModelApp.toolAdmin.acsContextLock; }
    /** Determine whether continuous rendering is enabled. */
    get continuousRendering() { return this._doContinuousRendering; }
    /** Set whether or not continuous rendering is enabled. */
    set continuousRendering(contRend) { this._doContinuousRendering = contRend; }
    /** Get the ClientRect of the canvas for this Viewport. */
    getClientRect() { return this.canvas.getBoundingClientRect(); }
    /** Set the event controller for this Viewport. Destroys previous controller, if one was defined. */
    setEventController(controller) { if (this._evController) {
        this._evController.destroy();
    } this._evController = controller; }
    /** The ViewState for this Viewport */
    get view() { return this._view; }
    /** @hidden */
    get pixelsPerInch() { /* ###TODO: This is apparently unobtainable information in a browser... */ return 96; }
    get viewCmdTargetCenter() { return this._viewCmdTargetCenter; }
    set viewCmdTargetCenter(center) { this._viewCmdTargetCenter = center ? center.clone() : undefined; }
    /**
     * Sets a function which can customize the appearance of features within a viewport.
     * If defined, this function will be invoked whenever the overrides are determined to need refreshing.
     * The overrides can be explicitly marked as needing a refresh by calling ViewState.setFeatureOverridesDirty().
     */
    set addFeatureOverrides(addFeatureOverrides) {
        if (addFeatureOverrides !== this._addFeatureOverrides) {
            this._addFeatureOverrides = addFeatureOverrides;
            this.view.setFeatureOverridesDirty(true);
        }
    }
    /** True if this is a 3d view with the camera turned on. */
    isCameraOn() { return this.view.is3d() && this.view.isCameraOn(); }
    /** @hidden */
    invalidateDecorations() { this.sync.invalidateDecorations(); }
    /** @hidden */
    changeDynamics(dynamics) {
        this.target.changeDynamics(dynamics);
        this.invalidateDecorations();
    }
    /** Change the cursor for this Viewport */
    setCursor(cursor = Tool_1.BeCursor.Default) {
        if (cursor === Tool_1.BeCursor.OpenHand)
            this.canvas.style.cursor = "-webkit-grab";
        else if (cursor === Tool_1.BeCursor.ClosedHand)
            this.canvas.style.cursor = "-webkit-grabbing";
        else
            this.canvas.style.cursor = cursor;
    }
    /** Set or clear the currently *flashed* element.
     * @param id The Id of the element to flash. If undefined, remove (un-flash) the currently flashed element
     * @param duration The amount of time, in seconds, the flash intensity will increase (see [[flashDuration]])
     */
    setFlashed(id, duration) {
        if (id !== this.flashedElem) {
            this.lastFlashedElem = this.flashedElem;
            this.flashedElem = id;
        }
        this.flashDuration = duration;
    }
    get auxCoordSystem() { return this.view.auxiliaryCoordinateSystem; }
    getAuxCoordRotation(result) { return this.auxCoordSystem.getRotation(result); }
    getAuxCoordOrigin(result) { return this.auxCoordSystem.getOrigin(result); }
    /** @hidden */
    toView(from, to) { this.rotMatrix.multiplyVectorInPlace(Viewport.copyOutput(from, to)); }
    /** @hidden */
    fromView(from, to) { this.rotMatrix.multiplyTransposeVectorInPlace(Viewport.copyOutput(from, to)); }
    /** Adjust the front and back planes to encompass the entire viewed volume */
    adjustZPlanes(origin, delta) {
        const view = this.view;
        if (!view.is3d())
            return;
        let extents = view.getViewedExtents();
        if (extents.isNull())
            return;
        // convert viewed extents in world coordinates to min/max in view aligned coordinates
        const viewTransform = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createZero(), this.rotMatrix);
        const extFrust = imodeljs_common_1.Frustum.fromRange(extents);
        extFrust.multiply(viewTransform);
        extents = extFrust.toRange();
        this.rotMatrix.multiplyVectorInPlace(origin); // put origin in view coordinates
        origin.z = extents.low.z; // set origin to back of viewed extents
        delta.z = extents.high.z - origin.z; // and delta to front of viewed extents
        this.rotMatrix.multiplyTransposeVectorInPlace(origin);
        if (!view.isCameraOn())
            return;
        // if the camera is on, we need to make sure that the viewed volume is not behind the eye
        const eyeOrg = view.camera.getEyePoint().minus(origin);
        this.rotMatrix.multiplyVectorInPlace(eyeOrg);
        // if the distance from the eye to origin in less than 1 meter, move the origin away from the eye. Usually, this means
        // that the camera is outside the viewed extents and pointed away from it. There's nothing to see anyway.
        if (eyeOrg.z < 1.0) {
            this.rotMatrix.multiplyVectorInPlace(origin);
            origin.z -= (2.0 - eyeOrg.z);
            this.rotMatrix.multiplyTransposeVectorInPlace(origin);
            delta.z = 1.0;
            return;
        }
        // if part of the viewed extents are behind the eye, don't include that.
        if (delta.z > eyeOrg.z)
            delta.z = eyeOrg.z;
    }
    validateCamera() {
        const view = this.view;
        if (!view.is3d())
            return;
        const camera = view.camera;
        camera.validateLens();
        if (camera.isFocusValid())
            return;
        const vDelta = view.getExtents();
        const maxDelta = vDelta.x > vDelta.y ? vDelta.x : vDelta.y;
        let focusDistance = maxDelta / (2.0 * Math.tan(camera.getLensAngle().radians / 2.0));
        if (focusDistance < vDelta.z / 2.0)
            focusDistance = vDelta.z / 2.0;
        const eyePoint = new geometry_core_1.Point3d(vDelta.x / 2.0, vDelta.y / 2.0, (vDelta.z / 2.0) + focusDistance);
        this.fromView(eyePoint);
        eyePoint.plus(view.getOrigin(), eyePoint);
        camera.setEyePoint(eyePoint);
        camera.setFocusDistance(focusDistance);
    }
    /**
     * Change the ViewState of this Viewport
     * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState
     */
    changeView(view) {
        this.clearUndo();
        this._view = view;
        this.setupFromView();
        this.saveViewUndo();
        this.invalidateScene();
        this.sync.invalidateController();
        this.target.queueReset();
    }
    invalidateScene() { this.sync.invalidateScene(); }
    /**
     * Computes the range of npc depth values for a region of the screen
     * @param rect the rectangle to test. If undefined, test entire view
     * @param result optional DepthRangeNpc to store the result
     * @returns the minimum and maximum depth values within the region, or undefined.
     */
    determineVisibleDepthRange(rect, result) {
        if (result) {
            result.minimum = 1;
            result.maximum = 0;
        }
        // Default to a (0, 0, 0) to (1, 1, 1) range if no range was provided
        rect = (rect && rect.isValid) ? rect : this.viewRect;
        // Determine the screen rectangle in which to query visible depth min + max
        const readRect = rect.computeOverlap(this.viewRect);
        if (undefined === readRect)
            return undefined;
        const pixels = this.readPixels(readRect, 2 /* Distance */);
        if (!pixels)
            return undefined;
        let maximum = 0;
        let minimum = 1;
        const npc = geometry_core_1.Point3d.create();
        const testPoint = geometry_core_1.Point2d.create();
        for (testPoint.x = readRect.left; testPoint.x < readRect.right; ++testPoint.x) {
            for (testPoint.y = readRect.top; testPoint.y < readRect.bottom; ++testPoint.y) {
                if (this.getPixelDataNpcPoint(pixels, testPoint.x, testPoint.y, npc) !== undefined) {
                    minimum = Math.min(minimum, npc.z);
                    maximum = Math.max(maximum, npc.z);
                }
            }
        }
        if (maximum <= 0)
            return undefined;
        if (undefined === result) {
            result = new DepthRangeNpc(minimum, maximum);
        }
        else {
            result.minimum = minimum;
            result.maximum = maximum;
        }
        return result;
    }
    determineDefaultRotatePoint(out) {
        if (this.isCameraOn())
            return this.view.getTargetPoint(out);
        const scratch = Viewport.scratchDefaultRotatePointLow;
        scratch.x = scratch.y = scratch.z = 0.5;
        return this.npcToWorld(scratch, out);
    }
    getFocusPlaneNpc() {
        const cameraTarget = this.view.getTargetPoint();
        let npcZ = this.worldToNpc(cameraTarget, cameraTarget).z;
        if (npcZ < 0.0 || npcZ > 1.0) {
            Viewport.scratchDefaultRotatePointHigh.z = 1.0;
            Viewport.scratchDefaultRotatePointLow.z = 0.0;
            const npcLow = this.npcToWorld(Viewport.scratchDefaultRotatePointLow);
            const npcHigh = this.npcToWorld(Viewport.scratchDefaultRotatePointHigh);
            const center = npcLow.interpolate(0.5, npcHigh);
            npcZ = this.worldToNpc(center, center).z;
        }
        return npcZ;
    }
    /** Turn the camera on if it is currently off. If the camera is already on, adjust it to use the supplied lens angle.
     * @param lensAngle The lens angle for the camera. If undefined, use view.camera.lens.
     * @note This method will fail if the ViewState is not 3d.
     */
    turnCameraOn(lensAngle) {
        const view = this.view;
        if (!view.is3d())
            return 15 /* InvalidViewport */;
        if (!lensAngle)
            lensAngle = view.camera.lens;
        imodeljs_common_1.Camera.validateLensAngle(lensAngle);
        if (view.isCameraOn())
            return view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle);
        // We need to figure out a new camera target. To do that, we need to know where the geometry is in the view.
        // We use the depth of the center of the view for that.
        let depthRange = this.determineVisibleDepthRange();
        if (!depthRange)
            depthRange = new DepthRangeNpc();
        const middle = depthRange.middle();
        const corners = [
            new geometry_core_1.Point3d(0.0, 0.0, middle),
            new geometry_core_1.Point3d(1.0, 1.0, middle),
            new geometry_core_1.Point3d(0.0, 0.0, depthRange.maximum),
            new geometry_core_1.Point3d(1.0, 1.0, depthRange.maximum),
        ];
        this.npcToWorldArray(corners);
        const eye = corners[2].interpolate(0.5, corners[3]); // middle of closest plane
        const target = corners[0].interpolate(0.5, corners[1]); // middle of halfway plane
        const backDist = eye.distance(target) * 2.0;
        const frontDist = view.minimumFrontDistance();
        return view.lookAtUsingLensAngle(eye, target, view.getYVector(), lensAngle, frontDist, backDist);
    }
    /* Get the extents of this view, in ViewCoordinates, as a Range3d */
    getViewCorners() {
        const corners = this.viewCorners;
        const viewRect = this.viewRect;
        corners.high.x = viewRect.right;
        corners.low.y = viewRect.bottom; // y's are swapped on the screen!
        corners.low.x = 0;
        corners.high.y = 0;
        corners.low.z = -32767;
        corners.high.z = 32767;
        return corners;
    }
    calcNpcToView() {
        const corners = this.getViewCorners();
        return geometry_core_1.Map4d.createBoxMap(imodeljs_common_1.NpcCorners[0 /* _000 */], imodeljs_common_1.NpcCorners[7 /* _111 */], corners.low, corners.high);
    }
    /** adjust the aspect ratio of the view volume to match the aspect ratio of the window of this Viewport.
     *  modifies the point and vector given
     */
    adjustAspectRatio(origin, delta) {
        const windowAspect = this.viewRect.aspect * this.view.getAspectRatioSkew();
        const viewAspect = delta.x / delta.y;
        if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)
            return;
        const oldDelta = delta.clone();
        if (viewAspect > windowAspect)
            delta.y = delta.x / windowAspect;
        else
            delta.x = delta.y * windowAspect;
        const newOrigin = origin.clone();
        this.toView(newOrigin);
        newOrigin.x += ((oldDelta.x - delta.x) / 2.0);
        newOrigin.y += ((oldDelta.y - delta.y) / 2.0);
        this.fromView(newOrigin, origin);
    }
    /** Ensure the rotation matrix for this view is aligns the root z with the view out (i.e. a "2d view"). */
    alignWithRootZ() {
        const zUp = geometry_core_1.Vector3d.unitZ();
        if (zUp.isAlmostEqual(this.rotMatrix.rowZ()))
            return;
        const r = this.rotMatrix.transpose();
        r.setColumn(2, zUp);
        geometry_core_1.RotMatrix.createRigidFromRotMatrix(r, 2 /* ZXY */, r);
        r.transpose(this.rotMatrix);
    }
    /** Get the rectangle of this Viewport in ViewCoordinates. */
    get viewRect() { this._viewRange.init(0, 0, this.canvas.clientWidth, this.canvas.clientHeight); return this._viewRange; }
    /** True if an undoable viewing operation exists on the stack */
    get isUndoPossible() { return 0 < this.backStack.length; }
    /** True if an redoable viewing operation exists on the stack */
    get isRedoPossible() { return 0 < this.forwardStack.length; }
    /** Clear the view undo buffers of this Viewport. */
    clearUndo() {
        this.currentBaseline = undefined;
        this.forwardStack.length = 0;
        this.backStack.length = 0;
    }
    setStandardRotation(id) {
        this.view.setStandardRotation(id);
        this.setupFromView();
    }
    /** Establish the parameters of this Viewport from the current information in its ViewState */
    setupFromView() {
        const view = this.view;
        if (!view)
            return 15 /* InvalidViewport */;
        const origin = view.getOrigin().clone();
        const delta = view.getExtents().clone();
        this.rotMatrix.setFrom(view.getRotation());
        // first, make sure none of the deltas are negative
        delta.x = Math.abs(delta.x);
        delta.y = Math.abs(delta.y);
        delta.z = Math.abs(delta.z);
        const limits = this.view.getExtentLimits();
        const clampRange = (val) => Math.min(Math.max(limits.min, val), limits.max);
        delta.x = clampRange(delta.x);
        delta.y = clampRange(delta.y);
        this.adjustAspectRatio(origin, delta);
        this.viewOriginUnexpanded.setFrom(origin);
        this.viewDeltaUnexpanded.setFrom(delta);
        this.viewOrigin.setFrom(origin);
        this.viewDelta.setFrom(delta);
        this.zClipAdjusted = false;
        if (view.is3d()) {
            if (!view.allow3dManipulations()) {
                // we're in a "2d" view of a physical model. That means that we must have our orientation with z out of the screen with z=0 at the center.
                this.alignWithRootZ(); // make sure we're in a z Up view
                const extents = view.getViewedExtents();
                if (extents.isNull()) {
                    extents.low.z = -Viewport.get2dFrustumDepth();
                    extents.high.z = Viewport.get2dFrustumDepth();
                }
                let zMax = Math.max(Math.abs(extents.low.z), Math.abs(extents.high.z));
                zMax = Math.max(zMax, 1.0); // make sure we have at least +-1m. Data may be purely planar
                delta.z = 2.0 * zMax;
                origin.z = -zMax;
            }
            else {
                if (view.isCameraOn())
                    this.validateCamera();
                this.adjustZPlanes(origin, delta); // make sure view volume includes entire volume of view
                // if the camera is on, don't allow front plane behind camera
                if (view.isCameraOn()) {
                    const eyeOrg = view.camera.getEyePoint().minus(origin); // vector from eye to origin
                    this.toView(eyeOrg);
                    const frontDist = eyeOrg.z - delta.z; // front distance is backDist - delta.z
                    // allow ViewState to specify a minimum front dist, but in no case less than 6 inches
                    const minFrontDist = Math.max(15.2 * geometry_core_1.Constant.oneCentimeter, view.forceMinFrontDist);
                    if (frontDist < minFrontDist) {
                        // camera is too close to front plane, move origin away from eye to maintain a minimum front distance.
                        this.toView(origin);
                        origin.z -= (minFrontDist - frontDist);
                        this.fromView(origin);
                    }
                }
                // if we moved the z planes, set the "zClipAdjusted" flag.
                if (!origin.isExactEqual(this.viewOriginUnexpanded) || !delta.isExactEqual(this.viewDeltaUnexpanded))
                    this.zClipAdjusted = true;
            }
        }
        else {
            this.alignWithRootZ();
            delta.z = 2 * Viewport.get2dFrustumDepth();
            origin.z = -Viewport.get2dFrustumDepth();
        }
        this.viewOrigin.setFrom(origin);
        this.viewDelta.setFrom(delta);
        const frustFraction = this.computeRootToNpc(this.worldToNpcMap, origin, delta);
        if (frustFraction === undefined)
            return 15 /* InvalidViewport */;
        this.frustFraction = frustFraction;
        this.worldToViewMap.setFrom(this.calcNpcToView().multiplyMapMap(this.worldToNpcMap));
        this.sync.invalidateRenderPlan();
        this.sync.setValidController();
        this.onViewChanged.raiseEvent(this);
        return 0 /* Success */;
    }
    /** Compute the root-to-npc map given an origin and delta. View orientation and camera comes from member variables. */
    computeRootToNpc(rootToNpc, inOrigin, delta) {
        const view = this.view;
        const viewRot = this.rotMatrix;
        const xVector = viewRot.rowX();
        const yVector = viewRot.rowY();
        const zVector = viewRot.rowZ();
        let frustFraction = 1.0;
        let xExtent;
        let yExtent;
        let zExtent;
        let origin;
        // Compute root vectors along edges of view frustum.
        if (view.is3d() && view.isCameraOn()) {
            const camera = view.camera;
            const eyeToOrigin = geometry_core_1.Vector3d.createStartEnd(camera.eye, inOrigin); // vector from origin on backplane to eye
            this.toView(eyeToOrigin); // align with view coordinates.
            const focusDistance = camera.focusDist;
            let zDelta = delta.z;
            let zBack = eyeToOrigin.z; // Distance from eye to backplane.
            let zFront = zBack + zDelta; // Distance from eye to frontplane.
            if (zFront / zBack < Viewport.nearScale24) {
                const maximumBackClip = 10000 * geometry_core_1.Constant.oneKilometer;
                if (-zBack > maximumBackClip) {
                    zBack = -maximumBackClip;
                    eyeToOrigin.z = zBack;
                }
                zFront = zBack * Viewport.nearScale24;
                zDelta = zFront - eyeToOrigin.z;
            }
            // z out back of eye ====> origin z coordinates are negative.  (Back plane more negative than front plane)
            const backFraction = -zBack / focusDistance; // Perspective fraction at back clip plane.
            const frontFraction = -zFront / focusDistance; // Perspective fraction at front clip plane.
            frustFraction = frontFraction / backFraction;
            // delta.x,delta.y are view rectangle sizes at focus distance.  Scale to back plane:
            xExtent = xVector.scale(delta.x * backFraction); // xExtent at back == delta.x * backFraction.
            yExtent = yVector.scale(delta.y * backFraction); // yExtent at back == delta.y * backFraction.
            // Calculate the zExtent in the View coordinate system.
            zExtent = new geometry_core_1.Vector3d(eyeToOrigin.x * (frontFraction - backFraction), // eyeToOrigin.x * frontFraction - eyeToOrigin.x * backFraction
            eyeToOrigin.y * (frontFraction - backFraction), // eyeToOrigin.y * frontFraction - eyeToOrigin.y * backFraction
            zDelta);
            this.fromView(zExtent); // rotate back to root coordinates.
            origin = new geometry_core_1.Point3d(eyeToOrigin.x * backFraction, // Calculate origin in eye coordinates
            eyeToOrigin.y * backFraction, eyeToOrigin.z);
            this.fromView(origin); // Rotate back to root coordinates
            origin.plus(camera.eye, origin); // Add the eye point.
        }
        else {
            origin = inOrigin;
            xExtent = xVector.scale(delta.x);
            yExtent = yVector.scale(delta.y);
            zExtent = zVector.scale(delta.z);
        }
        // calculate the root-to-npc mapping (using expanded frustum)
        const newRootToNpc = geometry_core_1.Map4d.createVectorFrustum(origin, xExtent, yExtent, zExtent, frustFraction);
        if (!newRootToNpc)
            return undefined;
        rootToNpc.setFrom(newRootToNpc); // Don't screw this up if we are returning ERROR (TR# 251771).
        this.frustFraction = frustFraction;
        return frustFraction;
    }
    /**
     * Check whether the ViewState of this Viewport has changed since the last call to this function.
     * If so, save a *copy* of the **previous** state in the view undo stack for future View Undo.
     */
    saveViewUndo() {
        if (!this._view)
            return;
        // the first time we're called we need to establish the baseline
        if (!this.currentBaseline)
            this.currentBaseline = this.view.clone();
        if (this.view.equalState(this.currentBaseline))
            return; // nothing changed, we're done
        const backStack = this.backStack;
        if (backStack.length >= this.maxUndoSteps)
            backStack.shift(); // remove the oldest entry
        /** Sometimes we get requests to save undo entries from rapid viewing operations (e.g. mouse wheel rolls). To avoid lots of
         * little useless intermediate view undo steps that mean nothing, if we get a call to this within a minimum time (1/2 second by default)
         * we don't add a new entry to the view undo buffer.
         */
        const now = bentleyjs_core_1.BeTimePoint.now();
        if (backStack.length < 1 || backStack[backStack.length - 1].undoTime.plus(Viewport.undoDelay).before(now)) {
            this.currentBaseline.undoTime = now; // save time we put this entry in undo buffer
            this.backStack.push(this.currentBaseline); // save previous state
            this.forwardStack.length = 0; // not possible to do redo after this
        }
        this.currentBaseline = this.view.clone();
    }
    /** Call [[setupFromView]] on this Viewport and save previous state in view undo stack */
    synchWithView(saveInUndo) {
        this.setupFromView();
        if (saveInUndo)
            this.saveViewUndo();
    }
    /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */
    viewToNpcArray(pts) {
        const corners = this.getViewCorners();
        const scrToNpcTran = geometry_core_1.Transform.createIdentity();
        geometry_core_1.Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);
        scrToNpcTran.multiplyPoint3dArrayInPlace(pts);
    }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */
    npcToViewArray(pts) {
        const corners = this.getViewCorners();
        for (const p of pts)
            corners.fractionToPoint(p.x, p.y, p.z, p);
    }
    /**
     * Convert a point from CoordSystem.View to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToNpc(pt, out) {
        const corners = this.getViewCorners();
        const scrToNpcTran = geometry_core_1.Transform.createIdentity();
        geometry_core_1.Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);
        return scrToNpcTran.multiplyPoint3d(pt, out);
    }
    /**
     * Convert a point from CoordSystem.Npc to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToView(pt, out) {
        const corners = this.getViewCorners();
        return corners.fractionToPoint(pt.x, pt.y, pt.z, out);
    }
    /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */
    worldToNpcArray(pts) { this.worldToNpcMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */
    npcToWorldArray(pts) { this.worldToNpcMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View */
    worldToViewArray(pts) { this.worldToViewMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */
    worldToView4dArray(worldPts, viewPts) { this.worldToViewMap.transform0.multiplyPoint3dArray(worldPts, viewPts); }
    /** Convert an array of points from CoordSystem.View to CoordSystem.World */
    viewToWorldArray(pts) { this.worldToViewMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */
    view4dToWorldArray(viewPts, worldPts) { this.worldToViewMap.transform1.multiplyPoint4dArrayQuietRenormalize(viewPts, worldPts); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToNpc(pt, out) { return this.worldToNpcMap.transform0.multiplyPoint3dQuietNormalize(pt, out); }
    /**
     * Convert a point from CoordSystem.Npc to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToWorld(pt, out) { return this.worldToNpcMap.transform1.multiplyPoint3dQuietNormalize(pt, out); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToView(input, out) { return this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(input, out); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.View as Point4d
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point4d is created.
     */
    worldToView4d(input, out) { return this.worldToViewMap.transform0.multiplyPoint3d(input, 1.0, out); }
    /**
     * Convert a point from CoordSystem.View to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToWorld(input, out) { return this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(input, out); }
    /**
     * Convert a point from CoordSystem.View as a Point4d to CoordSystem.View
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    view4dToWorld(input, out) { return this.worldToViewMap.transform1.multiplyXYZWQuietRenormalize(input.x, input.y, input.z, input.w, out); }
    /** Converts inches to pixels based on screen DPI.
     * @Note this information may not be accurate in some browsers.
     * @param inches the number of inches to convert
     * @returns the corresponding number of pixels
     */
    pixelsFromInches(inches) { return inches * this.pixelsPerInch; }
    /**
     * Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.
     *
     * There are two sets of corners that may be of interest.
     * The "adjusted" box is the one that is computed by examining the "viewed extents" and moving
     * the front and back planes to enclose everything in the view.
     * The "unadjusted" box is the one that is stored in the ViewState.
     * @param sys Coordinate system for points
     * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.
     * @param box optional Frustum for return value
     * @return the view frustum
     * @note The "adjusted" box may be either larger or smaller than the "unadjusted" box.
     */
    getFrustum(sys = 2 /* World */, adjustedBox = true, box) {
        box = box ? box.initNpc() : new imodeljs_common_1.Frustum();
        // if they are looking for the "unexpanded" (that is before f/b clipping expansion) box, we need to get the npc
        // coordinates that correspond to the unexpanded box in the npc space of the Expanded view (that's the basis for all
        // of the root-based maps.)
        if (!adjustedBox && this.zClipAdjusted) {
            // to get unexpanded box, we have to go recompute rootToNpc from original View.
            const ueRootToNpc = geometry_core_1.Map4d.createIdentity();
            if (undefined === this.computeRootToNpc(ueRootToNpc, this.viewOriginUnexpanded, this.viewDeltaUnexpanded))
                return box; // invalid frustum
            // get the root corners of the unexpanded box
            const ueRootBox = new imodeljs_common_1.Frustum();
            ueRootToNpc.transform1.multiplyPoint3dArrayQuietNormalize(ueRootBox.points);
            // and convert them to npc coordinates of the expanded view
            this.worldToNpcArray(ueRootBox.points);
            box.setFrom(ueRootBox);
        }
        // now convert from NPC space to the specified coordinate system.
        switch (sys) {
            case 0 /* View */:
                this.npcToViewArray(box.points);
                break;
            case 2 /* World */:
                this.npcToWorldArray(box.points);
                break;
        }
        return box;
    }
    /** Get a copy of the current (adjusted) frustum of this viewport, in world coordinates. */
    getWorldFrustum(box) { return this.getFrustum(2 /* World */, true, box); }
    /**
     * Scroll the view by a given number of pixels.
     * @param screenDist distance to scroll, in pixels
     */
    scroll(screenDist) {
        const view = this.view;
        if (!view)
            return 15 /* InvalidViewport */;
        if (view.is3d() && view.isCameraOn()) {
            const offset = new geometry_core_1.Vector3d(screenDist.x, screenDist.y, 0.0);
            const frust = this.getFrustum(0 /* View */, false);
            frust.translate(offset);
            this.viewToWorldArray(frust.points);
            view.setupFromFrustum(frust);
            view.centerEyePoint();
            return this.setupFromView();
        }
        const pts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d(screenDist.x, screenDist.y, 0)];
        this.viewToWorldArray(pts);
        const dist = pts[1].minus(pts[0]);
        const newOrg = view.getOrigin().plus(dist);
        view.setOrigin(newOrg);
        return this.setupFromView();
    }
    /**
     * Zoom the view by a scale factor, placing the new center at the projection of the given point (world coordinates)
     * on the focal plane.
     * Updates ViewState and re-synchs Viewport. Does not save in view undo buffer.
     */
    zoom(newCenter, factor) {
        const view = this.view;
        if (!view)
            return 15 /* InvalidViewport */;
        if (view.is3d() && view.isCameraOn()) {
            const centerNpc = newCenter ? this.worldToNpc(newCenter) : imodeljs_common_1.NpcCenter.clone();
            const scaleTransform = geometry_core_1.Transform.createFixedPointAndMatrix(centerNpc, geometry_core_1.RotMatrix.createScale(factor, factor, 1.0));
            const offset = centerNpc.minus(imodeljs_common_1.NpcCenter); // offset by difference of old/new center
            offset.z = 0.0; // z center stays the same.
            const offsetTransform = geometry_core_1.Transform.createTranslationXYZ(offset.x, offset.y, offset.z);
            const product = offsetTransform.multiplyTransformTransform(scaleTransform);
            const frust = new imodeljs_common_1.Frustum();
            product.multiplyPoint3dArrayInPlace(frust.points);
            this.npcToWorldArray(frust.points);
            view.setupFromFrustum(frust);
            view.centerEyePoint();
            return this.setupFromView();
        }
        // for non-camera views, do the zooming by adjusting the origin and delta directly so there can be no
        // chance of the rotation changing due to numerical precision errors calculating it from the frustum corners.
        const delta = view.getExtents().clone();
        delta.x *= factor;
        delta.y *= factor;
        // first check to see whether the zoom operation results in an invalid view. If so, make sure we don't change anything
        const validSize = view.validateViewDelta(delta, false);
        if (0 /* Success */ !== validSize)
            return validSize;
        const center = newCenter ? newCenter.clone() : view.getCenter().clone();
        if (!view.allow3dManipulations())
            center.z = 0.0;
        const newOrg = view.getOrigin().clone();
        this.toView(newOrg);
        this.toView(center);
        view.setExtents(delta);
        newOrg.x = center.x - delta.x / 2.0;
        newOrg.y = center.y - delta.y / 2.0;
        this.fromView(newOrg);
        view.setOrigin(newOrg);
        return this.setupFromView();
    }
    /**
     * Zoom the view to a show the tightest box around a given set of elements. Does not change view rotation.
     * @param placements element placement(s). Will zoom to the union of the placements.
     * @param margin the amount of white space to leave around elements
     * @note Updates ViewState and re-synchs Viewport. Does not save in view undo buffer.
     */
    zoomToElements(placements, margin) {
        const viewTransform = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createZero(), this.rotMatrix);
        const elemRange = Array.isArray(placements) ? placements : [placements];
        const hasAngle = (arg) => arg.angle !== undefined;
        const viewRange = new geometry_core_1.Range3d();
        for (const elRange of elemRange) {
            const placement = hasAngle(elRange) ? imodeljs_common_1.Placement2d.fromJSON(elRange) : imodeljs_common_1.Placement3d.fromJSON(elRange);
            const frust = imodeljs_common_1.Frustum.fromRange(placement.bbox);
            viewRange.extendArray(frust.points, viewTransform);
        }
        this.view.lookAtViewAlignedVolume(viewRange, this.viewRect.aspect, margin);
        this.setupFromView();
    }
    /**
     * Zoom the view to a volume of space, in world coordinates.
     * @param volume The low and high corners, in world coordinates.
     * @param margin the amount of white space to leave around elements
     * @note Updates ViewState and re-synchs Viewport. Does not save in view undo buffer.
     */
    zoomToVolume(volume, margin) {
        const range = geometry_core_1.Range3d.fromJSON(volume);
        this.view.lookAtVolume(range, this.viewRect.aspect, margin);
        this.setupFromView();
    }
    /**
     * Shortcut to call view.setupFromFrustum and then [[setupFromView]]
     * @param inFrustum the new viewing frustum
     * @returns true if both steps were successful
     */
    setupViewFromFrustum(inFrustum) {
        const validSize = this.view.setupFromFrustum(inFrustum);
        // note: always call setupFromView, even if setupFromFrustum failed
        return (0 /* Success */ === this.setupFromView() && 0 /* Success */ === validSize);
    }
    /** Clear the view undo buffer and establish the current ViewState as the new baseline. */
    resetUndo() {
        this.clearUndo();
        this.saveViewUndo(); // Set up new baseline state
    }
    /** @hidden */
    computeViewRange() {
        this.setupFromView(); // can't proceed if viewport isn't valid (not active)
        const viewRange = this.view.computeFitRange();
        return viewRange;
    }
    /**
     * Reverses the most recent change to the Viewport from the undo stack.
     */
    doUndo(animationTime) {
        if (0 === this.backStack.length)
            return;
        this.forwardStack.push(this.currentBaseline);
        this.currentBaseline = this.backStack.pop();
        this.applyViewState(this.currentBaseline, animationTime);
    }
    /**
     * Re-applies the most recently un-done change to the Viewport from the redo stack
     */
    doRedo(animationTime) {
        if (0 === this.forwardStack.length)
            return;
        this.backStack.push(this.currentBaseline);
        this.currentBaseline = this.forwardStack.pop();
        this.applyViewState(this.currentBaseline, animationTime);
    }
    /** @hidden */
    animate() {
        if (this.animator && this.animator.animate()) {
            this.animator = undefined;
        }
    }
    /** @hidden */
    removeAnimator() {
        if (this.animator) {
            this.animator.interrupt(); // will be destroyed
            this.animator = undefined;
        }
    }
    setAnimator(animator) {
        this.removeAnimator();
        this.animator = animator;
    }
    /** @hidden */
    animateFrustumChange(start, end, animationTime) {
        if (!animationTime || 0.0 >= animationTime.milliseconds) {
            this.setupViewFromFrustum(end);
            return;
        }
        this.setAnimator(new Animator(animationTime, this, start, end));
    }
    /** @hidden */
    applyViewState(val, animationTime) {
        const startFrust = this.getFrustum();
        this._view = val.clone();
        this.synchWithView(false);
        this.animateFrustumChange(startFrust, this.getFrustum(), animationTime);
    }
    static roundGrid(num, units) {
        const sign = ((num * units) < 0.0) ? -1.0 : 1.0;
        num = (num * sign) / units + 0.5;
        num = units * sign * Math.floor(num);
        return num;
    }
    getGridOrientation(origin, rMatrix) {
        if (this.view.isSpatialView())
            origin.setFrom(this.iModel.globalOrigin);
        switch (this.view.getGridOrientation()) {
            case 0 /* View */: {
                const center = this.view.getCenter();
                this.toView(center);
                this.toView(origin);
                origin.z = center.z;
                this.fromView(origin);
                break;
            }
            case 1 /* WorldXY */:
                break;
            case 2 /* WorldYZ */: {
                geometry_core_1.RotMatrix.createRows(rMatrix.getRow(1), rMatrix.getRow(2), rMatrix.getRow(0), rMatrix);
                break;
            }
            case 3 /* WorldXZ */: {
                geometry_core_1.RotMatrix.createRows(rMatrix.getRow(0), rMatrix.getRow(2), rMatrix.getRow(1), rMatrix);
                break;
            }
        }
    }
    pointToStandardGrid(point, rMatrix, origin) {
        const planeNormal = rMatrix.getRow(2);
        let eyeVec;
        if (this.view.is3d() && this.isCameraOn())
            eyeVec = this.view.camera.eye.vectorTo(point);
        else
            eyeVec = this.rotMatrix.getRow(2).clone();
        eyeVec.normalizeInPlace();
        LegacyMath_1.LegacyMath.linePlaneIntersect(point, point, eyeVec, origin, planeNormal, false);
        // // get origin and point in view coordinate system
        const pointView = point.clone();
        const originView = origin.clone();
        this.toView(pointView);
        this.toView(originView);
        // subtract off the origin
        pointView.y -= originView.y;
        pointView.x -= originView.x;
        // round off the remainder to the grid distances
        const gridSpacing = this.view.getGridSpacing();
        pointView.x = Viewport.roundGrid(pointView.x, gridSpacing.x);
        pointView.y = Viewport.roundGrid(pointView.y, gridSpacing.y);
        // add the origin back in
        pointView.x += originView.x;
        pointView.y += originView.y;
        // go back to root coordinate system
        this.fromView(pointView);
        point.setFrom(pointView);
    }
    /** @hidden */
    pointToGrid(point) {
        if (4 /* AuxCoord */ === this.view.getGridOrientation()) {
            this.pointToStandardGrid(point, this.getAuxCoordRotation(), this.getAuxCoordOrigin());
            return;
        }
        const origin = new geometry_core_1.Point3d();
        const rMatrix = geometry_core_1.RotMatrix.createIdentity();
        this.getGridOrientation(origin, rMatrix);
        this.pointToStandardGrid(point, rMatrix, origin);
    }
    /**
     * Get the width of a pixel (a unit vector in the x direction in view coordinates) at a given point in world coordinates, returning the result in meters (world units).
     *
     * This is most useful to determine how large something is in a view. In particular, in a perspective view
     * the result of this method will be a larger number for points closer to the back of the view Frustum (that is,
     * one pixel of the view represents more spatial area at the back of the Frustum than the front.)
     * @param point The point to test, in World coordinates. If undefined, the center of the view in NPC space is used.
     * @returns The width of a view pixel at the supplied world point, in meters.
     */
    getPixelSizeAtPoint(point) {
        if (point === undefined)
            point = this.npcToWorld(imodeljs_common_1.NpcCenter); // if undefined, use center of view
        const worldPts = [];
        const viewPts = [];
        viewPts[0] = this.worldToView4d(point);
        viewPts[1] = viewPts[0].clone();
        viewPts[1].x += viewPts[1].w; // form a vector one pixel wide in x direction.
        this.view4dToWorldArray(viewPts, worldPts);
        return worldPts[0].distance(worldPts[1]);
    }
    /** Show the surface normal for geometry under the cursor when snapping. */
    static drawLocateHitDetail(context, aperture, hit) {
        if (!context.viewport.view.is3d())
            return; // Not valuable feedback in 2d...
        if (!hit.isSnapDetail() || !hit.normal || hit.isPointAdjusted())
            return; // AccuSnap will flash edge/segment geometry if not a surface hit or snap location has been adjusted...
        const graphic = context.createWorldOverlay();
        const color = imodeljs_common_1.ColorDef.from(255 - context.viewport.hilite.color.colors.r, 255 - context.viewport.hilite.color.colors.g, 255 - context.viewport.hilite.color.colors.b); // Invert hilite color for good contrast...
        const colorFill = color.clone();
        color.setTransparency(100);
        colorFill.setTransparency(200);
        graphic.setSymbology(color, colorFill, 1);
        const radius = (2.5 * aperture) * context.viewport.getPixelSizeAtPoint(hit.snapPoint);
        const rMatrix = geometry_core_1.RotMatrix.createRigidHeadsUp(hit.normal);
        const ellipse = geometry_core_1.Arc3d.createScaledXYColumns(hit.snapPoint, rMatrix, radius, radius, geometry_core_1.AngleSweep.create360());
        graphic.addArc(ellipse, true, true);
        graphic.addArc(ellipse, false, false);
        const length = (0.6 * radius);
        const normal = geometry_core_1.Vector3d.create();
        ellipse.vector0.normalize(normal);
        const pt1 = hit.snapPoint.plusScaled(normal, length);
        const pt2 = hit.snapPoint.plusScaled(normal, -length);
        graphic.addLineString([pt1, pt2]);
        ellipse.vector90.normalize(normal);
        const pt3 = hit.snapPoint.plusScaled(normal, length);
        const pt4 = hit.snapPoint.plusScaled(normal, -length);
        graphic.addLineString([pt3, pt4]);
        context.addWorldOverlay(graphic.finish());
    }
    /** draw a filled and outlined circle to represent the size of the location tolerance in the current view. */
    static drawLocateCircle(context, aperture, pt) {
        const graphic = context.createViewOverlay();
        const white = imodeljs_common_1.ColorDef.white.clone();
        const black = imodeljs_common_1.ColorDef.black.clone();
        const radius = (aperture / 2.0) + .5;
        const center = context.viewport.worldToView(pt);
        const ellipse = geometry_core_1.Arc3d.createXYEllipse(center, radius, radius);
        const ellipse2 = geometry_core_1.Arc3d.createXYEllipse(center, radius + 1, radius + 1);
        white.setTransparency(165);
        graphic.setSymbology(white, white, 1);
        graphic.addArc2d(ellipse, true, true, 0.0);
        black.setTransparency(100);
        graphic.setSymbology(black, black, 1);
        graphic.addArc2d(ellipse2, false, false, 0.0);
        white.setTransparency(20);
        graphic.setSymbology(white, white, 1);
        graphic.addArc2d(ellipse, false, false, 0.0);
        context.addViewOverlay(graphic.finish());
    }
    /** @hidden */
    drawLocateCursor(context, pt, aperture, isLocateCircleOn, hit) {
        if (hit)
            Viewport.drawLocateHitDetail(context, aperture, hit);
        if (isLocateCircleOn)
            Viewport.drawLocateCircle(context, aperture, pt);
    }
    /** Get a color that will contrast to the current background color of this Viewport. Either Black or White depending on which will have the most contrast. */
    getContrastToBackgroundColor() {
        const bgColor = this.view.backgroundColor.colors;
        const invert = ((bgColor.r + bgColor.g + bgColor.b) > (255 * 3) / 2);
        return invert ? imodeljs_common_1.ColorDef.black : imodeljs_common_1.ColorDef.white; // should we use black or white?
    }
    processFlash() {
        let needsFlashUpdate = false;
        if (this.flashedElem !== this.lastFlashedElem) {
            this.flashIntensity = 0.0;
            this.flashUpdateTime = bentleyjs_core_1.BeTimePoint.now();
            this.lastFlashedElem = this.flashedElem; // flashing has begun; this is now the previous flash
            needsFlashUpdate = this.flashedElem === undefined; // notify render thread that flash has been turned off (signified by undefined elem)
        }
        if (this.flashedElem !== undefined && this.flashIntensity < 1.0) {
            const flashDuration = bentleyjs_core_1.BeDuration.fromSeconds(this.flashDuration);
            const flashElapsed = bentleyjs_core_1.BeTimePoint.now().milliseconds - this.flashUpdateTime.milliseconds;
            this.flashIntensity = Math.min(flashElapsed, flashDuration.milliseconds) / flashDuration.milliseconds; // how intense do we want the flash effect to be from [0..1]?
            needsFlashUpdate = true;
        }
        return needsFlashUpdate;
    }
    /** @hidden */
    renderFrame(plan) {
        const sync = this.sync;
        const view = this.view;
        const target = this.target;
        // Start timer for tile loading time
        const timer = new bentleyjs_core_1.StopWatch(undefined, true);
        this.animate();
        // Allow ViewState instance to change any state which might affect logic below...
        view.onRenderFrame(this);
        let isRedrawNeeded = sync.isRedrawPending || this._doContinuousRendering;
        sync.invalidateRedrawPending();
        if (target.updateViewRect()) {
            target.onResized();
            sync.invalidateController();
        }
        if (view.isSelectionSetDirty) {
            if ((0 === view.iModel.hilited.size && 0 === view.iModel.selectionSet.size) || (view.iModel.hilited.size > 0 && 0 === view.iModel.selectionSet.size)) {
                target.setHiliteSet(view.iModel.hilited.elements); // only hilited has elements to send (or empty)
            }
            else if (0 === view.iModel.hilited.size && view.iModel.selectionSet.size > 0) {
                target.setHiliteSet(view.iModel.selectionSet.elements); // only selectionSet has elements to send
            }
            else {
                const allHilites = new Set();
                view.iModel.hilited.elements.forEach((val) => allHilites.add(val));
                view.iModel.selectionSet.elements.forEach((val) => allHilites.add(val));
                target.setHiliteSet(allHilites);
            }
            view.setSelectionSetDirty(false);
            isRedrawNeeded = true;
        }
        if (view.areFeatureOverridesDirty) {
            const ovrs = new FeatureSymbology_1.FeatureSymbology.Overrides(view);
            if (undefined !== this._addFeatureOverrides)
                this._addFeatureOverrides(ovrs, this);
            target.overrideFeatureSymbology(ovrs);
            view.setFeatureOverridesDirty(false);
            isRedrawNeeded = true;
        }
        if (!sync.isValidController)
            this.setupFromView();
        if (!sync.isValidScene) {
            const context = new ViewContext_1.SceneContext(this, new TileTree_1.TileRequests());
            view.createScene(context);
            // ###TODO: request missing tiles
            target.changeScene(context.graphics);
            isRedrawNeeded = true;
            sync.setValidScene();
            // ###TODO? IModelApp.viewManager.notifyRenderSceneQueued(this);
        }
        if (!sync.isValidRenderPlan) {
            target.changeRenderPlan(new System_1.RenderPlan(this));
            sync.setValidRenderPlan();
            isRedrawNeeded = true;
        }
        if (!sync.isValidDecorations) {
            const decorations = new System_1.Decorations();
            this.prepareDecorations(plan, decorations);
            target.changeDecorations(decorations);
            isRedrawNeeded = true;
        }
        if (this.processFlash()) {
            target.setFlashed(new bentleyjs_core_1.Id64(this.flashedElem), this.flashIntensity);
            isRedrawNeeded = true;
        }
        timer.stop();
        if (isRedrawNeeded)
            target.drawFrame(this._doContinuousRendering ? timer.elapsed.milliseconds : undefined);
        return true;
    }
    /** @hidden */
    prepareDecorations(plan, decorations) {
        this.sync.setValidDecorations();
        if (plan.wantDecorators) {
            const context = new ViewContext_1.DecorateContext(this, decorations);
            IModelApp_1.IModelApp.viewManager.callDecorators(context);
        }
    }
    /** @hidden */
    decorate(context) {
        this.view.decorate(context);
        this.view.drawGrid(context);
        if (context.viewFlags.showAcsTriad())
            this.view.auxiliaryCoordinateSystem.display(context, (8 /* CheckVisible */ | 1 /* Active */));
    }
    /** @hidden */
    requestScene(_plan) { }
    /**
     * Read selected data about each pixel within a rectangular region of the viewport.
     * @param rect The area of the viewport's contents to read. The origin specifies the upper-left corner. Must lie entirely within the viewport's dimensions.
     * @param selector Specifies which aspect(s) of data to read.
     * @returns a Pixel.Buffer object from which the selected data can be retrieved, or undefined in the viewport is not active, the rect is out of bounds, or some other error.
     */
    readPixels(rect, selector) {
        const viewRect = this.viewRect;
        if (!rect.isContained(viewRect))
            return undefined;
        return this.target.readPixels(rect, selector);
    }
    /**
     * Attempt to determine the nearest visible geometry point within radius of supplied pick point.
     * @param pickPoint Center point in world coordinates
     * @param radius Integer radius of the circular area to include, in pixels
     * @param out Optional Point3d pre-allocated to hold the result
     * @returns the coordinates of the point within the circular area which is closest to the camera.
     */
    determineNearestVisibleGeometryPoint(pickPoint, radius, out) {
        radius = Math.floor(radius + 0.5);
        const inView = this.worldToView(pickPoint);
        const viewCenter = new geometry_core_1.Point2d(Math.floor(inView.x + 0.5), Math.floor(inView.y + 0.5));
        const viewRect = this.viewRect;
        const pickRect = new ViewRect(viewCenter.x - radius, viewCenter.y - radius, viewCenter.x + radius + 1, viewCenter.y + radius + 1);
        const overlapRect = pickRect.computeOverlap(viewRect);
        if (undefined === overlapRect)
            return undefined;
        const pixels = this.readPixels(overlapRect, 2 /* Distance */);
        if (undefined === pixels)
            return undefined;
        const testPoint = new geometry_core_1.Point2d();
        const result = undefined !== out ? out : new geometry_core_1.Point3d();
        for (testPoint.x = viewCenter.x - radius; testPoint.x <= viewCenter.x + radius; testPoint.x++) {
            for (testPoint.y = viewCenter.y - radius; testPoint.y <= viewCenter.y + radius; testPoint.y++) {
                if (overlapRect.containsPoint(testPoint) && this.getPixelDataWorldPoint(pixels, testPoint.x, testPoint.y, result))
                    return result;
            }
        }
        return undefined;
    }
    getPixelDataWorldPoint(pixels, x, y, out) {
        const npc = this.getPixelDataNpcPoint(pixels, x, y, out);
        if (undefined !== npc)
            this.npcToWorld(npc, npc);
        return npc;
    }
    getPixelDataNpcPoint(pixels, x, y, out) {
        const z = pixels.getPixel(x, y).distanceFraction;
        if (z <= 0.0)
            return undefined;
        const result = undefined !== out ? out : new geometry_core_1.Point3d();
        const viewRect = this.viewRect;
        result.x = (x + 0.5 - viewRect.left) / viewRect.width;
        result.y = 1.0 - (y + 0.5 - viewRect.top) / viewRect.height;
        if (this.frustFraction < 1.0)
            result.z = z * this.frustFraction / (1.0 + z * (this.frustFraction - 1.0)); // correct to npc if camera on.
        else
            result.z = z;
        return result;
    }
}
/** Maximum ratio of frontplane to backplane distance for 24 bit zbuffer */
Viewport.nearScale24 = 0.0003;
/** Don't allow entries in the view undo buffer unless they're separated by more than this amount of time. */
Viewport.undoDelay = bentleyjs_core_1.BeDuration.fromSeconds(.5);
Viewport.copyOutput = (from, to) => { let pt = from; if (to) {
    to.setFrom(from);
    pt = to;
} return pt; };
Viewport.scratchDefaultRotatePointLow = new geometry_core_1.Point3d(.5, .5, .5);
Viewport.scratchDefaultRotatePointHigh = new geometry_core_1.Point3d(.5, .5, .5);
exports.Viewport = Viewport;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const CachedGeometry_1 = __webpack_require__(29);
const System_1 = __webpack_require__(7);
const bentleyjs_core_1 = __webpack_require__(0);
const Surface_1 = __webpack_require__(127);
const isShaderBitSet = `
bool isShaderBitSet(float flag) { return 0.0 != extractNthBit(floor(u_shaderFlags + 0.5), flag); }
`;
function addShaderFlagsLookup(shader) {
    shader.addConstant("kShaderBit_Monochrome", 3 /* Float */, "0.0");
    shader.addConstant("kShaderBit_NonUniformColor", 3 /* Float */, "1.0");
    shader.addConstant("kShaderBit_OITFlatAlphaWeight", 3 /* Float */, "2.0");
    shader.addConstant("kShaderBit_OITScaleOutput", 3 /* Float */, "3.0");
    shader.addFunction(GLSLCommon.extractNthBit);
    shader.addFunction(isShaderBitSet);
}
function setShaderFlags(uniform, params) {
    bentleyjs_core_1.assert(params.geometry instanceof CachedGeometry_1.LUTGeometry);
    const geom = params.geometry;
    let flags = params.target.currentShaderFlags;
    const color = geom.getColor(params.target);
    if (color.isNonUniform)
        flags |= 2 /* NonUniformColor */;
    // Certain textures render in the translucent pass but we actually want to maintain true opacity for opaque pixels.
    // For these, use a constant Z to calculate alpha weight.  Otherwise, the opaque things in the texture are weighted by their Z due
    // to the nature of the OIT algorithm.  In this case, we set OITFlatAlphaWeight.
    // Since RGBA8 rendering is very low precision, if we are using that kind of output, we also want to flatten alpha weight.
    // Otherwise, the very tiny Z range makes things fade to black as the precision limit is encountered.  This workaround disregards Z
    // in calculating the color, so it means that transparency is less accurate based on Z-ordering, but it is the best we can do with
    // this algorithm on low-end hardware.
    const maxRenderType = System_1.System.instance.capabilities.maxRenderType;
    const surface = params.geometry instanceof Surface_1.SurfaceGeometry ? params.geometry : undefined;
    if ((undefined !== surface && (surface.isGlyph || surface.isTileSection)) || 0 /* TextureUnsignedByte */ === maxRenderType)
        flags |= 4 /* OITFlatAlphaWeight */;
    // If Cesium-style transparency is being used with non-float texture targets, we must scale the output in the shaders to 0-1 range.
    // Otherwise, it will get implicitly clamped to that range and we'll lose any semblance our desired precision (even though it is low).
    if (maxRenderType < 1 /* TextureHalfFloat */)
        flags |= 8 /* OITScaleOutput */;
    uniform.setUniform1f(flags);
}
function addShaderFlags(builder) {
    addShaderFlagsLookup(builder.vert);
    addShaderFlagsLookup(builder.frag);
    builder.addUniform("u_shaderFlags", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_shaderFlags", (uniform, params) => { setShaderFlags(uniform, params); });
    });
}
exports.addShaderFlags = addShaderFlags;
function addFrustum(builder) {
    builder.addUniform("u_frustum", 5 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_frustum", (uniform, params) => {
            uniform.setUniform3fv(params.target.frustumUniforms.frustum);
        });
    });
    builder.addGlobal("kFrustumType_Ortho2d", 3 /* Float */, 3 /* Both */, "0.0", true);
    builder.addGlobal("kFrustumType_Ortho3d", 3 /* Float */, 3 /* Both */, "1.0", true);
    builder.addGlobal("kFrustumType_Perspective", 3 /* Float */, 3 /* Both */, "2.0", true);
}
exports.addFrustum = addFrustum;
var GLSLCommon;
(function (GLSLCommon) {
    // Expects flags in range [0...256] with no fraction; and bit is [0..31] with no fraction.
    // Returns 1.0 if the nth bit is set, 0.0 otherwise.
    // dividing flags by 2^(n+1) yields #.5##... if the nth bit is set, #.0##... otherwise
    // Taking the fractional part yields 0.5##...
    // Multiplying by 2.0 and taking the floor yields 1.0 or 0.0
    GLSLCommon.extractNthBit = `
float extractNthBit(float flags, float n) {
  float denom = pow(2.0, n+1.0);
  return floor(fract(flags/denom)*2.0);
}
`;
    // TFS#794899 and related...float values of 0.0 or 1.0 used to indicate false/true apparently do not
    // get precisely preserved when interpolated to fragment shader despite all triangles producing
    // same values. Use this to work around it and make it clear what the code is actually doing.
    GLSLCommon.floatToBool = "\nbool floatToBool(float f) { return floor(f + 0.5) > 0.0; }\n";
})(GLSLCommon = exports.GLSLCommon || (exports.GLSLCommon = {}));


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
/** 4 Dimensional point (x,y,z,w) used in perspective calculations.
 * * the coordinates are stored in a Float64Array of length 4.
 * * properties `x`, `y`, `z`, `w` access array members.
 * *
 */
class Point4d {
    /** Set x,y,z,w of this point.  */
    set(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
        return this;
    }
    /** @returns Return the x component of this point. */
    get x() { return this.xyzw[0]; }
    set x(val) { this.xyzw[0] = val; }
    /** @returns Return the y component of this point. */
    get y() { return this.xyzw[1]; }
    set y(val) { this.xyzw[1] = val; }
    /** @returns Return the z component of this point. */
    get z() { return this.xyzw[2]; }
    set z(val) { this.xyzw[2] = val; }
    /** @returns Return the w component of this point. */
    get w() { return this.xyzw[3]; }
    set w(val) { this.xyzw[3] = val; }
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw = new Float64Array(4);
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
    }
    /** @returns Return a Point4d with specified x,y,z,w */
    static create(x = 0, y = 0, z = 0, w = 0, result) {
        return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);
    }
    setFrom(other) {
        this.xyzw[0] = other.xyzw[0];
        this.xyzw[1] = other.xyzw[1];
        this.xyzw[2] = other.xyzw[2];
        this.xyzw[3] = other.xyzw[3];
        return this;
    }
    clone(result) {
        return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    setFromJSON(json) {
        if (Geometry_1.Geometry.isNumberArray(json, 4))
            this.set(json[0], json[1], json[2], json[3]);
        else
            this.set(0, 0, 0, 0);
    }
    static fromJSON(json) {
        const result = new Point4d();
        result.setFromJSON(json);
        return result;
    }
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z)
            && Geometry_1.Geometry.isSameCoordinate(this.w, other.w);
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [[x,y,z,w]
     */
    toJSON() {
        return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];
    }
    /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceXYZW(other) {
        return Geometry_1.Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceSquaredXYZW(other) {
        return Geometry_1.Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the largest absolute distance between corresponding components
     * * x,y,z,w all participate without normalization.
     */
    maxDiff(other) {
        return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));
    }
    /** @returns Return the largest absolute entry of all 4 components x,y,z,w */
    maxAbs() {
        return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));
    }
    /**  @returns Returns the magnitude including all 4 components x,y,z,w */
    magnitudeXYZW() {
        return Geometry_1.Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    /** @returns Return the difference (this-other) using all 4 components x,y,z,w */
    minus(other, result) {
        return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);
    }
    /** @returns Return ((other.w \* this) -  (this.w \* other)) */
    crossWeightedMinus(other, result) {
        const wa = this.xyzw[3];
        const wb = other.xyzw[3];
        return PointVector_1.Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);
    }
    /** @returns Return the sum of this and other, using all 4 components x,y,z,w */
    plus(other, result) {
        return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);
    }
    isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxAbs());
    }
    static createZero() { return new Point4d(0, 0, 0, 0); }
    /**
     * extract 4 consecutive numbers from a Float64Array into a Point4d.
     * @param data buffer of numbers
     * @param xIndex first index for x,y,z,w sequence
     */
    static createFromPackedXYZW(data, xIndex = 0) {
        return new Point4d(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3]);
    }
    static createFromPointAndWeight(xyz, w) {
        return new Point4d(xyz.x, xyz.y, xyz.z, w);
    }
    /** Return point + vector \* scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);
    }
    /** Return point + vectorA \* scalarA + vectorB \* scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return point + vectorA \* scalarA + vectorB \* scalarB + vectorC \* scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    /** Return point + vectorA \* scalarA + vectorB \* scalarB */
    static add2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return point + vectorA \* scalarA + vectorB \* scalarB + vectorC \* scalarC */
    static add3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +
            (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +
            (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +
            (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);
    }
    dotProduct(other) {
        return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];
    }
    dotProductXYZW(x, y, z, w) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;
    }
    /** unit X vector */
    static unitX() { return new Point4d(1, 0, 0, 0); }
    /** unit Y vector */
    static unitY() { return new Point4d(0, 1, 0, 0); }
    /** unit Z vector */
    static unitZ() { return new Point4d(0, 0, 1, 0); }
    /** unit W vector */
    static unitW() { return new Point4d(0, 0, 0, 1); }
    // Divide by denominator, but return undefined if denominator is zero.
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /** scale all components (including w!!) */
    scale(scale, result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = this.xyzw[0] * scale;
        result.xyzw[1] = this.xyzw[1] * scale;
        result.xyzw[2] = this.xyzw[2] * scale;
        result.xyzw[3] = this.xyzw[3] * scale;
        return result;
    }
    /** Negate components (including w!!) */
    negate(result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = -this.xyzw[0];
        result.xyzw[1] = -this.xyzw[1];
        result.xyzw[2] = -this.xyzw[2];
        result.xyzw[3] = -this.xyzw[3];
        return result;
    }
    normalizeWeight(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
    realPoint(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return undefined;
        result = result ? result : new PointVector_1.Point3d();
        const a = 1.0 / mag;
        result.set(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a);
        return result;
    }
    realPointDefault000(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return PointVector_1.Point3d.create(0, 0, 0, result);
        result = result ? result : new PointVector_1.Point3d();
        const a = 1.0 / mag;
        return PointVector_1.Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);
    }
    /** divide all components (x,y,z,w) by the 4d magnitude.
     *
     * * This is appropriate for normalizing a quaternion
     * * Use normalizeWeight to divide by the w component.
     */
    normalizeXYZW(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitudeXYZW());
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
} // DPoint4d
exports.Point4d = Point4d;
class Matrix4d {
    constructor() { this.coffs = new Float64Array(16); }
    setFrom(other) {
        for (let i = 0; i < 16; i++)
            this.coffs[i] = other.coffs[i];
    }
    clone() {
        const result = new Matrix4d();
        for (let i = 0; i < 16; i++)
            result.coffs[i] = this.coffs[i];
        return result;
    }
    /** zero this matrix4d in place. */
    setZero() {
        for (let i = 0; i < 16; i++)
            this.coffs[i] = 0;
    }
    /** set to identity. */
    setIdentity() {
        for (let i = 0; i < 16; i++)
            this.coffs[i] = 0;
        this.coffs[0] = this.coffs[5] = this.coffs[10] = this.coffs[15] = 1.0;
    }
    static is1000(a, b, c, d, tol) {
        return Math.abs(a - 1.0) <= tol
            && Math.abs(b) <= tol
            && Math.abs(c) <= tol
            && Math.abs(d) <= tol;
    }
    /** set to identity. */
    isIdentity(tol = 1.0e-10) {
        return Matrix4d.is1000(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], tol)
            && Matrix4d.is1000(this.coffs[5], this.coffs[6], this.coffs[7], this.coffs[4], tol)
            && Matrix4d.is1000(this.coffs[10], this.coffs[11], this.coffs[8], this.coffs[9], tol)
            && Matrix4d.is1000(this.coffs[15], this.coffs[12], this.coffs[13], this.coffs[14], tol);
    }
    /** create a Matrix4d filled with zeros. */
    static createZero(result) {
        if (result) {
            result.setZero();
            return result;
        }
        return new Matrix4d(); // this is zero.
    }
    /** create a Matrix4d with values supplied "across the rows" */
    static createRowValues(cxx, cxy, cxz, cxw, cyx, cyy, cyz, cyw, czx, czy, czz, czw, cwx, cwy, cwz, cww, result) {
        result = result ? result : new Matrix4d();
        result.coffs[0] = cxx;
        result.coffs[1] = cxy;
        result.coffs[2] = cxz;
        result.coffs[3] = cxw;
        result.coffs[4] = cyx;
        result.coffs[5] = cyy;
        result.coffs[6] = cyz;
        result.coffs[7] = cyw;
        result.coffs[8] = czx;
        result.coffs[9] = czy;
        result.coffs[10] = czz;
        result.coffs[11] = czw;
        result.coffs[12] = cwx;
        result.coffs[13] = cwy;
        result.coffs[14] = cwz;
        result.coffs[15] = cww;
        return result;
    }
    /** directly set columns from typical 3d data:
     *
     * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.
     * * origin as column3, with weight 1
     */
    setOriginAndVectors(origin, vectorX, vectorY, vectorZ) {
        this.coffs[0] = vectorX.x;
        this.coffs[1] = vectorY.x;
        this.coffs[2] = vectorZ.x;
        this.coffs[3] = origin.x;
        this.coffs[4] = vectorX.y;
        this.coffs[5] = vectorY.y;
        this.coffs[6] = vectorZ.y;
        this.coffs[7] = origin.y;
        this.coffs[8] = vectorX.z;
        this.coffs[9] = vectorY.z;
        this.coffs[10] = vectorZ.z;
        this.coffs[11] = origin.z;
        this.coffs[12] = 0.0;
        this.coffs[13] = 0.0;
        this.coffs[14] = 0.0;
        this.coffs[15] = 1.0;
    }
    /** promote a transform to full Matrix4d (with 0001 in final row) */
    static createTransform(source, result) {
        const matrix = source.matrix;
        const point = source.origin;
        return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);
    }
    /** return an identity matrix. */
    static createIdentity(result) {
        result = Matrix4d.createZero(result);
        result.coffs[0] = 1.0;
        result.coffs[5] = 1.0;
        result.coffs[10] = 1.0;
        result.coffs[15] = 1.0;
        return result;
    }
    /** return matrix with translation directly inserted (along with 1 on diagonal) */
    static createTranslationXYZ(x, y, z, result) {
        result = Matrix4d.createZero(result);
        result.coffs[0] = 1.0;
        result.coffs[5] = 1.0;
        result.coffs[10] = 1.0;
        result.coffs[15] = 1.0;
        result.coffs[3] = x;
        result.coffs[7] = y;
        result.coffs[11] = z;
        return result;
    }
    /**
     * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)
     * @param tx x entry for translation column
     * @param ty y entry for translation column
     * @param tz z entry for translation column
     * @param scaleX x diagonal entry
     * @param scaleY y diagonal entry
     * @param scaleZ z diagonal entry
     * @param result optional result.
     */
    static createTranslationAndScaleXYZ(tx, ty, tz, scaleX, scaleY, scaleZ, result) {
        return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);
    }
    /**
     * Create a mapping the scales and translates (no rotation) from box A to boxB
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxToBox(lowA, highA, lowB, highB, result) {
        const ax = highA.x - lowA.x;
        const ay = highA.y - lowA.y;
        const az = highA.z - lowA.z;
        const bx = highB.x - lowB.x;
        const by = highB.y - lowB.y;
        const bz = highB.z - lowB.z;
        const abx = Geometry_1.Geometry.conditionalDivideFraction(bx, ax);
        const aby = Geometry_1.Geometry.conditionalDivideFraction(by, ay);
        const abz = Geometry_1.Geometry.conditionalDivideFraction(bz, az);
        if (abx !== undefined && aby !== undefined && abz !== undefined) {
            return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);
        }
        return undefined;
    }
    setFromJSON(json) {
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 4, 4))
            for (let i = 0; i < 4; ++i) {
                for (let j = 0; j < 4; ++j)
                    this.coffs[i * 4 + j] = json[i][j];
            }
        else
            this.setZero();
    }
    /**
     * Return the largest (absolute) difference between this and other Matrix4d.
     * @param other matrix to compare to
     */
    maxDiff(other) {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));
        return a;
    }
    /**
     * Return the largest absolute value in the Matrix4d
     */
    maxAbs() {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this.coffs[i]));
        return a;
    }
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /**
     * Convert an Matrix4d to a Matrix4dProps.
     */
    toJSON() {
        const value = [];
        for (let i = 0; i < 4; ++i) {
            const row = i * 4;
            value.push([this.coffs[row], this.coffs[row + 1], this.coffs[row + 2], this.coffs[row + 3]]);
        }
        return value;
    }
    static fromJSON(json) {
        const result = new Matrix4d();
        result.setFromJSON(json);
        return result;
    }
    getSteppedPoint(i0, step, result) {
        return Point4d.create(this.coffs[i0], this.coffs[i0 + step], this.coffs[i0 + 2 * step], this.coffs[i0 + 3 * step], result);
    }
    /** @returns Return column 0 as Point4d. */
    columnX() { return this.getSteppedPoint(0, 4); }
    /** @returns Return column 1 as Point4d. */
    columnY() { return this.getSteppedPoint(1, 4); }
    /** @returns Return column 2 as Point4d. */
    columnZ() { return this.getSteppedPoint(2, 4); }
    /** @returns Return column 3 as Point4d. */
    columnW() { return this.getSteppedPoint(3, 4); }
    /** @returns Return row 0 as Point4d. */
    rowX() { return this.getSteppedPoint(0, 1); }
    /** @returns Return row 1 as Point4d. */
    rowY() { return this.getSteppedPoint(4, 1); }
    /** @returns Return row 2 as Point4d. */
    rowZ() { return this.getSteppedPoint(8, 1); }
    /** @returns Return row 3 as Point4d. */
    rowW() { return this.getSteppedPoint(12, 1); }
    diagonal() { return this.getSteppedPoint(0, 5); }
    weight() { return this.coffs[15]; }
    matrixPart() {
        return Transform_1.RotMatrix.createRowValues(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[4], this.coffs[5], this.coffs[6], this.coffs[8], this.coffs[9], this.coffs[10]);
    }
    /** multiply this * other. */
    multiplyMatrixMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 4; k++)
                result.coffs[i0 + k] =
                    this.coffs[i0] * other.coffs[k] +
                        this.coffs[i0 + 1] * other.coffs[k + 4] +
                        this.coffs[i0 + 2] * other.coffs[k + 8] +
                        this.coffs[i0 + 3] * other.coffs[k + 12];
        }
        return result;
    }
    /** multiply this * transpose(other). */
    multiplyMatrixMatrixTranspose(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 16; k += 4)
                result.coffs[j++] =
                    this.coffs[i0] * other.coffs[k] +
                        this.coffs[i0 + 1] * other.coffs[k + 1] +
                        this.coffs[i0 + 2] * other.coffs[k + 2] +
                        this.coffs[i0 + 3] * other.coffs[k + 3];
        }
        return result;
    }
    /** multiply transpose (this) * other. */
    multiplyMatrixTransposeMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 4; i0 += 1) {
            for (let k0 = 0; k0 < 4; k0 += 1)
                result.coffs[j++] =
                    this.coffs[i0] * other.coffs[k0] +
                        this.coffs[i0 + 4] * other.coffs[k0 + 4] +
                        this.coffs[i0 + 8] * other.coffs[k0 + 8] +
                        this.coffs[i0 + 12] * other.coffs[k0 + 12];
        }
        return result;
    }
    /** Return a transposed matrix. */
    cloneTransposed(result) {
        return Matrix4d.createRowValues(this.coffs[0], this.coffs[4], this.coffs[8], this.coffs[12], this.coffs[1], this.coffs[5], this.coffs[9], this.coffs[13], this.coffs[2], this.coffs[6], this.coffs[10], this.coffs[14], this.coffs[3], this.coffs[7], this.coffs[11], this.coffs[15], result);
    }
    /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyXYZW(x, y, z, w, result) {
        result = result ? result : Point4d.createZero();
        return result.set(this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z + this.coffs[3] * w, this.coffs[4] * x + this.coffs[5] * y + this.coffs[6] * z + this.coffs[7] * w, this.coffs[8] * x + this.coffs[9] * y + this.coffs[10] * z + this.coffs[11] * w, this.coffs[12] * x + this.coffs[13] * y + this.coffs[14] * z + this.coffs[15] * w);
    }
    /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3d(pt, w, result) {
        return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);
    }
    /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3dArray(pts, results, w = 1.0) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });
    }
    /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyTransposeXYZW(x, y, z, w, result) {
        result = result ? result : Point4d.createZero();
        return result.set(this.coffs[0] * x + this.coffs[4] * y + this.coffs[8] * z + this.coffs[12] * w, this.coffs[1] * x + this.coffs[5] * y + this.coffs[9] * z + this.coffs[13] * w, this.coffs[2] * x + this.coffs[6] * y + this.coffs[10] * z + this.coffs[14] * w, this.coffs[3] * x + this.coffs[7] * y + this.coffs[11] * z + this.coffs[15] * w);
    }
    /** @returns dot product of row rowIndex of this with column columnIndex of other.
     */
    rowDotColumn(rowIndex, other, columnIndex) {
        const i = rowIndex * 4;
        const j = columnIndex;
        return this.coffs[i] * other.coffs[j]
            + this.coffs[i + 1] * other.coffs[j + 4]
            + this.coffs[i + 2] * other.coffs[j + 8]
            + this.coffs[i + 3] * other.coffs[j + 12];
    }
    /** @returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    rowDotRow(rowIndexThis, other, rowIndexOther) {
        const i = rowIndexThis * 4;
        const j = rowIndexOther * 4;
        return this.coffs[i] * other.coffs[j]
            + this.coffs[i + 1] * other.coffs[j + 1]
            + this.coffs[i + 2] * other.coffs[j + 2]
            + this.coffs[i + 3] * other.coffs[j + 3];
    }
    /** @returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    columnDotColumn(columnIndexThis, other, columnIndexOther) {
        const i = columnIndexThis;
        const j = columnIndexOther;
        return this.coffs[i] * other.coffs[j]
            + this.coffs[i + 4] * other.coffs[j + 4]
            + this.coffs[i + 8] * other.coffs[j + 8]
            + this.coffs[i + 12] * other.coffs[j + 12];
    }
    /** @returns dot product of column columnIndexThis of this with row rowIndexOther other.
     */
    columnDotRow(columnIndexThis, other, rowIndexOther) {
        const i = columnIndexThis;
        const j = 4 * rowIndexOther;
        return this.coffs[i] * other.coffs[j]
            + this.coffs[i + 4] * other.coffs[j + 1]
            + this.coffs[i + 8] * other.coffs[j + 2]
            + this.coffs[i + 12] * other.coffs[j + 3];
    }
    /** @returns return a matrix entry by row and column index.
     */
    atIJ(rowIndex, columnIndex) {
        return this.coffs[rowIndex * 4 + columnIndex];
    }
    /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.
     * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.
     */
    multiplyXYZWQuietRenormalize(x, y, z, w, result) {
        result = result ? result : PointVector_1.Point3d.createZero();
        result.set(this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z + this.coffs[3] * w, this.coffs[4] * x + this.coffs[5] * y + this.coffs[6] * z + this.coffs[7] * w, this.coffs[8] * x + this.coffs[9] * y + this.coffs[10] * z + this.coffs[11] * w);
        const w1 = this.coffs[12] * x + this.coffs[13] * y + this.coffs[14] * z + this.coffs[15] * w;
        if (!Geometry_1.Geometry.isSmallMetricDistance(w1)) {
            const a = 1.0 / w1;
            result.x *= a;
            result.y *= a;
            result.z *= a;
        }
        return result;
    }
    /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */
    multiplyPoint4dArrayQuietRenormalize(pts, results) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyPoint4d(point, result) {
        return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyTransposePoint4d(point, result) {
        return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply matrix * point. This produces a weighted xyzw.
     * Immediately renormalize back to xyz and return (with optional result convention).
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dQuietNormalize(point, result) {
        return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);
    }
    /** multiply each matrix * points[i].   This produces a weighted xyzw.
     * Immediately renormalize back to xyz and replace the original point.
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dArrayQuietNormalize(points) {
        points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));
    }
    addMomentsInPlace(x, y, z, w) {
        this.coffs[0] += x * x;
        this.coffs[1] += x * y;
        this.coffs[2] += x * z;
        this.coffs[3] += x * w;
        this.coffs[4] += y * x;
        this.coffs[5] += y * y;
        this.coffs[6] += y * z;
        this.coffs[7] += y * w;
        this.coffs[8] += z * x;
        this.coffs[9] += z * y;
        this.coffs[10] += z * z;
        this.coffs[11] += z * w;
        this.coffs[12] += w * x;
        this.coffs[13] += w * y;
        this.coffs[14] += w * z;
        this.coffs[15] += w * w;
    }
    /** accumulate all coefficients of other to this. */
    addScaledInPlace(other, scale = 1.0) {
        for (let i = 0; i < 16; i++)
            this.coffs[i] += scale * other.coffs[i];
    }
    /**
     * Add scale times rowA to rowB.
     * @param rowIndexA row that is not modified
     * @param rowIndexB row that is modified.
     * @param firstColumnIndex first column modified.  All from there to the right are updated
     * @param scale scale
     */
    rowOperation(rowIndexA, rowIndexB, firstColumnIndex, scale) {
        if (scale === 0.0)
            return;
        let iA = rowIndexA * 4 + firstColumnIndex;
        let iB = rowIndexB * 4 + firstColumnIndex;
        for (let i = firstColumnIndex; i < 4; i++, iA++, iB++)
            this.coffs[iB] += scale * this.coffs[iA];
    }
    /** Compute an inverse matrix.
     * * This uses simple Bauss-Jordan elimination -- no pivot.
     * @returns undefined if 1/pivot becomes too large. (i.e. apparent 0 pivot)
     */
    createInverse() {
        const work = this.clone();
        const inverse = Matrix4d.createIdentity();
        // console.log(work.rowArrays());
        // console.log(inverse.rowArrays());
        let pivotIndex;
        let pivotRow;
        let pivotValue;
        let divPivot;
        // Downward gaussian elimination, no pivoting:
        for (pivotRow = 0; pivotRow < 3; pivotRow++) {
            pivotIndex = pivotRow * 5;
            pivotValue = work.coffs[pivotIndex];
            // console.log("** pivot row " + pivotRow + " pivotvalue " + pivotValue);
            divPivot = Geometry_1.Geometry.conditionalDivideFraction(1.0, pivotValue);
            if (divPivot === undefined)
                return undefined;
            let indexB = pivotIndex + 4;
            for (let rowB = pivotRow + 1; rowB < 4; rowB++, indexB += 4) {
                const scale = -work.coffs[indexB] * divPivot;
                work.rowOperation(pivotRow, rowB, pivotRow, scale);
                inverse.rowOperation(pivotRow, rowB, 0, scale);
                // console.log(work.rowArrays());
                // console.log(inverse.rowArrays());
            }
        }
        // console.log("\n**********************Backsub\n");
        // upward gaussian elimination ...
        for (pivotRow = 1; pivotRow < 4; pivotRow++) {
            pivotIndex = pivotRow * 5;
            pivotValue = work.coffs[pivotIndex];
            // console.log("** pivot row " + pivotRow + " pivotvalue " + pivotValue);
            divPivot = Geometry_1.Geometry.conditionalDivideFraction(1.0, pivotValue);
            if (divPivot === undefined)
                return undefined;
            let indexB = pivotRow;
            for (let rowB = 0; rowB < pivotRow; rowB++, indexB += 4) {
                const scale = -work.coffs[indexB] * divPivot;
                work.rowOperation(pivotRow, rowB, pivotRow, scale);
                inverse.rowOperation(pivotRow, rowB, 0, scale);
                // console.log("Eliminate Row " + rowB + " from pivot " + pivotRow);
                // console.log(work.rowArrays());
                // console.log(inverse.rowArrays());
            }
        }
        // divide through by pivots (all have  beeen confirmed nonzero)
        inverse.scaleRowsInPlace(1.0 / work.coffs[0], 1.0 / work.coffs[5], 1.0 / work.coffs[10], 1.0 / work.coffs[15]);
        // console.log("descaled", inverse.rowArrays());
        return inverse;
    }
    /** @returns Restructure the matrix rows as separate arrays. (Useful for printing)
     * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)
     */
    rowArrays(f) {
        if (f)
            return [
                [f(this.coffs[0]), f(this.coffs[1]), f(this.coffs[2]), f(this.coffs[3])],
                [f(this.coffs[4]), f(this.coffs[5]), f(this.coffs[6]), f(this.coffs[7])],
                [f(this.coffs[8]), f(this.coffs[9]), f(this.coffs[10]), f(this.coffs[11])],
                [f(this.coffs[12]), f(this.coffs[13]), f(this.coffs[14]), f(this.coffs[15])]
            ];
        else
            return [
                [this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]],
                [this.coffs[4], this.coffs[5], this.coffs[6], this.coffs[7]],
                [this.coffs[8], this.coffs[9], this.coffs[10], this.coffs[11]],
                [this.coffs[12], this.coffs[13], this.coffs[14], this.coffs[15]]
            ];
    }
    scaleRowsInPlace(ax, ay, az, aw) {
        for (let i = 0; i < 4; i++)
            this.coffs[i] *= ax;
        for (let i = 4; i < 8; i++)
            this.coffs[i] *= ay;
        for (let i = 8; i < 12; i++)
            this.coffs[i] *= az;
        for (let i = 12; i < 16; i++)
            this.coffs[i] *= aw;
    }
}
exports.Matrix4d = Matrix4d;
/** Map4 carries two Matrix4d which are inverses of each other.
 */
class Map4d {
    constructor(matrix0, matrix1) {
        this.matrix0 = matrix0;
        this.matrix1 = matrix1;
    }
    /** @returns Return a reference to (not copy of) the "forward" Matrix4d */
    get transform0() { return this.matrix0; }
    /** @returns Return a reference to (not copy of) the "reverse" Matrix4d */
    get transform1() { return this.matrix1; }
    /** Create a Map4d, capturing the references to the two matrices. */
    static createRefs(matrix0, matrix1) {
        return new Map4d(matrix0, matrix1);
    }
    /** Create an identity map. */
    static createIdentity() { return new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity()); }
    /** Create a Map4d with given transform pair.
     * @returns undefined if the transforms are not inverses of each other.
     */
    static createTransform(transform0, transform1) {
        const product = transform0.multiplyTransformTransform(transform1);
        if (!product.isIdentity())
            return undefined;
        return new Map4d(Matrix4d.createTransform(transform0), Matrix4d.createTransform(transform1));
    }
    /**
     * Create a mapping the scales and translates (no rotation) between boxes.
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxMap(lowA, highA, lowB, highB, result) {
        const t0 = Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);
        const t1 = Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);
        if (t0 && t1) {
            if (result)
                return result;
            return new Map4d(t0, t1);
        }
        return undefined;
    }
    /** Copy contents from another Map4d */
    setFrom(other) { this.matrix0.setFrom(other.matrix0), this.matrix1.setFrom(other.matrix1); }
    /** @returns Return a clone of this Map4d */
    clone() { return new Map4d(this.matrix0.clone(), this.matrix1.clone()); }
    /** Reinitialize this Map4d as an identity. */
    setIdentity() { this.matrix0.setIdentity(); this.matrix1.setIdentity(); }
    /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    setFromJSON(json) {
        if (json.matrix0 && json.matrix1) {
            this.matrix0.setFromJSON(json.matrix0);
            this.matrix1.setFromJSON(json.matrix1);
        }
        else
            this.setIdentity();
    }
    /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    static fromJSON(json) {
        const result = new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity());
        result.setFromJSON(json);
        return result;
    }
    /** @returns a json object `{matrix0: value0, matrix1: value1}` */
    toJSON() { return { matrix0: this.matrix0.toJSON(), matrix1: this.matrix1.toJSON() }; }
    isAlmostEqual(other) {
        return this.matrix0.isAlmostEqual(other.matrix0) && this.matrix1.isAlmostEqual(other.matrix1);
    }
    /** Create a map between a frustum and world coordinates.
     * @param origin lower left of frustum
     * @param uVector Vector from lower left rear to lower right rear
     * @param vVector Vector from lower left rear to upper left rear
     * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.
     * @param fraction front size divided by rear size.
     */
    static createVectorFrustum(origin, uVector, vVector, wVector, fraction) {
        fraction = Math.max(fraction, 1.0e-8);
        const slabToWorld = Transform_1.Transform.createOriginAndMatrix(origin, Transform_1.RotMatrix.createColumns(uVector, vVector, wVector));
        const worldToSlab = slabToWorld.inverse();
        if (!worldToSlab)
            return undefined;
        const worldToSlabMap = Map4d.createTransform(worldToSlab, slabToWorld);
        if (undefined === worldToSlab)
            return undefined;
        const slabToNPCMap = new Map4d(Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));
        if (undefined === worldToSlabMap)
            return undefined;
        const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);
        /*
        let numIdentity = 0;
        const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);
        if (productA.isIdentity())
          numIdentity++;
        const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);
        if (productB.isIdentity())
          numIdentity++;
        const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);
        if (product.isIdentity())
          numIdentity++;
        if (numIdentity === 3)
            return result;
          */
        return result;
    }
    multiplyMapMap(other) {
        return new Map4d(this.matrix0.multiplyMatrixMatrix(other.matrix0), other.matrix1.multiplyMatrixMatrix(this.matrix1));
    }
    reverseInPlace() {
        const temp = this.matrix0;
        this.matrix0 = this.matrix1;
        this.matrix1 = temp;
    }
    /** return a Map4d whose transform0 is
     * other.transform0 * this.transform0 * other.transform1
     */
    sandwich0This1(other) {
        return new Map4d(other.matrix0.multiplyMatrixMatrix(this.matrix0.multiplyMatrixMatrix(other.matrix1)), other.matrix0.multiplyMatrixMatrix(this.matrix1.multiplyMatrixMatrix(other.matrix1)));
    }
    /** return a Map4d whose transform0 is
     * other.transform1 * this.transform0 * other.transform0
     */
    sandwich1This0(other) {
        return new Map4d(other.matrix1.multiplyMatrixMatrix(this.matrix0.multiplyMatrixMatrix(other.matrix0)), other.matrix1.multiplyMatrixMatrix(this.matrix1.multiplyMatrixMatrix(other.matrix0)));
    }
} // Map4d
exports.Map4d = Map4d;
/**
 * A Plane4dByOriginAndVectors is a 4d origin and pair of 4d "vectors" defining a 4d plane.
 *
 * * The parameterization of the plane is    `X = A + U*t + V*v`
 * * The unit coefficient of pointA makes this like a Plane3dByOriginAndVectors. Hence it is not a barycentric combination of 4d points.
 */
class Plane4dByOriginAndVectors {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    /** @returns Return a clone of this plane */
    clone(result) {
        if (result) {
            result.setFrom(this);
            return result;
        }
        return new Plane4dByOriginAndVectors(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());
    }
    /** copy all content from other plane */
    setFrom(other) {
        this.origin.setFrom(other.origin);
        this.vectorU.setFrom(other.vectorU);
        this.vectorV.setFrom(other.vectorV);
    }
    /** @returns Return true if origin, vectorU, and vectorV pass isAlmostEqual. */
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
    /** Create a plane with (copies of) origin, vectorU, vectorV parameters
     */
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.setOriginAndVectors(origin, vectorU, vectorV);
            return result;
        }
        return new Plane4dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /** Set all numeric data from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw) {
        this.origin.set(x0, y0, z0, w0);
        this.vectorU.set(ux, uy, uz, uw);
        this.vectorV.set(vx, vy, vz, vw);
        return this;
    }
    /** Copy the contents of origin, vectorU, vectorV parameters to respective member variables */
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    /** Create from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    static createOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw, result) {
        if (result)
            return result.setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw);
        return new Plane4dByOriginAndVectors(Point4d.create(x0, y0, z0, w0), Point4d.create(ux, uy, uz, uw), Point4d.create(vx, vy, vz, uw));
    }
    static createOriginAndTargets3d(origin, targetU, targetV, result) {
        return Plane4dByOriginAndVectors.createOriginAndVectorsXYZW(origin.x, origin.y, origin.z, 1.0, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, 0.0, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, 0.0, result);
    }
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    static createXYPlane(result) {
        return Plane4dByOriginAndVectors.createOriginAndVectorsXYZW(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, result);
    }
}
exports.Plane4dByOriginAndVectors = Plane4dByOriginAndVectors;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const Polynomials_1 = __webpack_require__(66);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const AnalyticGeometry_1 = __webpack_require__(11);
const CurvePrimitive_1 = __webpack_require__(12);
const StrokeOptions_1 = __webpack_require__(67);
const LineString3d_1 = __webpack_require__(10);
/* tslint:disable:variable-name no-empty*/
/**
 * Circular or elliptic arc.
 *
 * * The angle to point equation is:
 *
 * **  `X = center + cos(theta) * vector0 + sin(theta) * vector90`
 * * When the two vectors are perpendicular and have equal length, it is a true circle.
 * * Non-perpendicular vectors are always elliptic.
 * *  vectors of unequal length are always elliptic.
 * * To create an ellipse in the common "major and minor axis" form of an ellipse:
 *
 * ** vector0 is the vector from the center to the major axis extreme.
 * ** vector90 is the vector from the center to the minor axis extreme.
 * ** note the constructing the vectors to the extreme points makes them perpendicular.
 * *  The method toScaledRotMatrix () can be called to convert the unrestricted vector0,vector90 to perpendicular form.
 * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d, intersection with plane.
 */
class Arc3d extends CurvePrimitive_1.CurvePrimitive {
    isSameGeometryClass(other) { return other instanceof Arc3d; }
    get center() { return this._center; }
    get vector0() { return this._matrix.columnX(); }
    get vector90() { return this._matrix.columnY(); }
    get matrix() { return this._matrix; }
    get sweep() { return this._sweep; }
    // constructor copies the pointers !!!
    constructor(center, matrix, sweep) {
        super();
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    setRefs(center, matrix, sweep) {
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    set(center, matrix, sweep) {
        this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : Geometry_1.AngleSweep.create360());
    }
    setFrom(other) {
        this._center.setFrom(other._center);
        this._matrix.setFrom(other._matrix);
        this._sweep.setFrom(other._sweep);
    }
    clone() {
        return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());
    }
    static createRefs(center, matrix, sweep, result) {
        if (result) {
            result.setRefs(center, matrix, sweep);
            return result;
        }
        return new Arc3d(center, matrix, sweep);
    }
    static createScaledXYColumns(center, matrix, radius0, radius90, sweep, result) {
        const vector0 = matrix.columnX();
        const vector90 = matrix.columnY();
        return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);
    }
    static create(center, vector0, vector90, sweep, result) {
        const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case ! !!
        const matrix = Transform_1.RotMatrix.createColumns(vector0, vector90, normal);
        if (result) {
            result.setRefs(center.clone(), matrix, sweep ? sweep.clone() : Geometry_1.AngleSweep.create360());
            return result;
        }
        return new Arc3d(center.clone(), matrix, sweep ? sweep.clone() : Geometry_1.AngleSweep.create360());
    }
    /** Create a circular arc defined by start point, any intermediate point, and end point.
     * If the points are colinear, assemble them into a linestring.
     */
    static createCircularStartMiddleEnd(pointA, pointB, pointC, result) {
        const vectorAB = PointVector_1.Vector3d.createStartEnd(pointA, pointB);
        const vectorAC = PointVector_1.Vector3d.createStartEnd(pointA, pointC);
        const ab = vectorAB.magnitude();
        const bc = vectorAC.magnitude();
        const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));
        const vectorToCenter = Polynomials_1.SmallSystem.linearSystem3d(normal.x, normal.y, normal.z, vectorAB.x, vectorAB.y, vectorAB.z, vectorAC.x, vectorAC.y, vectorAC.z, 0, // vectorToCenter DOT normal = 0
        0.5 * ab * ab, // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)
        0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)
        if (vectorToCenter) {
            const center = PointVector_1.Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);
            const vectorX = PointVector_1.Vector3d.createStartEnd(center, pointA);
            const vectorY = PointVector_1.Vector3d.createRotateVectorAroundVector(vectorX, normal);
            if (vectorY) {
                const vectorCenterToC = PointVector_1.Vector3d.createStartEnd(center, pointC);
                const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);
                return Arc3d.create(center, vectorX, vectorY, Geometry_1.AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);
            }
        }
        return LineString3d_1.LineString3d.create(pointA, pointB, pointC);
    }
    fractionToPoint(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);
    }
    fractionToPointAndDerivative(fraction, result) {
        result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);
        result.direction.scaleInPlace(this._sweep.sweepRadians);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        if (!result)
            result = AnalyticGeometry_1.Plane3dByOriginAndVectors.createXYPlane();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        const a = this._sweep.sweepRadians;
        this._matrix.multiplyXY(-a * s, a * c, result.vectorU);
        const aa = a * a;
        this._matrix.multiplyXY(-aa * c, -aa * s, result.vectorV);
        return result;
    }
    radiansToPointAndDerivative(radians, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    angleToPointAndDerivative(theta, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        const c = theta.cos();
        const s = theta.sin();
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    endPoint(result) { return this.fractionToPoint(1.0, result); }
    curveLength() {
        const r = this.circularRadius();
        if (r !== undefined) {
            return Math.abs(this._sweep.sweepRadians * r);
        }
        // fall through for true ellipse . .. stroke and accumulate quadrature ...
        return super.curveLength();
    }
    quickLength() { return this._sweep.sweepRadians * Math.sqrt(this._matrix.columnXMagnitude() * this._matrix.columnYMagnitude()); }
    allPerpendicularAngles(spacePoint, _extend = false, _endpoints = false) {
        const radians = [];
        const vectorQ = spacePoint.vectorTo(this.center);
        const uu = this.matrix.columnXMagnitudeSquared();
        const uv = this._matrix.columnXDotColumnY();
        const vv = this._matrix.columnYMagnitudeSquared();
        Polynomials_1.TrigPolynomial.SolveUnitCircleImplicitQuadricIntersection(uv, vv - uu, -uv, this.matrix.dotColumnY(vectorQ), -this.matrix.dotColumnX(vectorQ), 0.0, radians);
        return radians;
    }
    closestPoint(spacePoint, extend, result) {
        result = CurvePrimitive_1.CurveLocationDetail.create(this, result);
        const allRadians = this.allPerpendicularAngles(spacePoint);
        if (!extend && !this._sweep.isFullCircle()) {
            allRadians.push(this._sweep.startRadians);
            allRadians.push(this._sweep.endRadians);
        }
        // hm... logically there must at least two angles there ...  but if it happens return the start point ...
        const workRay = AnalyticGeometry_1.Ray3d.createZero();
        if (allRadians.length === 0) {
            result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));
            result.a = spacePoint.distance(result.point);
        }
        else {
            let dMin = Number.MAX_VALUE;
            let d = 0;
            for (const radians of allRadians) {
                if (extend || this._sweep.isRadiansInSweep(radians)) {
                    this.radiansToPointAndDerivative(radians, workRay);
                    d = spacePoint.distance(workRay.origin);
                    if (d < dMin) {
                        dMin = d;
                        result.setFR(this._sweep.radiansToSignedPeriodicFraction(radians), workRay);
                        result.a = d;
                    }
                }
            }
        }
        return result;
    }
    reverseInPlace() { this._sweep.reverseInPlace(); }
    tryTransformInPlace(transform) {
        this._center = transform.multiplyPoint3d(this._center, this._center);
        this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);
        // force re-normalization of columnZ.
        this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());
        return true;
    }
    isInPlane(plane) {
        const normal = plane.getNormalRef();
        // The ellipse vectors are full-length  -- true distance comparisons say things.
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._center))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));
    }
    isCircular() {
        const axx = this._matrix.columnXMagnitudeSquared();
        const ayy = this._matrix.columnYMagnitudeSquared();
        const axy = this._matrix.columnXDotColumnY();
        return Geometry_1.Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry_1.Geometry.isSameCoordinateSquared(axx, ayy);
    }
    /** If the arc is circular, return its radius.  Otherwise return undefined */
    circularRadius() {
        return this.isCircular() ? this._matrix.columnXMagnitude() : undefined;
    }
    /** Return the larger of the two defining vectors. */
    maxVectorLength() { return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude()); }
    appendPlaneIntersectionPoints(plane, result) {
        const normal = plane.getNormalRef();
        const constCoff = normal.dotProductStartEnd(plane.getOriginRef(), this._center);
        const cosCoff = this._matrix.dotColumnX(normal);
        const sinCoff = this._matrix.dotColumnY(normal);
        const trigPoints = Geometry_1.Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);
        let numIntersection = 0;
        if (trigPoints !== undefined) {
            numIntersection = trigPoints.length;
            let xy;
            for (xy of trigPoints) {
                const radians = Math.atan2(xy.y, xy.x);
                const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);
                result.push(CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));
            }
        }
        return numIntersection;
    }
    extendRange(range) {
        const df = 1.0 / 32;
        // KLUDGE --- evaluate lots of points ...
        let point = PointVector_1.Point3d.create();
        for (let fraction = 0; fraction <= 1.001; fraction += df) {
            point = this.fractionToPoint(fraction, point);
            range.extendPoint(point);
        }
    }
    static createUnitCircle() {
        return Arc3d.createRefs(PointVector_1.Point3d.create(0, 0, 0), Transform_1.RotMatrix.createIdentity(), Geometry_1.AngleSweep.create360());
    }
    /**
     * @param center center of arc
     * @param radius radius of arc
     * @param sweep sweep limits.  defaults to full circle.
     */
    static createXY(center, radius, sweep = Geometry_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Transform_1.RotMatrix.createScale(radius, radius, 1.0), sweep);
    }
    static createXYEllipse(center, radiusA, radiusB, sweep = Geometry_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Transform_1.RotMatrix.createScale(radiusA, radiusB, 1.0), sweep);
    }
    setVector0Vector90(vector0, vector90) {
        this._matrix.setColumns(vector0, vector90, vector0.unitCrossProductWithDefault(vector90, 0, 0, 0));
    }
    toScaledRotMatrix() {
        const angleData = Geometry_1.Angle.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(), this._matrix.columnYMagnitudeSquared(), this._matrix.columnXDotColumnY(), true);
        const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);
        const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);
        const axes = Transform_1.RotMatrix.createRigidFromColumns(vector0A, vector90A, 0 /* XYZ */);
        return {
            axes: (axes ? axes : Transform_1.RotMatrix.createIdentity()),
            center: this._center,
            r0: vector0A.magnitude(),
            r90: vector90A.magnitude(),
            sweep: this.sweep.cloneMinusRadians(angleData.radians),
        };
    }
    /** Return the arc definition with center, two vectors, and angle sweep;
     * The center and AngleSweep are references to inside the Arc3d.
     */
    toVectors() {
        return {
            center: this.center,
            vector0: this.matrix.columnX(),
            vector90: this.matrix.columnY(),
            sweep: this.sweep,
        };
    }
    setFromJSON(json) {
        if (json && json.center && json.vector0 && json.vector90 && json.sweep) {
            this._center.setFromJSON(json.center);
            const vector0 = PointVector_1.Vector3d.create();
            const vector90 = PointVector_1.Vector3d.create();
            vector0.setFromJSON(json.vector0);
            vector90.setFromJSON(json.vector90);
            this.setVector0Vector90(vector0, vector90);
            this._sweep.setFromJSON(json.sweep);
        }
        else {
            this._center.set(0, 0, 0);
            this._matrix.setFrom(Transform_1.RotMatrix.identity);
            this._sweep.setStartEndRadians();
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [center:  [], vector0:[], vector90:[], sweep []}
     */
    toJSON() {
        return {
            center: this._center.toJSON(),
            sweep: this._sweep.toJSON(),
            vector0: this._matrix.columnX().toJSON(),
            vector90: this._matrix.columnY().toJSON(),
        };
    }
    isAlmostEqual(otherGeometry) {
        if (otherGeometry instanceof Arc3d) {
            const other = otherGeometry;
            return this._center.isAlmostEqual(other._center)
                && this._matrix.isAlmostEqual(other._matrix)
                && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        let numStrokes = 1;
        if (options) {
            const rMax = this.maxVectorLength();
            numStrokes = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);
        }
        else {
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);
        }
        dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        let numStrokes = 1;
        if (options) {
            const rMax = this.maxVectorLength();
            numStrokes = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);
        }
        else {
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);
        }
        handler.startCurvePrimitive(this);
        handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleArc3d(this);
    }
    /** Return (if possible) an arc which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const arcA = this.clonePartialCurve(fractionB, fractionA);
            if (arcA)
                arcA.reverseInPlace();
            return arcA;
        }
        const arcB = this.clone();
        arcB.sweep.setStartEndRadians(this.sweep.fractionToRadians(fractionA), this.sweep.fractionToRadians(fractionB));
        return arcB;
    }
    /**
     * Find intervals of this curveprimitve that are interior to a clipper
     * @param clipper clip structure (e.g.clip planes)
     * @param announce(optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedArcIntervals(this, announce);
    }
}
exports.Arc3d = Arc3d;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObj = __webpack_require__(253);
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const WsgClient_1 = __webpack_require__(32);
const bentleyjs_core_1 = __webpack_require__(0);
const loggingCategory = "imodeljs-clients.imodelhub";
/**
 * Error returned from iModel Hub service.
 */
class IModelHubError extends WsgClient_1.WsgError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, getMetaData);
    }
    /**
     * Gets IModelHubStatus from the string value returned by the service.
     * @param error Error id returned by the service.
     * @returns IModelHubStatus id
     */
    static getErrorId(error) {
        const id = bentleyjs_core_1.IModelHubStatus[error.slice(IModelHubError._idPrefix.length)];
        return id ? id : bentleyjs_core_1.IModelHubStatus.Unknown;
    }
    /**
     * Checks whether error could have extended data.
     * @param id Id of the error.
     * @returns True if service can return extended data for this error id.
     */
    static requiresExtendedData(id) {
        switch (id) {
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.FileAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.CodeStateInvalid:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.ConflictsAggregate:
                return true;
            default:
                return false;
        }
    }
    /**
     * Makes extended data available publically.
     */
    copyExtendedData() {
        this.data = this._data;
    }
    /**
     * Creates IModelHubError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     */
    static fromId(id, message) {
        const error = new IModelHubError(id);
        error.name = bentleyjs_core_1.IModelHubStatus[id];
        error.message = message;
        return error;
    }
    /**
     * Attempts to parse IModelHubError from server response.
     * @param response Response from the server.
     * @returns Parsed error.
     */
    static parse(response, log = true) {
        const wsgError = super.parse(response, false);
        if (wsgError instanceof WsgClient_1.WsgError && wsgError.name && wsgError.name.startsWith(IModelHubError._idPrefix)) {
            const errorId = IModelHubError.getErrorId(wsgError.name);
            const error = new IModelHubError(errorId);
            deepAssign(error, wsgError);
            error.errorNumber = errorId;
            if (IModelHubError.requiresExtendedData(error.errorNumber)) {
                error.copyExtendedData();
            }
            if (log)
                error.log();
            return error;
        }
        if (log)
            wsgError.log();
        return wsgError;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error returned by request
     * @param response Response returned by request
     */
    static shouldRetry(error, response) {
        if (response === undefined || response === null) {
            return super.shouldRetry(error, response);
        }
        if (super.parseHttpStatus(response.statusType) === 0 /* Success */) {
            return false;
        }
        const parsedError = IModelHubError.parse({ response }, false);
        if (!(parsedError instanceof WsgClient_1.WsgError)) {
            return super.shouldRetry(error, response);
        }
        if ((parsedError instanceof IModelHubError)) {
            return false;
        }
        const errorCodesToRetry = [94212 /* ServerError */,
            98305 /* Unknown */];
        const errorStatus = super.getErrorStatus(parsedError.name !== undefined ?
            super.getWSStatusId(parsedError.name) : 98305 /* Unknown */, response.statusType);
        return errorCodesToRetry.includes(errorStatus);
    }
    /**
     * Get log function
     */
    getLogLevel() {
        switch (this.errorNumber) {
            case bentleyjs_core_1.IModelHubStatus.AnotherUserPushing:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
                return bentleyjs_core_1.Logger.logWarning;
            default:
                return bentleyjs_core_1.Logger.logError;
        }
    }
    /**
     * Logs this error
     */
    log() {
        (this.getLogLevel())(loggingCategory, this.logMessage(), this.getMetaData());
    }
}
IModelHubError._idPrefix = "iModelHub.";
exports.IModelHubError = IModelHubError;
/**
 * Errors for incorrect iModel Hub requests.
 */
class IModelHubRequestError extends IModelHubError {
    /**
     * Creates IModelHubRequestError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     */
    static fromId(id, message) {
        const error = new IModelHubRequestError(id, message);
        error.log();
        return error;
    }
    /**
     * Create error for undefined arguments being passed.
     * @param argumentName Undefined argument name
     * @returns Created error.
     */
    static undefinedArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.UndefinedArgumentError, `Argument ${argumentName} is null or undefined`);
    }
    /**
     * Create error for invalid arguments being passed.
     * @param argumentName Invalid argument name
     * @returns Created error.
     */
    static invalidArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.InvalidArgumentError, `Argument ${argumentName} has an invalid value.`);
    }
    /**
     * Create error for arguments being passed that are missing download URL.
     * @param argumentName Argument name
     * @returns Created error.
     */
    static missingDownloadUrl(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.MissingDownloadUrlError, `Supplied ${argumentName} must include download URL. Use selectDownloadUrl() when getting ${argumentName}.`);
    }
    /**
     * Create error for incompatible operation being used in browser.
     * @returns Created error.
     */
    static browser() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.NotSupportedInBrowser, "Operation is not supported in browser.");
    }
    /**
     * Create error for incompatible operation being used in browser.
     * @returns Created error.
     */
    static fileHandler() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileHandlerNotSet, "File handler is required to be set for file download / upload.");
    }
    /**
     * Create error for a missing file.
     * @returns Created error.
     */
    static fileNotFound() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileNotFound, "Could not find the file to upload.");
    }
}
exports.IModelHubRequestError = IModelHubRequestError;
/** Class for aggregating multiple errors from multiple requests */
class AggregateResponseError extends Error {
    constructor() {
        super(...arguments);
        this.errors = [];
    }
}
exports.AggregateResponseError = AggregateResponseError;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcRegistry_1 = __webpack_require__(33);
const RpcConfiguration_1 = __webpack_require__(52);
/** An RPC interface is a set of operations exposed by a service that a client can call, using configurable protocols,
 * in a platform-independent way. TheRpcInterface class is the base class for RPC interface definitions and implementations.
 */
class RpcInterface {
    constructor() {
        /** The configuration for the RPC interface. */
        this.configuration = RpcConfiguration_1.RpcConfiguration.supply(this);
    }
    /** Obtains the implementation result for an RPC operation. */
    forward(operation, ...parameters) {
        const request = new (this.configuration.protocol.requestType)(this, operation, parameters);
        request.submit();
        this[RpcRegistry_1.CURRENT_REQUEST] = request;
        return request.response;
    }
}
exports.RpcInterface = RpcInterface;
RpcInterface.prototype.configurationSupplier = undefined;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RpcManager_1 = __webpack_require__(27);
const RpcProtocol_1 = __webpack_require__(28);
const RpcRequest_1 = __webpack_require__(42);
const RpcRegistry_1 = __webpack_require__(33);
const RpcControl_1 = __webpack_require__(59);
/** A RpcConfiguration specifies how calls on an RPC interface will be marshalled, plus other operating parameters.
 * RpcConfiguration is the base class for specific configurations.
 */
class RpcConfiguration {
    constructor() {
        /** Reserved for an application authorization key. */
        this.applicationAuthorizationKey = "";
        /** Reserved for an application authorization value. */
        this.applicationAuthorizationValue = "";
        /** The target interval (in milliseconds) between connection attempts for pending RPC operation requests. */
        this.pendingOperationRetryInterval = 10000;
        /** The control channel for the configuration. */
        this.controlChannel = RpcControl_1.RpcControlChannel.obtain(this);
    }
    /** Sets the configuration supplier for an RPC interface class. */
    static assign(definition, supplier) {
        definition.prototype.configurationSupplier = supplier;
    }
    /** Obtains the instance of an RPC configuration class. */
    static obtain(constructor) {
        let instance = constructor[RpcRegistry_1.INSTANCE];
        if (!instance)
            instance = constructor[RpcRegistry_1.INSTANCE] = new constructor();
        return instance;
    }
    /** Initializes the RPC interfaces managed by the configuration. */
    static initializeInterfaces(configuration) {
        configuration.interfaces().forEach((definition) => RpcManager_1.RpcManager.initializeInterface(definition));
        configuration.controlChannel.initialize();
    }
    /** @hidden @internal */
    static supply(definition) {
        return RpcConfiguration.obtain(definition.configurationSupplier ? definition.configurationSupplier() : RpcDefaultConfiguration);
    }
    /** @hidden @internal */
    onRpcClientInitialized(definition, client) {
        this.protocol.onRpcClientInitialized(definition, client);
    }
    /** @hidden @internal */
    onRpcImplInitialized(definition, impl) {
        this.protocol.onRpcImplInitialized(definition, impl);
    }
    /** @hidden @internal */
    onRpcClientTerminated(definition, client) {
        this.protocol.onRpcClientTerminated(definition, client);
    }
    /** @hidden @internal */
    onRpcImplTerminated(definition, impl) {
        this.protocol.onRpcImplTerminated(definition, impl);
    }
}
/**
 * Whether development mode is enabled.
 * @note This parameter determines whether developer convenience features like backend stack traces are available.
 */
RpcConfiguration.developmentMode = false;
/**
 * Whether strict mode is enabled.
 * This parameter determines system behaviors relating to strict checking:
 * - Whether an error is thrown if the type marshaling system encounters an unregistered type (only in strict mode).
 */
RpcConfiguration.strictMode = false;
exports.RpcConfiguration = RpcConfiguration;
// A default configuration that can be used for basic testing within a library.
class RpcDefaultConfiguration extends RpcConfiguration {
    constructor() {
        super(...arguments);
        this.interfaces = () => [];
        this.protocol = new RpcDirectProtocol(this);
        this.applicationAuthorizationKey = "Authorization";
        this.applicationAuthorizationValue = "Basic Og==";
    }
}
exports.RpcDefaultConfiguration = RpcDefaultConfiguration;
// A default protocol that can be used for basic testing within a library.
class RpcDirectProtocol extends RpcProtocol_1.RpcProtocol {
    constructor() {
        super(...arguments);
        this.requestType = RpcDirectRequest;
    }
}
exports.RpcDirectProtocol = RpcDirectProtocol;
// A default request type that can be used for basic testing within a library.
class RpcDirectRequest extends RpcRequest_1.RpcRequest {
    constructor() {
        super(...arguments);
        this.headers = new Map();
        this.fulfillment = { result: "", status: 0, id: "", interfaceName: "" };
    }
    send() {
        const request = this.protocol.serialize(this);
        this.protocol.fulfill(request).then((fulfillment) => {
            this.fulfillment = JSON.parse(JSON.stringify(fulfillment));
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ResponseLoaded, this);
        });
    }
    setHeader(name, value) {
        this.headers.set(name, value);
    }
    getResponseStatusCode() {
        return this.fulfillment.status;
    }
    getResponseText() {
        return this.fulfillment.result;
    }
}
exports.RpcDirectRequest = RpcDirectRequest;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module ElementState */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
/** The "state" of an Entity as represented in a web browser. */
class EntityState {
    /**
     * constructor for EntityState
     * @param props the properties of the Entity for this EntityState
     * @param iModel the iModel from which this EntityState is to be constructed
     * @param _state source EntityState for clone
     */
    constructor(props, iModel, _state) {
        this.classFullName = props.classFullName;
        this.iModel = iModel;
        this.id = bentleyjs_core_1.Id64.fromJSON(props.id);
        this.jsonProperties = props.jsonProperties ? JSON.parse(JSON.stringify(props.jsonProperties)) : {}; // make sure we have our own copy
    }
    toJSON() {
        const val = {};
        val.classFullName = this.classFullName;
        if (this.id.isValid())
            val.id = this.id;
        if (this.jsonProperties && Object.keys(this.jsonProperties).length > 0)
            val.jsonProperties = this.jsonProperties;
        return val;
    }
    equals(other) { return JSON.stringify(this.toJSON()) === JSON.stringify(other.toJSON()); }
    /** Make an independent copy of this EntityState */
    clone() { return new this.constructor(this.toJSON(), this.iModel, this); }
    /**
     * Get full class name of this Entity in the form "SchemaName:ClassName".
     * @note Subclasses from other than the BisCore domain should override their static member "schemaName" with their schema name.
     */
    static getClassFullName() { return this.schemaName + ":" + this.className; }
    static get sqlName() { return this.schemaName + "." + this.className; }
    /**
     * Get the ECClass name for this EntityState.
     * @note This default implementation relies on all EntityState subclasses using their ECClass name as their JavaScript class name, <em>with "State" appended to the end </em>.
     * If this is not true, you must override this method.
     */
    static get className() { return this.name.slice(0, this.name.lastIndexOf("State")); }
}
EntityState.schemaName = "BisCore";
exports.EntityState = EntityState;
/** The "state" of an Element as represented in a web browser. */
class ElementState extends EntityState {
    constructor(props, iModel) {
        super(props, iModel);
        this.code = imodeljs_common_1.Code.fromJSON(props.code);
        this.model = imodeljs_common_1.RelatedElement.idFromJson(props.model);
        this.parent = imodeljs_common_1.RelatedElement.fromJSON(props.parent);
        this.federationGuid = bentleyjs_core_1.Guid.fromJSON(props.federationGuid);
        this.userLabel = props.userLabel;
    }
    toJSON() {
        const val = super.toJSON();
        if (this.code.spec.isValid())
            val.code = this.code;
        val.model = this.model;
        val.parent = this.parent;
        val.federationGuid = this.federationGuid;
        val.userLabel = this.userLabel;
        return val;
    }
}
exports.ElementState = ElementState;


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var consoleLogger = {
  type: 'logger',

  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    var _console;

    /* eslint no-console: 0 */
    if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
  }
};

var Logger = function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Logger);

    this.init(concreteLogger, options);
  }

  Logger.prototype.init = function init(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.prefix = options.prefix || 'i18next:';
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  };

  Logger.prototype.setDebug = function setDebug(bool) {
    this.debug = bool;
  };

  Logger.prototype.log = function log() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return this.forward(args, 'log', '', true);
  };

  Logger.prototype.warn = function warn() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return this.forward(args, 'warn', '', true);
  };

  Logger.prototype.error = function error() {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return this.forward(args, 'error', '');
  };

  Logger.prototype.deprecate = function deprecate() {
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
  };

  Logger.prototype.forward = function forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (typeof args[0] === 'string') args[0] = '' + prefix + this.prefix + ' ' + args[0];
    return this.logger[lvl](args);
  };

  Logger.prototype.create = function create(moduleName) {
    return new Logger(this.logger, _extends({ prefix: this.prefix + ':' + moduleName + ':' }, this.options));
  };

  return Logger;
}();

/* harmony default export */ __webpack_exports__["a"] = (new Logger());

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FloatRGBA_1 = __webpack_require__(35);
// Describes one of the pre-defined line patterns.
// See Render.LinePixels.
var LineCode;
(function (LineCode) {
    function valueFromLinePixels(pixels) {
        switch (pixels) {
            case 0 /* Code0 */: return 0;
            case 2155905152 /* Code1 */: return 1;
            case 4177066232 /* Code2 */: return 2;
            case 4292935648 /* Code3 */: return 3;
            case 4262526480 /* Code4 */: return 4;
            case 3772834016 /* Code5 */: return 5;
            case 4169726088 /* Code6 */: return 6;
            case 4279828248 /* Code7 */: return 7;
            case 3435973836 /* HiddenLine */: return 8;
            case 1 /* Invisible */: return 9;
            default: return 0;
        }
    }
    LineCode.valueFromLinePixels = valueFromLinePixels;
    LineCode.solid = 0;
    LineCode.count = 16; // only 10 line codes, but pad to 16 to make height a power of two.
    LineCode.size = 32;
    // NB: Non-power-of-two textures in WebGL only support clamp-to-edge.
    // Make this a power of two so we can use repeat.
    LineCode.lineCodeData = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];
})(LineCode = exports.LineCode || (exports.LineCode = {}));
class EdgeOverrides {
    constructor(style, forceOpaque = false) {
        this._forceOpaque = false;
        this.init(forceOpaque, style);
    }
    get color() { return this._color; }
    get lineCode() { return this._lineCode; }
    get weight() { return this._weight; }
    get forceOpaque() { return this._forceOpaque; }
    get overridesColor() { return undefined !== this.color; }
    get overridesLineCode() { return undefined !== this.lineCode; }
    get overridesWeight() { return undefined !== this.weight; }
    get overridesAlpha() { return this.forceOpaque; }
    get anyOverridden() { return this.overridesColor || this.overridesLineCode || this.overridesWeight || this.overridesAlpha; }
    computeOvrFlags() {
        let flags = 0 /* None */;
        if (this.overridesColor)
            flags |= 6 /* Rgba */;
        if (this.overridesWeight)
            flags |= 8 /* Weight */;
        if (this.overridesLineCode)
            flags |= 64 /* LineCode */;
        if (this.overridesAlpha)
            flags |= 4 /* Alpha */;
        return flags;
    }
    init(forceOpaque, style) {
        this._forceOpaque = forceOpaque;
        if (undefined === style) {
            this._color = undefined;
            this._weight = undefined;
            this._lineCode = undefined;
        }
        else {
            this._color = style.ovrColor ? FloatRGBA_1.FloatPreMulRgba.fromColorDef(style.color) : undefined;
            this._weight = style.width !== 0 ? style.width : undefined;
            this._lineCode = -1 /* Invalid */ !== style.pattern ? LineCode.valueFromLinePixels(style.pattern) : undefined;
        }
    }
}
exports.EdgeOverrides = EdgeOverrides;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(81);
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const System_1 = __webpack_require__(7);
class ShaderProgramParams {
    constructor(target, pass) {
        this.target = target;
        this.renderPass = pass;
        if (this.isViewCoords) {
            const rect = target.viewRect;
            this.projectionMatrix = Matrix_1.Matrix4.fromOrtho(0.0, rect.width, rect.height, 0.0, -1.0, 1.0);
        }
        else {
            this.projectionMatrix = Matrix_1.Matrix4.fromMatrix4d(target.projectionMatrix);
        }
    }
    get isViewCoords() { return 8 /* ViewOverlay */ === this.renderPass || 0 /* Background */ === this.renderPass; }
    get isOverlayPass() { return 7 /* WorldOverlay */ === this.renderPass || 8 /* ViewOverlay */ === this.renderPass; }
    get context() { return System_1.System.instance.context; }
}
exports.ShaderProgramParams = ShaderProgramParams;
/** Supplies the context for drawing a graphic primitive via ShaderProgram.draw() */
class DrawParams extends ShaderProgramParams {
    constructor(target, geometry, modelMatrix = System_1.System.identityTransform, pass = 3 /* OpaqueGeneral */) {
        super(target, pass);
        this.geometry = geometry;
        this.modelMatrix = Matrix_1.Matrix4.fromTransform(modelMatrix);
        let mvMat;
        if (this.isViewCoords) {
            // TFS#811077: Zero out Z...see clipping tools in ClipViewTools.cpp...
            const tf = modelMatrix.clone(DrawParams._scratchTransform);
            tf.matrix.coffs[2] = tf.matrix.coffs[5] = tf.matrix.coffs[8] = 0.0;
            mvMat = Matrix_1.Matrix4.fromTransform(tf);
        }
        else {
            let modelViewMatrix = target.viewMatrix.clone(DrawParams._scratchTransform);
            modelViewMatrix = modelViewMatrix.multiplyTransformTransform(modelMatrix, modelViewMatrix);
            mvMat = Matrix_1.Matrix4.fromTransform(modelViewMatrix);
        }
        this.viewMatrix = Matrix_1.Matrix4.fromTransform(target.viewMatrix);
        this.modelViewMatrix = mvMat;
    }
}
DrawParams._scratchTransform = geometry_core_1.Transform.createIdentity();
exports.DrawParams = DrawParams;
/**
 * Represents a command to be executed within a RenderPass. The most common command is
 * to draw a primitive; others involve state changes such as pushing/popping transforms
 * and symbology overrides, which require that commands be executed in order.
 */
class DrawCommand {
    preExecute(_exec) { }
    postExecute(_exec) { }
    get primitive() { return undefined; }
    get branch() { return undefined; }
    get pushOrPop() { return undefined; }
    get isPrimitiveCommand() { return undefined !== this.primitive; }
    get featureIndexType() { return undefined !== this.primitive ? this.primitive.featureIndexType : 0 /* Empty */; }
    get hasFeatureOverrides() { return 0 /* Empty */ !== this.featureIndexType; }
    get renderOrder() { return undefined !== this.primitive ? this.primitive.renderOrder : 1 /* BlankingRegion */; }
    getRenderPass(target) { return undefined !== this.primitive ? this.primitive.getRenderPass(target) : 255 /* None */; }
    getTechniqueId(target) { return undefined !== this.primitive ? this.primitive.getTechniqueId(target) : -1 /* Invalid */; }
    isPushCommand(branch) {
        return 0 /* Push */ === this.pushOrPop && (undefined === branch || this.branch === branch);
    }
    isPopCommand(branch) {
        return 1 /* Pop */ === this.pushOrPop && (undefined === branch || this.branch === branch);
    }
    static createForPrimitive(primitive, batch) {
        return undefined !== batch ? new BatchPrimitiveCommand(primitive, batch) : new PrimitiveCommand(primitive);
    }
    static createForDecoration(primitive, ovrs) {
        return undefined !== ovrs ? new OvrPrimitiveCommand(primitive, ovrs) : new PrimitiveCommand(primitive);
    }
    static createForBranch(branch, pushOrPop) { return new BranchCommand(branch, pushOrPop); }
}
exports.DrawCommand = DrawCommand;
class BranchCommand extends DrawCommand {
    get branch() { return this._branch; }
    get pushOrPop() { return this._pushOrPop; }
    constructor(branch, pushOrPop) {
        super();
        this._branch = branch;
        this._pushOrPop = pushOrPop;
    }
    execute(exec) {
        if (0 /* Push */ === this._pushOrPop) {
            exec.pushBranch(this._branch);
        }
        else {
            exec.popBranch();
        }
    }
}
/** Draw a primitive with no symbology overrides */
class PrimitiveCommand extends DrawCommand {
    constructor(primitive) {
        super();
        this._primitive = primitive;
    }
    get primitive() { return this._primitive; }
    execute(exec) { this._primitive.draw(exec); }
}
/** Draw a batch primitive, possibly with symbology overridden per-feature */
class BatchPrimitiveCommand extends PrimitiveCommand {
    constructor(primitive, batch) {
        super(primitive);
        this.batch = batch;
    }
    preExecute(exec) {
        exec.target.currentOverrides = this.batch.getOverrides(exec.target);
        bentleyjs_core_1.assert(undefined === exec.target.currentPickTable);
        exec.target.currentPickTable = this.batch.pickTable;
    }
    postExecute(exec) {
        exec.target.currentOverrides = undefined;
        exec.target.currentPickTable = undefined;
    }
}
/** Draws a decoration primitive with symbology overriden */
class OvrPrimitiveCommand extends PrimitiveCommand {
    constructor(primitive, params) {
        super(primitive);
        this._params = params;
    }
    preExecute(_exec) {
        bentleyjs_core_1.assert(undefined !== this._params); // ###TODO
    }
    postExecute(_exec) {
        // ###TODO
    }
}
/** A list of DrawCommands to be rendered, ordered by render pass. */
class RenderCommands {
    constructor(target, stack) {
        this._scratchFrustum = new imodeljs_common_1.Frustum();
        this._commands = [[], [], [], [], [], [], [], [], [], []];
        this._curBatch = undefined;
        this._curOvrParams = undefined;
        this._forcedRenderPass = 255 /* None */;
        this._opaqueOverrides = false;
        this._translucentOverrides = false;
        this._addTranslucentAsOpaque = false; // true when rendering for _ReadPixels to force translucent items to be drawn in opaque pass.
        this.target = target;
        this._stack = stack;
        bentleyjs_core_1.assert(10 /* COUNT */ === this._commands.length);
    }
    get isEmpty() {
        for (const commands of this._commands)
            if (0 < commands.length)
                return false;
        return true;
    }
    get hasDecorationOverrides() { return undefined !== this._curOvrParams; }
    get currentViewFlags() { return this._stack.top.viewFlags; }
    get compositeFlags() {
        let flags = 0 /* None */;
        if (this.hasCommands(4 /* Translucent */))
            flags |= 1 /* Translucent */;
        if (this.hasCommands(6 /* Hilite */))
            flags |= 2 /* Hilite */;
        bentleyjs_core_1.assert(4 === 4 /* Translucent */);
        bentleyjs_core_1.assert(6 === 6 /* Hilite */);
        return flags;
    }
    hasCommands(pass) { return 0 !== this.getCommands(pass).length; }
    isOpaquePass(pass) { return pass >= 1 /* OpaqueLinear */ && pass <= 3 /* OpaqueGeneral */; }
    addGraphics(scene, forcedPass = 255 /* None */) {
        this._forcedRenderPass = forcedPass;
        scene.forEach((entry) => entry.addCommands(this));
        this._forcedRenderPass = 255 /* None */;
    }
    addDecorations(dec, forcedPass = 255 /* None */) {
        this._forcedRenderPass = forcedPass;
        for (const entry of dec.list) {
            this.addDecoration(entry.graphic, entry.overrides);
        }
        this._forcedRenderPass = 255 /* None */;
    }
    addWorldDecorations(decs) {
        const world = this.target.getWorldDecorations(decs);
        bentleyjs_core_1.assert(world.branch.entries.length === world.overrides.length);
        this.pushAndPopBranch(world, () => {
            for (let i = 0; i < world.branch.entries.length; i++) {
                this.addDecoration(world.branch.entries[i], world.overrides[i]);
            }
        });
    }
    addBackground(gf) {
        if (undefined === gf)
            return;
        bentleyjs_core_1.assert(255 /* None */ === this._forcedRenderPass);
        this._forcedRenderPass = 0 /* Background */;
        this._stack.pushState(this.target.decorationState);
        gf.addCommands(this);
        this._stack.pop();
        this._forcedRenderPass = 255 /* None */;
    }
    addSkyBox(gf) {
        if (undefined === gf)
            return;
        bentleyjs_core_1.assert(255 /* None */ === this._forcedRenderPass);
        this._forcedRenderPass = 9 /* SkyBox */;
        this._stack.pushState(this.target.decorationState);
        gf.addCommands(this);
        this._stack.pop();
        this._forcedRenderPass = 255 /* None */;
    }
    addDrawCommand(command, pass) {
        if (undefined === pass)
            pass = this.getRenderPass(command);
        if (255 /* None */ === pass)
            return;
        if (255 /* None */ !== this._forcedRenderPass) {
            // Add the command to the forced render pass (background).
            this.getCommands(this._forcedRenderPass).push(command);
            return;
        }
        let ovrType = 0 /* Empty */;
        if (this._opaqueOverrides || this._translucentOverrides)
            ovrType = this.hasDecorationOverrides ? 1 /* Uniform */ : command.featureIndexType;
        const haveFeatureOverrides = 0 /* Empty */ !== ovrType;
        if (4 /* Translucent */ === pass && this._addTranslucentAsOpaque) {
            switch (command.renderOrder) {
                case 10 /* PlanarSurface */:
                    pass = 2 /* OpaquePlanar */;
                    break;
                case 2 /* Surface */:
                    pass = 3 /* OpaqueGeneral */;
                    break;
                default:
                    pass = 1 /* OpaqueLinear */;
                    break;
            }
        }
        switch (pass) {
            // If this command ordinarily renders translucent, but some features have been overridden to be opaque, must draw in both passes
            case 4 /* Translucent */:
                if (this._opaqueOverrides && haveFeatureOverrides) {
                    let opaquePass;
                    switch (command.renderOrder) {
                        case 10 /* PlanarSurface */:
                            opaquePass = 2 /* OpaquePlanar */;
                            break;
                        case 2 /* Surface */:
                            opaquePass = 3 /* OpaqueGeneral */;
                            break;
                        default:
                            opaquePass = 1 /* OpaqueLinear */;
                            break;
                    }
                    this.getCommands(opaquePass).push(command);
                }
                break;
            // If this command ordinarily renders opaque, but some features have been overridden to be translucent,
            // must draw in both passes unless we are overriding translucent geometry to draw in the opaque pass for _ReadPixels.
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
                // Want these items to draw in general opaque pass so they are not in pick data.
                if (0 /* Empty */ === command.featureIndexType)
                    pass = 3 /* OpaqueGeneral */;
            /* falls through */
            case 3 /* OpaqueGeneral */:
                if (this._translucentOverrides && haveFeatureOverrides && !this._addTranslucentAsOpaque)
                    this.getCommands(4 /* Translucent */).push(command);
                break;
        }
        this.getCommands(pass).push(command);
    }
    // #TODO: implement FeatureOverrides
    addDecoration(gf, _ovr) {
        const anyOvr = false; // FeatureOverrides.anyOverrides(ovr);
        if (!anyOvr) {
            gf.addCommands(this);
            return;
        }
        // this._curOvrParams = ovr;
        // if (0 !== (ovr.flags & OvrGraphicParams.FLAGS_FillColorTransparency)) {
        //   this._opaqueOverrides = 0 === ovr.fillColor.alpha;
        //   this._translucentOverrides = !this._opaqueOverrides;
        // }
        // gf.addCommands(this);
        this._curOvrParams = undefined;
        this._opaqueOverrides = this._translucentOverrides = false;
    }
    getRenderPass(command) { return command.getRenderPass(this.target); }
    getCommands(pass) {
        let idx = pass;
        bentleyjs_core_1.assert(idx < this._commands.length);
        if (idx >= this._commands.length)
            idx -= 1;
        return this._commands[idx];
    }
    pushAndPopBranch(branch, func) {
        this._stack.pushBranch(branch);
        let cmds;
        const emptyRenderPass = 255 /* None */ === this._forcedRenderPass, start = emptyRenderPass ? 0 : this._forcedRenderPass, end = emptyRenderPass ? this._commands.length : start + 1;
        for (let i = start; i < end; ++i) {
            cmds = this._commands[i];
            cmds.push(DrawCommand.createForBranch(branch, 0 /* Push */));
        }
        // Add the commands from within the branch
        func();
        const popCmd = DrawCommand.createForBranch(branch, 1 /* Pop */);
        for (let i = start; i < end; ++i) {
            cmds = this._commands[i];
            bentleyjs_core_1.assert(0 < cmds.length);
            if (0 < cmds.length && cmds[cmds.length - 1].isPushCommand(branch))
                cmds.pop();
            else
                cmds.push(popCmd);
        }
        this._stack.pop();
    }
    clear() {
        this._commands.forEach((cmds) => { cmds.splice(0); });
        bentleyjs_core_1.assert(undefined === this._curOvrParams);
    }
    init(scene, dec, dynamics, initForReadPixels = false) {
        this.clear();
        if (initForReadPixels) {
            // Set flag to force translucent gometry to be put into the opaque pass.
            this._addTranslucentAsOpaque = true;
            // Add the scene graphics.
            this.addGraphics(scene);
            // TODO: also may want to add pickable decorations.
            this._addTranslucentAsOpaque = false;
            return;
        }
        this.addGraphics(scene);
        if (undefined !== dynamics && 0 < dynamics.list.length) {
            this.addDecorations(dynamics);
        }
        if (undefined !== dec) {
            this.addBackground(dec.viewBackground);
            this.addSkyBox(dec.skyBox);
            if (undefined !== dec.normal && 0 < dec.normal.length) {
                this.addGraphics(dec.normal);
            }
            if (undefined !== dec.world && 0 < dec.world.list.length) {
                this.addWorldDecorations(dec.world);
            }
            this._stack.pushState(this.target.decorationState);
            if (undefined !== dec.viewOverlay && 0 < dec.viewOverlay.list.length) {
                this.addDecorations(dec.viewOverlay, 8 /* ViewOverlay */);
            }
            if (undefined !== dec.worldOverlay && 0 < dec.worldOverlay.list.length) {
                this.addDecorations(dec.worldOverlay, 7 /* WorldOverlay */);
            }
            this._stack.pop();
        }
    }
    addPrimitive(prim) {
        bentleyjs_core_1.assert(undefined === this._curOvrParams || undefined === this._curBatch);
        const command = undefined !== this._curOvrParams ? DrawCommand.createForDecoration(prim, this._curOvrParams) : DrawCommand.createForPrimitive(prim, this._curBatch);
        this.addDrawCommand(command);
        if (255 /* None */ === this._forcedRenderPass && prim.isEdge) {
            const vf = this.target.currentViewFlags;
            if (vf.renderMode !== 0 /* Wireframe */ && vf.hiddenEdges)
                this.addDrawCommand(command, 5 /* HiddenEdge */);
        }
    }
    addBranch(branch) {
        this.pushAndPopBranch(branch, () => {
            branch.branch.entries.forEach((entry) => entry.addCommands(this));
        });
    }
    addBatch(batch) {
        // Batches (aka element tiles) should only draw during ordinary (translucent or opaque) passes.
        // They may draw during both, or neither.
        bentleyjs_core_1.assert(255 /* None */ === this._forcedRenderPass);
        bentleyjs_core_1.assert(!this._opaqueOverrides && !this._translucentOverrides);
        bentleyjs_core_1.assert(undefined === this._curBatch);
        // If all features are overridden to be invisible, draw no graphics in this batch
        const overrides = batch.getOverrides(this.target);
        if (overrides.allHidden)
            return;
        if (undefined !== this._frustumPlanes) {
            let frustum = imodeljs_common_1.Frustum.fromRange(batch.range, this._scratchFrustum);
            frustum = frustum.transformBy(this.target.currentTransform, frustum);
            if (0 /* Outside */ === this._frustumPlanes.computeFrustumContainment(frustum)) {
                return;
            }
        }
        // Don't bother pushing the batch if no features within it are overridden...
        // ^ Actually, we need the pick table...
        const pushBatch = true;
        if (pushBatch) {
            this._curBatch = batch;
            this._opaqueOverrides = overrides.anyOpaque;
            this._translucentOverrides = overrides.anyTranslucent;
        }
        batch.graphic.addCommands(this);
        if (!pushBatch) {
            bentleyjs_core_1.assert(!this._opaqueOverrides && !this._translucentOverrides);
            bentleyjs_core_1.assert(undefined === this._curBatch);
            return;
        }
        this._curBatch = undefined;
        // If the batch contains hilited features, need to render them in the hilite pass
        const anyHilited = overrides.anyHilited;
        if (anyHilited) {
            const hiliteCommands = this.getCommands(6 /* Hilite */);
            batch.graphic.addHiliteCommands(hiliteCommands, batch);
        }
        this._opaqueOverrides = this._translucentOverrides = false;
    }
    // Define a culling frustum. Commands associated with Graphics whose ranges do not intersect the frustum will be skipped.
    setCheckRange(frustum) { this._frustumPlanes = new imodeljs_common_1.FrustumPlanes(frustum); }
    // Clear the culling frustum.
    clearCheckRange() { this._frustumPlanes = undefined; }
}
exports.RenderCommands = RenderCommands;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(94);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(70);
util.inherits = __webpack_require__(50);
/*</replacement>*/

var Readable = __webpack_require__(173);
var Writable = __webpack_require__(177);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
// spell-checker: disable
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Symbology */
/**
 * A set of known colors by name, as a 32-bit integer in the form 0xBBGGRR (red is the low byte).
 * This is different than color values in #RRGGBB format for HTML pages (red and blue are swapped).
 * If your colors don't look right, likely you're using 0xRRGGBB where ColorDef expects 0xBBGGRR.
 */
var ColorByName;
(function (ColorByName) {
    ColorByName[ColorByName["aliceBlue"] = 16775408] = "aliceBlue";
    ColorByName[ColorByName["antiqueWhite"] = 14150650] = "antiqueWhite";
    ColorByName[ColorByName["aqua"] = 16776960] = "aqua";
    ColorByName[ColorByName["aquamarine"] = 13959039] = "aquamarine";
    ColorByName[ColorByName["azure"] = 16777200] = "azure";
    ColorByName[ColorByName["beige"] = 14480885] = "beige";
    ColorByName[ColorByName["bisque"] = 12903679] = "bisque";
    ColorByName[ColorByName["black"] = 0] = "black";
    ColorByName[ColorByName["blanchedAlmond"] = 13495295] = "blanchedAlmond";
    ColorByName[ColorByName["blue"] = 16711680] = "blue";
    ColorByName[ColorByName["blueViolet"] = 14822282] = "blueViolet";
    ColorByName[ColorByName["brown"] = 2763429] = "brown";
    ColorByName[ColorByName["burlyWood"] = 8894686] = "burlyWood";
    ColorByName[ColorByName["cadetBlue"] = 10526303] = "cadetBlue";
    ColorByName[ColorByName["chartreuse"] = 65407] = "chartreuse";
    ColorByName[ColorByName["chocolate"] = 1993170] = "chocolate";
    ColorByName[ColorByName["coral"] = 5275647] = "coral";
    ColorByName[ColorByName["cornflowerBlue"] = 15570276] = "cornflowerBlue";
    ColorByName[ColorByName["cornSilk"] = 14481663] = "cornSilk";
    ColorByName[ColorByName["crimson"] = 3937500] = "crimson";
    ColorByName[ColorByName["cyan"] = 16776960] = "cyan";
    ColorByName[ColorByName["darkBlue"] = 9109504] = "darkBlue";
    ColorByName[ColorByName["darkBrown"] = 2179941] = "darkBrown";
    ColorByName[ColorByName["darkCyan"] = 9145088] = "darkCyan";
    ColorByName[ColorByName["darkGoldenrod"] = 755384] = "darkGoldenrod";
    ColorByName[ColorByName["darkGray"] = 11119017] = "darkGray";
    ColorByName[ColorByName["darkGreen"] = 25600] = "darkGreen";
    ColorByName[ColorByName["darkGrey"] = 11119017] = "darkGrey";
    ColorByName[ColorByName["darkKhaki"] = 7059389] = "darkKhaki";
    ColorByName[ColorByName["darkMagenta"] = 9109643] = "darkMagenta";
    ColorByName[ColorByName["darkOliveGreen"] = 3107669] = "darkOliveGreen";
    ColorByName[ColorByName["darkOrange"] = 36095] = "darkOrange";
    ColorByName[ColorByName["darkOrchid"] = 13382297] = "darkOrchid";
    ColorByName[ColorByName["darkRed"] = 139] = "darkRed";
    ColorByName[ColorByName["darkSalmon"] = 8034025] = "darkSalmon";
    ColorByName[ColorByName["darkSeagreen"] = 9419919] = "darkSeagreen";
    ColorByName[ColorByName["darkSlateBlue"] = 9125192] = "darkSlateBlue";
    ColorByName[ColorByName["darkSlateGray"] = 5197615] = "darkSlateGray";
    ColorByName[ColorByName["darkSlateGrey"] = 5197615] = "darkSlateGrey";
    ColorByName[ColorByName["darkTurquoise"] = 13749760] = "darkTurquoise";
    ColorByName[ColorByName["darkViolet"] = 13828244] = "darkViolet";
    ColorByName[ColorByName["deepPink"] = 9639167] = "deepPink";
    ColorByName[ColorByName["deepSkyBlue"] = 16760576] = "deepSkyBlue";
    ColorByName[ColorByName["dimGray"] = 6908265] = "dimGray";
    ColorByName[ColorByName["dimGrey"] = 6908265] = "dimGrey";
    ColorByName[ColorByName["dodgerBlue"] = 16748574] = "dodgerBlue";
    ColorByName[ColorByName["fireBrick"] = 2237106] = "fireBrick";
    ColorByName[ColorByName["floralWhite"] = 15792895] = "floralWhite";
    ColorByName[ColorByName["forestGreen"] = 2263842] = "forestGreen";
    ColorByName[ColorByName["fuchsia"] = 16711935] = "fuchsia";
    ColorByName[ColorByName["gainsboro"] = 14474460] = "gainsboro";
    ColorByName[ColorByName["ghostWhite"] = 16775416] = "ghostWhite";
    ColorByName[ColorByName["gold"] = 55295] = "gold";
    ColorByName[ColorByName["goldenrod"] = 2139610] = "goldenrod";
    ColorByName[ColorByName["gray"] = 8421504] = "gray";
    ColorByName[ColorByName["green"] = 32768] = "green";
    ColorByName[ColorByName["greenYellow"] = 3145645] = "greenYellow";
    ColorByName[ColorByName["grey"] = 8421504] = "grey";
    ColorByName[ColorByName["honeydew"] = 15794160] = "honeydew";
    ColorByName[ColorByName["hotPink"] = 11823615] = "hotPink";
    ColorByName[ColorByName["indianRed"] = 6053069] = "indianRed";
    ColorByName[ColorByName["indigo"] = 8519755] = "indigo";
    ColorByName[ColorByName["ivory"] = 15794175] = "ivory";
    ColorByName[ColorByName["khaki"] = 9234160] = "khaki";
    ColorByName[ColorByName["lavender"] = 16443110] = "lavender";
    ColorByName[ColorByName["lavenderBlush"] = 16118015] = "lavenderBlush";
    ColorByName[ColorByName["lawnGreen"] = 64636] = "lawnGreen";
    ColorByName[ColorByName["lemonChiffon"] = 13499135] = "lemonChiffon";
    ColorByName[ColorByName["lightBlue"] = 15128749] = "lightBlue";
    ColorByName[ColorByName["lightCoral"] = 8421616] = "lightCoral";
    ColorByName[ColorByName["lightCyan"] = 16777184] = "lightCyan";
    ColorByName[ColorByName["lightGoldenrodYellow"] = 13826810] = "lightGoldenrodYellow";
    ColorByName[ColorByName["lightGray"] = 13882323] = "lightGray";
    ColorByName[ColorByName["lightGreen"] = 9498256] = "lightGreen";
    ColorByName[ColorByName["lightGrey"] = 13882323] = "lightGrey";
    ColorByName[ColorByName["lightPink"] = 12695295] = "lightPink";
    ColorByName[ColorByName["lightSalmon"] = 8036607] = "lightSalmon";
    ColorByName[ColorByName["lightSeagreen"] = 11186720] = "lightSeagreen";
    ColorByName[ColorByName["lightSkyBlue"] = 16436871] = "lightSkyBlue";
    ColorByName[ColorByName["lightSlateGray"] = 10061943] = "lightSlateGray";
    ColorByName[ColorByName["lightSlateGrey"] = 10061943] = "lightSlateGrey";
    ColorByName[ColorByName["lightSteelBlue"] = 14599344] = "lightSteelBlue";
    ColorByName[ColorByName["lightyellow"] = 14745599] = "lightyellow";
    ColorByName[ColorByName["lime"] = 65280] = "lime";
    ColorByName[ColorByName["limeGreen"] = 3329330] = "limeGreen";
    ColorByName[ColorByName["linen"] = 15134970] = "linen";
    ColorByName[ColorByName["magenta"] = 16711935] = "magenta";
    ColorByName[ColorByName["maroon"] = 128] = "maroon";
    ColorByName[ColorByName["mediumAquamarine"] = 11193702] = "mediumAquamarine";
    ColorByName[ColorByName["mediumBlue"] = 13434880] = "mediumBlue";
    ColorByName[ColorByName["mediumOrchid"] = 13850042] = "mediumOrchid";
    ColorByName[ColorByName["mediumPurple"] = 14381203] = "mediumPurple";
    ColorByName[ColorByName["mediumSeaGreen"] = 7451452] = "mediumSeaGreen";
    ColorByName[ColorByName["mediumSlateBlue"] = 15624315] = "mediumSlateBlue";
    ColorByName[ColorByName["mediumSpringGreen"] = 10156544] = "mediumSpringGreen";
    ColorByName[ColorByName["mediumTurquoise"] = 13422920] = "mediumTurquoise";
    ColorByName[ColorByName["mediumVioletRed"] = 8721863] = "mediumVioletRed";
    ColorByName[ColorByName["midnightBlue"] = 7346457] = "midnightBlue";
    ColorByName[ColorByName["mintCream"] = 16449525] = "mintCream";
    ColorByName[ColorByName["mistyRose"] = 14804223] = "mistyRose";
    ColorByName[ColorByName["moccasin"] = 11920639] = "moccasin";
    ColorByName[ColorByName["navajoWhite"] = 11394815] = "navajoWhite";
    ColorByName[ColorByName["navy"] = 8388608] = "navy";
    ColorByName[ColorByName["oldLace"] = 15136253] = "oldLace";
    ColorByName[ColorByName["olive"] = 32896] = "olive";
    ColorByName[ColorByName["oliveDrab"] = 2330219] = "oliveDrab";
    ColorByName[ColorByName["orange"] = 42495] = "orange";
    ColorByName[ColorByName["orangeRed"] = 17919] = "orangeRed";
    ColorByName[ColorByName["orchid"] = 14053594] = "orchid";
    ColorByName[ColorByName["paleGoldenrod"] = 11200750] = "paleGoldenrod";
    ColorByName[ColorByName["paleGreen"] = 10025880] = "paleGreen";
    ColorByName[ColorByName["paleTurquoise"] = 15658671] = "paleTurquoise";
    ColorByName[ColorByName["paleVioletRed"] = 9662683] = "paleVioletRed";
    ColorByName[ColorByName["papayaWhip"] = 14020607] = "papayaWhip";
    ColorByName[ColorByName["peachPuff"] = 12180223] = "peachPuff";
    ColorByName[ColorByName["peru"] = 4163021] = "peru";
    ColorByName[ColorByName["pink"] = 13353215] = "pink";
    ColorByName[ColorByName["plum"] = 14524637] = "plum";
    ColorByName[ColorByName["powderBlue"] = 15130800] = "powderBlue";
    ColorByName[ColorByName["purple"] = 8388736] = "purple";
    ColorByName[ColorByName["rebeccaPurple"] = 10040166] = "rebeccaPurple";
    ColorByName[ColorByName["red"] = 255] = "red";
    ColorByName[ColorByName["rosyBrown"] = 9408444] = "rosyBrown";
    ColorByName[ColorByName["royalBlue"] = 14772545] = "royalBlue";
    ColorByName[ColorByName["saddleBrown"] = 1262987] = "saddleBrown";
    ColorByName[ColorByName["salmon"] = 7504122] = "salmon";
    ColorByName[ColorByName["sandyBrown"] = 6333684] = "sandyBrown";
    ColorByName[ColorByName["seaGreen"] = 5737262] = "seaGreen";
    ColorByName[ColorByName["seaShell"] = 15660543] = "seaShell";
    ColorByName[ColorByName["sienna"] = 2970272] = "sienna";
    ColorByName[ColorByName["silver"] = 12632256] = "silver";
    ColorByName[ColorByName["skyBlue"] = 15453831] = "skyBlue";
    ColorByName[ColorByName["slateBlue"] = 13458026] = "slateBlue";
    ColorByName[ColorByName["slateGray"] = 9470064] = "slateGray";
    ColorByName[ColorByName["slateGrey"] = 9470064] = "slateGrey";
    ColorByName[ColorByName["snow"] = 16448255] = "snow";
    ColorByName[ColorByName["springGreen"] = 8388352] = "springGreen";
    ColorByName[ColorByName["steelBlue"] = 11829830] = "steelBlue";
    ColorByName[ColorByName["tan"] = 9221330] = "tan";
    ColorByName[ColorByName["teal"] = 8421376] = "teal";
    ColorByName[ColorByName["thistle"] = 14204888] = "thistle";
    ColorByName[ColorByName["tomato"] = 4678655] = "tomato";
    ColorByName[ColorByName["turquoise"] = 13688896] = "turquoise";
    ColorByName[ColorByName["violet"] = 15631086] = "violet";
    ColorByName[ColorByName["wheat"] = 11788021] = "wheat";
    ColorByName[ColorByName["white"] = 16777215] = "white";
    ColorByName[ColorByName["whiteSmoke"] = 16119285] = "whiteSmoke";
    ColorByName[ColorByName["yellow"] = 65535] = "yellow";
    ColorByName[ColorByName["yellowGreen"] = 3329434] = "yellowGreen";
})(ColorByName = exports.ColorByName || (exports.ColorByName = {}));
/** A color defined by Hue, Saturation, and Lightness.
 * @see [here](https://en.wikipedia.org/wiki/HSL_and_HSV) for difference between HSL and HSV
 */
class HSLColor {
    constructor() {
        /** Hue */
        this.h = 0;
        /** Saturation */
        this.s = 0;
        /** Lightness */
        this.l = 0;
    }
    clone() { const out = new HSLColor(); out.h = this.h; out.s = this.s; out.l = this.l; return out; }
    toColorDef(out) { return ColorDef.fromHSL(this.h, this.s, this.l, out); }
    static fromColorDef(val, out) { return val.toHSL(out); }
}
exports.HSLColor = HSLColor;
/**
 * A color defined by Hue, Saturation, and Value
 * @see [here](https://en.wikipedia.org/wiki/HSL_and_HSV) for difference between HSL and HSV
 */
class HSVColor {
    constructor() {
        /** Hue */
        this.h = 0;
        /** Saturation */
        this.s = 0;
        /** Value */
        this.v = 0;
    }
    clone() { const out = new HSVColor(); out.h = this.h; out.s = this.s; out.v = this.v; return out; }
    toColorDef(out) { return ColorDef.fromHSV(this, out); }
    static fromColorDef(val, out) { return val.toHSV(out); }
    adjustColor(darkenColor, delta) {
        if (darkenColor) {
            let weightedDelta = delta * 2 /* HSV_VALUE_WEIGHT */;
            if (this.v >= weightedDelta) {
                this.v -= weightedDelta;
            }
            else {
                weightedDelta -= this.v;
                this.v = 0;
                this.s = this.s + weightedDelta < 100 ? this.s + weightedDelta : 100;
            }
        }
        else {
            let weightedDelta = delta * 4 /* HSV_SATURATION_WEIGHT */;
            if (this.s >= weightedDelta) {
                this.s -= weightedDelta;
            }
            else {
                weightedDelta -= this.s;
                this.s = 0;
                this.v = this.v + weightedDelta < 100 ? this.v + weightedDelta : 100;
            }
        }
    }
}
exports.HSVColor = HSVColor;
const scratchBytes = new Uint8Array(4);
const scratchUInt32 = new Uint32Array(scratchBytes.buffer);
/**
 * An integer representation of a color.
 *
 * Colors are stored as 4 components: Red, Blue, Green, and Transparency (0=fully opaque). Each is an 8-bit integer between 0-255.
 *
 * Much confusion results from attempting to interpret those 4 one-byte values as a 4 byte integer. There are generally two sources
 * of confusion:
 *  1. The order the Red, Green, Blue bytes
 *  2. Whether to specify transparency or opacity (sometimes referred to as "alpha")
 *
 * Generally, iModelJs prefers to use `0xTTBBGGRR` (red in the low byte. 0==fully opaque in high byte), but this class provides methods
 * to convert to `0xRRGGBB` (see [[getRgb]]) and `0xAABBGGRR` (red in the low byte, 0==fully transparent in high byte. see [[getAbgr]]).
 *
 * The constructor also accepts strings in the common HTML formats.
 */
class ColorDef {
    /**
     * Create a new ColorDef.
     * @param val value to use.
     * If a number, it is interpreted as a 0xTTBBGGRR (Red in the low byte, high byte is transparency 0==fully opaque) value.
     *
     * If a string, must be in one of the following forms:
     * *"rgb(255,0,0)"*
     * *"rgba(255,0,0,255)"*
     * *"rgb(100%,0%,0%)"*
     * *"hsl(120,50%,50%)"*
     * *"#rrbbgg"*
     * *"blanchedAlmond"* (see possible values from [[ColorByName]]). Case insensitve.
     */
    constructor(val) {
        this._tbgr = 0;
        if (!val)
            return;
        if (typeof val === "number") {
            this.tbgr = val;
            return;
        }
        if (val instanceof ColorDef) {
            this._tbgr = val._tbgr;
            return;
        }
        this.fromString(val);
    }
    /** Swap the red and blue values of a 32-bit integer representing a color. Transparency and green are unchanged. */
    static rgb2bgr(val) { scratchUInt32[0] = val; return scratchBytes[3] << 24 + scratchBytes[0] << 16 + scratchBytes[1] << 8 + scratchBytes[2]; }
    /** Make a copy of this ColorDef */
    clone() { return new ColorDef(this._tbgr); }
    /** Set the color of this ColorDef from another ColorDef */
    setFrom(other) { this._tbgr = other._tbgr; }
    /** Convert this ColorDef to a 32 bit number representing the 0xTTBBGGRR value */
    toJSON() { return this._tbgr; }
    /** Create a new ColorDef from a json object. If the json object is a number, it is assumed to be a 0xTTBBGGRR value. */
    static fromJSON(json) { return new ColorDef(json); }
    /** Initialize or create a ColorDef fromn Red,Green,Blue,Transparency values. All values should be between 0-255 */
    static from(red, green, blue, transparency, result) {
        result = result ? result : new ColorDef();
        scratchBytes[0] = red;
        scratchBytes[1] = green;
        scratchBytes[2] = blue;
        scratchBytes[3] = transparency || 0;
        result._tbgr = scratchUInt32[0];
        return result;
    }
    /** Get the r,g,b,t values from this ColorDef. Returned as an object with {r, g, b, t} members. Values will be integers between 0-255. */
    get colors() { scratchUInt32[0] = this._tbgr; return { b: scratchBytes[2], g: scratchBytes[1], r: scratchBytes[0], t: scratchBytes[3] }; }
    /** The color value of this ColorDef as an integer in the form 0xTTBBGGRR (red in the low byte) */
    get tbgr() { return this._tbgr; }
    set tbgr(tbgr) { scratchUInt32[0] = tbgr; this._tbgr = scratchUInt32[0]; } // force to be a 32 bit unsigned integer
    /** Get the value of the color as a number in 0xAABBGGRR format (i.e. red is in low byte). Transparency (0==fully opaque) converted to alpha (0==fully transparent).  */
    getAbgr() { scratchUInt32[0] = this._tbgr; scratchBytes[3] = 255 - scratchBytes[3]; return scratchUInt32[0]; }
    /** Get the RGB value of the color as a number in 0xRRGGBB format (i.e blue is in the low byte). Transparency is ignored. Value will be from 0 to 2^24 */
    getRgb() { scratchUInt32[0] = this._tbgr; return (scratchBytes[0] << 16) + (scratchBytes[1] << 8) + scratchBytes[2]; }
    /** Change the alpha value for this ColorDef.
     * @param alpha the new alpha value. Must be between 0-255.
     */
    setAlpha(alpha) { scratchUInt32[0] = this._tbgr; scratchBytes[3] = 255 - (alpha | 0); this._tbgr = scratchUInt32[0]; }
    /** Get the alpha value for this ColorDef. Will be between 0-255 */
    getAlpha() { scratchUInt32[0] = this._tbgr; return 255 - scratchBytes[3]; }
    /** True if this ColorDef is fully opaque */
    get isOpaque() { return 255 === this.getAlpha(); }
    /** Change the transparency value for this ColorDef
     * @param transparency the new transparency value. Must be between 0-255, where 0 means 'fully opaque' and 255 means 'fully transparent'.
     */
    setTransparency(transparency) { this.setAlpha(255 - transparency); }
    /** The "known name" for this ColorDef. Will be undefined if color value is not in [[ColorByName]] list */
    get name() { return ColorByName[this._tbgr]; }
    /** Convert this ColorDef to a string in the form "#rrggbb" where values are hex digits of the respective colors */
    toHexString() { return "#" + ("000000" + this.getRgb().toString(16)).slice(-6); }
    /** Convert this ColorDef to a string in the form "rgb(r,g,b)" where values are decimal digits of the respective colors */
    toRgbString() { const c = this.colors; return "rgb(" + (c.r | 0) + "," + (c.g | 0) + "," + (c.b | 0) + ")"; }
    fromString(val) {
        if (typeof val !== "string")
            return this;
        val = val.toLowerCase();
        let m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(val);
        if (m) {
            let color;
            const name = m[1];
            const components = m[2];
            switch (name) {
                case "rgb":
                case "rgba":
                    color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components);
                    if (color) {
                        return ColorDef.from(Math.min(255, parseInt(color[1], 10)), Math.min(255, parseInt(color[2], 10)), Math.min(255, parseInt(color[3], 10)), color[5] != null ? 255 - Math.min(255, parseInt(color[5], 10)) : 0, this);
                    }
                    color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components);
                    if (color) {
                        return ColorDef.from((Math.min(100, parseInt(color[1], 10)) / 100) * 255, (Math.min(100, parseInt(color[2], 10)) / 100) * 255, (Math.min(100, parseInt(color[3], 10)) / 100) * 255, color[5] != null ? 255 - ((Math.min(100, parseInt(color[5], 10)) / 100) * 255) : 0, this);
                    }
                    break;
                case "hsl":
                case "hsla":
                    color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components);
                    if (color) {
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        return ColorDef.fromHSL(h, s, l, this);
                    }
                    break;
            }
            // tslint:disable-next-line:no-conditional-assignment
        }
        else if (m = /^\#([a-f0-9]+)$/.exec(val)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                return ColorDef.from(parseInt(hex.charAt(0) + hex.charAt(0), 16), parseInt(hex.charAt(1) + hex.charAt(1), 16), parseInt(hex.charAt(2) + hex.charAt(2), 16), 0, this);
            }
            if (size === 6) {
                return ColorDef.from(parseInt(hex.charAt(0) + hex.charAt(1), 16), parseInt(hex.charAt(2) + hex.charAt(3), 16), parseInt(hex.charAt(4) + hex.charAt(5), 16), 0, this);
            }
        }
        if (val && val.length > 0) {
            Object.entries(ColorByName).some((v) => {
                if (v[1].toLowerCase() !== val)
                    return false;
                this._tbgr = Number(v[0]);
                return true;
            });
        }
        return this;
    }
    /** Create a ColorDef that is the linear interpolation of this ColorDef and another ColorDef, using a weighting factor.
     * @param color2 The other color
     * @param weight The weighting factor for color2. 0.0 = this color, 1.0 = color2.
     * @param result Optional ColorDef to hold result. If undefined, a new ColorDef is created.
     */
    lerp(color2, weight, result) {
        const color = color2.colors;
        const c = this.colors;
        c.r += (color.r - c.r) * weight;
        c.g += (color.g - c.g) * weight;
        c.b += (color.b - c.b) * weight;
        return ColorDef.from(c.r, c.g, c.b, c.t, result);
    }
    /** Create a ColorDef from hue, saturation, lightness values */
    static fromHSL(h, s, l, out) {
        const torgb = (p1, q1, t) => {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p1 + (q1 - p1) * 6 * t;
            if (t < 1 / 2)
                return q1;
            if (t < 2 / 3)
                return p1 + (q1 - p1) * 6 * (2 / 3 - t);
            return p1;
        };
        const hue2rgb = (p1, q1, t) => Math.round(torgb(p1, q1, t) * 255);
        const modulo = (n, m) => ((n % m) + m) % m;
        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
        // h,s,l ranges are in 0.0 - 1.0
        h = modulo(h, 1);
        s = clamp(s, 0, 1);
        l = clamp(l, 0, 1);
        if (s === 0)
            return ColorDef.from(l, l, l, 0, out);
        const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
        const q = (2 * l) - p;
        return ColorDef.from(hue2rgb(q, p, h + 1 / 3), hue2rgb(q, p, h), hue2rgb(q, p, h - 1 / 3), 0, out);
    }
    /** Create an [[HSLColor]] from this ColorDef */
    toHSL(opt) {
        // h,s,l ranges are in 0.0 - 1.0
        const col = this.colors;
        col.r /= 255;
        col.g /= 255;
        col.b /= 255;
        const max = Math.max(col.r, col.g, col.b);
        const min = Math.min(col.r, col.g, col.b);
        let hue = 0;
        let saturation;
        const lightness = (min + max) / 2.0;
        if (min === max) {
            saturation = 0;
        }
        else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
                case col.r:
                    hue = (col.g - col.b) / delta + (col.g < col.b ? 6 : 0);
                    break;
                case col.g:
                    hue = (col.b - col.r) / delta + 2;
                    break;
                case col.b:
                    hue = (col.r - col.g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        const hsl = opt ? opt : new HSLColor();
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
    }
    /** Create an [[HSVColor]] from this ColorDef */
    toHSV(out) {
        const hsv = out ? out : new HSVColor();
        const { r, g, b } = this.colors;
        let min = (r < g) ? r : g;
        if (b < min)
            min = b;
        let max = (r > g) ? r : g;
        if (b > max)
            max = b;
        /* amount of "blackness" present */
        hsv.v = Math.floor((max / 255.0 * 100) + 0.5);
        const deltaRgb = max - min;
        hsv.s = (max !== 0.0) ? Math.floor((deltaRgb / max * 100) + 0.5) : 0;
        if (hsv.s) {
            const redDistance = (max - r) / deltaRgb;
            const greenDistance = (max - g) / deltaRgb;
            const blueDistance = (max - b) / deltaRgb;
            let intermediateHue;
            if (r === max)
                intermediateHue = blueDistance - greenDistance;
            else if (g === max)
                intermediateHue = 2.0 + redDistance - blueDistance;
            else
                intermediateHue = 4.0 + greenDistance - redDistance;
            /* intermediate hue is [0..6] */
            intermediateHue *= 60;
            if (intermediateHue < 0.0)
                intermediateHue += 360;
            hsv.h = Math.floor(intermediateHue + 0.5);
            if (hsv.h >= 360)
                hsv.h = 0;
        }
        else {
            hsv.h = 0;
        }
        return hsv;
    }
    /** Create a ColorDef from an HSVColor */
    static fromHSV(hsv, out) {
        // Check for simple case first.
        if ((!hsv.s) || (hsv.h === -1)) {
            // hue must be undefined, have no color only white
            const white = 0xff & Math.floor(((255.0 * hsv.v) / 100.0) + 0.5 + 3.0e-14);
            return ColorDef.from(white, white, white, 0, out);
        }
        let dhue = hsv.h, dsaturation = hsv.s, dvalue = hsv.v;
        if (dhue === 360)
            dhue = 0.0;
        dhue /= 60; // hue is now [0..6]
        const hueIntpart = Math.floor(dhue); // convert double -> int
        const hueFractpart = dhue - hueIntpart;
        dvalue /= 100;
        dsaturation /= 100;
        const p = 0xff & Math.floor((dvalue * (1.0 - dsaturation) * 255.0) + 0.5);
        const q = 0xff & Math.floor((dvalue * (1.0 - (dsaturation * hueFractpart)) * 255.0) + 0.5);
        const t = 0xff & Math.floor((dvalue * (1.0 - (dsaturation * (1.0 - hueFractpart))) * 255.0) + 0.5);
        const v = 0xff & Math.floor(dvalue * 255 + 0.5);
        let r = 0, b = 0, g = 0;
        switch (hueIntpart) {
            case 0:
                r = v;
                g = t;
                b = p;
                break; // reddish
            case 1:
                r = q, g = v;
                b = p;
                break; // yellowish
            case 2:
                r = p, g = v;
                b = t;
                break; // greenish
            case 3:
                r = p, g = q;
                b = v;
                break; // cyanish
            case 4:
                r = t, g = p;
                b = v;
                break; // bluish
            case 5:
                r = v, g = p;
                b = q;
                break; // magenta-ish
        }
        return ColorDef.from(r, g, b, 0, out);
    }
    visibilityCheck(other) {
        const fg = this.colors;
        const bg = other.colors;
        // Compute luminosity
        const red = Math.abs(fg.r - bg.r);
        const green = Math.abs(fg.g - bg.g);
        const blue = Math.abs(fg.b - bg.b);
        return (0.30 * red) + (0.59 * green) + (0.11 * blue);
    }
    /**
     * Create a new ColorDef that is adjusted from this ColorDef for maximum contrast against another color. The color will either be lighter
     * or darker, depending on which has more visibility against the other color.
     * @param other the color to contrast with
     * @param alpha optional alpha value for the adjusted color. If not supplied alpha from this color is used.
     */
    adjustForContrast(other, alpha) {
        const visibility = this.visibilityCheck(other);
        if (40 /* VISIBILITY_GOAL */ <= visibility)
            return this.clone();
        const adjPercent = Math.floor(((40 /* VISIBILITY_GOAL */ - visibility) / 255.0) * 100.0);
        alpha = alpha ? alpha : this.getAlpha();
        const darkerHSV = this.toHSV();
        const brightHSV = darkerHSV.clone();
        darkerHSV.adjustColor(true, adjPercent);
        brightHSV.adjustColor(false, adjPercent);
        const darker = ColorDef.fromHSV(darkerHSV);
        darker.setAlpha(alpha);
        const bright = ColorDef.fromHSV(brightHSV);
        bright.setAlpha(alpha);
        if (bright.getRgb() === other.getRgb())
            return darker;
        if (darker.getRgb() === other.getRgb())
            return bright;
        // NOTE: Best choice is the one most visible against the other color...
        return (bright.visibilityCheck(other) >= darker.visibilityCheck(other)) ? bright : darker;
    }
    /** True if the value of this ColorDef is the same as another ColorDef. */
    equals(other) { return this._tbgr === other._tbgr; }
}
/** A black frozen ColorDef. */
ColorDef.black = new ColorDef(ColorByName.black);
/** A white frozen ColorDef. */
ColorDef.white = new ColorDef(ColorByName.white);
/** A red frozen ColorDef. */
ColorDef.red = new ColorDef(ColorByName.red);
/** A green frozen ColorDef. */
ColorDef.green = new ColorDef(ColorByName.green);
/** A blue frozen ColorDef. */
ColorDef.blue = new ColorDef(ColorByName.blue);
exports.ColorDef = ColorDef;
Object.freeze(ColorDef.black);
Object.freeze(ColorDef.white);
Object.freeze(ColorDef.red);
Object.freeze(ColorDef.green);
Object.freeze(ColorDef.blue);
/** An immutable representation of a color with red, green, and blue components each in the integer range [0, 255]. */
class RgbColor {
    /** Constructs from red, green, and blue components.
     * @param r Red
     * @param g Green
     * @param b Blue
     */
    constructor(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.r = Math.max(0, Math.min(this.r, 0xff));
        this.g = Math.max(0, Math.min(this.g, 0xff));
        this.b = Math.max(0, Math.min(this.b, 0xff));
    }
    equals(other) { return this.r === other.r && this.g === other.g && this.b === other.b; }
    /** Constructs from the red, green, and blue components of a ColorDef. The alpha component is ignored. */
    static fromColorDef(colorDef) {
        const colors = colorDef.colors;
        return new RgbColor(colors.r, colors.g, colors.b);
    }
}
exports.RgbColor = RgbColor;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const RpcConfiguration_1 = __webpack_require__(52);
const RpcRequest_1 = __webpack_require__(42);
const RpcProtocol_1 = __webpack_require__(28);
const RpcOperation_1 = __webpack_require__(71);
const RpcRegistry_1 = __webpack_require__(33);
const IModel_1 = __webpack_require__(34);
const IModelError_1 = __webpack_require__(16);
// tslint:disable:space-before-function-paren
let obtainLock = 0;
/** @hidden @internal */
exports.aggregateLoad = { lastRequest: 0, lastResponse: 0 };
/** An RPC operation control response. */
class RpcControlResponse {
}
exports.RpcControlResponse = RpcControlResponse;
/** A pending RPC operation response. */
class RpcPendingResponse extends RpcControlResponse {
    /** Constructs a pending response. */
    constructor(message = "") {
        super();
        this.message = message;
    }
}
exports.RpcPendingResponse = RpcPendingResponse;
/** A RPC operation response . */
class RpcNotFoundResponse extends RpcControlResponse {
}
exports.RpcNotFoundResponse = RpcNotFoundResponse;
/** Manages requests and responses for an RPC configuration. */
class RpcControlChannel {
    constructor(configuration) {
        this.pendingInterval = undefined;
        this.disposeInterval = undefined;
        this.pending = [];
        /** @hidden @internal */
        this.requests = new Map();
        this.pendingLock = 0;
        this.initialized = false;
        this.clientActive = false;
        this._describeEndpoints = undefined;
        this.pendingIntervalHandler = function () {
            const now = new Date().getTime();
            ++this.pendingLock;
            for (const request of this.pending) {
                if (request.connecting || (request.lastSubmitted + request.retryInterval) > now) {
                    continue;
                }
                request.submit();
            }
            --this.pendingLock;
            this.cleanupPendingQueue();
        }.bind(this);
        this.disposeIntervalHandler = function () {
            this.requests.forEach((value, key, _map) => {
                if (value.status === RpcRequest_1.RpcRequestStatus.Finalized) {
                    value.dispose();
                    this.requests.delete(key);
                }
            });
            if (!this.requests.size) {
                clearInterval(this.disposeInterval);
                this.disposeInterval = undefined;
            }
        }.bind(this);
        this.channelInterface = (_a = class extends RpcInterface_1.RpcInterface {
                describeEndpoints() { return this.forward.apply(this, arguments); }
            },
            _a.version = "CONTROL",
            _a.types = () => [],
            _a);
        this.channelImpl = class extends RpcInterface_1.RpcInterface {
            describeEndpoints() {
                const endpoints = [];
                this.configuration.interfaces().forEach((definition) => {
                    if (!RpcRegistry_1.RpcRegistry.instance.isRpcInterfaceInitialized(definition))
                        return;
                    const description = { interfaceName: definition.name, interfaceVersion: definition.version, operationNames: [], compatible: true };
                    RpcOperation_1.RpcOperation.forEach(definition, (operation) => description.operationNames.push(operation.operationName));
                    endpoints.push(description);
                });
                return Promise.resolve(endpoints);
            }
        };
        this.configuration = configuration;
        RpcRequest_1.RpcRequest.events.addListener(this.requestEventHandler, this);
        RpcProtocol_1.RpcProtocol.events.addListener(this.protocolEventHandler, this);
        RpcControlChannel.channels.push(this);
        var _a;
    }
    /** @hidden @internal */
    describeEndpoints() {
        this.activateClient();
        return this._describeEndpoints();
    }
    /** @hidden @internal */
    static obtain(configuration) {
        if (obtainLock)
            return undefined;
        ++obtainLock;
        const channel = new RpcControlChannel(configuration);
        --obtainLock;
        return channel;
    }
    protocolEventHandler(type, object) {
        if (type === RpcProtocol_1.RpcProtocolEvent.ReleaseResources) {
            this.disposeIntervalHandler();
            return;
        }
        if (object.protocol.configuration !== this.configuration)
            return;
        const now = new Date().getTime();
        switch (type) {
            case RpcProtocol_1.RpcProtocolEvent.RequestReceived: {
                exports.aggregateLoad.lastRequest = now;
                break;
            }
            case RpcProtocol_1.RpcProtocolEvent.BackendReportedPending:
            case RpcProtocol_1.RpcProtocolEvent.BackendErrorOccurred:
            case RpcProtocol_1.RpcProtocolEvent.BackendResponseCreated: {
                exports.aggregateLoad.lastResponse = now;
                break;
            }
        }
    }
    requestEventHandler(type, request) {
        if (request.protocol.configuration !== this.configuration)
            return;
        if (type !== RpcRequest_1.RpcRequestEvent.StatusChanged)
            return;
        switch (request.status) {
            case RpcRequest_1.RpcRequestStatus.Created: {
                this.requests.set(request.id, request);
                this.setDisposeInterval();
                break;
            }
            case RpcRequest_1.RpcRequestStatus.Submitted: {
                exports.aggregateLoad.lastRequest = request.lastSubmitted;
                break;
            }
            case RpcRequest_1.RpcRequestStatus.Provisioning:
            case RpcRequest_1.RpcRequestStatus.Pending:
            case RpcRequest_1.RpcRequestStatus.Resolved:
            case RpcRequest_1.RpcRequestStatus.Rejected: {
                exports.aggregateLoad.lastResponse = request.lastUpdated;
                break;
            }
        }
        if (request.client.configuration.controlChannel !== this)
            return;
        switch (request.status) {
            case RpcRequest_1.RpcRequestStatus.Submitted: {
                this.enqueuePending(request);
                break;
            }
            case RpcRequest_1.RpcRequestStatus.Resolved: {
                this.dequeuePending(request);
                break;
            }
            case RpcRequest_1.RpcRequestStatus.Rejected: {
                this.dequeuePending(request);
                break;
            }
            case RpcRequest_1.RpcRequestStatus.NotFound: {
                this.dequeuePending(request);
                break;
            }
        }
    }
    enqueuePending(request) {
        this.pending.push(request);
        this.setPendingInterval();
    }
    dequeuePending(request) {
        if (this.pendingLock)
            return;
        const i = this.pending.indexOf(request);
        this.pending.splice(i, 1);
        this.clearPendingInterval();
    }
    cleanupPendingQueue() {
        if (this.pendingLock)
            return;
        let i = this.pending.length;
        while (i--) {
            if (!this.pending[i].pending) {
                this.pending.splice(i, 1);
            }
        }
        this.clearPendingInterval();
    }
    setPendingInterval() {
        if (this.pendingInterval)
            return;
        this.pendingInterval = setInterval(this.pendingIntervalHandler, 0);
    }
    clearPendingInterval() {
        if (!this.pending.length) {
            clearInterval(this.pendingInterval);
            this.pendingInterval = undefined;
        }
    }
    setDisposeInterval() {
        if (this.disposeInterval)
            return;
        this.disposeInterval = setInterval(this.disposeIntervalHandler, 1000);
    }
    computeId() {
        const interfaces = [];
        this.configuration.interfaces().forEach((definition) => interfaces.push(`${definition.name}@${definition.version}`));
        const id = interfaces.sort().join(",");
        if (typeof (btoa) !== "undefined")
            return btoa(id);
        else if (typeof (Buffer) !== "undefined")
            return Buffer.from(id, "binary").toString("base64");
        else
            return id;
    }
    activateClient() {
        if (this.clientActive)
            return;
        if (!this.initialized) {
            if (this.configuration.interfaces().length)
                throw new IModelError_1.IModelError(32768 /* ERROR */, `Invalid state.`);
            this.initialize(); // WIP...handshakes will eliminate this scenario
        }
        this.clientActive = true;
        RpcOperation_1.RpcOperation.forEach(this.channelInterface, (operation) => operation.policy.token = (_request) => RpcOperation_1.RpcOperation.fallbackToken || new IModel_1.IModelToken("none", "none", "none", "none"));
        const client = RpcManager_1.RpcManager.getClientForInterface(this.channelInterface);
        this._describeEndpoints = () => client.describeEndpoints();
    }
    /** @hidden @internal */
    initialize() {
        if (this.initialized)
            throw new IModelError_1.IModelError(32768 /* ERROR */, `Already initialized.`);
        this.initialized = true;
        const id = this.computeId();
        Object.defineProperty(this.channelInterface, "name", { value: id });
        Object.defineProperty(this.channelImpl, "name", { value: id });
        RpcConfiguration_1.RpcConfiguration.assign(this.channelInterface, () => this.configuration.constructor);
        RpcManager_1.RpcManager.registerImpl(this.channelInterface, this.channelImpl);
        RpcManager_1.RpcManager.initializeInterface(this.channelInterface);
    }
    /** @hidden @internal */
    handleUnknownOperation(invocation, _error) {
        const op = invocation.request.operation;
        if (op.interfaceVersion === "CONTROL" && op.operationName === "describeEndpoints") {
            op.interfaceDefinition = this.channelInterface.name;
            return true;
        }
        return false;
    }
}
/** @hidden @internal */
RpcControlChannel.channels = [];
exports.RpcControlChannel = RpcControlChannel;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
function compareMaterials(lhs, rhs) {
    return bentleyjs_core_1.comparePossiblyUndefined((lhMat, rhMat) => lhMat === rhMat ? 0 : bentleyjs_core_1.compareStringsOrUndefined(lhMat.key, rhMat.key), lhs, rhs);
}
function compareTextureMappings(lhs, rhs) {
    return bentleyjs_core_1.comparePossiblyUndefined((lhTex, rhTex) => lhTex === rhTex ? 0 : bentleyjs_core_1.compareStringsOrUndefined(lhTex.texture.key, rhTex.texture.key), lhs, rhs);
}
/** This class is used to determine if things can be batched together for display. */
class DisplayParams {
    constructor(type, lineColor, fillColor, width = 0, linePixels = 0 /* Solid */, fillFlags = imodeljs_common_1.FillFlags.None, material, gradient, ignoreLighting = false, textureMapping) {
        this.type = DisplayParams.Type.Mesh;
        this.type = type;
        this.material = material;
        this.gradient = gradient;
        this.lineColor = DisplayParams.adjustTransparencyInPlace(lineColor);
        this.fillColor = DisplayParams.adjustTransparencyInPlace(fillColor);
        this.width = width;
        this.linePixels = linePixels;
        this.fillFlags = fillFlags;
        this.ignoreLighting = ignoreLighting;
        this._textureMapping = textureMapping;
        bentleyjs_core_1.assert(undefined === material || undefined === textureMapping);
    }
    /** Creates a DisplayParams object for a particular type (mesh, linear, text) based on the specified GraphicParams. */
    static createForType(type, gf, resolveGradient) {
        const lineColor = DisplayParams.adjustTransparencyInPlace(gf.lineColor.clone());
        switch (type) {
            case DisplayParams.Type.Mesh: {
                let gradientMapping;
                if (undefined !== gf.gradient && undefined !== resolveGradient) {
                    const gradientTexture = resolveGradient(gf.gradient);
                    if (undefined !== gradientTexture)
                        gradientMapping = new imodeljs_common_1.TextureMapping(gradientTexture, new imodeljs_common_1.TextureMapping.Params());
                }
                return new DisplayParams(type, lineColor, DisplayParams.adjustTransparencyInPlace(gf.fillColor.clone()), gf.rasterWidth, gf.linePixels, gf.fillFlags, gf.material, gf.gradient, false, gradientMapping);
            }
            case DisplayParams.Type.Linear:
                return new DisplayParams(type, lineColor, lineColor, gf.rasterWidth, gf.linePixels);
            default:// DisplayParams.Type.Text
                return new DisplayParams(type, lineColor, lineColor, 0, 0 /* Solid */, imodeljs_common_1.FillFlags.Always, undefined, undefined, true);
        }
    }
    /** Creates a DisplayParams object that describes mesh geometry based on the specified GraphicParams. */
    static createForMesh(gf, resolveGradient) {
        return DisplayParams.createForType(DisplayParams.Type.Mesh, gf, resolveGradient);
    }
    /** Creates a DisplayParams object that describes linear geometry based on the specified GraphicParams. */
    static createForLinear(gf) {
        return DisplayParams.createForType(DisplayParams.Type.Linear, gf);
    }
    /** Creates a DisplayParams object that describes text geometry based on the specified GraphicParams. */
    static createForText(gf) {
        return DisplayParams.createForType(DisplayParams.Type.Text, gf);
    }
    get regionEdgeType() {
        if (this.hasBlankingFill)
            return DisplayParams.RegionEdgeType.None;
        if (this.gradient !== undefined && undefined !== this.gradient.flags) {
            // Even if the gradient is not outlined, produce an outline to be displayed as the region's edges when fill ViewFlag is off.
            const gradFlags = this.gradient.flags;
            if (0 !== (gradFlags & 2 /* Outline */) || imodeljs_common_1.FillFlags.None === (this.fillFlags & imodeljs_common_1.FillFlags.Always))
                return DisplayParams.RegionEdgeType.Outline;
            return DisplayParams.RegionEdgeType.None;
        }
        return (!this.fillColor.equals(this.lineColor)) ? DisplayParams.RegionEdgeType.Outline : DisplayParams.RegionEdgeType.Default;
    }
    get wantRegionOutline() {
        return DisplayParams.RegionEdgeType.Outline === this.regionEdgeType;
    }
    get hasBlankingFill() { return imodeljs_common_1.FillFlags.Blanking === (this.fillFlags & imodeljs_common_1.FillFlags.Blanking); }
    get hasFillTransparency() { return 255 !== this.fillColor.getAlpha(); }
    get hasLineTransparency() { return 255 !== this.lineColor.getAlpha(); }
    get textureMapping() { return undefined !== this.material ? this.material.textureMapping : this._textureMapping; }
    get isTextured() { return undefined !== this.textureMapping; }
    /** Determines if the properties of this DisplayParams object are equal to those of another DisplayParams object.  */
    equals(rhs, purpose = DisplayParams.ComparePurpose.Strict) {
        if (DisplayParams.ComparePurpose.Merge === purpose)
            return 0 === this.compareForMerge(rhs);
        else if (rhs === this)
            return true;
        if (this.type !== rhs.type)
            return false;
        if (this.ignoreLighting !== rhs.ignoreLighting)
            return false;
        if (this.width !== rhs.width)
            return false;
        if (this.linePixels !== rhs.linePixels)
            return false;
        if (this.fillFlags !== rhs.fillFlags)
            return false;
        if (this.wantRegionOutline !== rhs.wantRegionOutline)
            return false;
        if (this.material !== rhs.material)
            return false;
        if (this.textureMapping !== rhs.textureMapping)
            return false;
        if (!this.fillColor.equals(rhs.fillColor))
            return false;
        if (!this.lineColor.equals(rhs.lineColor))
            return false;
        return true;
    }
    compareForMerge(rhs) {
        if (rhs === this)
            return 0;
        let diff = bentleyjs_core_1.compareNumbers(this.type, rhs.type);
        if (0 === diff) {
            diff = bentleyjs_core_1.compareBooleans(this.ignoreLighting, rhs.ignoreLighting);
            if (0 === diff) {
                diff = bentleyjs_core_1.compareNumbers(this.width, rhs.width);
                if (0 === diff) {
                    diff = bentleyjs_core_1.compareNumbers(this.linePixels, rhs.linePixels);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareNumbers(this.fillFlags, rhs.fillFlags);
                        if (0 === diff) {
                            diff = bentleyjs_core_1.compareBooleans(this.wantRegionOutline, rhs.wantRegionOutline);
                            if (0 === diff) {
                                diff = bentleyjs_core_1.compareBooleans(this.hasFillTransparency, rhs.hasFillTransparency);
                                if (0 === diff) {
                                    diff = bentleyjs_core_1.compareBooleans(this.hasLineTransparency, rhs.hasLineTransparency);
                                    if (0 === diff) {
                                        diff = compareMaterials(this.material, rhs.material);
                                        if (0 === diff && undefined === this.material && this.isTextured) {
                                            diff = compareTextureMappings(this.textureMapping, rhs.textureMapping);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return diff;
    }
    /**
     * Given a ColorDef object, check its transparency and if it falls below the minimum, mark the color as fully opaque.
     * @return The original reference to the color provided, which has possibly been modified.
     */
    static adjustTransparencyInPlace(color) {
        if (color.colors.t < DisplayParams.minTransparency)
            color.setTransparency(0);
        return color;
    }
}
DisplayParams.minTransparency = 15; // Threshold below which we consider a color fully opaque
exports.DisplayParams = DisplayParams;
(function (DisplayParams) {
    let Type;
    (function (Type) {
        Type[Type["Mesh"] = 0] = "Mesh";
        Type[Type["Linear"] = 1] = "Linear";
        Type[Type["Text"] = 2] = "Text";
    })(Type = DisplayParams.Type || (DisplayParams.Type = {}));
    let RegionEdgeType;
    (function (RegionEdgeType) {
        RegionEdgeType[RegionEdgeType["None"] = 0] = "None";
        RegionEdgeType[RegionEdgeType["Default"] = 1] = "Default";
        RegionEdgeType[RegionEdgeType["Outline"] = 2] = "Outline";
    })(RegionEdgeType = DisplayParams.RegionEdgeType || (DisplayParams.RegionEdgeType = {}));
    let ComparePurpose;
    (function (ComparePurpose) {
        ComparePurpose[ComparePurpose["Merge"] = 0] = "Merge";
        ComparePurpose[ComparePurpose["Strict"] = 1] = "Strict";
    })(ComparePurpose = DisplayParams.ComparePurpose || (DisplayParams.ComparePurpose = {}));
})(DisplayParams = exports.DisplayParams || (exports.DisplayParams = {}));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
var ToleranceRatio;
(function (ToleranceRatio) {
    ToleranceRatio.vertex = 0.1;
    ToleranceRatio.facetArea = 0.1;
})(ToleranceRatio = exports.ToleranceRatio || (exports.ToleranceRatio = {}));
class GeometryOptions {
    constructor(normals = 1 /* Always */, surfaces = 0 /* No */, preserveOrder = 0 /* No */, edges = 1 /* Yes */) {
        this.normals = normals;
        this.surfaces = surfaces;
        this.preserveOrder = preserveOrder;
        this.edges = edges;
    }
    get wantSurfacesOnly() { return this.surfaces === 1 /* Yes */; }
    get wantPreserveOrder() { return this.preserveOrder === 1 /* Yes */; }
    get wantEdges() { return this.edges === 1 /* Yes */; }
    static createForGraphicBuilder(params, normals = 1 /* Always */, surfaces = 0 /* No */) {
        return new GeometryOptions(normals, surfaces, (params.isOverlay || params.isViewBackground) ? 1 /* Yes */ : 0 /* No */, params.isSceneGraphic ? 1 /* Yes */ : 0 /* No */);
    }
}
exports.GeometryOptions = GeometryOptions;
class Triangle {
    constructor(singleSided = true) {
        this.indices = new Uint32Array(3);
        this.visible = [true, true, true];
        this.singleSided = singleSided;
    }
    setIndices(a, b, c) {
        this.indices[0] = a;
        this.indices[1] = b;
        this.indices[2] = c;
    }
    setEdgeVisibility(a, b, c) {
        this.visible[0] = a;
        this.visible[1] = b;
        this.visible[2] = c;
    }
    isEdgeVisible(index) {
        bentleyjs_core_1.assert(index < 3 && index >= 0);
        return this.visible[index];
    }
    get isDegenerate() { return this.indices[0] === this.indices[1] || this.indices[0] === this.indices[2] || this.indices[1] === this.indices[2]; }
}
exports.Triangle = Triangle;
class TriangleList {
    constructor() {
        this._flags = [];
        this.indices = [];
    }
    get length() { return this._flags.length; }
    get isEmpty() { return 0 === this.length; }
    addTriangle(triangle) {
        let flags = triangle.singleSided ? 1 : 0;
        for (let i = 0; i < 3; i++) {
            if (triangle.isEdgeVisible(i))
                flags |= (0x0002 << i);
            this.indices.push(triangle.indices[i]);
        }
        this._flags.push(flags);
    }
    getTriangle(index, out) {
        const triangle = undefined !== out ? out : new Triangle();
        if (index > this.length) {
            bentleyjs_core_1.assert(false);
            return new Triangle();
        }
        const flags = this._flags[index];
        triangle.singleSided = 0 !== (flags & 0x0001);
        const baseIndex = index * 3;
        for (let i = 0; i < 3; i++) {
            triangle.indices[i] = this.indices[baseIndex + i];
            triangle.visible[i] = 0 !== (flags & 0x0002 << i);
        }
        return triangle;
    }
}
exports.TriangleList = TriangleList;
class TriangleKey {
    constructor(triangle) {
        this._sortedIndices = new Uint32Array(3);
        const index = triangle.indices;
        const sorted = this._sortedIndices;
        if (index[0] < index[1]) {
            if (index[0] < index[2]) {
                sorted[0] = index[0];
                if (index[1] < index[2]) {
                    sorted[1] = index[1];
                    sorted[2] = index[2];
                }
                else {
                    sorted[1] = index[2];
                    sorted[2] = index[1];
                }
            }
            else {
                sorted[0] = index[2];
                sorted[1] = index[0];
                sorted[2] = index[1];
            }
        }
        else {
            if (index[1] < index[2]) {
                sorted[0] = index[1];
                if (index[0] < index[2]) {
                    sorted[1] = index[0];
                    sorted[2] = index[2];
                }
                else {
                    sorted[1] = index[2];
                    sorted[2] = index[0];
                }
            }
            else {
                sorted[0] = index[2];
                sorted[1] = index[1];
                sorted[2] = index[0];
            }
        }
        bentleyjs_core_1.assert(sorted[0] < sorted[1]);
        bentleyjs_core_1.assert(sorted[1] < sorted[2]);
    }
    compare(rhs) {
        let diff = 0;
        for (let i = 0; i < 3; i++) {
            diff = this._sortedIndices[i] - rhs._sortedIndices[i];
            if (0 !== diff)
                break;
        }
        return diff;
    }
}
exports.TriangleKey = TriangleKey;
class TriangleSet extends bentleyjs_core_1.SortedArray {
    constructor() {
        super((lhs, rhs) => lhs.compare(rhs));
    }
    insertKey(triangle, onInsert) {
        return this.insert(new TriangleKey(triangle), onInsert);
    }
}
exports.TriangleSet = TriangleSet;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(17);
const IModelApp_1 = __webpack_require__(5);
const TileIO_1 = __webpack_require__(74);
const B3dmTileIO_1 = __webpack_require__(335);
const PntsTileIO_1 = __webpack_require__(336);
const IModelTileIO_1 = __webpack_require__(338);
function compareMissingTiles(lhs, rhs) {
    const diff = bentleyjs_core_1.compareNumbers(lhs.depth, rhs.depth);
    return 0 === diff ? bentleyjs_core_1.compareStrings(lhs.id, rhs.id) : diff;
}
// ###TODO: TileRequests and MissingNodes are likely to change...
class MissingNodes extends bentleyjs_core_1.SortedArray {
    constructor() { super(compareMissingTiles); }
}
exports.MissingNodes = MissingNodes;
class TileRequests {
    constructor() {
        this._map = new Map();
    }
    getMissing(root) {
        let found = this._map.get(root);
        if (undefined === found) {
            found = new MissingNodes();
            this._map.set(root, found);
        }
        return found;
    }
}
exports.TileRequests = TileRequests;
class Tile {
    // ###TODO: Artificially limiting depth for now until tile selection is fixed...
    constructor(props, _maxDepth = 32) {
        this._maxDepth = _maxDepth;
        this.root = props.root;
        this.range = props.range;
        this.parent = props.parent;
        this.depth = 1 + (undefined !== this.parent ? this.parent.depth : 0);
        this.loadStatus = 0 /* NotLoaded */;
        this.id = props.id;
        this.maximumSize = props.maximumSize;
        this._childIds = props.childIds;
        this._childrenLastUsed = bentleyjs_core_1.BeTimePoint.now();
        this._contentRange = props.contentRange;
        this.yAxisUp = props.yAxisUp ? props.yAxisUp : false;
        // ###TODO: Defer loading of graphics (separate request to backend to obtain tile geometry)
        this.loadGraphics(props.geometry);
        this.center = this.range.low.interpolate(0.5, this.range.high);
        this.radius = 0.5 * this.range.low.distance(this.range.high);
        // ###TODO: Back-end is not setting maximumSize in json!
        if (undefined === this.maximumSize)
            this.maximumSize = this.hasGraphics ? 512 : 0;
        this._childrenLoadStatus = this.hasChildren && this.depth < this._maxDepth ? TileTree.LoadStatus.NotLoaded : TileTree.LoadStatus.Loaded;
    }
    dispose() {
        this._graphic = bentleyjs_core_1.dispose(this._graphic);
        if (this._children)
            for (const child of this._children)
                bentleyjs_core_1.dispose(child);
        this._children = undefined;
        this.loadStatus = 5 /* Abandoned */;
    }
    loadGraphics(blob) {
        if (undefined === blob) {
            this.setIsReady();
            return;
        }
        this.loadStatus = 2 /* Loading */;
        const streamBuffer = new TileIO_1.TileIO.StreamBuffer(blob.buffer);
        const format = streamBuffer.nextUint32;
        const isCanceled = () => !this.isLoading;
        let reader;
        streamBuffer.rewind(4);
        switch (format) {
            case 1835283298 /* B3dm */:
                reader = B3dmTileIO_1.B3dmTileIO.Reader.create(streamBuffer, this.root.model, this.range, IModelApp_1.IModelApp.renderSystem, this.yAxisUp, isCanceled);
                break;
            case 1416521572 /* IModel */:
                reader = IModelTileIO_1.IModelTileIO.Reader.create(streamBuffer, this.root.model, IModelApp_1.IModelApp.renderSystem, isCanceled);
                break;
            case 1937010288 /* Pnts */:
                {
                    this._graphic = PntsTileIO_1.PntsTileIO.readPointCloud(streamBuffer, this.root.model, this.range, IModelApp_1.IModelApp.renderSystem, this.yAxisUp);
                    this.setIsReady();
                    return;
                }
        }
        if (undefined === reader) {
            this.setNotFound();
            return;
        }
        const read = reader.read();
        read.catch((_err) => this.setNotFound());
        read.then((result) => {
            // Make sure we still want this tile - may been unloaded, imodel may have been closed, IModelApp may have shut down taking render system with it, etc.
            if (this.isLoading) {
                this._graphic = result.renderGraphic;
                this.setIsReady();
            }
        });
    }
    get isQueued() { return 1 /* Queued */ === this.loadStatus; }
    get isAbandoned() { return 5 /* Abandoned */ === this.loadStatus; }
    get isNotLoaded() { return 0 /* NotLoaded */ === this.loadStatus; }
    get isLoading() { return 2 /* Loading */ === this.loadStatus; }
    get isNotFound() { return 4 /* NotFound */ === this.loadStatus; }
    get isReady() { return 3 /* Ready */ === this.loadStatus; }
    setIsReady() { this.loadStatus = 3 /* Ready */; }
    setIsQueued() { this.loadStatus = 1 /* Queued */; }
    setNotLoaded() { this.loadStatus = 0 /* NotLoaded */; }
    setNotFound() { this.loadStatus = 4 /* NotFound */; }
    setAbandoned() {
        const children = this.children;
        if (undefined !== children)
            for (const child of children)
                child.setAbandoned();
        this.loadStatus = 5 /* Abandoned */;
    }
    get isEmpty() { return this.isReady && !this.hasGraphics && !this.hasChildren; }
    get hasChildren() { return 0 !== this._childIds.length; }
    get contentRange() { return undefined !== this._contentRange ? this._contentRange : this.range; }
    get isLeaf() { return !this.hasChildren; }
    get isDisplayable() { return this.maximumSize > 0; }
    get isParentDisplayable() { return undefined !== this.parent && this.parent.isDisplayable; }
    get graphics() { return this._graphic; }
    get hasGraphics() { return undefined !== this.graphics; }
    get hasZoomFactor() { return undefined !== this.zoomFactor; }
    get children() { return this._children; }
    get iModel() { return this.root.iModel; }
    get hasContentRange() { return undefined !== this._contentRange; }
    isRegionCulled(args) { return this.isCulled(this.range, args); }
    isContentCulled(args) { return this.isCulled(this.contentRange, args); }
    /** Returns the range of this tile's contents in world coordinates. */
    computeWorldContentRange() {
        const range = new imodeljs_common_1.ElementAlignedBox3d();
        this.root.location.multiplyRange(this.contentRange, range);
        return range;
    }
    computeVisibility(args) {
        // NB: We test for region culling before isDisplayable - otherwise we will never unload children of undisplayed tiles when
        // they are outside frustum
        if (this.isEmpty || this.isRegionCulled(args))
            return 0 /* OutsideFrustum */;
        // some nodes are merely for structure and don't have any geometry
        if (!this.isDisplayable)
            return 1 /* TooCoarse */;
        const hasContentRange = this.hasContentRange;
        if (!this.hasChildren) {
            if (hasContentRange && this.isContentCulled(args))
                return 0 /* OutsideFrustum */;
            else
                return 2 /* Visible */; // it's a leaf node
        }
        const radius = args.getTileRadius(this); // use a sphere to test pixel size. We don't know the orientation of the image within the bounding box.
        const center = args.getTileCenter(this);
        const pixelSizeAtPt = args.context.getPixelSizeAtPoint(center);
        const pixelSize = 0 !== pixelSizeAtPt ? radius / pixelSizeAtPt : 1.0e-3;
        if (pixelSize > this.maximumSize * args.tileSizeModifier)
            return 1 /* TooCoarse */;
        else if (hasContentRange && this.isContentCulled(args))
            return 0 /* OutsideFrustum */;
        else
            return 2 /* Visible */;
    }
    selectTiles(selected, args, numSkipped = 0) {
        const vis = this.computeVisibility(args);
        if (0 /* OutsideFrustum */ === vis) {
            this.unloadChildren(args.purgeOlderThan);
            return 0 /* No */;
        }
        if (2 /* Visible */ === vis) {
            // This tile is of appropriate resolution to draw. If need loading or refinement, enqueue.
            if (!this.isReady)
                args.insertMissing(this);
            if (this.hasGraphics) {
                // It can be drawn - select it
                selected.push(this);
                this.unloadChildren(args.purgeOlderThan);
            }
            else {
                // It can't be drawn. If direct children are drawable, draw them in this tile's place; otherwise draw the parent.
                // Do not load/request the children for this purpose.
                const initialSize = selected.length;
                const kids = this.children;
                if (undefined === kids)
                    return 1 /* Yes */;
                for (const kid of kids) {
                    if (0 /* OutsideFrustum */ !== kid.computeVisibility(args)) {
                        if (!kid.hasGraphics) {
                            selected.length = initialSize;
                            return 1 /* Yes */;
                        }
                        else {
                            selected.push(kid);
                        }
                    }
                }
                this._childrenLastUsed = args.now;
            }
            // We're drawing either this tile, or its direct children.
            return 0 /* No */;
        }
        // This tile is too coarse to draw. Try to draw something more appropriate.
        // If it is not ready to draw, we may want to skip loading in favor of loading its descendants.
        let canSkipThisTile = this.isReady || this.isParentDisplayable;
        if (canSkipThisTile && this.isDisplayable) {
            // Some tiles do not sub-divide - they only facet the same geometry to a higher resolution. We can skip directly to the correct resolution.
            const isNotReady = !this.hasGraphics && !this.hasZoomFactor;
            if (isNotReady) {
                if (numSkipped >= this.root.maxTilesToSkip)
                    canSkipThisTile = false;
                else
                    numSkipped += 1;
            }
        }
        this.loadChildren(); // NB: asynchronous
        const children = canSkipThisTile ? this.children : undefined;
        if (undefined !== children) {
            this._childrenLastUsed = args.now;
            let allChildrenDrawable = true;
            const initialSize = selected.length;
            for (const child of children) {
                if (1 /* Yes */ === child.selectTiles(selected, args, numSkipped))
                    allChildrenDrawable = false; // NB: We must continue iterating children so that they can be requested if missing.
            }
            if (allChildrenDrawable)
                return 0 /* No */;
            selected.length = initialSize;
        }
        if (this.hasGraphics) {
            if (!this.isReady)
                args.insertMissing(this);
            selected.push(this);
            return 0 /* No */;
        }
        args.insertMissing(this);
        return this.isParentDisplayable ? 1 /* Yes */ : 0 /* No */;
    }
    drawGraphics(args) {
        if (undefined !== this.graphics)
            args.graphics.add(this.graphics);
    }
    unloadChildren(olderThan) {
        const children = this.children;
        if (undefined === children) {
            return;
        }
        if (this._childrenLastUsed.milliseconds > olderThan.milliseconds) {
            // this node has been used recently. Keep it, but potentially unload its grandchildren.
            for (const child of children)
                child.unloadChildren(olderThan);
        }
        else {
            for (const child of children) {
                child.setAbandoned();
                child.dispose();
            }
            this._children = undefined;
            this._childrenLoadStatus = TileTree.LoadStatus.NotLoaded;
        }
    }
    isCulled(range, args) {
        const box = imodeljs_common_1.Frustum.fromRange(range, Tile.scratchRootFrustum);
        const worldBox = box.transformBy(args.location, Tile.scratchWorldFrustum);
        const isOutside = 0 /* Outside */ === args.context.frustumPlanes.computeFrustumContainment(worldBox);
        const isClipped = !isOutside && undefined !== args.clip && 3 /* StronglyOutside */ === args.clip.classifyPointContainment(box.points);
        const isCulled = isOutside || isClipped;
        return isCulled;
    }
    loadChildren() {
        if (TileTree.LoadStatus.NotLoaded === this._childrenLoadStatus) {
            this._childrenLoadStatus = TileTree.LoadStatus.Loading;
            this.root.loader.getTileProps(this._childIds).then((props) => {
                this._children = [];
                this._childrenLoadStatus = TileTree.LoadStatus.Loaded;
                if (undefined !== props) {
                    // If this tile is undisplayable, update its content range based on children's content ranges.
                    const parentRange = this.hasContentRange ? undefined : new imodeljs_common_1.ElementAlignedBox3d();
                    for (const prop of props) {
                        // ###TODO if child is empty don't bother adding it to list...
                        const child = new Tile(Tile.Params.fromJSON(prop, this.root, this), this.root.loader.getMaxDepth());
                        this._children.push(child);
                        if (undefined !== parentRange && !child.isEmpty)
                            parentRange.extendRange(child.contentRange);
                    }
                    if (undefined !== parentRange)
                        this._contentRange = parentRange;
                }
                IModelApp_1.IModelApp.viewManager.onNewTilesReady();
            }).catch((_err) => { this._childrenLoadStatus = TileTree.LoadStatus.NotFound; this._children = undefined; });
        }
        return this._childrenLoadStatus;
    }
}
Tile.scratchWorldFrustum = new imodeljs_common_1.Frustum();
Tile.scratchRootFrustum = new imodeljs_common_1.Frustum();
exports.Tile = Tile;
(function (Tile) {
    /** Arguments used when selecting and drawing tiles. */
    class DrawArgs {
        constructor(context, location, root, now, purgeOlderThan, clip) {
            this.graphics = new System_1.GraphicBranch();
            this.location = location;
            this.root = root;
            this.clip = clip;
            this.context = context;
            this.now = now;
            this.purgeOlderThan = purgeOlderThan;
            this.graphics.setViewFlagOverrides(root.viewFlagOverrides);
            this.missing = context.requests.getMissing(root);
        }
        get tileSizeModifier() { return 1.0; } // ###TODO? may adjust for performance, or device pixel density, etc
        getTileCenter(tile) { return this.location.multiplyPoint3d(tile.center); }
        getTileRadius(tile) {
            let range = tile.range.clone(DrawArgs.scratchRange);
            range = this.location.multiplyRange(range, range);
            return 0.5 * (tile.root.is3d ? range.low.distance(range.high) : range.low.distanceXY(range.high));
        }
        clear() {
            this.graphics.clear();
            this.missing.clear();
        }
        drawGraphics() {
            if (this.graphics.isEmpty)
                return;
            // const clipVolume = this.clip !== undefined ? IModelApp.renderSystem.getClipVolume(this.clip, this.root.iModel) : undefined;
            const branch = this.context.createBranch(this.graphics, this.location, undefined);
            this.context.outputGraphic(branch);
        }
        insertMissing(tile) { this.missing.insert(tile); }
    }
    DrawArgs.scratchRange = new geometry_core_1.Range3d();
    Tile.DrawArgs = DrawArgs;
    /** Parameters used to construct a Tile. */
    class Params {
        constructor(root, id, range, maximumSize, childIds, yAxisUp, parent, contentRange, zoomFactor, geometry) {
            this.root = root;
            this.id = id;
            this.range = range;
            this.maximumSize = maximumSize;
            this.childIds = childIds;
            this.yAxisUp = yAxisUp;
            this.parent = parent;
            this.contentRange = contentRange;
            this.zoomFactor = zoomFactor;
            this.geometry = geometry;
        }
        static fromJSON(props, root, parent) {
            // ###TODO: We should be requesting the geometry separately, when needed
            // ###TODO: Transmit as binary, not base-64
            let tileBytes;
            if (typeof props.geometry === "string") {
                tileBytes = new Uint8Array(atob(props.geometry).split("").map((c) => c.charCodeAt(0)));
            }
            else if (props.geometry instanceof ArrayBuffer) {
                tileBytes = new Uint8Array(props.geometry);
            }
            else {
                tileBytes = undefined;
            }
            const contentRange = undefined !== props.contentRange ? imodeljs_common_1.ElementAlignedBox3d.fromJSON(props.contentRange) : undefined;
            return new Params(root, props.id.tileId, imodeljs_common_1.ElementAlignedBox3d.fromJSON(props.range), props.maximumSize, props.childIds, props.yAxisUp, parent, contentRange, props.zoomFactor, tileBytes);
        }
    }
    Tile.Params = Params;
})(Tile = exports.Tile || (exports.Tile = {}));
class TileTree {
    constructor(props) {
        this.model = props.model;
        this.id = props.id;
        this.location = props.location;
        this.expirationTime = bentleyjs_core_1.BeDuration.fromSeconds(5000); // ###TODO tile purging strategy
        this.clipVector = props.clipVector;
        this.viewFlagOverrides = undefined !== props.viewFlagOverrides ? props.viewFlagOverrides : new imodeljs_common_1.ViewFlag.Overrides();
        this.maxTilesToSkip = bentleyjs_core_1.JsonUtils.asInt(props.maxTilesToSkip, 100);
        this._rootTile = new Tile(Tile.Params.fromJSON(props.rootTile, this));
        this._loader = props.loader;
    }
    get rootTile() { return this._rootTile; }
    get loader() { return this._loader; }
    dispose() {
        bentleyjs_core_1.dispose(this._rootTile);
    }
    get is3d() { return this.model.is3d; }
    get is2d() { return this.model.is2d; }
    get modelId() { return this.model.id; }
    get iModel() { return this.model.iModel; }
    get range() { return this._rootTile !== undefined ? this._rootTile.range : new imodeljs_common_1.ElementAlignedBox3d(); }
    selectTilesForScene(context) { return this.selectTiles(this.createDrawArgs(context)); }
    selectTiles(args) {
        const selected = [];
        if (undefined !== this._rootTile)
            this._rootTile.selectTiles(selected, args);
        return selected;
    }
    drawScene(context) { this.draw(this.createDrawArgs(context)); }
    draw(args) {
        const selectedTiles = this.selectTiles(args);
        for (const selectedTile of selectedTiles)
            selectedTile.drawGraphics(args);
        args.drawGraphics();
    }
    // ###TODO: requestTile(), requestTiles()
    createDrawArgs(context) {
        const now = bentleyjs_core_1.BeTimePoint.now();
        const purgeOlderThan = now.minus(this.expirationTime);
        return new Tile.DrawArgs(context, this.location, this, now, purgeOlderThan, this.clipVector);
    }
    constructTileId(tileId) { return new imodeljs_common_1.TileId(this.id, tileId); }
}
exports.TileTree = TileTree;
class TileLoader {
}
exports.TileLoader = TileLoader;
class IModelTileLoader {
    constructor(iModel, rootId) {
        this.iModel = iModel;
        this.rootId = rootId;
    }
    getMaxDepth() { return 32; } // Can be removed when element tile selector is working.
    async getTileProps(ids) {
        const tileIds = ids.map((id) => new imodeljs_common_1.TileId(this.rootId, id));
        return this.iModel.tiles.getTileProps(tileIds);
    }
}
exports.IModelTileLoader = IModelTileLoader;
(function (TileTree) {
    /** Parameters used to construct a TileTree */
    class Params {
        constructor(id, rootTile, model, loader, location, maxTilesToSkip, clipVector, viewFlagOverrides) {
            this.id = id;
            this.rootTile = rootTile;
            this.model = model;
            this.loader = loader;
            this.location = location;
            this.maxTilesToSkip = maxTilesToSkip;
            this.clipVector = clipVector;
            this.viewFlagOverrides = viewFlagOverrides;
        }
        static fromJSON(props, model, loader) {
            return new Params(bentleyjs_core_1.Id64.fromJSON(props.id), props.rootTile, model, loader, geometry_core_1.Transform.fromJSON(props.location), props.maxTilesToSkip);
        }
    }
    TileTree.Params = Params;
    let LoadStatus;
    (function (LoadStatus) {
        LoadStatus[LoadStatus["NotLoaded"] = 0] = "NotLoaded";
        LoadStatus[LoadStatus["Loading"] = 1] = "Loading";
        LoadStatus[LoadStatus["Loaded"] = 2] = "Loaded";
        LoadStatus[LoadStatus["NotFound"] = 3] = "NotFound";
    })(LoadStatus = TileTree.LoadStatus || (TileTree.LoadStatus = {}));
})(TileTree = exports.TileTree || (exports.TileTree = {}));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
const geometry_core_1 = __webpack_require__(1);
const Sprites_1 = __webpack_require__(97);
/**
 * A HitDetail identifies an approximate location on an element or pickable decoration. A HitDetail stores the result when locating geometry displayed in a view.
 */
class HitDetail {
    /**
     * Create a new HitDetail from the inputs to and results of a locate operation.
     * @param testPoint The world coordinate space point that was used as the locate point.
     * @param viewport The view the locate operation was performed in.
     * @param hitSource The procedure that requested the locate operation.
     * @param hitPoint The approximate world coordinate location on the geometry identified by this HitDetail.
     * @param sourceId The source of the geometry, either a persistent element id or pickable decoration id.
     * @param priority The hit geometry priority/classification.
     * @param distXY The xy distance to hit in view coordinates.
     * @param distFraction The near plane distance fraction to hit.
     */
    constructor(testPoint, viewport, hitSource, hitPoint, sourceId, priority, distXY, distFraction) {
        this.testPoint = testPoint;
        this.viewport = viewport;
        this.hitSource = hitSource;
        this.hitPoint = hitPoint;
        this.sourceId = sourceId;
        this.priority = priority;
        this.distXY = distXY;
        this.distFraction = distFraction;
    }
    getHitType() { return 1 /* Hit */; }
    getPoint() { return this.hitPoint; }
    isSnapDetail() { return false; }
    isSameHit(otherHit) { return (undefined !== otherHit && this.sourceId === otherHit.sourceId); }
    isElementHit() { return true; } // NEEDSWORK: Check that sourceId is a valid Id64 for an element...
    clone() { const val = new HitDetail(this.testPoint, this.viewport, this.hitSource, this.hitPoint, this.sourceId, this.priority, this.distXY, this.distFraction); return val; }
    draw(_context) { this.viewport.setFlashed(this.sourceId, 0.25); }
}
exports.HitDetail = HitDetail;
class SnapDetail extends HitDetail {
    /** Constructor for SnapDetail.
     * @param from The HitDetail that created this snap
     * @param snapMode The SnapMode used to create this SnapDetail
     * @param heat The SnapHeat of this SnapDetail
     * @param snapPoint The snapped point in the element
     */
    constructor(from, snapMode = 1 /* Nearest */, heat = 0 /* None */, snapPoint) {
        super(from.testPoint, from.viewport, from.hitSource, from.hitPoint, from.sourceId, from.priority, from.distXY, from.distFraction);
        this.snapMode = snapMode;
        this.heat = heat;
        this.snapPoint = geometry_core_1.Point3d.fromJSON(snapPoint ? snapPoint : from.hitPoint);
        this.adjustedPoint = this.snapPoint.clone();
        this.sprite = Sprites_1.IconSprites.getSprite(SnapDetail.getSnapSprite(snapMode), from.viewport);
    }
    getHitType() { return 2 /* Snap */; }
    getPoint() { return this.isHot() ? this.snapPoint : super.getPoint(); }
    isSnapDetail() { return true; }
    isHot() { return this.heat !== 0 /* None */; }
    isPointAdjusted() { return !this.adjustedPoint.isExactEqual(this.snapPoint); }
    setSnapPoint(point, heat) { this.snapPoint.setFrom(point); this.adjustedPoint.setFrom(point); this.heat = heat; }
    /** Set curve primitive and HitGeometryType for this SnapDetail. */
    setCurvePrimitive(primitive, localToWorld, geomType) {
        this.primitive = primitive;
        this.geomType = undefined;
        // Only HitGeomType.Point and HitGeomType.Surface are valid without a curve primitive.
        if (undefined === this.primitive) {
            if (1 /* Point */ === geomType || 5 /* Surface */ === geomType)
                this.geomType = geomType;
            return;
        }
        if (undefined !== localToWorld)
            this.primitive.tryTransformInPlace(localToWorld);
        if (this.primitive instanceof geometry_core_1.Arc3d)
            this.geomType = 4 /* Arc */;
        else if (this.primitive instanceof geometry_core_1.LineSegment3d)
            this.geomType = 2 /* Segment */;
        else if (this.primitive instanceof geometry_core_1.LineString3d)
            this.geomType = 2 /* Segment */;
        else
            this.geomType = 3 /* Curve */;
        // Set curve primitive geometry type override...
        //  - HitGeomType.Point with arc/ellipse denotes center.
        //  - HitGeomType.Surface with any curve primitive denotes an interior hit.
        if (undefined !== geomType && 0 /* None */ !== geomType)
            this.geomType = geomType;
    }
    clone() {
        const val = new SnapDetail(this, this.snapMode, this.heat, this.snapPoint);
        val.sprite = this.sprite;
        val.geomType = this.geomType;
        val.adjustedPoint.setFrom(this.adjustedPoint);
        if (undefined !== this.primitive)
            val.primitive = this.primitive.clone();
        if (undefined !== this.normal)
            val.normal = this.normal.clone();
        return val;
    }
    draw(context) {
        if (undefined !== this.primitive) {
            const graphic = context.createWorldOverlay();
            graphic.setSymbology(context.viewport.hilite.color, context.viewport.hilite.color, 2); // ### TODO Get weight from SnapResponse + Subcaetegory Appearance...
            switch (this.snapMode) {
                case 8 /* Center */:
                case 16 /* Origin */:
                case 32 /* Bisector */:
                    break; // Snap point for these is computed using entire linestring, not just the hit segment...
                default: {
                    if (this.primitive instanceof geometry_core_1.LineString3d) {
                        const ls = this.primitive;
                        if (ls.points.length > 2) {
                            const loc = ls.closestPoint(this.snapPoint, false);
                            const nSegments = ls.points.length - 1;
                            const uSegRange = (1.0 / nSegments);
                            let segmentNo = Math.floor(loc.fraction / uSegRange);
                            if (segmentNo >= nSegments)
                                segmentNo = nSegments - 1;
                            const points = [ls.points[segmentNo].clone(), ls.points[segmentNo + 1].clone()];
                            graphic.addLineString(points);
                            context.addWorldOverlay(graphic.finish());
                            return;
                        }
                    }
                    break;
                }
            }
            graphic.addPath(geometry_core_1.Path.create(this.primitive));
            context.addWorldOverlay(graphic.finish());
            return;
        }
        super.draw(context);
    }
    static getSnapSprite(snapType) {
        switch (snapType) {
            case 1 /* Nearest */: return "SnapPointOn";
            case 2 /* NearestKeypoint */: return "SnapKeypoint";
            case 4 /* MidPoint */: return "SnapMidpoint";
            case 8 /* Center */: return "SnapCenter";
            case 16 /* Origin */: return "SnapOrigin";
            case 32 /* Bisector */: return "SnapBisector";
            case 64 /* Intersection */: return "SnapIntersection";
        }
        return "";
    }
}
exports.SnapDetail = SnapDetail;
class IntersectDetail extends SnapDetail {
}
exports.IntersectDetail = IntersectDetail;
/**
 * The result of a "locate" is a sorted list of objects that satisfied the search criteria (a HitList). Earlier hits in the list
 *  are somehow "better" than those later on.
 */
class HitList {
    constructor() {
        this.hits = [];
        this.currHit = -1;
    }
    get length() { return this.hits.length; }
    empty() { this.hits.length = 0; this.currHit = -1; }
    resetCurrentHit() { this.currHit = -1; }
    /**
     * get a hit from a particular index into a HitList
     * return the requested hit from the HitList or undefined
     */
    getHit(hitNum) {
        if (hitNum < 0)
            hitNum = this.length - 1;
        return (hitNum >= this.length) ? undefined : this.hits[hitNum];
    }
    /** When setting one or more indices to undefined you must call dropNulls afterwards */
    setHit(i, p) {
        if (i < 0 || i >= this.length)
            return;
        this.hits[i] = p;
    }
    dropNulls() {
        const hits = this.hits;
        this.hits = [];
        for (const hit of hits)
            this.hits.push(hit);
    }
    getNextHit() { this.currHit++; return this.getCurrentHit(); }
    getCurrentHit() { return -1 === this.currHit ? undefined : this.getHit(this.currHit); }
    setCurrentHit(hit) {
        this.resetCurrentHit();
        for (let thisHit; undefined !== (thisHit = this.getNextHit());) {
            if (thisHit === hit)
                return;
        }
    }
    /** remove the current hit from the list. */
    removeCurrentHit() { this.removeHit(this.currHit); }
    /** remove a hit in the list. */
    removeHit(hitNum) {
        if (hitNum < 0)
            hitNum = this.length - 1;
        if (hitNum <= this.currHit)
            this.currHit = -1;
        if (hitNum >= this.length)
            return; // Then Reset call RemoteCurrentHit, which passes in currHit. When it is out of range, we do nothing.
        this.hits.splice(hitNum, 1);
    }
    /** search through list and remove any hits that contain a specified element id. */
    removeHitsFrom(sourceId) {
        let removedOne = false;
        // walk backwards through list so we don't have to worry about what happens on remove
        for (let i = this.length - 1; i >= 0; i--) {
            const thisHit = this.hits[i];
            if (thisHit && sourceId === thisHit.sourceId) {
                removedOne = true;
                this.removeHit(i);
            }
        }
        return removedOne;
    }
    getPriorityZOverride(priority) {
        switch (priority) {
            case 0 /* WireEdge */:
            case 1 /* PlanarEdge */:
            case 2 /* NonPlanarEdge */:
                return 0;
            case 3 /* SilhouetteEdge */:
                return 1;
            case 4 /* PlanarSurface */:
            case 5 /* NonPlanarSurface */:
                return 2;
            default:
                return 3;
        }
    }
    /** compare two hits for insertion into list. */
    compare(hit1, hit2) {
        if (!hit1 || !hit2)
            return 0;
        const zOverride1 = this.getPriorityZOverride(hit1.priority);
        const zOverride2 = this.getPriorityZOverride(hit2.priority);
        // Prefer edges over surfaces, this is more important than z because we know the edge isn't obscured...
        if (zOverride1 < zOverride2)
            return -1;
        if (zOverride1 > zOverride2)
            return 1;
        // Compare xy distance from pick point, prefer hits closer to center...
        if (hit1.distXY < hit2.distXY)
            return -1;
        if (hit1.distXY > hit2.distXY)
            return 1;
        // Compare distance fraction, prefer hits closer to eye...
        if (hit1.distFraction > hit2.distFraction)
            return -1;
        if (hit1.distFraction < hit2.distFraction)
            return 1;
        // Compare geometry class, prefer path/region hits over surface hits when all else is equal...
        if (hit1.priority < hit2.priority)
            return -1;
        if (hit1.priority > hit2.priority)
            return 1;
        return 0;
    }
    /** Add a new hit to the list. Hits are sorted according to their priority and distance. */
    addHit(newHit) {
        if (0 === this.hits.length) {
            this.hits.push(newHit);
            return 0;
        }
        let index = 0;
        for (; index < this.hits.length; ++index) {
            const oldHit = this.hits[index];
            const comparison = this.compare(newHit, oldHit);
            if (comparison < 0)
                break;
        }
        this.hits.splice(index, 0, newHit);
        return index;
    }
    /** Insert a new hit into the list at the supplied index. */
    insertHit(i, hit) {
        if (i < 0 || i >= this.length)
            this.hits.push(hit);
        else
            this.hits.splice(i, 0, hit);
    }
}
exports.HitList = HitList;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(17);
const Texture_1 = __webpack_require__(19);
const FeatureDimensions_1 = __webpack_require__(100);
const FloatRGBA_1 = __webpack_require__(35);
const EdgeOverrides_1 = __webpack_require__(55);
const GL_1 = __webpack_require__(8);
class OvrUniform {
    constructor() {
        this.floatFlags = 0;
        this.weight = 0;
        this.lineCode = 0;
        this.unused = 0;
        this.rgba = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.black, 0);
        this.flags = 0 /* None */;
    }
    isFlagSet(flag) { return 0 /* None */ !== (this.flags & flag); }
    get anyOverridden() { return 0 /* None */ !== this.flags; }
    get allHidden() { return this.isFlagSet(1 /* Visibility */); }
    get anyOpaque() { return this.isFlagSet(4 /* Alpha */) && 1.0 === this.rgba.alpha; } // ###TODO: alpha???
    get anyTranslucent() { return this.isFlagSet(4 /* Alpha */) && 1.0 > this.rgba.alpha; }
    get anyHilited() { return this.isFlagSet(32 /* Hilited */); }
    initialize(map, ovrs, hilite, flashed) {
        this.update(map, hilite, flashed, ovrs);
    }
    update(map, hilites, flashedElemId, ovrs) {
        bentleyjs_core_1.assert(map.isUniform);
        // NB: To be consistent with the lookup table approach for non-uniform feature tables and share shader code, we pass
        // the override data as two RGBA values - hence all the conversions to floating point range [0.0..1.0]
        const kvp = map.getArray()[0];
        const isFlashed = flashedElemId.isValid && kvp.value.elementId.value === flashedElemId.value;
        const isHilited = hilites.has(kvp.value.elementId.value);
        if (undefined === ovrs) {
            // We only need to update the 'flashed' and 'hilited' flags
            // NB: Don't do so if the feature is invisible
            if (0 /* None */ === (this.flags & 1 /* Visibility */)) {
                this.flags = isFlashed ? (this.flags | 16 /* Flashed */) : (this.flags & ~16 /* Flashed */);
                this.flags = isHilited ? (this.flags | 32 /* Hilited */) : (this.flags & ~32 /* Hilited */);
                this.floatFlags = this.flags / 256.0;
            }
            return;
        }
        this.floatFlags = this.weight = this.lineCode = this.unused = 0;
        this.rgba = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.black, 0);
        this.flags = 0 /* None */;
        const app = ovrs.getAppearance(kvp.value, map.modelId);
        if (undefined === app) {
            // We're invisible. Don't care about any other overrides.
            this.flags = 1 /* Visibility */;
            this.floatFlags = this.flags / 256.0;
            return;
        }
        if (isFlashed)
            this.flags |= 16 /* Flashed */;
        if (isHilited)
            this.flags |= 32 /* Hilited */;
        if (app.overridesRgb && app.rgb) {
            this.flags |= 2 /* Rgb */;
            this.rgba = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.from(app.rgb.r, app.rgb.g, app.rgb.b, 1.0)); // NB: Alpha ignored unless OvrFlags.Alpha set...
        }
        if (app.overridesAlpha && app.alpha) {
            const alpha = (255.0 - app.alpha) / 255.0; // ###TODO: app.alpha appears to actually be transparency - fix property name!
            this.flags |= 4 /* Alpha */;
            this.rgba = new FloatRGBA_1.FloatRgba(this.rgba.red, this.rgba.green, this.rgba.blue, alpha); // NB: rgb ignored unless OvrFlags.Rgb set...
        }
        if (app.overridesWeight && app.weight) {
            this.flags |= 8 /* Weight */;
            this.weight = app.weight / 256.0;
        }
        if (app.overridesLinePixels && app.linePixels) {
            this.flags |= 64 /* LineCode */;
            this.lineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(app.linePixels) / 256.0;
        }
        if (app.ignoresMaterial)
            this.flags |= 128 /* IgnoreMaterial */;
        this.floatFlags = this.flags / 256.0;
    }
}
class OvrNonUniform {
    constructor() {
        this.lutParams = new FeatureDimensions_1.LUTParams(1, 1);
        this.anyOverridden = true;
        this.allHidden = true;
        this.anyTranslucent = true;
        this.anyOpaque = true;
        this.anyHilited = true;
    }
    initialize(map, ovrs, hilite, flashedElemId) {
        const nFeatures = map.length;
        const dims = FeatureDimensions_1.LUTDimensions.computeWidthAndHeight(nFeatures, 2);
        const width = dims.width;
        const height = dims.height;
        bentleyjs_core_1.assert(width * height >= nFeatures);
        this.lutParams = new FeatureDimensions_1.LUTParams(width, height);
        const data = new Uint8Array(width * height * 4);
        const creator = new Texture_1.TextureDataUpdater(data);
        this.buildLookupTable(creator, map, ovrs, hilite, flashedElemId);
        return Texture_1.TextureHandle.createForData(width, height, data, true, GL_1.GL.Texture.WrapMode.ClampToEdge);
    }
    update(map, lut, hilites, flashedElemId, ovrs) {
        const updater = new Texture_1.TextureDataUpdater(lut.dataBytes);
        if (undefined === ovrs)
            this.updateFlashedAndHilited(updater, map, hilites, flashedElemId);
        else
            this.buildLookupTable(updater, map, ovrs, hilites, flashedElemId);
        lut.update(updater);
    }
    buildLookupTable(data, map, ovr, hilites, flashedElemId) {
        this.anyOpaque = this.anyTranslucent = this.anyHilited = false;
        let nHidden = 0;
        let nOverridden = 0;
        // NB: We currently use 2 RGBA values per feature as follows:
        //  [0]
        //      R = override flags (see FeatureOverrides::Flags)
        //      G = line weight
        //      B = line code
        //      A = unused
        //  [1]
        //      RGB = rgb
        //      A = alpha
        const arr = map.getArray();
        for (const kvp of arr) {
            const feature = kvp.value;
            const dataIndex = kvp.index * 4 * 2;
            const app = ovr.getAppearance(feature, map.modelId);
            if (undefined === app || (app.overridesAlpha && 0.0 === app.alpha)) {
                // The feature is not visible. We don't care about any of the other overrides, because we're not going to render it.
                data.setOvrFlagsAtIndex(dataIndex, 1 /* Visibility */);
                nHidden++;
                nOverridden++;
                continue;
            }
            let flags = 0 /* None */;
            if (hilites.has(feature.elementId.value)) {
                flags |= 32 /* Hilited */;
                this.anyHilited = true;
            }
            if (app.overridesRgb && app.rgb) {
                flags |= 2 /* Rgb */;
                const rgb = app.rgb;
                data.setByteAtIndex(dataIndex + 4, rgb.r);
                data.setByteAtIndex(dataIndex + 5, rgb.g);
                data.setByteAtIndex(dataIndex + 6, rgb.b);
            }
            if (app.overridesAlpha && app.alpha) {
                flags |= 4 /* Alpha */;
                const alpha = 255 - app.alpha; // ###TODO: ???
                data.setByteAtIndex(dataIndex + 7, alpha);
                if (255 === alpha)
                    this.anyOpaque = true;
                else
                    this.anyTranslucent = true;
            }
            if (app.overridesWeight && app.weight) {
                flags |= 8 /* Weight */;
                let weight = app.weight;
                weight = Math.min(31, weight);
                weight = Math.max(1, weight);
                data.setByteAtIndex(dataIndex + 1, weight);
            }
            if (app.overridesLinePixels && app.linePixels) {
                flags |= 64 /* LineCode */;
                const lineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(app.linePixels);
                data.setByteAtIndex(dataIndex + 2, lineCode);
            }
            if (app.ignoresMaterial)
                flags |= 128 /* IgnoreMaterial */;
            if (flashedElemId.isValid() && feature.elementId.value === flashedElemId.value)
                flags |= 16 /* Flashed */;
            data.setOvrFlagsAtIndex(dataIndex, flags);
            if (0 /* None */ !== flags)
                nOverridden++;
        }
        this.allHidden = (nHidden === map.length);
        this.anyOverridden = (nOverridden > 0);
    }
    updateFlashedAndHilited(data, map, hilites, flashedElemId) {
        this.anyOverridden = false;
        this.anyHilited = false;
        const arr = map.getArray();
        for (const kvp of arr) {
            const feature = kvp.value;
            const dataIndex = kvp.index * 4 * 2;
            const oldFlags = data.getFlagsAtIndex(dataIndex);
            if (0 /* None */ !== (oldFlags & 1 /* Visibility */)) {
                // Do the same thing as when applying feature overrides - if it's invisible, none of the other flags matter
                // (and if we don't check this we can end up rendering silhouettes around invisible elements in selection set)
                this.anyOverridden = true;
                continue;
            }
            const isFlashed = feature.elementId.value === flashedElemId.value;
            const isHilited = hilites.has(feature.elementId.value);
            let newFlags = isFlashed ? (oldFlags | 16 /* Flashed */) : (oldFlags & ~16 /* Flashed */);
            newFlags = isHilited ? (newFlags | 32 /* Hilited */) : (newFlags & ~32 /* Hilited */);
            data.setOvrFlagsAtIndex(dataIndex, newFlags);
            if (0 /* None */ !== newFlags) {
                this.anyOverridden = true;
                this.anyHilited = this.anyHilited || isHilited;
            }
        }
    }
}
class FeatureOverrides {
    constructor(target) {
        this.dimension = 0 /* Uniform */;
        this._lastOverridesUpdated = bentleyjs_core_1.BeTimePoint.now();
        this._lastFlashUpdated = bentleyjs_core_1.BeTimePoint.now();
        this._lastHiliteUpdated = bentleyjs_core_1.BeTimePoint.now();
        this.target = target;
    }
    static createFromTarget(target) {
        return new FeatureOverrides(target);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        this.lut = undefined;
    }
    get isNonUniform() { return 1 /* NonUniform */ === this.dimension; }
    get isUniform() { return !this.isNonUniform; }
    get anyOverridden() { return this._uniform ? this._uniform.anyOverridden : this._nonUniform.anyOverridden; }
    get allHidden() { return this._uniform ? this._uniform.allHidden : this._nonUniform.allHidden; }
    get anyOpaque() { return this._uniform ? this._uniform.anyOpaque : this._nonUniform.anyOpaque; }
    get anyTranslucent() { return this._uniform ? this._uniform.anyTranslucent : this._nonUniform.anyTranslucent; }
    get anyHilited() { return this._uniform ? this._uniform.anyHilited : this._nonUniform.anyHilited; }
    get uniform1() {
        if (this.isUniform) {
            const uniform = this._uniform;
            return new Float32Array([uniform.floatFlags, uniform.weight, uniform.lineCode, uniform.unused]);
        }
        return new Float32Array(4);
    }
    get uniform2() {
        if (this.isUniform) {
            const rgba = this._uniform.rgba;
            return new Float32Array([rgba.red, rgba.green, rgba.blue, rgba.alpha]);
        }
        return new Float32Array(4);
    }
    initFromMap(map) {
        const nFeatures = map.length;
        bentleyjs_core_1.assert(0 < nFeatures);
        this._uniform = this._nonUniform = undefined;
        this.lut = undefined;
        const ovrs = this.target.currentFeatureSymbologyOverrides;
        const hilite = this.target.hilite;
        if (1 < nFeatures) {
            this._nonUniform = new OvrNonUniform();
            this.lut = this._nonUniform.initialize(map, ovrs, hilite, this.target.flashedElemId);
            this.dimension = 1 /* NonUniform */;
        }
        else {
            this._uniform = new OvrUniform();
            this._uniform.initialize(map, ovrs, hilite, this.target.flashedElemId);
            this.dimension = 0 /* Uniform */;
        }
        this._lastOverridesUpdated = this._lastFlashUpdated = this._lastHiliteUpdated = bentleyjs_core_1.BeTimePoint.now();
    }
    update(features) {
        const styleLastUpdated = this.target.overridesUpdateTime;
        const flashLastUpdated = this.target.flashedUpdateTime;
        const ovrsUpdated = this._lastOverridesUpdated.before(styleLastUpdated);
        const hiliteLastUpdated = this.target.hiliteUpdateTime;
        const hiliteUpdated = this._lastHiliteUpdated.before(hiliteLastUpdated);
        const ovrs = ovrsUpdated ? this.target.currentFeatureSymbologyOverrides : undefined;
        const hilite = this.target.hilite;
        if (ovrsUpdated || hiliteUpdated || this._lastFlashUpdated.before(flashLastUpdated)) {
            if (this.isUniform)
                this._uniform.update(features, hilite, this.target.flashedElemId, ovrs);
            else
                this._nonUniform.update(features, this.lut, hilite, this.target.flashedElemId, ovrs);
            this._lastOverridesUpdated = styleLastUpdated;
            this._lastFlashUpdated = flashLastUpdated;
            this._lastHiliteUpdated = hiliteLastUpdated;
        }
    }
}
exports.FeatureOverrides = FeatureOverrides;
const scratchUint32 = new Uint32Array(1);
const scratchBytes = new Uint8Array(scratchUint32.buffer);
function uint32ToFloatArray(value) {
    scratchUint32[0] = value;
    const floats = new Float32Array(4);
    for (let i = 0; i < 4; i++)
        floats[i] = scratchBytes[i] / 255.0;
    return floats;
}
function createUniformPickTable(elemId) {
    return {
        elemId0: uint32ToFloatArray(elemId.getLowUint32()),
        elemId1: uint32ToFloatArray(elemId.getHighUint32()),
    };
}
function createNonUniformPickTable(features) {
    const nFeatures = features.length;
    if (nFeatures <= 1) {
        bentleyjs_core_1.assert(false);
        return undefined;
    }
    const dims = FeatureDimensions_1.LUTDimensions.computeWidthAndHeight(nFeatures, 2);
    bentleyjs_core_1.assert(dims.width * dims.height >= nFeatures);
    const bytes = new Uint8Array(dims.width * dims.height * 4);
    const ids = new Uint32Array(bytes.buffer);
    for (const entry of features.getArray()) {
        const elemId = entry.value.elementId;
        const index = entry.index;
        ids[index * 2] = elemId.getLowUint32();
        ids[index * 2 + 1] = elemId.getHighUint32();
    }
    return Texture_1.TextureHandle.createForData(dims.width, dims.height, bytes);
}
function createPickTable(features) {
    if (!features.anyDefined)
        return {};
    else if (features.isUniform)
        return { uniform: createUniformPickTable(features.uniform.elementId) };
    else
        return { nonUniform: createNonUniformPickTable(features) };
}
function wantJointTriangles(lineWeight, is2d) {
    // Joints are incredibly expensive. In 3d, only generate them if the line is sufficiently wide for them to be noticeable.
    const jointWidthThreshold = 5;
    return is2d || lineWeight > jointWidthThreshold;
}
exports.wantJointTriangles = wantJointTriangles;
class Graphic extends System_1.RenderGraphic {
    addHiliteCommands(_commands, _batch) { bentleyjs_core_1.assert(false); }
    assignUniformFeatureIndices(_index) { } // ###TODO: Implement for Primitive
    toPrimitive() { return undefined; }
}
exports.Graphic = Graphic;
class Batch extends Graphic {
    constructor(graphic, features, range) {
        super();
        this._overrides = [];
        this.graphic = graphic;
        this.featureTable = features;
        this.range = range;
    }
    // Note: This does not remove FeatureOverrides from the array, but rather disposes of the WebGL resources they contain
    dispose() {
        bentleyjs_core_1.dispose(this.graphic);
        for (const over of this._overrides) {
            over.target.onBatchDisposed(this);
            bentleyjs_core_1.dispose(over);
        }
        this._overrides.length = 0;
    }
    get pickTable() {
        if (undefined === this._pickTable)
            this._pickTable = createPickTable(this.featureTable);
        return this._pickTable;
    }
    addCommands(commands) { commands.addBatch(this); }
    getOverrides(target) {
        let ret;
        for (const ovr of this._overrides) {
            if (ovr.target === target) {
                ret = ovr;
                break;
            }
        }
        if (undefined === ret) {
            ret = FeatureOverrides.createFromTarget(target);
            this._overrides.push(ret);
            target.addBatch(this);
            // ###TODO target.addBatch(*this);
            ret.initFromMap(this.featureTable);
        }
        ret.update(this.featureTable);
        return ret;
    }
    onTargetDisposed(target) {
        let index = 0;
        let foundIndex = -1;
        for (const ovr of this._overrides) {
            if (ovr.target === target) {
                foundIndex = index;
                break;
            }
            index++;
        }
        if (foundIndex > -1) {
            bentleyjs_core_1.dispose(this._overrides[foundIndex]);
            this._overrides.splice(foundIndex, 1);
        }
    }
}
exports.Batch = Batch;
class Branch extends Graphic {
    constructor(branch, localToWorld = geometry_core_1.Transform.createIdentity(), clips, viewFlags) {
        super();
        this.branch = branch;
        this.localToWorldTransform = localToWorld;
        this.clips = clips;
        if (undefined !== viewFlags)
            branch.setViewFlags(viewFlags);
    }
    dispose() { }
    addCommands(commands) { commands.addBranch(this); }
    assignUniformFeatureIndices(index) {
        for (const entry of this.branch.entries) {
            entry.assignUniformFeatureIndices(index);
        }
    }
}
exports.Branch = Branch;
class WorldDecorations extends Branch {
    constructor(viewFlags) {
        super(new System_1.GraphicBranch(), geometry_core_1.Transform.createIdentity(), undefined, viewFlags);
        this.overrides = [];
    }
    init(decs) {
        this.branch.clear();
        this.overrides.length = 0;
        for (const dec of decs.list) {
            this.branch.add(dec.graphic);
            this.overrides.push(dec.overrides);
        }
    }
}
exports.WorldDecorations = WorldDecorations;
class GraphicsList extends Graphic {
    // Note: We assume the graphics array we get contains undisposed graphics to start
    constructor(graphics) {
        super();
        this.graphics = graphics;
    }
    dispose() {
        for (const graphic of this.graphics)
            bentleyjs_core_1.dispose(graphic);
        this.graphics.length = 0;
    }
    addCommands(commands) {
        for (const graphic of this.graphics) {
            graphic.addCommands(commands);
        }
    }
    addHiliteCommands(commands, batch) {
        for (const graphic of this.graphics) {
            graphic.addHiliteCommands(commands, batch);
        }
    }
    assignUniformFeatureIndices(index) {
        for (const gf of this.graphics) {
            gf.assignUniformFeatureIndices(index);
        }
    }
}
exports.GraphicsList = GraphicsList;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const Graphic_1 = __webpack_require__(64);
const DrawCommand_1 = __webpack_require__(56);
const FeaturesInfo_1 = __webpack_require__(87);
const DrawCommand_2 = __webpack_require__(56);
const bentleyjs_core_1 = __webpack_require__(0);
class PolylineParamVertex {
    constructor(isSegmentStart, isPolylineStartOrEnd, point, prevPoint, nextPoint, color, attrib, length) {
        this.isSegmentStart = isSegmentStart;
        this.isPolylineStartOrEnd = isPolylineStartOrEnd;
        this.point = point;
        this.prevPoint = prevPoint;
        this.nextPoint = nextPoint;
        this.color = color;
        this.attrib = attrib;
        this.length = length;
    }
    DotProduct() {
        const prevDir = geometry_core_1.Vector3d.createStartEnd(this.prevPoint, this.point);
        prevDir.normalizeInPlace();
        const nextDir = geometry_core_1.Vector3d.createStartEnd(this.nextPoint, this.point);
        nextDir.normalizeInPlace();
        return prevDir.dotProduct(nextDir);
    }
    GetParam(negatePerp, adjacentToJoint = false, joint = false, noDisplacement = false) {
        if (joint)
            return 12 /* kJointBase */;
        let param = this.isPolylineStartOrEnd ? 3 /* kSquare */ : 6 /* kMiter */;
        if (noDisplacement)
            param = 96 /* kNoneAdjWt */; // prevent getting tossed before width adjustment
        else if (adjacentToJoint)
            param = 9 /* kMiterInsideOnly */;
        let adjust = 0 /* kNone */;
        if (negatePerp)
            adjust = 24 /* kNegatePerp */;
        if (!this.isSegmentStart)
            adjust += 48 /* kNegateAlong */;
        param = adjust + param;
        return param;
    }
}
exports.PolylineParamVertex = PolylineParamVertex;
class Primitive extends Graphic_1.Graphic {
    constructor(cachedGeom) {
        super();
        this.isPixelMode = false;
        this.cachedGeometry = cachedGeom;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.cachedGeometry);
    }
    getRenderPass(target) {
        if (this.isPixelMode)
            return 8 /* ViewOverlay */;
        return this.cachedGeometry.getRenderPass(target);
    }
    get featureIndexType() {
        const feature = this.cachedGeometry.featuresInfo;
        if (feature instanceof FeaturesInfo_1.FeaturesInfo)
            return feature.type;
        return 0 /* Empty */;
    }
    get usesMaterialColor() {
        const materialData = this.cachedGeometry.material;
        return undefined !== materialData && (materialData.overridesRgb || materialData.overridesAlpha);
    }
    get isLit() { return this.cachedGeometry.isLitSurface; }
    addCommands(commands) { commands.addPrimitive(this); }
    addHiliteCommands(commands, batch) {
        // Edges do not contribute to hilite pass.
        // Note that IsEdge() does not imply geom->ToEdge() => true...polylines can be edges too...
        if (!this.isEdge) {
            commands.push(DrawCommand_2.DrawCommand.createForPrimitive(this, batch));
        }
    }
    setUniformFeatureIndices(featId) { this.cachedGeometry.uniformFeatureIndices = featId; }
    get isEdge() { return false; }
    toPrimitive() { return this; }
    draw(shader) {
        // ###TODO: local to world should be pushed before we're invoked...we shouldn't need to pass (or copy) it
        const drawParams = new DrawCommand_1.DrawParams(shader.target, this.cachedGeometry, shader.target.currentTransform, shader.renderPass);
        shader.draw(drawParams);
    }
    getTechniqueId(target) { return this.cachedGeometry.getTechniqueId(target); }
    get debugString() { return this.cachedGeometry.debugString; }
}
exports.Primitive = Primitive;
class SkyBoxPrimitive extends Primitive {
    constructor(cachedGeom) { super(cachedGeom); }
    get renderOrder() { return 2 /* Surface */; }
}
exports.SkyBoxPrimitive = SkyBoxPrimitive;
class PointCloudPrimitive extends Primitive {
    constructor(cachedGeom) { super(cachedGeom); }
    get renderOrder() { return 2 /* Surface */; }
}
exports.PointCloudPrimitive = PointCloudPrimitive;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const PointVector_1 = __webpack_require__(4);
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(3);
const GrowableArray_1 = __webpack_require__(37);
// import { Arc3d } from "../curve/Arc3d";
/* tslint:disable:variable-name*/
class Degree2PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0) {
        this.coffs = [c0, c1, c2];
    }
    /**
     * * Return 2 duplicate roots in double root case.
     * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)
     */
    static solveQuadratic(a, b, c) {
        const b1 = Geometry_1.Geometry.conditionalDivideFraction(b, a);
        const c1 = Geometry_1.Geometry.conditionalDivideFraction(c, a);
        if (b1 !== undefined && c1 !== undefined) {
            // now solving xx + b1*x + c1 = 0 -- i.e. implied "a" coefficient is 1 . .
            const q = b1 * b1 - 4 * c1;
            if (q > 0) {
                const e = Math.sqrt(q);
                // e is positive, so this sorts algebraically
                return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];
            }
            if (q < 0)
                return undefined;
            const root = -0.5 * b1;
            return [root, root];
        }
        // "divide by a" failed.  solve bx + c = 0
        const x = Geometry_1.Geometry.conditionalDivideFraction(-c, b);
        if (x !== undefined)
            return [x];
        return undefined;
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    // Add s * (a + b*x)^2 to the quadratic coefficients
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    realRoots() {
        const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);
        if (ss && ss.length > 1) {
            if (ss[0] > ss[1]) {
                const temp = ss[0];
                ss[0] = ss[1];
                ss[1] = temp;
            }
        }
        return ss;
    }
    /**
     * Evaluate the quadratic at x.
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + 2 * x * this.coffs[2];
    }
    // Factor the polyonmial as c0 + c1 * x + c2 * x*x = y0 + c2 * (x-x0)^2
    tryGetVertexFactorization() {
        const x = Geometry_1.Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);
        if (x !== undefined) {
            const y = this.evaluate(x);
            return { c: this.coffs[2], x0: x, y0: y };
        }
        return undefined;
    }
    static fromRootsAndC2(root0, root1, c2 = 1) {
        return new Degree2PowerPolynomial(c2 * root0 * root1, -c2 * (root0 + root1), c2);
    }
}
exports.Degree2PowerPolynomial = Degree2PowerPolynomial;
class Degree3PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 1) {
        this.coffs = [c0, c1, c2, c3];
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    // Add s * (a + b*x)^2 to the quadratic coefficients
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    /**
     * Evaluate the polynomial at x
     * @param u parameter for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));
    }
    /**
     * Evaluate the polynomial derivative
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);
    }
    static fromRootsAndC3(root0, root1, root2, c3 = 1.0) {
        return new Degree3PowerPolynomial(-c3 * root0 * root1 * root2, c3 * (root0 * root1 + root1 * root2 + root0 * root2), -c3 * (root0 + root1 + root2), c3);
    }
}
exports.Degree3PowerPolynomial = Degree3PowerPolynomial;
class Degree4PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0) {
        this.coffs = [c0, c1, c2, c3, c4];
    }
    addConstant(a) {
        this.coffs[0] += a;
    }
    /**
     * Evaluate the polynomial
     * @param x x coordinate for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));
    }
    /**
     * Evaluate the derivative
     * @param x x coordinate for evaluation
     */
    evaluateDerivative(x) {
        return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));
    }
    static fromRootsAndC4(root0, root1, root2, root3, c4 = 1) {
        return new Degree4PowerPolynomial(c4 * (root0 * root1 * root2 * root3), -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3), c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3), -c4 * (root0 + root1 + root2 + root3), c4);
    }
}
exports.Degree4PowerPolynomial = Degree4PowerPolynomial;
class TorusImplicit {
    constructor(majorRadiusR, minorRadiusr) {
        this.majorRadius = majorRadiusR;
        this.minorRadius = minorRadiusr;
    }
    // Return size of box (e.g. for use as scale factor)
    boxSize() {
        return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));
    }
    /** @returns a scale factor appropriate to control the magnitude of the implicit function. */
    implicitFunctionScale() {
        const a = this.boxSize();
        if (a === 0.0)
            return 1.0;
        return 1.0 / (a * a * a * a);
    }
    // Implicit equation for the torus is ...
    // (x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)
    // x,y,z are weighted,
    // (x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)
    evaluateImplicitFunctionXYZ(x, y, z) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + (R2 - r2);
        const g = 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    evaluateImplicitFunctionPoint(xyz) {
        return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);
    }
    evaluateImplicitFunctionXYZW(x, y, z, w) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const w2 = w * w;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + w2 * (R2 - r2);
        const g = w2 * 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    // public intersectRay(ray: Ray3d, rayFractions: number, points: Point3d, maxHit: number) {}
    evaluateThetaPhi(theta, phi) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        // theta=0 point
        const x0 = this.majorRadius + this.minorRadius * Math.cos(phi);
        const z0 = this.minorRadius * Math.sin(phi);
        return PointVector_1.Point3d.create(c * x0, s * x0, z0);
    }
    evaluateDerivativesThetaPhi(theta, phi, dxdTheta, dxdPhi) {
        const cTheta = Math.cos(theta);
        const sTheta = Math.sin(theta);
        const bx = this.minorRadius * Math.cos(phi);
        const bz = this.minorRadius * Math.sin(phi);
        const x0 = this.majorRadius + bx;
        PointVector_1.Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);
        PointVector_1.Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);
    }
    evaluateThetaPhiDistance(theta, phi, distance) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        // theta=0 point
        const x0 = this.majorRadius + distance * Math.cos(phi);
        const z0 = distance * Math.sin(phi);
        return PointVector_1.Point3d.create(c * x0, s * x0, z0);
    }
    /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization
     * * theta = angular coordinate in xy plane
     * * phi = angular coordinate in minor circle.
     * * distance = distance from major circle
     * * rho = distance from origin to xy part of the input.
     * @param xyz space point in local coordinates.
     * @return object with properties theta, phi, distance, rho
     */
    XYZToThetaPhiDistance(xyz) {
        const rho = xyz.magnitudeXY();
        const majorRadiusFactor = Geometry_1.Geometry.conditionalDivideFraction(this.majorRadius, rho);
        let safeMajor;
        let majorCirclePoint;
        if (majorRadiusFactor) {
            safeMajor = true;
            majorCirclePoint = PointVector_1.Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);
        }
        else {
            safeMajor = false;
            majorCirclePoint = PointVector_1.Point3d.create(xyz.x, xyz.y, 0.0);
        }
        const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;
        const vectorFromMajorCircle = PointVector_1.Vector3d.createStartEnd(majorCirclePoint, xyz);
        const distance = vectorFromMajorCircle.magnitude();
        const drho = rho - this.majorRadius;
        let safePhi;
        let phi;
        if (xyz.z === 0.0 && drho === 0.0) {
            phi = 0.0;
            safePhi = false;
        }
        else {
            phi = Math.atan2(xyz.z, drho);
            safePhi = true;
        }
        return { theta: (theta), phi: (phi), distance: (distance), rho: (rho), safePhi: safeMajor && safePhi };
    }
}
exports.TorusImplicit = TorusImplicit;
/**
 * evaluation methods for an implicit sphere `x*x + y*y + z*z - r*r = 0`.
 */
class SphereImplicit {
    constructor(r) { this.radius = r; }
    // Evaluate the implicit function at space point
    // @param [in] xyz coordinates
    evaluateImplicitFunction(x, y, z) {
        return x * x + y * y + z * z - this.radius * this.radius;
    }
    // Evaluate the implicit function at weighted space point (wx/w, wy/w, wz/w)
    // @param [in] wx (preweighted) x coordinate
    // @param [in] wy (preweighted) y coordinate
    // @param [in] wz (preweighted) z coordinate
    // @param [in] w  weight
    evaluateImplicitFunctionXYZW(wx, wy, wz, w) {
        if (w === 0.0)
            return 0.0;
        return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;
    }
    XYZToThetaPhiR(xyz) {
        const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;
        const rho = Math.sqrt(rhoSquared);
        const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);
        let theta;
        let phi;
        let valid;
        if (r === 0.0) {
            theta = phi = 0.0;
            valid = false;
        }
        else {
            phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero
            if (rhoSquared !== 0.0) {
                theta = Math.atan2(xyz.y, xyz.x);
                valid = true;
            }
            else {
                theta = 0.0;
                valid = false;
            }
        }
        return { theta: (theta), phi: (phi), r: (r), valid: (valid) };
    }
    // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {
    //   const q = new Degree2PowerPolynomial();
    //   // Ray is (origin.x + s * direction.x, etc)
    //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc
    //   // sphere radius in local system is 1.
    //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);
    //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);
    //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);
    //   q.addConstant(-this.radius * this.radius);
    //   let ss = [];
    //   let n = q.realRoots(ss);
    //   if (n > maxHit)
    //     n = maxHit;
    //   let rayFractions;
    //   let points;
    //   for (let i = 0; i < n; i++) {
    //     rayFractions[i] = ss[i];
    //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?
    //   }
    // Compute the point on the surface at specified angles
    // @param [in] theta major circle angle.
    // @param [in] phi minor circle angle.
    // @return point on surface
    evaluateThetaPhi(thetaRadians, phiRadians) {
        const rc = this.radius * Math.cos(thetaRadians);
        const rs = this.radius * Math.sin(thetaRadians);
        const cosPhi = Math.cos(phiRadians);
        const sinPhi = Math.sin(phiRadians);
        return PointVector_1.Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi);
    }
    // Compute derivatives of the point on the surface at specified angles
    // @param [in] theta major circle angle.
    // @param [in] phi minor circle angle.
    // @param [out] dXdTheta derivative wrt theta
    // @param [out] dXdPhi derivative wrt phi
    evaluateDerivativesThetaPhi(theta, phi, dxdTheta, dxdPhi) {
        const rc = this.radius * Math.cos(theta);
        const rs = this.radius * Math.sin(theta);
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        PointVector_1.Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);
        PointVector_1.Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);
    }
}
exports.SphereImplicit = SphereImplicit;
/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.
 *
 */
class AnalyticRoots {
    /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */
    static IsZero(x) {
        return Math.abs(x) < this.EQN_EPS;
    }
    /** Without actually doing a division, test if (x/y) is small.
     * @param x numerator
     * @param y denominator
     * @param abstol absolute tolerance
     * @param reltol relative tolerance
     */
    static isSmallRatio(x, y, abstol = 1.0e-9, reltol = 8.0e-16) {
        return Math.abs(x) <= abstol || Math.abs(x) < reltol * Math.abs(y);
    }
    // @returns the principal (always real) cube root of x.
    static cbrt(x) {
        return ((x) > 0.0 ? Math.pow((x), 1.0 / 3.0) : ((x) < 0.0 ? -Math.pow(-(x), 1.0 / 3.0) : 0.0));
    }
    /**
     * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`
     * @param values array of values.  `values[offset]` will be replaced.
     * @param numerator numerator for division.
     * @param denominator denominator for division.
     * @param defaultValue value to save if denominator is too small to divide.
     * @param offset index of value to replace.
     */
    static SafeDivide(values, numerator, denominator, defaultValue = 0.0, offset) {
        if (Math.abs(denominator) > (this.s_safeDivideFactor * Math.abs(numerator))) {
            values[offset] = numerator / denominator;
            return true;
        }
        values[offset] = defaultValue;
        return false;
    }
    // Used in NewtonMethod for testing if a root has been adjusted past its bounding region
    static checkRootProximity(roots, i) {
        if (i === 0) {
            return roots.at(i) < roots.at(i + 1);
        }
        else if (i > 0 && i + 1 < roots.length) {
            return (roots.at(i) > roots.at(i - 1)) && (roots.at(i) < roots.at(i + 1));
        }
        else {
            return (roots.at(i) > roots.at(i - 1));
        }
    }
    static NewtonMethodAdjustment(coffs, root, order) {
        if (order === 3) {
            const f = coffs[0] + root * (coffs[1] + root * (coffs[2] + root * coffs[3]));
            const df = coffs[1] + root * (2.0 * coffs[2] + root * 3.0 * coffs[3]);
            return f / df;
        }
        else if (order === 4) {
            const f = coffs[0] + root * (coffs[1] + root * (coffs[2] + root * (coffs[3] + root * coffs[4])));
            const df = coffs[1] + root * (2.0 * coffs[2] + root * (3.0 * coffs[3] + root * 4.0 * coffs[4]));
            return f / df;
        }
        else {
            return 0;
        }
    }
    static improveSortedRoots(coffs, degree, roots) {
        const relTol = 1.0e-10;
        // Loop through each root
        for (let i = 0; i < roots.length; i++) {
            let dx = this.NewtonMethodAdjustment(coffs, roots.at(i), degree);
            if (!dx)
                continue; // skip if newton step had divide by zero.
            const originalValue = roots.at(i);
            let counter = 0;
            let convergenceCounter = 0;
            // Loop through applying changes to found root until dx is diminished or counter is hit
            while (dx !== 0 && (counter < 10)) {
                // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.
                if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.at(i)))) {
                    if (++convergenceCounter > 1)
                        break;
                }
                else {
                    convergenceCounter = 0;
                }
                const rootDX = roots.at(i) - dx;
                roots.reassign(i, rootDX);
                // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert
                // to originally found root
                if (!this.checkRootProximity(roots, i)) {
                    roots.reassign(i, originalValue);
                    break;
                }
                dx = this.NewtonMethodAdjustment(coffs, roots.at(i), degree);
                counter++;
            }
        }
    }
    /**
     * Append (if defined) value to results.
     * @param value optional value to append
     * @param results growning array
     */
    static appendSolution(value, results) {
        if (value !== undefined) {
            results.push(value);
        }
    }
    /**
     * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case
     * @param value1
     * @param value2
     * @param results
     */
    static append2Solutions(valueA, valueB, results) {
        results.push(valueA);
        results.push(valueB);
    }
    /**
     * If `co/c1` is a safed division, append it to the values array.
     * @param c0 numerator
     * @param c1 denominaotr
     * @param values array to expand
     */
    static appendLinearRoot(c0, c1, values) {
        AnalyticRoots.appendSolution(Geometry_1.Geometry.conditionalDivideFraction(-c0, c1), values);
    }
    // Search an array for the value which is farthest from the average of all the values.
    static mostDistantFromMean(data) {
        if (!data || data.length === 0)
            return 0;
        let a = 0.0; // to become the sum and finally the average.
        for (let i = 0; i < data.length; i++)
            a += data.at(i);
        a /= data.length;
        let dMax = 0.0;
        let result = data.at(0);
        for (let i = 0; i < data.length; i++) {
            const d = Math.abs(data.at(i) - a);
            if (d < dMax) {
                dMax = d;
                result = data.at(i);
            }
        }
        return result;
    }
    /**
     * Append 0, 1, or 2 solutions of a quadratic to the values array.
     * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`
     * @param values array to be expanded.
     */
    static appendQuadraticRoots(c, values) {
        // Normal form: x^2 + 2px + q = 0
        const divFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[2]);
        if (!divFactor) {
            this.appendLinearRoot(c[0], c[1], values);
            return;
        }
        const p = 0.5 * c[1] * divFactor;
        const q = c[0] * divFactor;
        const D = p * p - q;
        if (this.IsZero(D)) {
            this.appendSolution(-p, values);
            return;
        }
        else if (D < 0) {
            return;
        }
        else if (D > 0) {
            const sqrt_D = Math.sqrt(D);
            this.append2Solutions(sqrt_D - p, -sqrt_D - p, values);
            return;
        }
        return;
    }
    static addConstant(value, data) {
        for (let i = 0; i < data.length; i++)
            data.reassign(i, data.at(i) + value);
    }
    /** return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.
     * In the usual case where c0 is non-zero, there are either 1 or 3 roots.
     * But if c0 is zero the (0, 1, or 2) roots of the lower order equation
     */
    static appendCubicRootsUnsorted(c, results) {
        let A;
        let B;
        let C;
        let sq_A;
        let p;
        let q;
        let cb_p;
        let D;
        // normal form: x^3 + Ax^2 + Bx + C = 0
        const scaleFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[3]);
        if (!scaleFactor) {
            this.appendQuadraticRoots(c, results);
            return;
        }
        // It is a real cubic.  There MUST be at least one real solution . . .
        A = c[2] * scaleFactor;
        B = c[1] * scaleFactor;
        C = c[0] * scaleFactor;
        /*  substitute x = y - A/3 to eliminate quadric term:
            f = y^3 +3py + 2q = 0
            f' = 3y^2 + p
                local min/max at Y = +-sqrt (-p)
                f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q
        */
        sq_A = A * A;
        p = (3.0 * B - sq_A) / 9.0;
        q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
        // Use Cardano's formula
        cb_p = p * p * p;
        D = q * q + cb_p;
        const origin = A / (-3.0);
        if (D >= 0.0 && this.IsZero(D)) {
            if (this.IsZero(q)) {
                // One triple solution
                results.push(origin);
                results.push(origin);
                results.push(origin);
                return;
            }
            else {
                // One single and one double solution
                const u = this.cbrt(-q);
                if (u < 0) {
                    results.push(origin + 2 * u);
                    results.push(origin - u);
                    results.push(origin - u);
                    return;
                }
                else {
                    results.push(origin - u);
                    results.push(origin - u);
                    results.push(origin + 2 * u);
                    return;
                }
            }
        }
        else if (D <= 0) {
            const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
            const t = 2 * Math.sqrt(-p);
            results.push(origin + t * Math.cos(phi));
            results.push(origin - t * Math.cos(phi + Math.PI / 3));
            results.push(origin - t * Math.cos(phi - Math.PI / 3));
            return;
        }
        else {
            const sqrt_D = Math.sqrt(D);
            const u = this.cbrt(sqrt_D - q);
            const v = -(this.cbrt(sqrt_D + q));
            results.push(origin + u + v);
            return;
        }
    }
    static appendCubicRoots(c, results) {
        this.appendCubicRootsUnsorted(c, results);
        results.sort();
    }
    static appendQuarticRoots(c, results) {
        const coeffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.
        let u;
        let v;
        let A;
        let B;
        let C;
        let D;
        let sq_A;
        let p;
        let q;
        let r;
        // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0
        const coffScale = new Float64Array(1);
        if (!this.SafeDivide(coffScale, 1.0, c[4], 0.0, 0)) {
            this.appendCubicRoots(c, results);
            return;
        }
        A = c[3] * coffScale[0];
        B = c[2] * coffScale[0];
        C = c[1] * coffScale[0];
        D = c[0] * coffScale[0];
        const origin = -0.25 * A;
        /*  substitute x = y - A/4 to eliminate cubic term:
            x^4 + px^2 + qx + r = 0 */
        sq_A = A * A;
        p = -3.0 / 8 * sq_A + B;
        q = 0.125 * sq_A * A - 0.5 * A * B + C;
        r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;
        const tempStack = new GrowableArray_1.GrowableFloat64Array();
        if (this.IsZero(r)) {
            // no absolute term: y(y^3 + py + q) = 0
            coeffs[0] = q;
            coeffs[1] = p;
            coeffs[2] = 0;
            coeffs[3] = 1;
            this.appendCubicRootsUnsorted(coeffs, results);
            results.push(0); // APPLY ORIGIN ....
            this.addConstant(origin, results);
            return;
        }
        else {
            // Solve the resolvent cubic
            coeffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;
            coeffs[1] = -r;
            coeffs[2] = -1.0 / 2 * p;
            coeffs[3] = 1;
            this.appendCubicRootsUnsorted(coeffs, tempStack);
            const z = this.mostDistantFromMean(tempStack);
            // ... to build two quadric equations
            u = z * z - r;
            v = 2 * z - p;
            if (this.isSmallRatio(u, r)) {
                u = 0;
            }
            else if (u > 0) {
                u = Math.sqrt(u);
            }
            else {
                return;
            }
            if (this.isSmallRatio(v, p)) {
                v = 0;
            }
            else if (v > 0) {
                v = Math.sqrt(v);
            }
            else {
                for (let i = 0; i < tempStack.length; i++) {
                    results.push(tempStack.at(i));
                }
                return;
            }
            coeffs[0] = z - u;
            coeffs[1] = ((q < 0) ? (-v) : (v));
            coeffs[2] = 1;
            this.appendQuadraticRoots(coeffs, results);
            coeffs[0] = z + u;
            coeffs[1] = ((q < 0) ? (v) : (-v));
            coeffs[2] = 1;
            this.appendQuadraticRoots(coeffs, results);
        }
        // resubstitute
        this.addConstant(origin, results);
        results.sort();
        this.improveSortedRoots(c, 4, results);
        return;
    }
    static appendCosSinRadians(c, s, cosValues, sinValues, radiansValues) {
        if (cosValues)
            cosValues.push(c);
        if (sinValues)
            sinValues.push(s);
        if (radiansValues)
            radiansValues.push(Math.atan2(s, c));
    }
    /*-----------------------------------------------------------------
     Solve the simultaneous equations
     <pre>
                   alpha + beta*c + gamma*s = 0
                   c*c + s*s = 1
  
     @param c1P OUT x cosine component of first solution point
     @param s1P OUT y sine component of first solution point
     @param c2P OUT x cosine component of second solution point
     @param s2P OUT y sine component of second solution point
     @param solutionType OUT One of the following values:
    <pre>
        -2 -- all coefficients identically 0.   The entire c,s plane -- and therefore
            the entire unit circle -- is a solution.
        -1 -- beta,gamma are zero, alpha is not.   There is no line defined.  There are
            no solutions.
        0 -- the line is well defined, but passes completely outside the unit circle.
                In this case, (c1,s1) is the circle point closest to the line
                and (c2,s2) is the line point closest to the circle.
        1 -- the line is tangent to the unit circle.  As tangency is identified at
                numerical precision, faithful interpretation of the coefficients
                may allow for some distance from line to circle. (c1,s1) is returned
                as the closest circle point, (c2,s2) the line point.  These are
                nominally the same but may differ due to the tolerance
                decision.
        2 -- two simple intersections.
    </pre>
  
      @param alpha => constant coefficient on line
     @param beta => x cosine coefficient on line
     @param gamma => y sine coefficient on line
     @param reltol => relative tolerance for tangencies
     @return the (nonnegative) solution count.
  
    @remarks Here is an example of the tangible meaning of the coefficients and
    the cryptic 5-way solution type separation.
    Point X on a 3D ellipse at parameter space angle theta is given by
        X = C + U cos(theta) + V sin(theta)
    where C,U,V are (respectively) center, 0 degree, and 90 degree vectors.
    A plane has normal N and is at distance a from the origin.  X is on the plane if
        X.N = a
    i.e.
        C.N + U.N cos(theta) + V.N sin(theta) = a
    i.e.
        C.N - a + U.N cos(theta) + V.N sin(theta) = 0
    i.e.
        alpha = C.N - a
        beta =  U.N
        gamma = V.N
    If the ellipse is parallel to the plane, both beta and gamma are zero.  These are
    the two degenerat cases.  If alpha is also zero the entire ellipse is completely
    in the plane.   If alpha is nonzero the ellipse is completely out of plane.
  
    If the ellipse plane is NOT parallel, there are zero, one, or two solutions according as
    the ellipse is completly on one side, tangent or is properly split by the plane.
  
     @bsihdr                                       EarlinLutz      12/97
    +---------------+---------------+---------------+---------------+------*/
    static appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosValues, sinValues, radiansValues, reltol = 1.0e-14) {
        let twoTol;
        const delta2 = beta * beta + gamma * gamma;
        const alpha2 = alpha * alpha;
        let solutionType = 0;
        if (reltol < 0.0) {
            twoTol = 0.0;
        }
        else {
            twoTol = 2.0 * reltol;
        }
        if (delta2 <= 0.0) {
            solutionType = (alpha === 0) ? -2 : -1;
        }
        else {
            const lambda = -alpha / delta2;
            const a2 = alpha2 / delta2;
            const D2 = 1.0 - a2;
            if (D2 < -twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 0;
            }
            else if (D2 < twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 1;
            }
            else {
                const mu = Math.sqrt(D2 / delta2);
                /* c0,s0 = closest approach of line to origin */
                const c0 = lambda * beta;
                const s0 = lambda * gamma;
                this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);
                solutionType = 2;
            }
        }
        return solutionType;
    }
}
AnalyticRoots.EQN_EPS = 1.0e-9;
AnalyticRoots.s_safeDivideFactor = 1.0e-14;
AnalyticRoots.s_quadricRelTol = 1.0e-14;
AnalyticRoots.sTestWindow = 1.0e-6;
exports.AnalyticRoots = AnalyticRoots;
class PowerPolynomial {
    // Evaluate a standard basis polynomial.
    static degreeKnownEvaluate(coff, degree, x) {
        if (degree < 0) {
            return 0.0;
        }
        let p = coff[degree];
        for (let i = degree - 1; i >= 0; i--)
            p = x * p + coff[i];
        return p;
    }
    // Evaluate a standard basis polynomial
    static Evaluate(coff, x) {
        const degree = coff.length - 1;
        return this.degreeKnownEvaluate(coff, degree, x);
    }
    // Accumulate Q*scale into P.  Both are treated as full degree.
    //         (Expect Address exceptions if P is smaller than Q)
    // Returns degree of result as determined by comparing leading coefficients to zero
    static Accumulate(coffP, coffQ, scaleQ) {
        let degreeP = coffP.length - 1;
        const degreeQ = coffQ.length - 1;
        for (let i = 0; i <= degreeQ; i++) {
            coffP[i] += scaleQ * coffQ[i];
        }
        while (degreeP >= 0 && coffP[degreeP] === 0.0) {
            degreeP--;
        }
        return degreeP;
    }
    // Zero all coefficients in a polynomial
    static Zero(coff) {
        for (let i = 0; i < coff.length; i++) {
            coff[i] = 0.0;
        }
    }
}
exports.PowerPolynomial = PowerPolynomial;
class TrigPolynomial {
    /// Solve a polynomial created from trigonometric condition using
    /// Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots
    /// corresponding zero leading coefficients (roots at infinity)
    /// <param name="coff">Coefficients</param>
    /// <param name="nominalDegree">degree of the polynomial under most complex
    ///     root case.  If there are any zero coefficients up to this degree, a single root
    ///     "at infinity" is recorded as its corresponding angular parameter at negative pi/2
    /// <param name="referenceCoefficient">A number which represents the size of coefficients
    ///     at various stages of computation.  A small fraction of this will be used as a zero
    ///     tolerance</param>
    /// <param name="angles">Roots are placed here. Assumed preallocated with adequate size.</param>
    /// <param name="numRoots">Number of roots  .  Zero roots is possible. (Passed as array of size
    /// one to pass-by-reference)</param>
    /// Returns false if equation is all zeros.   This usually means any angle is a solution.
    // ------------------------------------------------------------------------------------------------
    // Solve a standard basis polynomial.   Immediately use the roots as ordinates
    //            in rational polynomials for sine and cosine, and convert to angle via arctan
    static SolveAngles(coff, nominalDegree, referenceCoefficient, radians) {
        let maxCoff = Math.abs(referenceCoefficient);
        let a;
        radians.length = 0;
        const relTol = this.SmallAngle;
        for (let i = 0; i <= nominalDegree; i++) {
            a = Math.abs(coff[i]);
            if (a > maxCoff) {
                maxCoff = a;
            }
        }
        const coffTol = relTol * maxCoff;
        let degree = nominalDegree;
        while (degree > 0 && (Math.abs(coff[degree - 1]) <= coffTol)) {
            degree--;
        }
        // let bstat = false;
        const roots = new GrowableArray_1.GrowableFloat64Array();
        if (degree === -1) {
            // Umm.   Dunno.   Nothing there.
            // bstat = false;
        }
        else {
            // bstat = true;
            if (degree === 0) {
                // p(t) is a nonzero constant
                // No roots, but not degenerate.
                // bstat = true;
            }
            else if (degree === 1) {
                // p(t) = coff[1] * t + coff[0]...
                roots.push(-coff[0] / coff[1]);
            }
            else if (degree === 2) {
                AnalyticRoots.appendQuadraticRoots(coff, roots);
            }
            else if (degree === 3) {
                AnalyticRoots.appendCubicRoots(coff, roots);
            }
            else if (degree === 4) {
                AnalyticRoots.appendQuarticRoots(coff, roots);
            }
            else {
                // TODO: WILL WORK WITH BEZIER SOLVER
                // bstat = false;
            }
            if (roots.length > 0) {
                // Each solution t represents an angle with
                //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)
                // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)
                for (let i = 0; i < roots.length; i++) {
                    const ss = PowerPolynomial.Evaluate(this.S, roots.at(i));
                    const cc = PowerPolynomial.Evaluate(this.C, roots.at(i));
                    radians.push(Math.atan2(ss, cc));
                }
                // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.
                // Only make one entry....
                // for (int i = degree; i < nominalDegree; i++)
                if (degree < nominalDegree) {
                    radians.push(-0.5 * Math.PI);
                }
            }
        }
        return radians.length > 0;
    }
    /// <summary> Compute intersections of unit circle x^2 + y 2 = 1 with general quadric
    ///         axx*x^2 + axy*x*y + ayy*y^2 + ax * x + ay * y + a1 = 0
    /// Solutions are returned as angles. Sine and Cosine of the angles are the x,y results.
    /// <param name="axx">Coefficient of x^2</param>
    /// <param name="axy">Coefficient of xy</param>
    /// <param name="ayy">Coefficient of y^2</param>
    /// <param name="ax">Coefficient of x</param>
    /// <param name="ay">Coefficient of y</param>
    /// <param name="a1">Constant coefficient</param>
    /// <param name="angles">solution angles</param>
    /// <param name="numAngle">number of solution angles (Passed as array to make changes to reference)</param>
    static SolveUnitCircleImplicitQuadricIntersection(axx, axy, ayy, ax, ay, a1, radians) {
        const Coffs = new Float64Array(5);
        PowerPolynomial.Zero(Coffs);
        let degree = 2;
        if (Math.hypot(axx, axy, ayy) > TrigPolynomial.coeffientRelTol * Math.hypot(ax, ay, a1)) {
            PowerPolynomial.Accumulate(Coffs, this.CW, ax);
            PowerPolynomial.Accumulate(Coffs, this.SW, ay);
            PowerPolynomial.Accumulate(Coffs, this.WW, a1);
            PowerPolynomial.Accumulate(Coffs, this.SS, ayy);
            PowerPolynomial.Accumulate(Coffs, this.CC, axx);
            PowerPolynomial.Accumulate(Coffs, this.SC, axy);
            degree = 4;
        }
        else {
            PowerPolynomial.Accumulate(Coffs, this.C, ax);
            PowerPolynomial.Accumulate(Coffs, this.S, ay);
            PowerPolynomial.Accumulate(Coffs, this.W, a1);
            degree = 2;
        }
        let maxCoff = 0.0;
        maxCoff = Math.max(maxCoff, Math.abs(axx), Math.abs(ayy), Math.abs(axy), Math.abs(ax), Math.abs(ay), Math.abs(a1));
        const b = this.SolveAngles(Coffs, degree, maxCoff, radians);
        /*
        for (const theta of angles) {
          const c = theta.cos();
          const s = theta.sin();
          console.log({
            angle: theta, co: c, si: s,
            f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});
      } */
        return b;
    }
    /// <summary> Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse
    ///         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)
    /// Solutions are returned as angles in the ellipse space.
    /// <param name="cx">center x</param>
    /// <param name="cy">center y</param>
    /// <param name="ux">0 degree vector x</param>
    /// <param name="uy">0 degree vector y</param>
    /// <param name="vx">90 degree vector x</param>
    /// <param name="vy">90 degree vector y</param>
    /// <param name="ellipseAngles">solution angles in ellipse parameter space</param>
    /// <param name="circleAngles">solution angles in circle parameter space</param>
    /// <param name="numAngle">number of solution angles (passed as an array to change reference)</param>
    static SolveUnitCircleEllipseIntersection(cx, cy, ux, uy, vx, vy, ellipseRadians, circleRadians) {
        circleRadians.length = 0;
        const acc = ux * ux + uy * uy;
        const acs = 2.0 * (ux * vx + uy * vy);
        const ass = vx * vx + vy * vy;
        const ac = 2.0 * (ux * cx + uy * cy);
        const asi = 2.0 * (vx * cx + vy * cy);
        const a = cx * cx + cy * cy - 1.0;
        const boolstat = this.SolveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);
        for (const radians of ellipseRadians) {
            const cc = Math.cos(radians);
            const ss = Math.sin(radians);
            const x = cx + ux * cc + vx * ss;
            const y = cy + uy * cc + vy * ss;
            circleRadians.push(Math.atan2(y, x));
        }
        return boolstat;
    }
}
// Constants taken from Angle.cpp (may be later moved to a constants module)
TrigPolynomial.SmallAngle = 1.0e-11;
// Standard Basis coefficients for rational sine numerator.
TrigPolynomial.S = Float64Array.from([0.0, 2.0, -2.0]);
// Standard Basis coefficients for rational cosine numerator.
TrigPolynomial.C = Float64Array.from([1.0, -2.0]);
// Standard Basis coefficients for rational denominator.
TrigPolynomial.W = Float64Array.from([1.0, -2.0, 2.0]);
// Standard Basis coefficients for cosine*weight numerator
TrigPolynomial.CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);
// Standard Basis coefficients for sine*weight numerator
TrigPolynomial.SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);
// Standard Basis coefficients for sine*cosine numerator
TrigPolynomial.SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);
// Standard Basis coefficients for sine^2 numerator
TrigPolynomial.SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);
// Standard Basis coefficients for cosine^2 numerator
TrigPolynomial.CC = Float64Array.from([1.0, -4.0, 4.0]);
// Standard Basis coefficients for weight^2
TrigPolynomial.WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);
// Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator
TrigPolynomial.CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);
TrigPolynomial.coeffientRelTol = 1.0e-12;
exports.TrigPolynomial = TrigPolynomial;
class SmallSystem {
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment2dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dClosestApproachUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const uz = a1.z - a0.z;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const vz = b1.z - b0.z;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const cz = b0.z - a0.z;
        const uu = Geometry_1.Geometry.dotProductXYZXYZ(ux, uy, uz, ux, uy, uz);
        const vv = Geometry_1.Geometry.dotProductXYZXYZ(vx, vy, vz, vx, vy, vz);
        const uv = Geometry_1.Geometry.dotProductXYZXYZ(ux, uy, uz, vx, vy, vz);
        const cu = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, ux, uy, uz);
        const cv = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, vx, vy, vz);
        return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);
    }
    static linearSystem2d(ux, vx, // first row of matrix
    uy, vy, // second row of matrix
    cx, cy, // right side
    result) {
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Solve a linear system
     * * x equation: `ux *u * vx * v + wx * w = cx`
     * * y equation: `uy *u * vy * v + wy * w = cy`
     * * z equation: `uz *u * vz * v + wz * w = cz`
     * @param axx row 0, column 0 coefficient
     * @param axy row 0, column 1 coefficient
     * @param axz row 0, column 1 coefficient
     * @param ayx row 1, column 0 coefficient
     * @param ayy row 1, column 1 coefficient
     * @param ayz row 1, column 2 coefficient
     * @param azx row 2, column 0 coefficient
     * @param azy row 2, column 1 coefficient
     * @param azz row 2, column 2 coefficient
     * @param cx right hand side row 0 coefficient
     * @param cy right hand side row 1 coefficient
     * @param cz right hand side row 2 coeficient
     * @param result optional result.
     */
    static linearSystem3d(axx, axy, axz, // first row of matrix
    ayx, ayy, ayz, // second row of matrix
    azx, azy, azz, // second row of matrix
    cx, cy, cz, // right side
    result) {
        // determinants of various combinations of columns ...
        const detXYZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);
        const detCYZ = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);
        const detXCZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);
        const detXYC = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, cx, cy, cz);
        const s = Geometry_1.Geometry.conditionalDivideFraction(detCYZ, detXYZ);
        const t = Geometry_1.Geometry.conditionalDivideFraction(detXCZ, detXYZ);
        const u = Geometry_1.Geometry.conditionalDivideFraction(detXYC, detXYZ);
        if (s !== undefined && t !== undefined && t !== undefined) {
            return PointVector_1.Vector3d.create(s, t, u, result);
        }
        return undefined;
    }
}
exports.SmallSystem = SmallSystem;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
/* tslint:disable:variable-name no-empty */
/** tolerance blob for various stroking methods.
 *
 * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength
 * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.
 * * angle is the angle between two contiguous strokes or across a facet edge.
 * * maxEdgeLength is the length of a stroke or a edge of a facet.
 *
 * It is rare for all three to be active at once:
 * * Nearly all stroke and facet use cases will apply an angle tolerance.
 * * * For curves, 15 degrees is typical
 * * * For facets, 22.5 degrees is typical.
 * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.
 * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.
 * * When creating output for devicies such as 3D printing will want a chord tolerance.
 * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.
 * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.
 * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the samll number of long quads usually used for graphics.
 * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.
 * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.
 *
 */
class StrokeOptions {
    constructor() {
        /** whether or not to triangulate each added facet */
        this.shouldTriangulate = false;
        this.defaultCircleStrokes = 16;
    }
    get needParams() { return this._needParams !== undefined ? this._needParams : false; }
    set needParams(value) { this._needParams = value; }
    get needNormals() { return this._needNormals !== undefined ? this._needNormals : false; }
    set needNormals(value) { this._needNormals = value; }
    hasMaxEdgeLength() { return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0; }
    // return stroke count which is the larger of the minCount or count needed for edge length condition.
    applyMaxEdgeLength(minCount, totalLength) {
        if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {
            minCount = Geometry_1.Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);
        }
        return minCount;
    }
    // return stroke count which is the larger of the existing count or count needed for angle condition for given sweepRadians
    // defaultStepRadians is assumed to be larger than zero.
    applyAngleTol(minCount, sweepRadians, defaultStepRadians) {
        return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);
    }
    static applyAngleTol(options, minCount, sweepRadians, defaultStepRadians) {
        sweepRadians = Math.abs(sweepRadians);
        let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;
        if (options && options.angleTol && options.angleTol.radians > 0.0)
            stepRadians = options.angleTol.radians;
        if (minCount * stepRadians < sweepRadians)
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        return minCount;
    }
    applyTolerancesToArc(radius, sweepRadians = Math.PI * 2) {
        let numStrokes = 1;
        numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);
        numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);
        numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);
        numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);
        return numStrokes;
    }
    // return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition.
    applyChordTol(minCount, radius, sweepRadians) {
        if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {
            const a = this.chordTol;
            const stepRadians = 2.0 * Math.acos((1.0 - a / radius));
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        }
        return minCount;
    }
    applyMinStrokesPerPrimitive(minCount) {
        if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)
            && this.minStrokesPerPrimitive > minCount)
            minCount = this.minStrokesPerPrimitive;
        return minCount;
    }
    static createForCurves() {
        const options = new StrokeOptions();
        options.angleTol = Geometry_1.Angle.createDegrees(15.0);
        return options;
    }
    static createForFacets() {
        const options = new StrokeOptions();
        options.angleTol = Geometry_1.Angle.createDegrees(22.5);
        return options;
    }
}
exports.StrokeOptions = StrokeOptions;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const Config_1 = __webpack_require__(31);
const Request_1 = __webpack_require__(23);
const bentleyjs_core_1 = __webpack_require__(0);
const loggingCategory = "imodeljs-clients.Clients";
/**
 * Container to hold service URLs for deployment environments
 */
class UrlDescriptor {
}
exports.UrlDescriptor = UrlDescriptor;
/** Provider for default RequestOptions, used by Client to set defaults.
 */
class DefaultRequestOptionsProvider {
    /**
     * Creates an instance of DefaultRequestOptionsProvider and sets up the default options.
     */
    constructor() {
        this.defaultOptions = {
            method: "GET",
            headers: {
                "Mas-App-Guid": Config_1.Config.host.guid,
                "Mas-Uuid": Config_1.Config.host.deviceId,
            },
        };
    }
    /**
     * Augments options with the provider's default values.
     * @note The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this.defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultRequestOptionsProvider = DefaultRequestOptionsProvider;
// @todo Setup a logging framework.
/**
 * Base class for all Client implementations
 */
class Client {
    /**
     * Creates an instance of Client.
     * @param deploymentEnv Deployment environment
     */
    constructor(deploymentEnv) {
        this.deploymentEnv = deploymentEnv;
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Augments request options with defaults returned by the DefaultRequestOptionsProvider.
     * @note The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!Client._defaultRequestOptionsProvider)
            Client._defaultRequestOptionsProvider = new DefaultRequestOptionsProvider();
        return Client._defaultRequestOptionsProvider.assignOptions(options);
    }
    /**
     * Gets the URL of the service. Attempts to discover and cache the URL from the URL Discovery Service. If not
     * found uses the default URL provided by client implementations. Note that for consistency
     * sake, the URL is stripped of any trailing "/"
     * @returns URL for the service
     */
    async getUrl() {
        if (this.url) {
            return Promise.resolve(this.url);
        }
        const urlDiscoveryClient = new UrlDiscoveryClient("PROD");
        // todo: Investigate why QA/DEV are not working
        const searchKey = this.getUrlSearchKey();
        return urlDiscoveryClient.discoverUrl(searchKey, this.deploymentEnv)
            .then((url) => {
            this.url = url;
            return Promise.resolve(this.url); // TODO: On the server this really needs a lifetime!!
        })
            .catch((error) => {
            console.log(`WARNING: Could not determine URL for ${searchKey} service. Error = ${error}`); // tslint:disable-line:no-console
            return Promise.resolve(this.getDefaultUrl().replace(/\/$/, "")); // strip trailing "/" for consistency
        });
    }
    /** used by clients to send delete requests */
    async delete(token, relativeUrlPath) {
        const url = await this.getUrl() + relativeUrlPath;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Sending DELETE request to ${url}`);
        const options = {
            method: "DELETE",
            headers: { authorization: token.toTokenString() },
        };
        await this.setupOptionDefaults(options);
        await Request_1.request(url, options);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Successful DELETE request to ${url}`);
    }
}
exports.Client = Client;
/**
 * Error for issues with authentication.
 */
class AuthenticationError extends Request_1.ResponseError {
}
exports.AuthenticationError = AuthenticationError;
/**
 * Client API to discover URLs from the URL Discovery service
 * (a.k.a. Buddi service)
 */
class UrlDiscoveryClient extends Client {
    /**
     * Creates an instance of UrlDiscoveryClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return "";
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return UrlDiscoveryClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets the URL for the discovery service
     * @returns URL of the discovery service.
     */
    async getUrl() {
        return Promise.resolve(this.getDefaultUrl().replace(/\/$/, "")); // strip trailing "/" for consistency
    }
    /**
     * Discovers a URL given the search key.
     * @param searchKey Search key registered for the service.
     * @param searchDeploymentEnv The deployment environment to search for.
     * @returns Registered URL for the service.
     */
    async discoverUrl(searchKey, searchDeploymentEnv) {
        const url = this.getDefaultUrl().replace(/\/$/, "") + "/GetUrl/";
        const options = {
            method: "GET",
            qs: {
                url: searchKey,
                region: UrlDiscoveryClient.regionMap[searchDeploymentEnv],
            },
        };
        await this.setupOptionDefaults(options);
        const response = await Request_1.request(url, options);
        const discoveredUrl = response.body.result.url.replace(/\/$/, ""); // strip trailing "/" for consistency
        return Promise.resolve(discoveredUrl);
    }
}
UrlDiscoveryClient.defaultUrlDescriptor = {
    DEV: "https://dev-buddi-eus2.cloudapp.net/WebService",
    QA: "https://qa-buddi-eus2.cloudapp.net/WebService",
    PROD: "https://buddi.bentley.com/WebService",
    PERF: "https://qa-buddi-eus2.cloudapp.net/WebService",
};
UrlDiscoveryClient.regionMap = { DEV: 103, QA: 102, PROD: 0, PERF: 294 };
exports.UrlDiscoveryClient = UrlDiscoveryClient;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(112));
__export(__webpack_require__(41));
__export(__webpack_require__(49));
__export(__webpack_require__(297));
__export(__webpack_require__(298));
__export(__webpack_require__(180));
__export(__webpack_require__(299));
__export(__webpack_require__(182));
__export(__webpack_require__(300));
__export(__webpack_require__(301));
__export(__webpack_require__(183));
__export(__webpack_require__(302));
__export(__webpack_require__(184));
__export(__webpack_require__(303));
__export(__webpack_require__(185));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelError_1 = __webpack_require__(16);
const IModel_1 = __webpack_require__(34);
const bentleyjs_core_1 = __webpack_require__(0);
const RpcRegistry_1 = __webpack_require__(33);
/** The policy for an RPC operation. */
class RpcOperationPolicy {
    constructor() {
        /** Supplies the IModelToken for an operation request. */
        this.token = (request) => request.findParameterOfType(IModel_1.IModelToken);
        /** Supplies the unique identifier for an operation request.  */
        this.requestId = (_request) => bentleyjs_core_1.Guid.createValue();
        /** Supplies the initial retry interval for an operation request. */
        this.retryInterval = (configuration) => configuration.pendingOperationRetryInterval;
        /** Whether an operation request must be acknowledged. */
        this.requiresAcknowledgement = false;
        /** Called for every operation request on the frontend. */
        this.requestCallback = (_request) => { };
        /** Called for every operation invocation on the backend. */
        this.invocationCallback = (_invocation) => { };
    }
}
exports.RpcOperationPolicy = RpcOperationPolicy;
/** An RPC operation descriptor. */
class RpcOperation {
    /** @hidden @internal */
    constructor(definition, operation, policy) {
        this.interfaceDefinition = definition;
        this.operationName = operation;
        this.policy = policy;
    }
    /** Looks up an RPC operation by name. */
    static lookup(target, operationName) {
        const definition = typeof (target) === "string" ? RpcRegistry_1.RpcRegistry.instance.lookupInterfaceDefinition(target) : target;
        const proto = definition.prototype;
        if (!proto.hasOwnProperty(operationName))
            throw new IModelError_1.IModelError(32768 /* ERROR */, `RPC interface class "${definition.name}" does not does not declare operation "${operationName}"`);
        return proto[operationName][RpcRegistry_1.OPERATION];
    }
    /** Iterates the operations of an RPC interface definition. */
    static forEach(definition, callback) {
        Object.getOwnPropertyNames(definition.prototype).forEach((operationName) => {
            if (operationName === "constructor" || operationName === "configurationSupplier")
                return;
            callback(definition.prototype[operationName][RpcRegistry_1.OPERATION]);
        });
    }
    /** The version of this operation. */
    get interfaceVersion() { return this.interfaceDefinition.version; }
}
/** A fallback token to use for RPC system management requests like RpcManager.describeAvailableEndpoints. */
RpcOperation.fallbackToken = undefined;
exports.RpcOperation = RpcOperation;
(function (RpcOperation) {
    /** Decorator for setting the policy for an RPC operation function. */
    function setPolicy(policy) {
        return (target, propertyKey, descriptor) => {
            descriptor.value[RpcRegistry_1.OPERATION] = new RpcOperation(target.constructor, propertyKey, policy);
        };
    }
    RpcOperation.setPolicy = setPolicy;
    /** Decorator for setting the default policy for an RPC interface definition class. */
    function setDefaultPolicy(policy) {
        return (definition) => {
            definition[RpcRegistry_1.POLICY] = policy;
        };
    }
    RpcOperation.setDefaultPolicy = setDefaultPolicy;
})(RpcOperation = exports.RpcOperation || (exports.RpcOperation = {}));


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/** Utilities for handling image data. */
class ImageUtil {
    /** Get a string describing the mime type associated with an ImageSource format. */
    static getImageSourceMimeType(format) { return 0 /* Jpeg */ === format ? "image/jpeg" : "image/png"; }
    /** Get the ImageSourceFormat corresponding to the mime type string, or undefined if the string does not identify an ImageSourceFormat. */
    static getImageSourceFormatForMimeType(mimeType) {
        switch (mimeType) {
            case "image/jpeg": return 0 /* Jpeg */;
            case "image/png": return 2 /* Png */;
            default: return undefined;
        }
    }
    /**
     * Extract an html Image element from a binary jpeg or png.
     * @param source The ImageSource containing the binary jpeg or png data.
     * @returns a Promise which resolves to an HTMLImageElement containing the uncompressed bitmap image in RGBA format.
     */
    static async extractImage(source) {
        return new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => resolve(image);
            image.onerror = reject;
            const blob = new Blob([source.data], { type: this.getImageSourceMimeType(source.format) });
            const url = URL.createObjectURL(blob);
            image.src = url;
        });
    }
    /**
     * Extract the dimensions of the jpeg or png data encoded in an ImageSource.
     * @param source The ImageSource containing the binary jpeg or png data.
     * @returns a Promise resolving to a Point2d of which x corresponds to the integer width of the uncompressed bitmap and y to the height.
     */
    static async extractImageDimensions(source) {
        return this.extractImage(source).then((image) => new geometry_core_1.Point2d(image.naturalWidth, image.naturalHeight));
    }
}
exports.ImageUtil = ImageUtil;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
var FeatureSymbology;
(function (FeatureSymbology) {
    /** Defines overrides for selected aspects of a Feature's symbology. */
    class Appearance {
        constructor(props) {
            this.rgb = props.rgb;
            this.weight = props.weight;
            this.alpha = props.alpha;
            this.linePixels = props.linePixels;
            this.ignoresMaterial = undefined !== props.ignoresMaterial && props.ignoresMaterial;
        }
        static fromJSON(props) {
            if (undefined === props || (undefined === props.rgb && undefined === props.weight && undefined === props.alpha && undefined === props.linePixels && !props.ignoresMaterial))
                return this.defaults;
            else
                return new Appearance(props);
        }
        /** Create an Appearance that overrides the RGB color of a Feature. */
        static fromRgb(color) { return this.fromJSON({ rgb: imodeljs_common_1.RgbColor.fromColorDef(color) }); }
        /** Create an Appearance that overrides the RGB and alpha of a Feature. */
        static fromRgba(color) {
            return this.fromJSON({
                rgb: imodeljs_common_1.RgbColor.fromColorDef(color),
                alpha: color.getAlpha(),
            });
        }
        /** Create an Appearance with overrides corresponding to those defined by the supplied SubCategoryOverride. */
        static fromSubCategoryOverride(ovr) {
            const rgb = undefined !== ovr.color ? imodeljs_common_1.RgbColor.fromColorDef(ovr.color) : undefined;
            const alpha = undefined !== ovr.transparency ? ovr.transparency : undefined;
            const weight = undefined !== ovr.weight ? ovr.weight : undefined;
            const ignoresMaterial = undefined !== ovr.material && !ovr.material.isValid ? true : undefined;
            return this.fromJSON({ rgb, alpha, weight, ignoresMaterial });
        }
        get overridesRgb() { return undefined !== this.rgb; }
        get overridesAlpha() { return undefined !== this.alpha; }
        get overridesLinePixels() { return undefined !== this.linePixels; }
        get overridesWeight() { return undefined !== this.weight; }
        get overridesSymbology() { return this.overridesRgb || this.overridesAlpha || this.overridesWeight || this.overridesLinePixels || this.ignoresMaterial; }
        equals(other) {
            return this.rgbIsEqual(other.rgb) && this.weight === other.weight && this.alpha === other.alpha && this.linePixels === other.linePixels && this.ignoresMaterial === other.ignoresMaterial;
        }
        toJSON() {
            return {
                rgb: this.rgb,
                weight: this.weight,
                alpha: this.alpha,
                linePixels: this.linePixels,
                ignoresMaterial: this.ignoresMaterial ? true : undefined,
            };
        }
        /** Produce an Appearance from the supplied Appearance in which any aspect not defined by the base Appearance is overridden by this Appearance. */
        extendAppearance(base) {
            if (!this.overridesSymbology)
                return base;
            const props = base.toJSON();
            if (undefined === props.rgb)
                props.rgb = this.rgb;
            if (undefined === props.alpha)
                props.alpha = this.alpha;
            if (undefined === props.linePixels)
                props.linePixels = this.linePixels;
            if (undefined === props.weight)
                props.weight = this.weight;
            if (undefined === props.ignoresMaterial && this.ignoresMaterial)
                props.ignoresMaterial = true;
            return Appearance.fromJSON(props);
        }
        rgbIsEqual(rgb) { return undefined === this.rgb ? undefined === rgb ? true : false : undefined === rgb ? false : this.rgb.equals(rgb); }
    }
    Appearance.defaults = new Appearance({});
    FeatureSymbology.Appearance = Appearance;
    class Overrides {
        constructor(view) {
            /** Drawn Sets */
            this.neverDrawn = new Set();
            this.alwaysDrawn = new Set();
            this.isAlwaysDrawnExclusive = false;
            /** Following properties are only mutable internally: */
            this._defaultOverrides = Appearance.defaults;
            this._constructions = false;
            this._dimensions = false;
            this._patterns = false;
            this._lineWeights = true;
            this.modelOverrides = new Map();
            this.elementOverrides = new Map();
            this.subCategoryOverrides = new Map();
            this.visibleSubCategories = new Set();
            if (undefined !== view)
                this.initFromView(view);
        }
        get defaultOverrides() { return this._defaultOverrides; }
        get lineWeights() { return this._lineWeights; }
        isNeverDrawn(id) { return this.neverDrawn.has(id.toString()); }
        isAlwaysDrawn(id) { return this.alwaysDrawn.has(id.toString()); }
        isSubCategoryVisible(id) { return this.visibleSubCategories.has(id.toString()); }
        clearModelOverrides(id) { this.modelOverrides.delete(id.toString()); }
        clearElementOverrides(id) { this.elementOverrides.delete(id.toString()); }
        clearSubCategoryOverrides(id) { this.subCategoryOverrides.delete(id.toString()); }
        getModelOverrides(id) { return this.modelOverrides.get(id.toString()); }
        getElementOverrides(id) { return this.elementOverrides.get(id.toString()); }
        getSubCategoryOverrides(id) { return this.subCategoryOverrides.get(id.toString()); }
        setVisibleSubCategory(id) { this.visibleSubCategories.add(id.toString()); }
        setNeverDrawn(id) { this.neverDrawn.add(id.toString()); }
        setAlwaysDrawn(id) { this.alwaysDrawn.add(id.toString()); }
        /** Returns the feature's Appearance overrides, or undefined if the feature is not visible. */
        getAppearance(feature, modelId) {
            let app = !this._lineWeights ? Appearance.fromJSON({ weight: 1 }) : Appearance.defaults;
            const modelApp = this.getModelOverrides(modelId);
            if (undefined !== modelApp)
                app = modelApp.extendAppearance(app);
            // Is the element visible?
            const { elementId, subCategoryId, geometryClass } = feature;
            let elemApp, alwaysDrawn = false;
            if (elementId.isValid()) {
                if (this.isNeverDrawn(elementId))
                    return undefined;
                alwaysDrawn = this.isAlwaysDrawn(elementId);
                if (!alwaysDrawn && this.isAlwaysDrawnExclusive)
                    return undefined;
                // Element overrides take precedence
                elemApp = this.getElementOverrides(elementId);
                if (undefined !== elemApp)
                    app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;
            }
            if (subCategoryId.isValid()) {
                if (!alwaysDrawn && !this.isSubCategoryVisible(subCategoryId))
                    return undefined;
                const subCat = this.getSubCategoryOverrides(subCategoryId);
                if (undefined !== subCat)
                    app = subCat.extendAppearance(app);
            }
            if (undefined === elemApp && undefined === modelApp)
                app = this._defaultOverrides.extendAppearance(app);
            let visible = alwaysDrawn || this.isClassVisible(geometryClass);
            if (visible && app.overridesAlpha)
                visible = app.alpha < 0xff; // don't bother rendering something with full transparency...
            return visible ? app : undefined;
        }
        isClassVisible(geomClass) {
            switch (geomClass) {
                case 1 /* Construction */: return this._constructions;
                case 2 /* Dimension */: return this._dimensions;
                case 3 /* Pattern */: return this._patterns;
                default: return true;
            }
        }
        isFeatureVisible(feature) {
            // TFS#808986: Navigator puts some elements into both the 'never' and 'always' lists which is weird but
            // the docs for ViewController::GetNeverDrawn() assert that in that case the 'never' list wins.
            const { elementId, subCategoryId, geometryClass } = feature;
            const isValidElemId = elementId.isValid();
            if (isValidElemId && this.isNeverDrawn(elementId))
                return false;
            const alwaysDrawn = isValidElemId && this.isAlwaysDrawn(elementId);
            if (alwaysDrawn || this.isAlwaysDrawnExclusive)
                return alwaysDrawn;
            if (!this.isSubCategoryVisible(subCategoryId))
                return false;
            return this.isClassVisible(geometryClass);
        }
        // Specify overrides for all elements within the specified model. These overrides take priority.
        overrideModel(id, app, replaceExisting = true) {
            if (replaceExisting || undefined === this.getModelOverrides(id))
                this.modelOverrides.set(id.toString(), app);
        }
        overrideSubCategory(id, app, replaceExisting = true) {
            if (!this.isSubCategoryVisible(id))
                return;
            // NB: Appearance may specify no overridden symbology - this means "don't apply the default overrides to this subcategory"
            if (replaceExisting || undefined === this.getSubCategoryOverrides(id))
                this.subCategoryOverrides.set(id.toString(), app);
        }
        // NB: Appearance can override nothing, which prevents the default overrides from applying to it.
        overrideElement(id, app, replaceExisting = true) {
            if (this.isNeverDrawn(id))
                return;
            // NB: Appearance may specify no overridden symbology - this means "don't apply the default overrides to this element"
            if (replaceExisting || undefined === this.getElementOverrides(id))
                this.elementOverrides.set(id.toString(), app);
        }
        setDefaultOverrides(appearance, replaceExisting = true) {
            if (replaceExisting || !appearance.overridesSymbology)
                this._defaultOverrides = appearance;
        }
        initFromView(view) {
            const { alwaysDrawn, neverDrawn, viewFlags } = view;
            const { constructions, dimensions, patterns } = viewFlags;
            this.copy(this.alwaysDrawn, alwaysDrawn);
            this.copy(this.neverDrawn, neverDrawn);
            this.isAlwaysDrawnExclusive = view.isAlwaysDrawnExclusive;
            this._constructions = constructions;
            this._dimensions = dimensions;
            this._patterns = patterns;
            this._lineWeights = viewFlags.showWeights();
            for (const categoryId of view.categorySelector.categories) {
                const subCategoryIds = view.subCategories.getSubCategories(categoryId);
                if (undefined === subCategoryIds)
                    continue;
                for (const subCategoryId of subCategoryIds) {
                    if (view.isSubCategoryVisible(subCategoryId)) {
                        this.visibleSubCategories.add(subCategoryId);
                        const ovr = view.getSubCategoryOverride(subCategoryId);
                        if (undefined !== ovr) {
                            const app = Appearance.fromSubCategoryOverride(ovr);
                            if (app.overridesSymbology)
                                this.subCategoryOverrides.set(subCategoryId, app);
                        }
                    }
                }
            }
        }
        copy(dst, src) {
            dst.clear();
            if (undefined !== src) {
                for (const id of src)
                    dst.add(id);
            }
        }
    }
    FeatureSymbology.Overrides = Overrides;
})(FeatureSymbology = exports.FeatureSymbology || (exports.FeatureSymbology = {}));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
/** Provides facilities for deserializing 3d tiles */
var TileIO;
(function (TileIO) {
    /** Given a magic number, return whether it identifies a known tile format. */
    function isValidFormat(format) {
        switch (format) {
            case 0 /* Unknown */:
            case 1835283298 /* B3dm */:
            case 1179937895 /* Gltf */:
            case 1416521572 /* IModel */:
            case 1937010288 /* Pnts */:
                return true;
            default:
                return false;
        }
    }
    /** Given a magic number, attempt to convert it to a known tile Format. */
    function formatFromNumber(formatNumber) {
        const format = formatNumber;
        return isValidFormat(format) ? format : 0 /* Unknown */;
    }
    /**
     * Wraps a binary stream along with a current read position. The position can be adjusted by the caller.
     * Methods and properties beginning with 'next' consume data at the current read position and advance it
     * by the size of the data read.
     */
    class StreamBuffer {
        constructor(buffer) {
            this._curPos = 0;
            this._view = new DataView(buffer);
        }
        get length() { return this._view.byteLength; }
        get isPastTheEnd() { return this.curPos > this.length; }
        get curPos() { return this._curPos; }
        set curPos(pos) { this._curPos = pos; bentleyjs_core_1.assert(!this.isPastTheEnd); }
        advance(numBytes) { this.curPos = (this.curPos + numBytes); return !this.isPastTheEnd; }
        rewind(numBytes) { if (this.curPos - numBytes < 0)
            return false; this.curPos = this.curPos - numBytes; return true; }
        reset() { this.curPos = 0; }
        /** Read a uint8 at the current read position and advance by 1 byte. */
        get nextUint8() { return this.read(1, (view) => view.getUint8(this.curPos)); }
        /** Read a uint16 at the current read position and advance by 2 bytes. */
        get nextUint16() { return this.read(2, (view) => view.getUint16(this.curPos, true)); }
        /** Read a uint32 at the current read position and advance by 4 bytes. */
        get nextUint32() { return this.read(4, (view) => view.getUint32(this.curPos, true)); }
        /** Read a 32-bit floating point number at the current read position and advance by 4 bytes. */
        get nextFloat32() { return this.read(4, (view) => view.getFloat32(this.curPos, true)); }
        /** Read a 64-bit floating point number at the current read position and advance by 8 bytes. */
        get nextFloat64() { return this.read(8, (view) => view.getFloat64(this.curPos, true)); }
        /** Read 3 64-bit floating point numbers at the current read position, advance by 24 bytes, and return a Point3d constructed from the 3 numbers. */
        get nextPoint3d64() { return new geometry_core_1.Point3d(this.nextFloat64, this.nextFloat64, this.nextFloat64); }
        /** Read a uint64 at the current read position, advance by 8 bytes, and return the uint64 value as an Id64. */
        get nextId64() { return bentleyjs_core_1.Id64.fromUint32Pair(this.nextUint32, this.nextUint32); }
        /** Read the next numBytes bytes into a Uint8Array and advance by numBytes. */
        nextBytes(numBytes) {
            const bytes = new Uint8Array(this.arrayBuffer, this.curPos, numBytes);
            this.advance(numBytes);
            return bytes;
        }
        get arrayBuffer() { return this._view.buffer; }
        read(numBytes, read) {
            const result = read(this._view);
            this.advance(numBytes);
            return result;
        }
    }
    TileIO.StreamBuffer = StreamBuffer;
    /** The base header preceding tile data, identifying the tile format and version of that format. */
    class Header {
        constructor(stream) {
            this._format = formatFromNumber(stream.nextUint32);
            this.version = stream.nextUint32;
        }
        get format() { return this._format; }
        invalidate() { this._format = 0 /* Unknown */; }
    }
    TileIO.Header = Header;
    class GeometryCollection {
        constructor(meshes, isComplete, isCurved) {
            this.meshes = meshes;
            this.isComplete = isComplete;
            this.isCurved = isCurved;
        }
        get isEmpty() { return 0 === this.meshes.length; }
    }
    TileIO.GeometryCollection = GeometryCollection;
})(TileIO = exports.TileIO || (exports.TileIO = {}));


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
class LegacyMath {
    static linePlaneIntersect(outP, linePt, lineNormal, planePt, planeNormal, perpendicular) {
        let dot = 0;
        if (lineNormal)
            dot = lineNormal.dotProduct(planeNormal);
        else
            perpendicular = true;
        let temp;
        if (perpendicular || Math.abs(dot) < .001) {
            const t = linePt.vectorTo(planePt).dotProduct(planeNormal);
            temp = planeNormal.scale(t);
        }
        else {
            const t = (planeNormal.dotProduct(planePt) - planeNormal.dotProduct(linePt)) / dot;
            temp = lineNormal.scale(t);
        }
        outP.setFrom(temp.plus(linePt));
    }
    static normalizedDifference(point1, point2, out) { return point2.vectorTo(point1).normalizeWithLength(out).mag; }
    static normalizedCrossProduct(vec1, vec2, out) { return vec1.crossProduct(vec2, out).normalizeWithLength(out).mag; }
}
exports.LegacyMath = LegacyMath;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module ModelState */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const EntityState_1 = __webpack_require__(53);
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const IModelApp_1 = __webpack_require__(5);
const TileTree_1 = __webpack_require__(62);
const RealityModelTileTree_1 = __webpack_require__(339);
/** The state of a Model */
class ModelState extends EntityState_1.EntityState {
    constructor(props, iModel) {
        super(props, iModel);
        this.modeledElement = imodeljs_common_1.RelatedElement.fromJSON(props.modeledElement);
        this.name = props.name ? props.name : "";
        this.parentModel = bentleyjs_core_1.Id64.fromJSON(props.parentModel); // NB! Must always match the model of the modeledElement!
        this.isPrivate = bentleyjs_core_1.JsonUtils.asBool(props.isPrivate);
        this.isTemplate = bentleyjs_core_1.JsonUtils.asBool(props.isTemplate);
    }
    /** Add all custom-handled properties of a Model to a json object. */
    toJSON() {
        const val = super.toJSON();
        val.modeledElement = this.modeledElement;
        val.parentModel = this.parentModel;
        val.name = this.name;
        if (this.isPrivate)
            val.isPrivate = this.isPrivate;
        if (this.isTemplate)
            val.isTemplate = this.isTemplate;
        return val;
    }
    getExtents() { return new imodeljs_common_1.AxisAlignedBox3d(); } // NEEDS_WORK
    /** Determine whether this is a GeometricModel */
    get isGeometricModel() { return false; }
    /** Runs when the iModel this iModelState represents closes. */
    onIModelConnectionClose() { }
}
exports.ModelState = ModelState;
/** The state of a geometric model */
class GeometricModelState extends ModelState {
    constructor() {
        super(...arguments);
        this._loadStatus = TileTree_1.TileTree.LoadStatus.NotLoaded;
    }
    get is2d() { return !this.is3d; }
    /** @hidden */
    get tileTree() { return this._tileTree; }
    /** @hidden */
    get loadStatus() { return this._loadStatus; }
    set loadStatus(status) { this._loadStatus = status; }
    /** Override of ModelState method, returns true */
    get isGeometricModel() { return true; }
    getOrLoadTileTree() {
        if (undefined === this.tileTree)
            this.loadTileTree();
        return this.tileTree;
    }
    /** @hidden */
    loadTileTree() {
        if (TileTree_1.TileTree.LoadStatus.NotLoaded !== this._loadStatus)
            return this._loadStatus;
        this._loadStatus = TileTree_1.TileTree.LoadStatus.Loading;
        if (this.jsonProperties.tilesetUrl !== undefined) {
            RealityModelTileTree_1.RealityModelTileTree.loadRealityModelTileTree(this.jsonProperties.tilesetUrl, this);
            return this._loadStatus;
        }
        const ids = bentleyjs_core_1.Id64.toIdSet(this.id);
        this.iModel.tiles.getTileTreeProps(ids).then((result) => {
            this.setTileTree(result[0], new TileTree_1.IModelTileLoader(this.iModel, bentleyjs_core_1.Id64.fromJSON(result[0].id)));
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        }).catch((_err) => this._loadStatus = TileTree_1.TileTree.LoadStatus.NotFound);
        return this._loadStatus;
    }
    setTileTree(props, loader) {
        this._tileTree = new TileTree_1.TileTree(TileTree_1.TileTree.Params.fromJSON(props, this, loader));
        this._loadStatus = TileTree_1.TileTree.LoadStatus.Loaded;
    }
    onIModelConnectionClose() {
        bentleyjs_core_1.dispose(this._tileTree); // we do not track if we are disposed... catch this at the tiletree level
        super.onIModelConnectionClose();
    }
}
exports.GeometricModelState = GeometricModelState;
/** The state of a 2d Geometric Model */
class GeometricModel2dState extends GeometricModelState {
    constructor(props, iModel) {
        super(props, iModel);
        this.globalOrigin = geometry_core_1.Point2d.fromJSON(props.globalOrigin);
    }
    get is3d() { return false; }
    toJSON() {
        const val = super.toJSON();
        val.globalOrigin = this.globalOrigin;
        return val;
    }
}
exports.GeometricModel2dState = GeometricModel2dState;
/** The state of a 3d Geometric Model */
class GeometricModel3dState extends GeometricModelState {
    /** Returns true. */
    get is3d() { return true; }
}
exports.GeometricModel3dState = GeometricModel3dState;
/**
 * The state of a SheetModel.
 *
 * A SheetModel is a GeometricModel2d that has the following characteristics:
 * * Has finite extents, specified in meters (the *page size*.)
 * * Can contain views of other models, like pictures pasted on a photo album.
 */
class SheetModelState extends GeometricModel2dState {
}
exports.SheetModelState = SheetModelState;
/** The state of a SpatialModel */
class SpatialModelState extends GeometricModel3dState {
}
exports.SpatialModelState = SpatialModelState;
/** The state of a DrawingModel */
class DrawingModelState extends GeometricModel2dState {
}
exports.DrawingModelState = DrawingModelState;
/** The state of a SectionDrawingModel */
class SectionDrawingModelState extends DrawingModelState {
}
exports.SectionDrawingModelState = SectionDrawingModelState;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(15);
const Viewport_1 = __webpack_require__(44);
const geometry_core_1 = __webpack_require__(1);
const geometry_core_2 = __webpack_require__(1);
const geometry_core_3 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_4 = __webpack_require__(1);
const LegacyMath_1 = __webpack_require__(75);
const IModelApp_1 = __webpack_require__(5);
const ElementLocateManager_1 = __webpack_require__(78);
const scratchFrustum = new imodeljs_common_1.Frustum();
const scratchTransform1 = geometry_core_2.Transform.createIdentity();
const scratchTransform2 = geometry_core_2.Transform.createIdentity();
const scratchRotMatrix1 = new geometry_core_2.RotMatrix();
const scratchPoint3d1 = new geometry_core_1.Point3d();
const scratchPoint3d2 = new geometry_core_1.Point3d();
const scratchVector3d1 = new geometry_core_1.Vector3d();
const scratchVector3d2 = new geometry_core_1.Vector3d();
// tslint:disable-next-line:variable-name
exports.ViewToolSettings = {
    preserveWorldUp: true,
    walkEnforceZUp: true,
    viewBallRadius: 0.35,
    walkVelocity: 3.5,
    walkCameraAngle: geometry_core_4.Angle.createDegrees(75.6),
    animationTime: bentleyjs_core_1.BeDuration.fromMilliseconds(260),
    animateZoom: false,
    pickSize: 13,
};
/** An InteractiveTool that manipulates a view. */
class ViewTool extends Tool_1.InteractiveTool {
    constructor() {
        super(...arguments);
        this.inDynamicUpdate = false;
    }
    beginDynamicUpdate() { this.inDynamicUpdate = true; }
    endDynamicUpdate() { this.inDynamicUpdate = false; }
    run() {
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        if (!toolAdmin.onInstallTool(this))
            return false;
        // toolAdmin.setViewTool(undefined);
        toolAdmin.startViewTool();
        toolAdmin.setViewTool(this);
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    onResetButtonUp(_ev) { this.exitTool(); return true; }
    onSelectedViewportChanged(_previous, _current) { }
    /** Do not override. */
    exitTool() { IModelApp_1.IModelApp.toolAdmin.exitViewTool(); }
}
exports.ViewTool = ViewTool;
class ViewingToolHandle {
    constructor(viewTool) {
        this.viewTool = viewTool;
    }
    onReinitialize() { }
    focusOut() { }
    noMotion(_ev) { return false; }
    motion(_ev) { return false; }
    checkOneShot() { return true; }
    getHandleCursor() { return Tool_1.BeCursor.Default; }
    focusIn() { IModelApp_1.IModelApp.toolAdmin.setCursor(this.getHandleCursor()); }
    drawHandle(_context, _hasFocus) { }
}
exports.ViewingToolHandle = ViewingToolHandle;
class ViewHandleArray {
    constructor(viewTool) {
        this.viewTool = viewTool;
        this.handles = [];
        this.focus = -1;
        this.focusDrag = false;
        this.hitHandleIndex = 0;
    }
    empty() {
        this.focus = -1;
        this.focusDrag = false;
        this.hitHandleIndex = -1; // setting to -1 will result in onReinitialize getting called before testHit which sets the hit index
        this.handles.length = 0;
    }
    get count() { return this.handles.length; }
    get hitHandle() { return this.getByIndex(this.hitHandleIndex); }
    get focusHandle() { return this.getByIndex(this.focus); }
    add(handle) { this.handles.push(handle); }
    getByIndex(index) { return (index >= 0 && index < this.count) ? this.handles[index] : undefined; }
    focusHitHandle() { this.setFocus(this.hitHandleIndex); }
    testHit(ptScreen, forced = 0 /* None */) {
        this.hitHandleIndex = -1;
        const data = { distance: 0.0, priority: 10 /* Normal */ };
        let minDistance = 0.0;
        let minDistValid = false;
        let highestPriority = 1 /* Low */;
        let nearestHitHandle;
        for (let i = 0; i < this.count; i++) {
            data.priority = 10 /* Normal */;
            const handle = this.handles[i];
            if (forced) {
                if (handle.handleType === forced) {
                    this.hitHandleIndex = i;
                    return true;
                }
            }
            else if (handle.testHandleForHit(ptScreen, data)) {
                if (data.priority >= highestPriority) {
                    if (data.priority > highestPriority)
                        minDistValid = false;
                    highestPriority = data.priority;
                    if (!minDistValid || (data.distance < minDistance)) {
                        minDistValid = true;
                        minDistance = data.distance;
                        nearestHitHandle = handle;
                        this.hitHandleIndex = i;
                    }
                }
            }
        }
        return undefined !== nearestHitHandle;
    }
    drawHandles(context) {
        // all handle objects must draw themselves
        for (let i = 0; i < this.count; i++) {
            if (i !== this.hitHandleIndex) {
                const handle = this.handles[i];
                handle.drawHandle(context, this.focus === i);
            }
        }
        // draw the hit handle last
        if (-1 !== this.hitHandleIndex) {
            const handle = this.handles[this.hitHandleIndex];
            handle.drawHandle(context, this.focus === this.hitHandleIndex);
        }
    }
    setFocus(index) {
        if (this.focus === index && (this.focusDrag === this.viewTool.isDragging))
            return;
        let focusHandle;
        if (this.focus >= 0) {
            focusHandle = this.getByIndex(this.focus);
            if (focusHandle)
                focusHandle.focusOut();
        }
        if (index >= 0) {
            focusHandle = this.getByIndex(index);
            if (focusHandle)
                focusHandle.focusIn();
        }
        this.focus = index;
        this.focusDrag = this.viewTool.isDragging;
        if (undefined !== this.viewport)
            this.viewport.invalidateDecorations();
    }
    onReinitialize() {
        this.handles.forEach((handle) => {
            if (undefined !== handle)
                handle.onReinitialize();
        });
    }
    /** determine whether a handle of a specific type exists */
    hasHandle(handleType) {
        for (let i = 0; i < this.count; ++i) {
            const handle = this.getByIndex(i);
            if (handle && handle.handleType === handleType)
                return true;
        }
        return false;
    }
    getHandleByType(handleType) {
        for (let i = 0; i < this.count; i++) {
            const handle = this.getByIndex(i);
            if (handle && handle.handleType === handleType)
                return handle;
        }
        return undefined;
    }
    motion(ev) {
        this.handles.forEach((handle) => { if (handle)
            handle.motion(ev); });
        return true;
    }
}
exports.ViewHandleArray = ViewHandleArray;
/** Base class for tools that manipulate the viewing frustum of a Viewport */
class ViewManip extends ViewTool {
    constructor(viewport, handleMask, isOneShot, scrollOnNoMotion, isDragOperationRequired = false) {
        super();
        this.handleMask = handleMask;
        this.isOneShot = isOneShot;
        this.scrollOnNoMotion = scrollOnNoMotion;
        this.isDragOperationRequired = isDragOperationRequired;
        this.viewport = undefined;
        this.frustumValid = false;
        this.alwaysLeaveLastView = false;
        this.ballRadius = 0; // screen coords
        this.lastPtScreen = new geometry_core_1.Point3d();
        this.targetCenterWorld = new geometry_core_1.Point3d();
        this.worldUpVector = new geometry_core_1.Vector3d();
        this.isDragging = false;
        this.isDragOperation = false;
        this.stoppedOverHandle = false;
        this.wantMotionStop = true;
        this.targetCenterValid = false;
        this.supportsOrientationEvents = true;
        this.nPts = 0;
        this.forcedHandle = 0 /* None */;
        this.lastFrustum = new imodeljs_common_1.Frustum();
        this.viewHandles = new ViewHandleArray(this);
        // if (handleMask & ViewHandleType.ViewPan) this.viewHandles.add(new ViewPan(this));
        // if (handleMask & ViewHandleType.Rotate) {
        //   this.synchViewBallInfo(true);
        //   this.viewHandles.add(new ViewRotate(this));
        // }
        // if (handleMask & ViewHandleType.ViewWalk) this.viewHandles.add(new ViewWalk(this));
        // We call ChangeViewport here and in _PostInstall.  There is some code that relies on it being
        // set up after the constructor. However, when this tool is installed there may be a call to
        // OnCleanup that makes it appear that the viewport is not attached to a view command.
        this.changeViewport(viewport);
    }
    decorate(context) {
        this.viewHandles.drawHandles(context);
    }
    onReinitialize() {
        IModelApp_1.IModelApp.toolAdmin.gesturePending = false;
        if (undefined !== this.viewport) {
            this.viewport.synchWithView(true); // make sure we store any changes in view undo buffer.
            this.viewHandles.setFocus(-1);
        }
        this.nPts = 0;
        this.isDragging = false;
        this.inDynamicUpdate = false;
        this.frustumValid = false;
        this.viewHandles.onReinitialize();
    }
    static getTargetHitDetail(viewport, worldPoint) {
        // NOTE: Don't change options without restoring the old values or it will affect the suspended primitive...
        const options = IModelApp_1.IModelApp.locateManager.options; // this is a reference
        const saveDisabled = options.disableIModelFilter;
        const saveHitSource = options.hitSource;
        options.disableIModelFilter = true;
        options.hitSource = 2 /* MotionLocate */;
        const path = IModelApp_1.IModelApp.locateManager.doLocate(new ElementLocateManager_1.LocateResponse(), true, worldPoint, viewport, false);
        options.disableIModelFilter = saveDisabled;
        options.hitSource = saveHitSource;
        return path;
    }
    onDataButtonDown(ev) {
        // Tool was started in "drag required" mode, don't advance tool state and wait to see if we get the start drag event.
        if (0 === this.nPts && this.isDragOperationRequired && !this.isDragOperation)
            return false;
        switch (this.nPts) {
            case 0:
                this.changeViewport(ev.viewport);
                if (this.processFirstPoint(ev))
                    this.nPts = 1;
                break;
            case 1:
                this.nPts = 2;
                break;
        }
        if (this.nPts > 1) {
            this.inDynamicUpdate = false;
            if (this.processPoint(ev, false) && this.isOneShot)
                this.exitTool();
            else
                this.onReinitialize();
        }
        return true;
    }
    onDataButtonUp(_ev) {
        if (this.nPts <= 1 && this.isDragOperationRequired && !this.isDragOperation && this.isOneShot)
            this.exitTool();
        return false;
    }
    onMiddleButtonDown(_ev) {
        // Just let idle tool handle this...
        return false;
    }
    onMiddleButtonUp(_ev) {
        // Can only support middle button for viewing tools in drag mode in order to allow middle click for tentative...
        if (this.nPts <= 1 && !this.isDragOperation && this.isOneShot)
            this.exitTool();
        return false;
    }
    onMouseWheel(inputEv) {
        const ev = inputEv.clone();
        // If the rotate is active, the mouse wheel should work as if the cursor is at the target center
        if ((this.handleMask & 1 /* Rotate */)) {
            ev.point = this.targetCenterWorld;
            ev.coordsFrom = 1 /* Precision */; // don't want raw point used...
        }
        IModelApp_1.IModelApp.toolAdmin.processWheelEvent(ev, false);
        this.doUpdate(true);
        return true;
    }
    onModelStartDrag(ev) {
        this.isDragOperation = true;
        this.stoppedOverHandle = false;
        IModelApp_1.IModelApp.toolAdmin.gesturePending = false;
        if (0 === this.nPts)
            this.onDataButtonDown(ev);
        return true;
    }
    onModelEndDrag(ev) {
        this.isDragOperation = false;
        return 0 === this.nPts || this.onDataButtonDown(ev);
    }
    onModelMotion(ev) {
        this.stoppedOverHandle = false;
        if (0 === this.nPts && this.viewHandles.testHit(ev.viewPoint))
            this.viewHandles.focusHitHandle();
        if (0 !== this.nPts)
            this.processPoint(ev, true);
        this.viewHandles.motion(ev);
    }
    onModelMotionStopped(ev) {
        if (ev.viewport !== this.viewport)
            return;
        if (0 === this.nPts) {
            if (this.viewHandles.testHit(ev.viewPoint)) {
                this.stoppedOverHandle = true;
                this.viewHandles.focusHitHandle();
            }
            else if (this.stoppedOverHandle) {
                this.stoppedOverHandle = false;
                this.viewport.invalidateDecorations();
            }
        }
    }
    onModelNoMotion(ev) {
        if (0 === this.nPts || !ev.viewport)
            return;
        const hitHandle = this.viewHandles.hitHandle;
        if (hitHandle && hitHandle.noMotion(ev))
            this.doUpdate(false);
    }
    onPostInstall() {
        this.changeViewport(this.viewport);
        super.onPostInstall();
        // can't _OnReinitialize until tool is installed (have to have saved current tool's state first).
        this.onReinitialize();
    }
    onCleanup() {
        let restorePrevious = false;
        if (this.inDynamicUpdate) {
            this.endDynamicUpdate();
            restorePrevious = !this.alwaysLeaveLastView;
        }
        const vp = this.viewport;
        if (undefined !== vp) {
            vp.synchWithView(true);
            if (restorePrevious)
                vp.doUndo(bentleyjs_core_1.BeDuration.fromSeconds(0));
            vp.invalidateDecorations();
        }
        this.viewHandles.empty();
        this.viewport = undefined;
    }
    isSameFrustum() {
        const frust = this.viewport.getWorldFrustum(scratchFrustum);
        if (this.frustumValid && frust.equals(this.lastFrustum))
            return true;
        this.lastFrustum.setFrom(frust);
        this.frustumValid = true;
        return false;
    }
    /** Get the geometric center of the union of the ranges of all selected elements. */
    getSelectedElementCenter() {
        // DgnElementIdSet const& elemSet = SelectionSetManager:: GetManager().GetElementIds();
        // if (0 == elemSet.size())
        //   return ERROR;
        // DRange3d range = DRange3d:: NullRange();
        // DgnDbR dgnDb = SelectionSetManager:: GetManager().GetDgnDbR();
        // for (DgnElementId elemId : elemSet)
        // {
        //   DgnElementCP el = dgnDb.Elements().FindLoadedElement(elemId); // Only care about already loaded elements...
        //   if (NULL == el)
        //     continue;
        //   DPoint3d origin;
        //   GeometrySourceCP geom = el -> ToGeometrySource();
        //   if (geom && geom -> HasGeometry()) {
        //     DRange3d elRange = geom -> CalculateRange3d();
        //     origin.Interpolate(elRange.low, 0.5, elRange.high);
        //     range.Extend(origin);
        //   }
        // }
        // if (range.IsNull())
        //   return ERROR;
        // center.Interpolate(range.low, 0.5, range.high);
        // return SUCCESS;
        return undefined;
    }
    updateTargetCenter() {
        const vp = this.viewport;
        if (!vp)
            return;
        if (this.targetCenterValid) {
            // React to AccuDraw compass being moved using "O" shortcut or tentative snap...
            if (this.isDragging)
                return;
            // DPoint3d  center = this.getTargetCenterWorld();
            // AccuDrawR accudraw = AccuDraw:: GetInstance();
            // if (accudraw.IsActive()) {
            //   DPoint3d    testPoint;
            //   accudraw.GetOrigin(testPoint);
            //   // Redefine target center if changed...world-locked if moved by user after tool starts...
            //   if (!testPoint.IsEqual(center, 1.0e-10))
            //     SetTargetCenterWorld(& testPoint, true);
            // }
            // else if (TentativePoint:: GetInstance().IsActive())
            // {
            //   // Clear current tentative, i.e. no datapoint to accept...
            //   DPoint3d    testPoint = * TentativePoint:: GetInstance().GetPoint();
            //   // Redefine target center if changed...world-locked if moved by user after tool starts...
            //   if (!testPoint.IsEqual(center, 1.0e-10))
            //     SetTargetCenterWorld(& testPoint, true);
            //   TentativePoint:: GetInstance().Clear(true);
            //   // NOTE: AccuDraw won't normally grab focus because it is disabled for viewing tools...
            //   AccuDrawShortcuts:: RequestInputFocus();
            // }
            return;
        }
        // TentativePoint & tentPoint = TentativePoint:: GetInstance();
        // // Define initial target center for view ball...
        // if (tentPoint.IsActive()) {
        //   SetTargetCenterWorld(tentPoint.GetPoint(), true);
        //   return;
        // }
        // if (tentPoint.IsSnapped() || AccuSnap:: GetInstance().IsHot())
        // {
        //   SetTargetCenterWorld(TentativeOrAccuSnap:: GetCurrentPoint(), true);
        //   return;
        // }
        let center = this.getSelectedElementCenter();
        if (center && this.isPointVisible(center)) {
            this.setTargetCenterWorld(center, true);
            return;
        }
        center = vp.viewCmdTargetCenter;
        if (center && this.isPointVisible(center)) {
            this.setTargetCenterWorld(center, true);
            return;
        }
        center = scratchPoint3d1;
        if (!vp.view.allow3dManipulations()) {
            vp.npcToWorld(imodeljs_common_1.NpcCenter, center);
            center.z = 0.0;
        }
        else {
            vp.determineDefaultRotatePoint(center);
        }
        this.setTargetCenterWorld(center, false);
    }
    updateWorldUpVector(initialSetup) {
        if (!initialSetup)
            return;
        this.worldUpVector.x = 0.0;
        this.worldUpVector.y = 0.0;
        this.worldUpVector.z = 1.0;
    }
    processFirstPoint(ev) {
        const forcedHandle = this.forcedHandle;
        this.forcedHandle = 0 /* None */;
        this.frustumValid = false;
        if (this.viewHandles.testHit(ev.viewPoint, forcedHandle)) {
            this.isDragging = true;
            this.viewHandles.focusHitHandle();
            const handle = this.viewHandles.hitHandle;
            if (undefined !== handle && !handle.firstPoint(ev))
                return false;
        }
        return true;
    }
    processPoint(ev, inDynamics) {
        const hitHandle = this.viewHandles.hitHandle;
        if (undefined === hitHandle) {
            return true;
        }
        const doUpdate = hitHandle.doManipulation(ev, inDynamics);
        if (doUpdate)
            this.doUpdate(true);
        return inDynamics || (doUpdate && hitHandle.checkOneShot());
    }
    lensAngleMatches(angle, tolerance) {
        const cameraView = this.viewport.view;
        return !cameraView.is3d() ? false : Math.abs(cameraView.calcLensAngle().radians - angle.radians) < tolerance;
    }
    isZUp() {
        const view = this.viewport.view;
        const viewX = view.getXVector();
        const viewY = view.getXVector();
        const zVec = geometry_core_1.Vector3d.unitZ();
        return (Math.abs(zVec.dotProduct(viewY)) > 0.99 && Math.abs(zVec.dotProduct(viewX)) < 0.01);
    }
    doUpdate(_abortOnButton) {
        // we currently have no built-in support for dynamics, therefore nothing to update.
    }
    setTargetCenterWorld(pt, snapOrPrecision) {
        this.targetCenterWorld.setFrom(pt);
        this.targetCenterValid = true;
        const vp = this.viewport;
        if (!vp)
            return;
        if (!vp.view.allow3dManipulations())
            this.targetCenterWorld.z = 0.0;
        vp.viewCmdTargetCenter = (snapOrPrecision ? pt : undefined);
        const viewPt = vp.worldToView(this.targetCenterWorld, scratchPoint3d1);
        const ev = new Tool_1.BeButtonEvent();
        ev.initEvent(this.targetCenterWorld, this.targetCenterWorld, viewPt, vp, 0 /* User */, 0);
        IModelApp_1.IModelApp.toolAdmin.setAdjustedDataPoint(ev);
    }
    invalidateTargetCenter() { this.targetCenterValid = false; }
    /** Determine whether the supplied point is visible in this Viewport. */
    isPointVisible(testPt) {
        const vp = this.viewport;
        if (!vp)
            return false;
        const testPtView = vp.worldToView(testPt);
        const frustum = vp.getFrustum(0 /* View */, false, scratchFrustum);
        const screenRange = scratchPoint3d1;
        screenRange.x = frustum.points[0 /* _000 */].distance(frustum.points[1 /* _100 */]);
        screenRange.y = frustum.points[0 /* _000 */].distance(frustum.points[2 /* _010 */]);
        screenRange.z = frustum.points[0 /* _000 */].distance(frustum.points[4 /* _001 */]);
        return (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));
    }
    static fitView(viewport, doUpdate, marginPercent) {
        const range = viewport.computeViewRange();
        const aspect = viewport.viewRect.aspect;
        const before = viewport.getWorldFrustum(scratchFrustum);
        // ###TODO: Currently computeViewRange() simply returns the viewed extents, in *world* coords.
        // This will change to be the range of a particular geometric model once Keith adds range as a property of GeometricModelState
        if (this._useViewAlignedVolume)
            viewport.view.lookAtViewAlignedVolume(range, aspect, marginPercent);
        else
            viewport.view.lookAtVolume(range, aspect, marginPercent);
        viewport.synchWithView(false);
        viewport.viewCmdTargetCenter = undefined;
        if (doUpdate)
            viewport.animateFrustumChange(before, viewport.getFrustum(), exports.ViewToolSettings.animationTime);
        viewport.synchWithView(true);
    }
    setCameraLensAngle(lensAngle, retainEyePoint) {
        const vp = this.viewport;
        if (!vp)
            return 15 /* InvalidViewport */;
        const view = vp.view;
        if (!view || !view.is3d())
            return 15 /* InvalidViewport */;
        const result = (retainEyePoint && view.isCameraOn()) ?
            view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle) :
            vp.turnCameraOn(lensAngle);
        if (result !== 0 /* Success */)
            return result;
        this.targetCenterValid = false;
        vp.synchWithView(false);
        return 0 /* Success */;
    }
    enforceZUp(pivotPoint) {
        const vp = this.viewport;
        if (!vp || this.isZUp())
            return false;
        const view = vp.view;
        const viewY = view.getYVector();
        const rotMatrix = geometry_core_2.RotMatrix.createRotationVectorToVector(viewY, geometry_core_1.Vector3d.unitZ(), scratchRotMatrix1);
        if (!rotMatrix)
            return false;
        const transform = geometry_core_2.Transform.createFixedPointAndMatrix(pivotPoint, rotMatrix, scratchTransform1);
        const frust = vp.getWorldFrustum(scratchFrustum);
        frust.multiply(transform);
        vp.setupViewFromFrustum(frust);
        return true;
    }
    viewPtToSpherePt(viewPt, invertY, result) {
        const vp = this.viewport;
        const ballRadius = this.ballRadius;
        const targetCenterView = vp.worldToView(this.targetCenterWorld, scratchPoint3d1);
        const ballMouse = scratchPoint3d2;
        ballMouse.x = (viewPt.x - targetCenterView.x) / ballRadius;
        ballMouse.y = (viewPt.y - targetCenterView.y) / ballRadius;
        const mag = (ballMouse.x * ballMouse.x) + (ballMouse.y * ballMouse.y);
        if (mag > 1.0 || !vp.view.allow3dManipulations()) {
            // we're outside of the circle
            if (mag <= 0.0)
                return undefined;
            const scale = 1.0 / Math.sqrt(mag);
            ballMouse.x *= scale;
            ballMouse.y *= scale;
            ballMouse.z = 0.0;
        }
        else {
            ballMouse.z = vp.view.allow3dManipulations() ? Math.sqrt(1.0 - mag) : 0.0;
        }
        if (invertY)
            ballMouse.y = -ballMouse.y;
        result = result ? result : new geometry_core_1.Vector3d();
        result.setFrom(ballMouse);
        return result;
    }
    ballPointsToMatrix(matrix, axisVector, ballVector0, ballVector1) {
        const normal = ballVector1.crossProduct(ballVector0);
        const theta = ballVector1.angleTo(ballVector0);
        if (matrix)
            geometry_core_2.RotMatrix.createRotationAroundVector(normal, theta, matrix);
        if (axisVector)
            axisVector.setFrom(normal);
        return theta;
    }
    synchViewBallInfo(initialSetup) {
        if (!this.viewport)
            return;
        const frustum = this.viewport.getFrustum(0 /* View */, false, scratchFrustum);
        const screenRange = scratchPoint3d1;
        screenRange.set(frustum.points[0 /* _000 */].distance(frustum.points[1 /* _100 */]), frustum.points[0 /* _000 */].distance(frustum.points[2 /* _010 */]), frustum.points[0 /* _000 */].distance(frustum.points[4 /* _001 */]));
        this.ballRadius = (((screenRange.x < screenRange.y) ? screenRange.x : screenRange.y) * exports.ViewToolSettings.viewBallRadius);
        this.updateTargetCenter();
        this.updateWorldUpVector(initialSetup);
    }
    changeViewport(vp) {
        // If viewport isn't really changing do nothing...
        if (vp === this.viewport)
            return;
        if (undefined !== this.viewport) {
            this.viewport.invalidateDecorations(); // Remove decorations from current viewport...
            this.viewHandles.empty();
        }
        // Set m_viewport to new viewport and return if new viewport is undefined...
        if (undefined === (this.viewport = vp))
            return;
        this.targetCenterValid = false;
        // allocate and initialize handles array
        this.viewHandles.viewport = vp;
        if (this.handleMask & 1 /* Rotate */) {
            // Setup initial view ball size and location...
            this.synchViewBallInfo(true);
            this.viewHandles.add(new ViewRotate(this));
        }
        // if (this.handleMask & ViewHandleType.TargetCenter)
        //   this.viewHandles.add(new TargetCenter(this));
        // if (this.handleMask & ViewHandleType.ViewScroll)
        //   this.viewHandles.add(new ViewScroll(this));
        if (this.handleMask & 4 /* ViewPan */)
            this.viewHandles.add(new ViewPan(this));
        // if (this.handleMask & ViewHandleType.ViewZoom)
        //   this.viewHandles.add(new ViewZoom(this));
        if (this.handleMask & 32 /* ViewWalk */)
            this.viewHandles.add(new ViewWalk(this));
        // if (this.handleMask & ViewHandleType.ViewWalkMobile)
        //   this.viewHandles.add(new ViewWalkMobile(this));
        // if (this.handleMask & ViewHandleType.ViewFly)
        //   this.viewHandles.add(new ViewFly(this));
        // if (this.handleMask & ViewHandleType.ViewLook)
        //   this.viewHandles.add(new ViewLook(this));
    }
}
ViewManip._useViewAlignedVolume = false;
exports.ViewManip = ViewManip;
/** ViewingToolHandle for performing the "pan view" operation */
class ViewPan extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this.anchorPt = new geometry_core_1.Point3d();
        this.lastPtNpc = new geometry_core_1.Point3d();
    }
    get handleType() { return 4 /* ViewPan */; }
    getHandleCursor() { return this.viewTool.isDragging ? Tool_1.BeCursor.ClosedHand : Tool_1.BeCursor.OpenHand; }
    doManipulation(ev, _inDynamics) {
        const vp = ev.viewport;
        const newPtWorld = ev.point.clone();
        const thisPtNpc = vp.worldToNpc(newPtWorld);
        const firstPtNpc = vp.worldToNpc(this.anchorPt);
        thisPtNpc.z = firstPtNpc.z;
        if (this.lastPtNpc.isAlmostEqual(thisPtNpc, 1.0e-10))
            return true;
        vp.npcToWorld(thisPtNpc, newPtWorld);
        this.lastPtNpc.setFrom(thisPtNpc);
        return this.doPan(newPtWorld);
    }
    firstPoint(ev) {
        const vp = ev.viewport;
        this.anchorPt.setFrom(ev.point);
        // if the camera is on, we need to find the element under the starting point to get the z
        if (0 /* User */ === ev.coordsFrom && vp.isCameraOn()) {
            const depthIntersection = undefined; // TODO: NEEDS_WORK vp.pickDepthBuffer(ev.viewPoint);
            if (depthIntersection) {
                this.anchorPt.setFrom(depthIntersection);
            }
            else {
                const firstPtNpc = vp.worldToNpc(this.anchorPt);
                firstPtNpc.z = vp.getFocusPlaneNpc();
                this.anchorPt = vp.npcToWorld(firstPtNpc, this.anchorPt);
            }
        }
        this.viewTool.beginDynamicUpdate();
        return true;
    }
    onReinitialize() {
        const vha = this.viewTool.viewHandles.hitHandle;
        if (vha === this) {
            IModelApp_1.IModelApp.toolAdmin.setCursor(this.getHandleCursor());
        }
    }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    doPan(newPtWorld) {
        const vp = this.viewTool.viewport;
        const view = vp.view;
        const dist = newPtWorld.vectorTo(this.anchorPt);
        if (view.is3d()) {
            if (0 /* Success */ !== view.moveCameraWorld(dist))
                return false;
        }
        else {
            view.setOrigin(view.getOrigin().plus(dist));
        }
        vp.synchWithView(false);
        return true;
    }
}
class ViewRotate extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this.lastPtNpc = new geometry_core_1.Point3d();
        this.firstPtNpc = new geometry_core_1.Point3d();
        this.ballVector0 = new geometry_core_1.Vector3d();
        this.frustum = new imodeljs_common_1.Frustum();
        this.activeFrustum = new imodeljs_common_1.Frustum();
    }
    get handleType() { return 1 /* Rotate */; }
    getHandleCursor() { return Tool_1.BeCursor.Rotate; }
    testHandleForHit(ptScreen, out) {
        const tool = this.viewTool;
        const targetPt = tool.viewport.worldToView(tool.targetCenterWorld);
        const dist = targetPt.distanceXY(ptScreen);
        // add 3 to give a little slop around circle
        // if (m_viewTool->UseSphere() && viewport->Allow3dManipulations() && distance > (m_viewTool->GetBallRadius() + 3))
        //     return false;
        out.distance = dist;
        out.priority = 10 /* Normal */;
        return true;
    }
    firstPoint(ev) {
        if (IModelApp_1.IModelApp.toolAdmin.gesturePending)
            return false;
        const tool = this.viewTool;
        const vp = ev.viewport;
        if (vp.view.allow3dManipulations()) {
            const visiblePoint = vp.determineNearestVisibleGeometryPoint(ev.rawPoint, 20.0);
            if (undefined !== visiblePoint)
                tool.setTargetCenterWorld(visiblePoint, false);
        }
        let pickPt;
        let pickPtOrig;
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isActive()) {
            const aDrawOrigin = accudraw.origin;
            const aDrawMatrix = accudraw.getRotation();
            pickPt = ev.point.clone(); // Use adjusted point when AccuDraw is active...
            pickPtOrig = pickPt.clone();
            // Lock to the construction plane
            const distWorld = pickPt.clone();
            const viewZWorld = (vp.view.is3d() && vp.isCameraOn()) ? vp.view.camera.eye.vectorTo(distWorld) : vp.rotMatrix.getRow(2);
            const aDrawZWorld = aDrawMatrix.getRow(2);
            LegacyMath_1.LegacyMath.linePlaneIntersect(distWorld, distWorld, viewZWorld, aDrawOrigin, aDrawZWorld, false);
            let flags = 2097156 /* AlwaysSetOrigin */ | 1 /* SetModePolar */ | 8 /* FixedOrigin */;
            const activeOrg = this.viewTool.targetCenterWorld;
            const aDrawX = activeOrg.vectorTo(distWorld);
            if (aDrawX.normalizeWithLength(aDrawX).mag > 0.00001) {
                const aDrawZ = aDrawMatrix.getRow(2);
                const aDrawY = aDrawZ.crossProduct(aDrawX);
                geometry_core_2.RotMatrix.createRows(aDrawX, aDrawY, aDrawZ, aDrawMatrix);
                aDrawMatrix.normalizeRowsInPlace();
                flags |= 16 /* SetRMatrix */;
            }
            accudraw.setContext(flags, activeOrg, aDrawMatrix);
        }
        else {
            pickPt = ev.rawPoint.clone(); // Use raw point when AccuDraw is not active, don't want tentative location...
            pickPtOrig = pickPt.clone();
        }
        const viewPt = vp.worldToView(pickPt);
        tool.viewPtToSpherePt(viewPt, true, this.ballVector0);
        vp.worldToNpc(pickPtOrig, this.firstPtNpc);
        this.lastPtNpc.setFrom(this.firstPtNpc);
        vp.getWorldFrustum(this.activeFrustum);
        this.frustum.setFrom(this.activeFrustum);
        tool.beginDynamicUpdate();
        return true;
    }
    doManipulation(ev, _inDynamics) {
        const tool = this.viewTool;
        const viewport = tool.viewport;
        const ptNpc = viewport.worldToNpc(ev.point);
        if (this.lastPtNpc.isAlmostEqual(ptNpc, 1.0e-10))
            return true;
        if (this.firstPtNpc.isAlmostEqual(ptNpc, 1.0e-2))
            ptNpc.setFrom(this.firstPtNpc);
        this.lastPtNpc.setFrom(ptNpc);
        const currentFrustum = viewport.getWorldFrustum(scratchFrustum);
        const frustumChange = !currentFrustum.equals(this.activeFrustum);
        if (frustumChange)
            this.frustum.setFrom(currentFrustum);
        else if (!viewport.setupViewFromFrustum(this.frustum))
            return false;
        const currPt = viewport.npcToView(ptNpc, scratchPoint3d2);
        if (frustumChange) {
            this.firstPtNpc.setFrom(ptNpc);
            tool.viewPtToSpherePt(currPt, true, this.ballVector0);
        }
        let radians;
        let worldAxis;
        const worldPt = tool.targetCenterWorld;
        if (!viewport.view.allow3dManipulations()) {
            const currBallPt = this.viewTool.viewPtToSpherePt(currPt, true);
            const axisVector = new geometry_core_1.Vector3d();
            radians = tool.ballPointsToMatrix(undefined, axisVector, this.ballVector0, currBallPt);
            const viewMatrix = viewport.rotMatrix;
            const xVec = viewMatrix.getRow(0);
            const yVec = viewMatrix.getRow(1);
            const zVec = viewMatrix.getRow(2);
            worldAxis = geometry_core_1.Vector3d.add3Scaled(xVec, axisVector.x, yVec, axisVector.y, zVec, axisVector.z);
        }
        else {
            const viewRect = viewport.viewRect;
            const xExtent = viewRect.width;
            const yExtent = viewRect.height;
            viewport.npcToView(ptNpc, currPt);
            const firstPt = viewport.npcToView(this.firstPtNpc);
            const xDelta = (currPt.x - firstPt.x);
            const yDelta = (currPt.y - firstPt.y);
            // Movement in screen x == rotation about drawing Z (preserve up) or rotation about screen  Y...
            const xAxis = exports.ViewToolSettings.preserveWorldUp ? this.viewTool.worldUpVector.clone() : viewport.rotMatrix.getRow(1);
            // Movement in screen y == rotation about screen X...
            const yAxis = viewport.rotMatrix.getRow(0);
            const xRMatrix = xDelta ? geometry_core_2.RotMatrix.createRotationAroundVector(xAxis, geometry_core_4.Angle.createRadians(Math.PI / (xExtent / xDelta))) : geometry_core_2.RotMatrix.createIdentity();
            const yRMatrix = yDelta ? geometry_core_2.RotMatrix.createRotationAroundVector(yAxis, geometry_core_4.Angle.createRadians(Math.PI / (yExtent / yDelta))) : geometry_core_2.RotMatrix.createIdentity();
            const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);
            const result = worldRMatrix.getAxisAndAngleOfRotation();
            radians = geometry_core_4.Angle.createRadians(-result.angle.radians);
            worldAxis = result.axis;
        }
        this.rotateViewWorld(worldPt, worldAxis, radians);
        // viewport.moveViewToSurfaceIfRequired();
        viewport.getWorldFrustum(this.activeFrustum);
        return true;
    }
    rotateViewWorld(worldOrigin, worldAxisVector, primaryAngle) {
        const worldMatrix = geometry_core_2.RotMatrix.createRotationAroundVector(worldAxisVector, primaryAngle);
        if (!worldMatrix)
            return;
        const worldTransform = geometry_core_2.Transform.createFixedPointAndMatrix(worldOrigin, worldMatrix);
        const frustum = this.frustum.clone();
        frustum.multiply(worldTransform);
        this.viewTool.viewport.setupViewFromFrustum(frustum);
    }
}
// class WalkDecoration {
//   constructor(parentElement, origin, color) {
//     this.parentElement = parentElement;
//     const ruleColor = '1px solid ' + Cesium.defaultValue(color, 'white');
//     const halfLen = 7;
//     const fullLen = halfLen * 2 + 1;
//     const hor = document.createElement('div');
//     hor.className = 'bim-overlay-box-rule-horizontal';
//     this.hor = hor;
//     const style = hor.style;
//     style.height = '0px';
//     style.width = fullLen + 'px';
//     style.top = origin.y + 'px';
//     style.left = (origin.x - halfLen) + 'px';
//     style.borderBottom = ruleColor;
//     parentElement.appendChild(hor);
//     const ver = document.createElement('div');
//     ver.className = 'bim-overlay-box-rule-vertical';
//     this.ver = ver;
//     style = ver.style;
//     style.width = '0px';
//     style.height = fullLen + 'px';
//     style.left = origin.x + 'px';
//     style.top = (origin.y - halfLen) + 'px';
//     style.borderLeft = ruleColor;
//     parentElement.appendChild(ver);
//   }
//   public destroy() {
//      if (!this.destroyed) {
//        this.destroyed = true;
//        this.parentElement.removeChild(this.hor);
//        this.parentElement.removeChild(this.ver);
//     }
//   }
// }
class NavigateMotion {
    constructor(viewport) {
        this.viewport = viewport;
        this.deltaTime = 0;
        this.transform = geometry_core_2.Transform.createIdentity();
    }
    init(elapsedMilliseconds) {
        this.deltaTime = elapsedMilliseconds * 0.001;
        this.transform.setIdentity();
    }
    getViewUp(result) { return this.viewport.rotMatrix.getRow(1, result); }
    getViewDirection(result) {
        const forward = this.viewport.rotMatrix.getRow(2, result);
        forward.scale(-1, forward); // positive z is out of the screen, but we want direction into the screen
        return forward;
    }
    takeElevator(distance) {
        const trans = scratchPoint3d1;
        trans.x = trans.y = 0;
        trans.z = distance * this.deltaTime;
        geometry_core_2.Transform.createTranslation(trans, this.transform);
    }
    modifyPitchAngleToPreventInversion(pitchAngle) {
        const angleLimit = geometry_core_4.Angle.degreesToRadians(85);
        const angleTolerance = geometry_core_4.Angle.degreesToRadians(0.01);
        if (0.0 === pitchAngle)
            return 0.0;
        const viewUp = this.getViewUp(scratchVector3d1);
        const viewDir = this.getViewDirection(scratchVector3d2);
        const worldUp = geometry_core_1.Vector3d.unitZ();
        let viewAngle = worldUp.angleTo(viewUp).radians;
        if (viewDir.z < 0)
            viewAngle *= -1;
        let newAngle = pitchAngle + viewAngle;
        if (Math.abs(newAngle) < angleLimit)
            return pitchAngle; // not close to the limit
        if ((pitchAngle > 0) !== (viewAngle > 0) && (Math.abs(pitchAngle) < Math.PI / 2))
            return pitchAngle; // tilting away from the limit
        if (Math.abs(viewAngle) >= (angleLimit - angleTolerance))
            return 0.0; // at the limit already
        const difference = Math.abs(newAngle) - angleLimit;
        newAngle = (pitchAngle > 0) ? pitchAngle - difference : pitchAngle + difference;
        return newAngle; // almost at the limit, but still can go a little bit closer
    }
    getWorldUp(result) {
        const up = geometry_core_1.Vector3d.createFrom(geometry_core_1.Vector3d.unitZ(), result);
        //    this.viewport.geometry.rootTransform.multiplyByPointAsVector(Cartesian3.UNIT_Z, up);
        return up;
    }
    generateRotationTransform(yawRate, pitchRate, result) {
        const vp = this.viewport;
        const view = vp.view;
        const viewRot = vp.rotMatrix;
        const invViewRot = viewRot.inverse(scratchRotMatrix1);
        const pitchAngle = geometry_core_4.Angle.createRadians(this.modifyPitchAngleToPreventInversion(pitchRate * this.deltaTime));
        const pitchMatrix = geometry_core_2.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitX(), pitchAngle);
        const pitchTimesView = pitchMatrix.multiplyMatrixMatrix(viewRot);
        const inverseViewTimesPitchTimesView = invViewRot.multiplyMatrixMatrix(pitchTimesView);
        const yawMatrix = geometry_core_2.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_4.Angle.createRadians(yawRate * this.deltaTime));
        const yawTimesInverseViewTimesPitchTimesView = yawMatrix.multiplyMatrixMatrix(inverseViewTimesPitchTimesView);
        return geometry_core_2.Transform.createFixedPointAndMatrix(view.getEyePoint(), yawTimesInverseViewTimesPitchTimesView, result);
    }
    generateTranslationTransform(velocity, isConstrainedToXY, result) {
        const points = new Array(3);
        points[0] = new geometry_core_1.Point3d(0, 0, 0);
        points[1] = new geometry_core_1.Point3d(1, 0, 0);
        points[2] = new geometry_core_1.Point3d(0, 1, 0);
        if (this.viewport.isCameraOn()) {
            this.viewport.viewToNpcArray(points);
            points[0].z = points[1].z = points[2].z = this.viewport.getFocusPlaneNpc(); // use the focal plane for z coordinates
            this.viewport.npcToViewArray(points);
        }
        this.viewport.viewToWorldArray(points);
        const xDir = geometry_core_1.Vector3d.createStartEnd(points[0], points[1]);
        xDir.normalizeInPlace();
        const yDir = geometry_core_1.Vector3d.createStartEnd(points[0], points[2]);
        yDir.normalizeInPlace();
        const zDir = this.getViewDirection();
        if (isConstrainedToXY) {
            const up = this.getWorldUp();
            const cross = up.crossProduct(zDir);
            cross.crossProduct(up, zDir);
            zDir.normalizeInPlace();
        }
        xDir.scale(velocity.x * this.deltaTime, xDir);
        yDir.scale(velocity.y * this.deltaTime, yDir);
        zDir.scale(velocity.z * this.deltaTime, zDir);
        xDir.plus(yDir, xDir).plus(zDir, xDir);
        return geometry_core_2.Transform.createTranslation(xDir, result);
    }
    moveAndLook(linearVelocity, angularVelocityX, angularVelocityY, isConstrainedToXY) {
        const rotateTrans = this.generateRotationTransform(angularVelocityX, angularVelocityY, scratchTransform1);
        const dollyTrans = this.generateTranslationTransform(linearVelocity, isConstrainedToXY, scratchTransform2);
        this.transform.setMultiplyTransformTransform(rotateTrans, dollyTrans);
    }
    pan(horizontalVelocity, verticalVelocity) {
        const travel = new geometry_core_1.Vector3d(horizontalVelocity, verticalVelocity, 0);
        this.moveAndLook(travel, 0, 0, false);
    }
    travel(yawRate, pitchRate, forwardVelocity, isConstrainedToXY) {
        const travel = new geometry_core_1.Vector3d(0, 0, forwardVelocity);
        this.moveAndLook(travel, yawRate, pitchRate, isConstrainedToXY);
    }
    look(yawRate, pitchRate) {
        this.generateRotationTransform(yawRate, pitchRate, this.transform);
    }
    /** reset pitch of view to zero */
    resetToLevel() {
        const view = this.viewport.view;
        if (!view.is3d() || !view.isCameraOn())
            return;
        const angles = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(this.viewport.rotMatrix);
        angles.pitch.setRadians(0); // reset pitch to zero
        geometry_core_2.Transform.createFixedPointAndMatrix(view.getEyePoint(), angles.toRotMatrix(scratchRotMatrix1), this.transform);
    }
}
class ViewNavigate extends ViewingToolHandle {
    constructor(viewManip) {
        super(viewManip);
        this.anchorPtView = new geometry_core_1.Point3d();
        this.lastPtView = new geometry_core_1.Point3d();
        this.initialized = false;
        this.lastMotionTime = 0;
        this.orientationValid = false;
        this.orientationTime = 0;
        this.orientationZ = new geometry_core_1.Vector3d();
    }
    haveStaticOrientation(zVec, currentTime) {
        if (!this.orientationValid || zVec.angleTo(this.orientationZ).radians > ViewNavigate.angleLimit || this.orientationZ.isAlmostZero()) {
            this.orientationValid = true;
            this.orientationTime = currentTime;
            this.orientationZ = zVec;
            return false;
        }
        return (currentTime - this.orientationTime) > ViewNavigate.timeLimit;
    }
    tryOrientationEvent(_forward, _ev) {
        // ###TODO: support orientation events?
        return { eventsEnabled: false, result: 1 /* NoEvent */ };
    }
    getElapsedTime(currentTime) {
        let elapsedTime = currentTime - this.lastMotionTime;
        if (0 === this.lastMotionTime || elapsedTime < 0 || elapsedTime > 1000)
            elapsedTime = 100;
        return elapsedTime;
    }
    getMaxLinearVelocity() { return exports.ViewToolSettings.walkVelocity; }
    getMaxAngularVelocity() { return Math.PI / 4; }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    getInputVector(result) {
        const inputDeadZone = 5.0;
        const input = this.anchorPtView.vectorTo(this.lastPtView, result);
        const viewRect = this.viewTool.viewport.viewRect;
        if (Math.abs(input.x) < inputDeadZone)
            input.x = 0;
        else
            input.x = 2 * input.x / viewRect.width;
        if (Math.abs(input.y) < inputDeadZone)
            input.y = 0;
        else
            input.y = 2 * input.y / viewRect.height;
        input.x = Math.min(input.x, 1);
        input.y = Math.min(input.y, 1);
        return input;
    }
    getCenterPoint(result) {
        const center = result ? result : new geometry_core_1.Point3d();
        center.setZero();
        const rect = this.viewTool.viewport.viewRect;
        const width = rect.width;
        const height = rect.height;
        if (width > 0)
            center.x = width / 2;
        if (height > 0)
            center.y = height / 2;
        return center;
    }
    getNavigateMode() {
        const state = IModelApp_1.IModelApp.toolAdmin.currentInputState;
        if (state.isShiftDown || !this.viewTool.viewport.isCameraOn())
            return 0 /* Pan */;
        return state.isControlDown ? 1 /* Look */ : 2 /* Travel */;
    }
    doNavigate(ev) {
        const currentTime = Date.now();
        const forward = ViewNavigate.scratchForward;
        const orientationEvent = this.tryOrientationEvent(forward, ev);
        const orientationResult = orientationEvent.result;
        const elapsedTime = this.getElapsedTime(currentTime);
        this.lastMotionTime = currentTime;
        const vp = this.viewTool.viewport;
        const motion = this.getNavigateMotion(elapsedTime);
        let haveNavigateEvent = !!motion;
        if (haveNavigateEvent) {
            const frust = vp.getWorldFrustum(scratchFrustum);
            frust.multiply(motion.transform);
            if (!vp.setupViewFromFrustum(frust)) {
                haveNavigateEvent = false;
                if (1 /* NoEvent */ === orientationResult)
                    return false;
            }
        }
        let doFull = false;
        let doDynamic = false;
        if (haveNavigateEvent)
            doDynamic = true;
        else {
            switch (orientationResult) {
                case 2 /* Disabled */:
                case 1 /* NoEvent */:
                    doFull = true;
                    break;
                case 3 /* RejectedByController */:
                    if (!this.haveStaticOrientation(forward, currentTime))
                        return false;
                    doFull = true;
                    break;
                case 0 /* Success */:
                    if (this.haveStaticOrientation(forward, currentTime))
                        doFull = true;
                    else
                        doDynamic = true;
                    break;
            }
        }
        if (doFull) {
            this.viewTool.endDynamicUpdate();
            this.viewTool.doUpdate(true);
            this.viewTool.beginDynamicUpdate();
            return false;
        }
        return doDynamic;
    }
    doManipulation(ev, inDynamics) {
        if (!inDynamics)
            return true;
        else if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.lastPtView.setFrom(ev.viewPoint);
        return this.doNavigate(ev);
    }
    noMotion(ev) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.viewTool.beginDynamicUpdate();
        this.doNavigate(ev);
        return false;
    }
    onReinitialize() {
        if (this.initialized)
            return;
        this.initialized = true;
        const tool = this.viewTool;
        const vp = tool.viewport;
        const view = vp.view;
        if (!view.is3d() || !view.allow3dManipulations())
            return;
        const startFrust = vp.getWorldFrustum();
        const walkAngle = exports.ViewToolSettings.walkCameraAngle;
        if (!tool.lensAngleMatches(walkAngle, geometry_core_4.Angle.degreesToRadians(10)) || !tool.isZUp()) {
            //  This turns on the camera if its not already on. It also assures the camera is centered. Obviously this is required if
            //  the camera is not on or the lens angle is not what we want. We also want to do it if Z will be
            //  adjusted because EnforceZUp swivels the camera around what GetTargetPoint returns. If the FocusDistance is not set to something
            //  reasonable the target point may be far beyond anything relevant.
            tool.setCameraLensAngle(walkAngle, tool.lensAngleMatches(walkAngle, geometry_core_4.Angle.degreesToRadians(45.)));
        }
        if (exports.ViewToolSettings.walkEnforceZUp)
            this.viewTool.enforceZUp(view.getTargetPoint());
        const endFrust = vp.getWorldFrustum();
        if (!startFrust.equals(endFrust))
            vp.animateFrustumChange(startFrust, endFrust, exports.ViewToolSettings.animationTime);
        this.getCenterPoint(this.anchorPtView);
        // const that = this;
        // this._removeEventListener = vp.cameraToggled.addEventListener(function () { if (!vp.isCameraOn) that.viewTool.exitTool(); });
    }
    onCleanup() {
        //   if (Cesium.defined(this._removeEventListener)) {
        //     this._removeEventListener();
        //     this._removeEventListener = undefined;
        //   }
    }
    firstPoint(ev) {
        // NB: In desktop apps we want to center the cursor in the view.
        // The browser doesn't support that, and it is more useful to be able to place the anchor point freely anyway.
        this.viewTool.beginDynamicUpdate();
        this.lastPtView.setFrom(ev.viewPoint);
        this.anchorPtView.setFrom(this.lastPtView);
        // this.decoration = new WalkDecoration(this.viewport.canvas.parentElement, this.anchorPtView, this.viewport.getContrastToBackgroundColor());
        return true;
    }
    getHandleCursor() { return Tool_1.BeCursor.CrossHair; }
    focusOut() {
        // this.decoration = this.decoration && this.decoration.destroy();
    }
    drawHandle(context, _hasFocus) {
        if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)
            return;
        const point = new geometry_core_1.Point2d(this.anchorPtView.x, this.anchorPtView.y);
        const points = [point];
        const black = imodeljs_common_1.ColorDef.black.clone();
        let graphic = context.createViewOverlay();
        graphic.setSymbology(black, black, 9);
        graphic.addPointString2d(points, 0.0);
        context.addViewOverlay(graphic.finish());
        const white = imodeljs_common_1.ColorDef.white.clone();
        graphic = context.createViewOverlay();
        graphic.setSymbology(white, black, 5);
        graphic.addPointString2d(points, 0.0);
        context.addViewOverlay(graphic.finish());
    }
}
ViewNavigate.angleLimit = 0.075;
ViewNavigate.timeLimit = 500;
ViewNavigate.scratchForward = new geometry_core_1.Vector3d();
class ViewWalk extends ViewNavigate {
    constructor(viewManip) {
        super(viewManip);
        this.navigateMotion = new NavigateMotion(this.viewTool.viewport);
    }
    get handleType() { return 32 /* ViewWalk */; }
    getNavigateMotion(elapsedTime) {
        const input = this.getInputVector(scratchVector3d1);
        if (0 === input.x && 0 === input.y)
            return undefined;
        const motion = this.navigateMotion;
        motion.init(elapsedTime);
        switch (this.getNavigateMode()) {
            case 0 /* Pan */:
                input.scale(this.getMaxLinearVelocity(), input);
                motion.pan(input.x, input.y);
                break;
            case 1 /* Look */:
                input.scale(-this.getMaxAngularVelocity(), input);
                motion.look(input.x, input.y);
                break;
            case 2 /* Travel */:
                motion.travel(-input.x * this.getMaxAngularVelocity(), 0, -input.y * this.getMaxLinearVelocity(), true); // ###TODO: multiplied input.x by -1 added as temporary fix for unknown bug causing inverse walk directions
                break;
        }
        return motion;
    }
}
/** The tool that performs a fit view */
class FitViewTool extends ViewTool {
    constructor(viewport, oneShot, doAnimate = true) {
        super();
        this.viewport = viewport;
        this.oneShot = oneShot;
        this.doAnimate = doAnimate;
    }
    onDataButtonDown(_ev) {
        if (_ev.viewport) {
            return this.doFit(_ev.viewport, false, this.doAnimate);
        }
        return false;
    }
    onPostInstall() {
        super.onPostInstall();
        if (this.viewport)
            this.doFit(this.viewport, this.oneShot, this.doAnimate);
    }
    doFit(viewport, oneShot, doAnimate = true) {
        ViewManip.fitView(viewport, doAnimate);
        if (oneShot)
            this.exitTool();
        return oneShot;
    }
}
FitViewTool.toolId = "View.Fit";
exports.FitViewTool = FitViewTool;
/** The tool that performs a Pan view operation */
class PanTool extends ViewManip {
    constructor(vp, oneShot = false, scrollOnNoMotion = false, isDragOperationRequired = false) {
        super(vp, 4 /* ViewPan */, oneShot, scrollOnNoMotion, isDragOperationRequired);
    }
}
PanTool.toolId = "View.Pan";
exports.PanTool = PanTool;
/** tool that performs a Rotate view operation */
class RotateTool extends ViewManip {
    constructor(vp, oneShot = false, scrollOnNoMotion = false, isDragOperationRequired = false) {
        super(vp, 4 /* ViewPan */ | 1 /* Rotate */, oneShot, scrollOnNoMotion, isDragOperationRequired);
    }
}
RotateTool.toolId = "View.Rotate";
exports.RotateTool = RotateTool;
/** tool that performs the walk operation */
class ViewWalkTool extends ViewManip {
    constructor(vp) { super(vp, 32 /* ViewWalk */, false, true, false); }
}
ViewWalkTool.toolId = "View.Walk";
exports.ViewWalkTool = ViewWalkTool;
/** tool that performs a Window-area view operation */
class WindowAreaTool extends ViewTool {
    constructor(viewport) {
        super();
        this.haveFirstPoint = false;
        this.firstPtWorld = geometry_core_1.Point3d.create();
        this.secondPtWorld = geometry_core_1.Point3d.create();
        this.lastPtView = new geometry_core_1.Point3d();
        this.corners = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this.shapePts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this.lineHorzPts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this.lineVertPts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this.fillColor = imodeljs_common_1.ColorDef.from(0, 0, 255, 200);
        this.viewport = viewport;
    }
    onModelEndDrag(ev) { return this.onDataButtonDown(ev); }
    onReinitialize() {
        this.haveFirstPoint = false;
        this.firstPtWorld.setZero();
        this.secondPtWorld.setZero();
    }
    onModelMotion(ev) { this.doManipulation(ev, true); }
    updateDynamics(ev) { this.doManipulation(ev, true); }
    onDataButtonDown(ev) {
        if (this.haveFirstPoint) {
            this.secondPtWorld.setFrom(ev.point);
            this.doManipulation(ev, false);
            this.onReinitialize();
            this.viewport.invalidateDecorations();
        }
        else {
            this.firstPtWorld.setFrom(ev.point);
            this.secondPtWorld.setFrom(this.firstPtWorld);
            this.haveFirstPoint = true;
            this.lastPtView.setFrom(ev.viewPoint);
        }
        return true;
    }
    onResetButtonUp(ev) {
        if (this.haveFirstPoint) {
            this.haveFirstPoint = false;
            return true;
        }
        return super.onResetButtonUp(ev);
    }
    decorate(context) {
        const color = this.viewport.getContrastToBackgroundColor();
        if (this.haveFirstPoint) {
            const corners = this.computeWindowCorners();
            if (undefined === corners)
                return;
            this.shapePts[0].x = this.shapePts[3].x = corners[0].x;
            this.shapePts[1].x = this.shapePts[2].x = corners[1].x;
            this.shapePts[0].y = this.shapePts[1].y = corners[0].y;
            this.shapePts[2].y = this.shapePts[3].y = corners[1].y;
            this.shapePts[0].z = this.shapePts[1].z = this.shapePts[2].z = this.shapePts[3].z = corners[0].z;
            this.shapePts[4].setFrom(this.shapePts[0]);
            this.viewport.viewToWorldArray(this.shapePts);
            const graphic = context.createWorldOverlay();
            graphic.setBlankingFill(this.fillColor);
            graphic.addShape(this.shapePts);
            graphic.setSymbology(color, color, 1 /* Thin */);
            graphic.addLineString(this.shapePts);
            graphic.setSymbology(color, color, 8 /* FatDot */);
            graphic.addPointString([this.firstPtWorld]);
            context.addWorldOverlay(graphic.finish());
            return;
        }
        const gf = context.createViewOverlay();
        gf.setSymbology(color, color, 1 /* Thin */);
        const viewRect = this.viewport.viewRect;
        const cursorPt = this.lastPtView;
        cursorPt.z = 0;
        this.lineHorzPts[0].setFrom(cursorPt);
        this.lineHorzPts[1].setFrom(cursorPt);
        this.lineHorzPts[0].x = viewRect.left;
        this.lineHorzPts[1].x = viewRect.right;
        gf.addLineString(this.lineHorzPts);
        this.lineVertPts[0].setFrom(cursorPt);
        this.lineVertPts[1].setFrom(cursorPt);
        this.lineVertPts[0].y = viewRect.top;
        this.lineVertPts[1].y = viewRect.bottom;
        gf.addLineString(this.lineVertPts);
        context.addViewOverlay(gf.finish());
    }
    computeWindowCorners() {
        const vp = this.viewport;
        const corners = this.corners;
        corners[0].setFrom(this.firstPtWorld);
        corners[1].setFrom(this.secondPtWorld);
        vp.worldToViewArray(corners);
        const delta = corners[1].minus(corners[0]);
        if (delta.magnitudeXY() < 2.0)
            return undefined;
        const currentDelta = this.viewport.viewDelta;
        if (currentDelta.x === 0 || delta.x === 0)
            return undefined;
        const viewAspect = currentDelta.y / currentDelta.x;
        const aspectRatio = Math.abs(delta.y / delta.x);
        let halfDeltaX;
        let halfDeltaY;
        if (aspectRatio < viewAspect) {
            halfDeltaX = Math.abs(delta.x) / 2.0;
            halfDeltaY = halfDeltaX * viewAspect;
        }
        else {
            halfDeltaY = Math.abs(delta.y) / 2.0;
            halfDeltaX = halfDeltaY / viewAspect;
        }
        const center = corners[0].plusScaled(delta, 0.5);
        corners[0].x = center.x - halfDeltaX;
        corners[0].y = center.y - halfDeltaY;
        corners[1].x = center.x + halfDeltaX;
        corners[1].y = center.y + halfDeltaY;
        return corners;
    }
    doManipulation(ev, inDynamics) {
        this.secondPtWorld.setFrom(ev.point);
        if (inDynamics) {
            this.lastPtView.setFrom(ev.viewPoint);
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            return;
        }
        const corners = this.computeWindowCorners();
        if (!corners)
            return;
        let delta;
        const vp = this.viewport;
        const startFrust = vp.getWorldFrustum(scratchFrustum);
        vp.viewToWorldArray(corners);
        if (vp.view.is3d() && vp.view.isCameraOn()) {
            const cameraView = vp.view;
            const windowArray = [corners[0].clone(), corners[1].clone()];
            vp.worldToViewArray(windowArray);
            const windowRange = new Viewport_1.ViewRect(windowArray[0].x, windowArray[0].y, windowArray[1].x, windowArray[1].y);
            let npcZValues = vp.determineVisibleDepthRange(windowRange);
            if (!npcZValues)
                npcZValues = new Viewport_1.DepthRangeNpc(0, vp.getFocusPlaneNpc()); // Just use the focus plane
            const lensAngle = cameraView.getLensAngle();
            vp.worldToNpcArray(corners);
            corners[0].z = corners[1].z = npcZValues.maximum;
            vp.npcToWorldArray(corners); // Put corners back in world at correct depth
            const viewPts = [corners[0].clone(), corners[1].clone()];
            vp.rotMatrix.multiplyVectorArrayInPlace(viewPts); // rotate to view orientation to get extents
            const range = geometry_core_3.Range3d.createArray(viewPts);
            delta = geometry_core_1.Vector3d.createStartEnd(range.low, range.high);
            const focusDist = Math.max(delta.x, delta.y) / (2.0 * Math.tan(lensAngle.radians / 2));
            const newTarget = corners[0].interpolate(.5, corners[1]);
            const newEye = newTarget.plusScaled(cameraView.getZVector(), focusDist);
            if (cameraView.lookAtUsingLensAngle(newEye, newTarget, cameraView.getYVector(), lensAngle, focusDist) !== 0 /* Success */)
                return;
        }
        else {
            vp.rotMatrix.multiplyVectorArrayInPlace(corners);
            const range = geometry_core_3.Range3d.createArray(corners);
            delta = geometry_core_1.Vector3d.createStartEnd(range.low, range.high);
            // get the view extents
            delta.z = vp.view.getExtents().z;
            // make sure its not too big or too small
            if (vp.view.validateViewDelta(delta, true) !== 0 /* Success */)
                return;
            vp.view.setExtents(delta);
            const originVec = vp.rotMatrix.multiplyTransposeXYZ(range.low.x, range.low.y, range.low.z);
            vp.view.setOrigin(geometry_core_1.Point3d.createFrom(originVec));
        }
        vp.synchWithView(true);
        vp.animateFrustumChange(startFrust, vp.getFrustum(), exports.ViewToolSettings.animationTime);
    }
    onSingleFingerMove(ev) { IModelApp_1.IModelApp.toolAdmin.convertGestureMoveToButtonDownAndMotion(ev); return true; }
    onEndGesture(ev) { IModelApp_1.IModelApp.toolAdmin.convertGestureEndToButtonUp(ev); return true; }
}
WindowAreaTool.toolId = "View.WindowArea";
exports.WindowAreaTool = WindowAreaTool;
/** tool that handles gestures */
class ViewGestureTool extends ViewManip {
    constructor(ev) {
        super(ev.viewport, 0, true, false, false);
        this.startInfo = new Tool_1.GestureInfo();
        this.numberTouches = 0;
        this.touches = [new geometry_core_1.Point2d(), new geometry_core_1.Point2d(), new geometry_core_1.Point2d()];
        this.centerNpc = new geometry_core_1.Point3d();
    }
    onDataButtonDown(_ev) { return false; }
    doGesture(transform) {
        const vp = this.viewport;
        const frustum = vp.getFrustum(1 /* Npc */, false, scratchFrustum);
        frustum.multiply(transform);
        vp.npcToWorldArray(frustum.points);
        if (!vp.setupViewFromFrustum(frustum))
            return false;
        const view = vp.view;
        if (view.is3d() && view.isCameraOn()) {
            view.centerEyePoint();
            vp.setupFromView();
        }
        this.doUpdate(true);
        return true;
    }
    endGesture() {
        this.clearTouchStopData();
        this.doUpdate(true);
        this.exitTool();
        return true;
    }
    clearTouchStopData() { this.numberTouches = 0; }
    saveTouchStopData(info) {
        this.numberTouches = info.numberTouches;
        for (let i = 0; i < this.numberTouches; ++i)
            this.touches[i].setFrom(info.touches[i]);
    }
    onStart(ev) {
        this.clearTouchStopData();
        this.startInfo.copyFrom(ev.gestureInfo);
    }
}
ViewGestureTool.toolId = ""; // gesture tools are never registered
exports.ViewGestureTool = ViewGestureTool;
class RotatePanZoomGestureTool extends ViewGestureTool {
    constructor(ev, allowRotate) {
        super(ev);
        this.allowRotate = allowRotate;
        this.allowZoom = true;
        this.rotatePrevented = false;
        this.doing2dRotation = false;
        this.rotateInitialized = false;
        this.ballVector0 = new geometry_core_1.Vector3d();
        this.lastPtView = new geometry_core_1.Point3d();
        this.startPtWorld = new geometry_core_1.Point3d();
        this.startPtView = new geometry_core_1.Point3d();
        this.startTime = 0;
        this.frustum = new imodeljs_common_1.Frustum();
        this.is2dRotateGestureLimit = 350; // milliseconds
        this.onStart(ev);
        this.handleEvent(ev);
    }
    is2dRotateGesture(ev) {
        if (!this.allowRotate || this.rotatePrevented)
            return false;
        if (this.doing2dRotation)
            return true;
        const vp = this.viewport;
        const view = vp.view;
        const info = ev.gestureInfo;
        if (view.allow3dManipulations() || info.numberTouches !== 2) {
            this.rotatePrevented = false;
            return false;
        }
        const startInfo = this.startInfo;
        const angleChange = Math.abs(this.getRotationFromStart(info).radians);
        const angularDistance = Math.abs(info.distance / 2.0 * Math.sin(angleChange));
        const zoomDistance = Math.abs(info.distance - startInfo.distance);
        const panDistance = startInfo.getViewPoint(vp).distance(info.getViewPoint(vp));
        if (angleChange > Math.PI / 10 || angularDistance > zoomDistance && angularDistance > panDistance * 0.75) {
            this.doing2dRotation = true;
            return true;
        }
        const timeDiff = Date.now() - this.startTime;
        this.rotatePrevented = timeDiff > this.is2dRotateGestureLimit;
        return false;
    }
    is3dRotateGesture(ev) {
        return this.allowRotate && (1 === ev.gestureInfo.numberTouches) && this.viewport.view.allow3dManipulations();
    }
    computeZoomRatio(info) {
        if (!this.allowZoom)
            return 1.0;
        let newDistance = info.distance;
        if (newDistance < 1.0)
            newDistance = 1.0;
        let startDistance = this.startInfo.distance;
        if (startDistance < 1.0)
            startDistance = 1.0;
        let zoomRatio = startDistance / newDistance;
        if (zoomRatio < 0.1)
            zoomRatio = 0.1;
        else if (zoomRatio > 10.0)
            zoomRatio = 10.0;
        if (info.numberTouches > 2 || (Math.abs(startDistance - newDistance) < this.viewport.pixelsFromInches(0.125)))
            zoomRatio = 1.0;
        return zoomRatio;
    }
    getRotationFromStart(info) {
        const currentTouches = info.touches;
        const startTouches = this.startInfo.touches;
        const startVec = new geometry_core_1.Vector2d(startTouches[1].x - startTouches[0].x, startTouches[1].y - startTouches[0].y);
        const currentVec = new geometry_core_1.Vector2d(currentTouches[1].x - currentTouches[0].x, currentTouches[1].y - currentTouches[0].y);
        return startVec.angleTo(currentVec);
    }
    handle2dRotate(ev) {
        const vp = this.viewport;
        //  All of the transforms and computation are relative to the original transform.
        if (!vp.setupViewFromFrustum(this.frustum))
            return true;
        const view = vp.view;
        const info = ev.gestureInfo;
        const currentTouches = info.touches;
        const startTouches = this.startInfo.touches;
        const startPt0 = vp.viewToWorld(new geometry_core_1.Point3d(startTouches[0].x, startTouches[0].y, 0));
        const currPt0 = vp.viewToWorld(new geometry_core_1.Point3d(currentTouches[0].x, currentTouches[0].y, 0));
        const diffWorld = startPt0.minus(currPt0);
        const translateTransform = geometry_core_2.Transform.createTranslation(diffWorld);
        const radians = this.getRotationFromStart(info);
        const matrix = geometry_core_2.RotMatrix.createRotationAroundVector(view.getZVector(), radians);
        const rotationTransform = geometry_core_2.Transform.createFixedPointAndMatrix(currPt0, matrix);
        let transform = translateTransform.multiplyTransformTransform(rotationTransform);
        const zoomRatio = this.computeZoomRatio(info);
        const scaleTransform = geometry_core_2.Transform.createScaleAboutPoint(startPt0, zoomRatio, scratchTransform1);
        transform = scaleTransform.multiplyTransformTransform(transform, scratchTransform2);
        const frust = this.frustum.transformBy(transform);
        vp.setupViewFromFrustum(frust);
        this.saveTouchStopData(info);
        this.doUpdate(true);
        this.lastPtView.setFrom(currPt0);
        return true;
    }
    handle3dRotate(ev) {
        if (this.lastPtView.isAlmostEqual(ev.viewPoint, 2.0))
            return true;
        const vp = this.viewport;
        const currPt = ev.viewPoint.clone();
        if (this.startPtView.isAlmostEqual(currPt, 2.0))
            currPt.setFrom(this.startPtView);
        this.lastPtView.setFrom(currPt);
        if (!vp.setupViewFromFrustum(this.frustum))
            return true;
        const viewRect = vp.viewRect;
        const xExtent = viewRect.width;
        const yExtent = viewRect.height;
        const xDelta = currPt.x - this.startPtView.x;
        const yDelta = currPt.y - this.startPtView.y;
        const xAxis = exports.ViewToolSettings.preserveWorldUp ? this.worldUpVector : vp.rotMatrix.getRow(1);
        const yAxis = vp.rotMatrix.getRow(0);
        const xRMatrix = (0.0 !== xDelta) ? geometry_core_2.RotMatrix.createRotationAroundVector(xAxis, geometry_core_4.Angle.createRadians(Math.PI / (xExtent / xDelta))) : geometry_core_2.RotMatrix.identity;
        const yRMatrix = (0.0 !== yDelta) ? geometry_core_2.RotMatrix.createRotationAroundVector(yAxis, geometry_core_4.Angle.createRadians(Math.PI / (yExtent / yDelta))) : geometry_core_2.RotMatrix.identity;
        const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);
        const worldTransform = geometry_core_2.Transform.createFixedPointAndMatrix(this.startPtWorld, worldRMatrix);
        const frustum = this.frustum.transformBy(worldTransform, scratchFrustum);
        if (!vp.setupViewFromFrustum(frustum))
            return true;
        this.saveTouchStopData(ev.gestureInfo);
        this.doUpdate(true);
        return true;
    }
    onStart(ev) {
        super.onStart(ev);
        const vp = this.viewport;
        vp.getWorldFrustum(this.frustum);
        this.doing2dRotation = this.rotatePrevented = false;
        this.startPtWorld.setFrom(ev.point);
        this.startPtView.setFrom(ev.viewPoint);
        this.synchViewBallInfo(this.rotateInitialized);
        this.rotateInitialized = true;
        this.viewPtToSpherePt(this.startPtView, true, this.ballVector0);
        if (vp.isCameraOn()) {
            const targetCenterView = vp.worldToView(this.targetCenterWorld);
            this.startPtView.z = targetCenterView.z;
            vp.viewToWorld(this.startPtView, this.startPtWorld);
        }
        this.lastPtView.setFrom(this.startPtView);
        this.startTime = Date.now();
        const pickPt = undefined; // TODO: NEEDS_WORK vp.pickDepthBuffer(ev.viewPoint);
        if (!pickPt)
            return;
        this.startPtWorld.setFrom(pickPt);
        vp.worldToView(this.startPtWorld, this.startPtView);
        this.lastPtView.setFrom(this.startPtView);
    }
    handleEvent(ev) {
        if (this.is3dRotateGesture(ev))
            return this.handle3dRotate(ev);
        if (this.is2dRotateGesture(ev))
            return this.handle2dRotate(ev);
        const vp = this.viewport;
        const info = ev.gestureInfo;
        const zoomRatio = this.computeZoomRatio(info);
        // reset frustum to original position
        if (!vp.setupViewFromFrustum(this.frustum))
            return true;
        const zoomCenter = geometry_core_1.Point3d.create();
        ev.getTargetPoint(zoomCenter);
        vp.zoom(zoomCenter, zoomRatio);
        this.saveTouchStopData(info);
        this.doUpdate(true);
        return true;
    }
    onMultiFingerMove(ev) {
        const info = ev.gestureInfo;
        if (info.numberTouches !== this.startInfo.numberTouches) {
            this.onStart(ev);
            return true;
        }
        return this.handleEvent(ev);
    }
    onSingleFingerMove(ev) { return this.onMultiFingerMove(ev); }
    onEndGesture(_ev) {
        this.clearTouchStopData();
        return this.endGesture();
    }
}
exports.RotatePanZoomGestureTool = RotatePanZoomGestureTool;
class ViewLookTool extends ViewManip {
    constructor(vp) {
        super(vp, 512 /* ViewLook */, true, false, true);
    }
}
ViewLookTool.toolId = "View.Look";
exports.ViewLookTool = ViewLookTool;
class ViewScrollTool extends ViewManip {
    constructor(vp) {
        super(vp, 8 /* ViewScroll */, true, false, true);
    }
}
ViewScrollTool.toolId = "View.Scroll";
exports.ViewScrollTool = ViewScrollTool;
class ViewUndoTool extends ViewTool {
    constructor(vp) { super(); this.viewport = vp; }
    onPostInstall() {
        super.onPostInstall();
        this.viewport.doUndo(exports.ViewToolSettings.animationTime);
    }
    onDataButtonDown(_ev) { return false; }
}
ViewUndoTool.toolId = "View.Undo";
exports.ViewUndoTool = ViewUndoTool;
class ViewRedoTool extends ViewTool {
    constructor(vp) { super(); this.viewport = vp; }
    onPostInstall() {
        super.onPostInstall();
        this.viewport.doRedo(exports.ViewToolSettings.animationTime);
    }
    onDataButtonDown(_ev) { return false; }
}
ViewRedoTool.toolId = "View.Redo";
exports.ViewRedoTool = ViewRedoTool;
class ViewToggleCameraTool extends ViewTool {
    constructor(viewport) { super(); this.viewport = viewport; this.isCameraOn = viewport.isCameraOn(); }
    onPostInstall() {
        // If we are in a 3d view, check if the camera is on or off, and then toggle it
        if (this.viewport) {
            if (this.viewport.view.is3d()) {
                if (this.isCameraOn) {
                    this.viewport.view.turnCameraOff();
                    // ### TODO: Make sure still works with caching undo
                    this.viewport.synchWithView(false);
                    this.isCameraOn = false;
                }
                else {
                    this.viewport.turnCameraOn();
                    // ## TODO: Make sure still works with caching undo
                    this.viewport.synchWithView(false);
                    this.isCameraOn = true;
                }
            }
        }
    }
    onDataButtonDown(_ev) { return false; }
}
ViewToggleCameraTool.toolId = "View.ToggleCamera";
exports.ViewToggleCameraTool = ViewToggleCameraTool;
// ###TODO: This tool is redundant and is currently only used for debug purposes in SVT. This should eventually be deleted, as
// users of imodeljs-core have the ability to set these flags from their app without the use of a tool.
class ViewChangeRenderModeTool extends ViewTool {
    constructor(viewport, renderOptionsMap, renderMenuDialog, mode) {
        super();
        this.viewport = viewport;
        this.renderOptions = renderOptionsMap;
        this.renderMenu = renderMenuDialog;
        this.renderMode = mode;
    }
    // We want changes to happen immediately when checking or unchecking an option
    onPostInstall() {
        const viewflags = imodeljs_common_1.ViewFlags.createFrom(this.viewport.viewFlags);
        viewflags.setRenderMode(this.renderMode);
        viewflags.setShowAcsTriad(this.renderOptions.get("ACSTriad"));
        viewflags.setShowFill(this.renderOptions.get("fill"));
        viewflags.setShowGrid(this.renderOptions.get("grid"));
        viewflags.setShowTextures(this.renderOptions.get("textures"));
        viewflags.setShowVisibleEdges(this.renderOptions.get("visibleEdges"));
        viewflags.setShowMaterials(this.renderOptions.get("materials"));
        viewflags.setMonochrome(this.renderOptions.get("monochrome"));
        viewflags.setShowConstructions(this.renderOptions.get("constructions"));
        viewflags.setShowTransparency(this.renderOptions.get("transparency"));
        viewflags.setShowHiddenEdges(this.renderOptions.get("hiddenEdges"));
        viewflags.setShowWeights(this.renderOptions.get("weights"));
        viewflags.setShowStyles(this.renderOptions.get("styles"));
        const lights = this.renderOptions.get("lights");
        viewflags.setShowSourceLights(lights);
        viewflags.setShowSolarLight(lights);
        viewflags.setShowCameraLights(lights);
        // Now handle environment
        if (this.viewport.view.is3d()) {
            const view = this.viewport.view;
            const displayStyle = view.getDisplayStyle3d();
            const env = displayStyle.getEnvironment();
            env.ground.display = this.renderOptions.get("groundplane"); // Changes directly within displaystyle
            env.sky.display = this.renderOptions.get("skybox"); // Changes directly within displaystyle
            displayStyle.setEnvironment(env);
        }
        this.viewport.view.viewFlags = viewflags;
        this.viewport.sync.invalidateController();
    }
    onDataButtonDown(_ev) {
        this.renderMenu.style.display = "none";
        this.exitTool();
        return true;
    }
}
ViewChangeRenderModeTool.toolId = "View.ChangeRenderMode";
exports.ViewChangeRenderModeTool = ViewChangeRenderModeTool;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
const HitDetail_1 = __webpack_require__(63);
const geometry_core_1 = __webpack_require__(1);
const Viewport_1 = __webpack_require__(44);
const IModelApp_1 = __webpack_require__(5);
const PrimitiveTool_1 = __webpack_require__(98);
class LocateOptions {
    constructor() {
        this.disableIModelFilter = false;
        this.allowDecorations = false;
        this.maxHits = 20;
        this.hitSource = 5 /* DataPoint */;
    }
    clone() {
        const other = new LocateOptions();
        other.disableIModelFilter = this.disableIModelFilter;
        other.allowDecorations = this.allowDecorations;
        other.maxHits = this.maxHits;
        other.hitSource = this.hitSource;
        return other;
    }
    init() { this.disableIModelFilter = false, this.allowDecorations = false; this.maxHits = 20; this.hitSource = 5 /* DataPoint */; }
}
exports.LocateOptions = LocateOptions;
class LocateResponse {
    constructor() {
        this.snapStatus = 0 /* Success */;
        this.explanation = "";
    }
}
exports.LocateResponse = LocateResponse;
class ElementPicker {
    constructor() {
        this.pickPointWorld = new geometry_core_1.Point3d();
    }
    empty() {
        this.pickPointWorld.setZero();
        this.viewport = undefined;
        if (this.hitList)
            this.hitList.empty();
        else
            this.hitList = new HitDetail_1.HitList();
    }
    /** return the HitList for the last Pick performed. Optionally allows the caller to take ownership of the list. */
    getHitList(takeOwnership) {
        const list = this.hitList;
        if (takeOwnership)
            this.hitList = undefined;
        return list;
    }
    getNextHit() {
        return this.hitList ? this.hitList.getNextHit() : undefined;
    }
    /** return a particular hit from the list of hits from the last time pickElements was called. */
    getHit(i) {
        return this.hitList ? this.hitList.getHit(i) : undefined;
    }
    resetCurrentHit() {
        if (this.hitList)
            this.hitList.resetCurrentHit();
    }
    getPixelPriority(pixel) {
        switch (pixel.type) {
            case 2 /* Surface */:
                return 2 /* Planar */ === pixel.planarity ? 4 /* PlanarSurface */ : 5 /* NonPlanarSurface */;
            case 3 /* Linear */:
                return 0 /* WireEdge */;
            case 4 /* Edge */:
                return 2 /* Planar */ === pixel.planarity ? 1 /* PlanarEdge */ : 2 /* NonPlanarEdge */;
            case 5 /* Silhouette */:
                return 3 /* SilhouetteEdge */;
            default:
                return 6 /* Unknown */;
        }
    }
    comparePixel(pixel1, pixel2, distXY1, distXY2) {
        const priority1 = this.getPixelPriority(pixel1);
        const priority2 = this.getPixelPriority(pixel2);
        if (priority1 < priority2)
            return -1;
        if (priority1 > priority2)
            return 1;
        if (distXY1 < distXY2)
            return -1;
        if (distXY1 > distXY2)
            return 1;
        if (pixel1.distanceFraction > pixel2.distanceFraction)
            return -1;
        if (pixel1.distanceFraction < pixel2.distanceFraction)
            return 1;
        return 0;
    }
    /** Generate a list of elements that are close to a given point. */
    doPick(vp, pickPointWorld, pickRadiusView, options) {
        if (this.hitList && this.hitList.length > 0 && vp === this.viewport && pickPointWorld.isAlmostEqual(this.pickPointWorld)) {
            this.hitList.resetCurrentHit();
            return this.hitList.length;
        }
        this.empty(); // empty the hit list
        this.viewport = vp;
        this.pickPointWorld.setFrom(pickPointWorld);
        const pickPointView = vp.worldToView(pickPointWorld);
        const testPointView = new geometry_core_1.Point2d(Math.floor(pickPointView.x + 0.5), Math.floor(pickPointView.y + 0.5));
        const pixelRadius = Math.floor(pickRadiusView + 0.5);
        const rect = new Viewport_1.ViewRect(testPointView.x - pixelRadius, testPointView.y - pixelRadius, testPointView.x + pixelRadius, testPointView.y + pixelRadius);
        const pixels = vp.readPixels(rect, 7 /* All */);
        if (undefined === pixels)
            return 0;
        const elmHits = new Map();
        const testPoint = geometry_core_1.Point2d.createZero();
        for (testPoint.x = testPointView.x - pixelRadius; testPoint.x <= testPointView.x + pixelRadius; ++testPoint.x) {
            for (testPoint.y = testPointView.y - pixelRadius; testPoint.y <= testPointView.y + pixelRadius; ++testPoint.y) {
                const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                if (undefined === pixel || undefined === pixel.elementId || !pixel.elementId.isValid())
                    continue; // no geometry at this location...
                const distXY = testPointView.distance(testPoint);
                if (distXY > pixelRadius)
                    continue; // ignore corners. it's a locate circle not square...
                const oldPoint = elmHits.get(pixel.elementId.toString());
                if (undefined !== oldPoint) {
                    if (this.comparePixel(pixel, pixels.getPixel(oldPoint.x, oldPoint.y), distXY, testPointView.distance(oldPoint)) < 0)
                        oldPoint.setFrom(testPoint); // new hit is better, update location...
                }
                else {
                    elmHits.set(pixel.elementId.toString(), testPoint.clone());
                }
            }
        }
        if (0 === elmHits.size)
            return 0;
        for (const elmPoint of elmHits.values()) {
            const pixel = pixels.getPixel(elmPoint.x, elmPoint.y);
            if (undefined === pixel || undefined === pixel.elementId)
                continue;
            const hitPointWorld = vp.getPixelDataWorldPoint(pixels, elmPoint.x, elmPoint.y);
            if (undefined === hitPointWorld)
                continue;
            const hit = new HitDetail_1.HitDetail(pickPointWorld, vp, options.hitSource, hitPointWorld, pixel.elementId.toString(), this.getPixelPriority(pixel), testPointView.distance(elmPoint), pixel.distanceFraction);
            this.hitList.addHit(hit);
            if (this.hitList.hits.length > options.maxHits)
                this.hitList.hits.length = options.maxHits; // truncate array...
        }
        return this.hitList.length;
    }
    testHit(hit, vp, pickPointWorld, pickRadiusView, options) {
        if (0 === this.doPick(vp, pickPointWorld, pickRadiusView, options))
            return false;
        for (let iHit = 0; iHit < this.hitList.length; ++iHit) {
            const thisHit = this.hitList.getHit(iHit);
            if (hit.isSameHit(thisHit))
                return true;
        }
        return false;
    }
}
exports.ElementPicker = ElementPicker;
class ElementLocateManager {
    constructor() {
        this.options = new LocateOptions();
        this.picker = new ElementPicker();
    }
    /** get the full message key for a locate failure  */
    static getFailureMessageKey(key) { return "LocateFailure." + key; }
    onInitialized() { }
    getApertureInches() { return 0.11; }
    getElementPicker() { return this.picker; }
    clear() { this.setCurrHit(undefined); }
    setHitList(list) { this.hitList = list; }
    setCurrHit(hit) { this.currHit = hit; }
    getNextHit() {
        return this.hitList ? this.hitList.getNextHit() : undefined;
    }
    /** return the current path from either the snapping logic or the pre-locating systems. */
    getPreLocatedHit() {
        // NOTE: Check AccuSnap first as Tentative is used to build intersect snap. For normal snaps when a Tentative is active there should be no AccuSnap.
        let preLocated = IModelApp_1.IModelApp.accuSnap.getHitAndList(this);
        if (!preLocated && !!(preLocated = IModelApp_1.IModelApp.tentativePoint.getHitAndList(this))) {
            const vp = preLocated.viewport;
            this.picker.empty(); // Get new hit list at hit point; want reset to cycle hits using adjusted point location...
            this.picker.doPick(vp, preLocated.getPoint(), (vp.pixelsFromInches(this.getApertureInches()) / 2.0) + 1.5, this.options);
            this.setHitList(this.picker.getHitList(true));
        }
        if (this.hitList)
            this.hitList.resetCurrentHit();
        return preLocated;
    }
    filterHit(hit, _action, out) {
        // Tools must opt-in to locate of transient geometry as it requires special treatment.
        if (!hit.isElementHit() && !this.options.allowDecorations) {
            out.reason = ElementLocateManager.getFailureMessageKey("Transient");
            return true;
        }
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (!(tool && tool instanceof PrimitiveTool_1.PrimitiveTool))
            return false;
        const retVal = !tool.onPostLocate(hit, out);
        if (retVal)
            out.reason = ElementLocateManager.getFailureMessageKey("ByCommand");
        return retVal;
    }
    initLocateOptions() { this.options.init(); }
    initToolLocate() {
        this.initLocateOptions();
        this.clear();
        this.getElementPicker().empty();
        IModelApp_1.IModelApp.tentativePoint.clear(true);
    }
    _doLocate(response, newSearch, testPoint, vp, filterHits) {
        if (!vp)
            return;
        // the "newSearch" flag indicates whether the caller wants us to conduct a new search at the testPoint, or just continue returning paths from the previous search.
        if (newSearch) {
            const hit = this.getPreLocatedHit();
            // if we're snapped to something, that path has the highest priority and becomes the active hit.
            if (hit) {
                if (!filterHits || !this.filterHit(hit, 0 /* Identify */, response))
                    return hit;
                response = new LocateResponse(); // we have the reason and explanation we want.
            }
            this.picker.empty();
            this.picker.doPick(vp, testPoint, (vp.pixelsFromInches(this.getApertureInches()) / 2.0) + 1.5, this.options);
            const hitList = this.picker.getHitList(true);
            this.setHitList(hitList);
        }
        let newHit;
        while (undefined !== (newHit = this.getNextHit())) {
            if (!filterHits || !this.filterHit(newHit, 0 /* Identify */, response))
                return newHit;
            response = new LocateResponse(); // we have the reason and explanation we want.
        }
        return undefined;
    }
    doLocate(response, newSearch, testPoint, view, filterHits = true) {
        response.reason = ElementLocateManager.getFailureMessageKey("NoElements");
        response.explanation = "";
        const hit = this._doLocate(response, newSearch, testPoint, view, filterHits);
        this.setCurrHit(hit);
        // if we found a hit, remove it from the list of remaining hits near the current search point.
        if (hit && this.hitList)
            this.hitList.removeHitsFrom(hit.sourceId);
        return hit;
    }
}
exports.ElementLocateManager = ElementLocateManager;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const IModelJsonSchema_1 = __webpack_require__(109);
const Tool_1 = __webpack_require__(15);
const ElementLocateManager_1 = __webpack_require__(78);
const Sprites_1 = __webpack_require__(97);
const HitDetail_1 = __webpack_require__(63);
const IModelApp_1 = __webpack_require__(5);
/** @hidden */
class AccuSnapToolState {
    constructor() {
        this.enabled = false;
        this.locate = false;
        this.suspended = 0;
    }
    setFrom(other) {
        this.enabled = other.enabled;
        this.locate = other.locate;
        this.suspended = other.suspended;
    }
    clone() { const val = new AccuSnapToolState(); val.setFrom(this); return val; }
}
exports.AccuSnapToolState = AccuSnapToolState;
class AccuSnapSettings {
    constructor() {
        this.hotDistanceFactor = 1.2;
        this.stickyFactor = 1.0;
        this.searchDistance = 2.0;
        this.showIcon = true;
        this.showHint = true;
        this.coordUpdate = false;
        this.hiliteColdHits = true;
        this.popupInfo = true;
        this.popupMode = false;
        this.enableFlag = true;
        this.popupDelay = 5; // delay before info balloon pops up - in 10th of a second
    }
}
/** AccuSnap is an aide for snapping to interesting points on elements as the cursor moves over them. */
class AccuSnap {
    constructor() {
        /** Views that need to be flashed */
        this.needFlash = new Set();
        /** Views that are already flashed */
        this.areFlashed = new Set();
        /** The "+" that indicates where the snap point is */
        this.cross = new Sprites_1.SpriteLocation();
        /** The icon that indicates what type of snap is active */
        this.icon = new Sprites_1.SpriteLocation();
        /** The icon that indicates an error */
        this.errorIcon = new Sprites_1.SpriteLocation();
        /** During snap creation: the snap to try */
        this.candidateSnapMode = 1 /* Nearest */;
        /** Number of times "suppress" has been called -- unlike suspend this is not automatically cleared by tools */
        this.suppressed = 0;
        /** Number of times "noMotion" has been called since last motion */
        this.noMotionCount = 0;
        /** Anchor point for infoWindow. window is cleared when cursor moves away from this point. */
        this.infoPt = new geometry_core_1.Point3d();
        /** Location of cursor when we last checked for motion */
        this.lastCursorPos = new geometry_core_1.Point2d();
        /** Accumulated distance (squared) the mouse has moved since we started checking for motion */
        this.totalMotionSq = 0;
        /** How much mouse movement constitutes a "move" (squared) */
        this.motionToleranceSq = 0;
        this.toolState = new AccuSnapToolState();
        this.defaultSettings = new AccuSnapSettings();
        this.settings = this.defaultSettings;
    }
    onInitialized() { }
    wantShowIcon() { return this.settings.showIcon; }
    wantShowHint() { return this.settings.showHint; }
    wantInfoBalloon() { return this.settings.popupInfo; }
    wantAutoInfoBalloon() { return this.settings.popupInfo && !this.settings.popupMode; }
    wantHiliteColdHits() { return this.settings.hiliteColdHits; }
    getStickyFactor() { return this.settings.stickyFactor; }
    doLocateTesting() { return this.isLocateEnabled(); }
    getSearchDistance() { return this.doLocateTesting() ? 1.0 : this.settings.searchDistance; }
    getHotDistanceInches() { return IModelApp_1.IModelApp.locateManager.getApertureInches() * this.settings.hotDistanceFactor; }
    isLocateEnabled() { return this.toolState.locate; }
    isFlashed(view) { return (this.areFlashed.has(view)); }
    needsFlash(view) { return (this.needFlash.has(view)); }
    setNeedsFlash(view) { this.needFlash.add(view); this.clearIsFlashed(view); view.invalidateDecorations(); }
    setIsFlashed(view) { this.areFlashed.add(view); }
    clearIsFlashed(view) { this.areFlashed.delete(view); }
    isSnapEnabled() { return this.toolState.enabled; }
    getUserEnabled() { return this.settings.enableFlag; }
    userWantsSnaps() { return this.getUserEnabled(); }
    static toSnapDetail(hit) { return (hit && hit.isSnapDetail()) ? hit : undefined; }
    getCurrSnapDetail() { return AccuSnap.toSnapDetail(this.currHit); }
    isHot() { const currSnap = this.getCurrSnapDetail(); return !currSnap ? false : currSnap.isHot(); }
    destroy() {
        this.currHit = undefined;
        this.aSnapHits = undefined;
    }
    doSnapping() { return this.isSnapEnabled() && this.userWantsSnaps() && !this.isSnapSuspended(); }
    isSnapSuspended() { return (0 !== this.suppressed || 0 !== this.toolState.suspended); }
    /**
     * Get the SnapMode that was used to generate the SnapDetail. Since getActiveSnapModes can return multiple SnapMode values, candidateSnapMode holds
     * the SnapMode that was chosen.
     */
    getSnapMode() { return this.candidateSnapMode; }
    /** Get the current snap divisor to use to use for SnapMode.NearestKeypoint.
     * A subclass of IModelApp can implement onStartup to return a subclass of AccuSnap that implements this method to provide a snap divisor ui component.
     */
    getKeypointDivisor() { return 2; }
    /** Get the current active SnapModes. SnapMode position determines priority, with the first entry being the highest. The SnapDetail will be returned for the first SnapMode that produces a hot snap.
     * A subclass of IModelApp can implement onStartup to return a subclass of AccuSnap that implements this method to provide a SnapMode ui component.
     */
    getActiveSnapModes() {
        const snaps = [];
        snaps.push(2 /* NearestKeypoint */);
        return snaps;
    }
    /** Can be used by a subclass of AccuSnap to implement a SnapMode override that applies only to the next point.
     * This method will be called whenever a new tool is installed and on a button event.
     */
    synchSnapMode() { }
    /**
     * Check to see whether its appropriate to generate an AccuSnap point, given the current user
     * and command settings, and whether a tentative point is currently active.
     */
    isActive() {
        // Unless we're snapping in intersect mode (to find extended intersections), skip if tentative point active...
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            if (!this.doSnapping())
                return false;
            const snaps = this.getActiveSnapModes();
            for (const snap of snaps) {
                if (snap === 64 /* Intersection */)
                    return true;
            }
            return false;
        }
        return this.doSnapping() || this.doLocateTesting();
    }
    initializeForCheckMotion() {
        this.lastCursorPos.setFrom(IModelApp_1.IModelApp.toolAdmin.currentInputState.lastMotion);
        this.totalMotionSq = 0;
        this.motionToleranceSq = IModelApp_1.IModelApp.toolAdmin.isCurrentInputSourceMouse() ? 1 : 20;
    }
    checkStopLocate() {
        const curPos = IModelApp_1.IModelApp.toolAdmin.currentInputState.lastMotion; //  Get the current cursor pos and compute the distance moved since last check.
        const dx = curPos.x - this.lastCursorPos.x;
        const dy = curPos.y - this.lastCursorPos.y;
        if (0 === dx && 0 === dy)
            return false;
        this.lastCursorPos.setFrom(curPos); //  Remember the new pos
        //  See if distance moved since we started checking is over the "move" threshold
        const dsq = dx * dx + dy * dy;
        this.totalMotionSq += dsq;
        return this.totalMotionSq > this.motionToleranceSq;
    }
    /** Clear any AccuSnap info on the screen and release any hit path references */
    clear() { this.setCurrHit(undefined); }
    setCurrHit(newHit) {
        const newSnap = AccuSnap.toSnapDetail(newHit);
        const currSnap = this.getCurrSnapDetail();
        const sameElem = (newHit && newHit.isSameHit(this.currHit));
        const sameHit = (sameElem && !newSnap);
        const sameSnap = (sameElem && newSnap && currSnap);
        const samePt = (sameHit || (sameSnap && newSnap.snapPoint.isAlmostEqual(currSnap.snapPoint)));
        const sameHot = (sameHit || (sameSnap && (this.isHot() === newSnap.isHot())));
        const sameBaseSnapMode = (!newSnap || !currSnap || newSnap.snapMode === currSnap.snapMode);
        const sameType = (sameHot && (!currSnap || (currSnap.getHitType() === newHit.getHitType())));
        // see if it is the same point on the same element, the hot flags are the same multiple snaps, and the snap modes are the same
        if (samePt && sameType && sameBaseSnapMode) {
            // we know that nothing about the screen could change, just save the new hit and return to avoid screen flash
            this.currHit = newHit;
            return;
        }
        this.erase();
        // if we hit the same element with the same "hotness" as last time, we don't need to erase it
        //  multiple snaps: but only if the old and new snap modes are the same
        if (!sameHot || !sameBaseSnapMode) {
            this.unFlashViews();
            this.setFlashHit(newHit);
        }
        // if we didn't get a new hit, we're done
        if (undefined === (this.currHit = newHit))
            return;
        // draw sprites for this hit
        this.showSnapSprite();
    }
    /**  flash a hit in a single view. */
    flashHitInView(hit, context) {
        const viewport = context.viewport;
        if (!viewport || !this.hitShouldBeHilited(hit) || !this.needsFlash(viewport))
            return;
        hit.draw(context);
        this.setIsFlashed(viewport);
    }
    setNeedsFlashView(view) {
        if (this.isFlashed(view) || this.needsFlash(view))
            return;
        this.setNeedsFlash(view);
    }
    /** flash a hit in its view. */
    setFlashHit(hit) {
        if (!hit || !this.hitShouldBeHilited(hit))
            return;
        this.setNeedsFlashView(hit.viewport);
    }
    erase() {
        this.clearInfoBalloon(undefined); // make sure there's no info balloon up.
        this.clearSprites(); // remove all sprites from the screen
    }
    showElemInfo(viewPt, vp, hit) {
        if (IModelApp_1.IModelApp.viewManager.doesHostHaveFocus())
            this.showLocateMessage(viewPt, vp, IModelApp_1.IModelApp.toolAdmin.getInfoString(hit, "\n"));
    }
    showLocateMessage(viewPt, vp, msg) {
        if (IModelApp_1.IModelApp.viewManager.doesHostHaveFocus())
            IModelApp_1.IModelApp.viewManager.showInfoWindow(viewPt, vp, msg);
    }
    displayInfoBalloon(viewPt, vp, uorPt) {
        // if the info balloon is already displayed, or if he doesn't want it, quit.
        if (IModelApp_1.IModelApp.viewManager.isInfoWindowUp() || !this.wantInfoBalloon())
            return;
        const accuSnapHit = this.currHit;
        const tpHit = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
        // if we don't have either an AccuSnap or a tentative point hit, quit.
        if (!accuSnapHit && !tpHit && !this.errorIcon.isActive)
            return;
        let timeout = this.settings.popupDelay;
        let theHit;
        // determine which type of hit and how long to wait, and the detail level
        if (tpHit) {
            // when the tentative button is first pressed, we pass nullptr for uorPt so that we show the info window immediately
            if (uorPt) {
                const aperture = (this.getStickyFactor() * vp.pixelsFromInches(IModelApp_1.IModelApp.locateManager.getApertureInches()) / 2.0) + 1.5;
                // see if he came back somewhere near the currently snapped element
                if (!IModelApp_1.IModelApp.locateManager.getElementPicker().testHit(tpHit, vp, uorPt, aperture, IModelApp_1.IModelApp.locateManager.options))
                    return;
                timeout = 3;
            }
            else {
                // if uorPt is nullptr, that means that we want to display the infoWindow immediately.
                timeout = 0;
            }
            theHit = tpHit;
        }
        else {
            if (!this.wantAutoInfoBalloon())
                return;
            theHit = accuSnapHit;
        }
        // have we waited long enough to show the balloon?
        if (this.noMotionCount < timeout) {
            return;
        }
        this.infoPt.setFrom(viewPt);
        // if we're currently showing an error, get the error message...otherwise display hit info...
        if (!this.errorIcon.isActive && theHit) {
            this.showElemInfo(viewPt, vp, theHit);
            return;
        }
        // If we have an error explanation...use it as is!
        if (this.explanation) {
            this.showLocateMessage(viewPt, vp, this.explanation);
            return;
        }
        // if we don't have an explanation yet, translate the error code.
        if (!this.errorKey)
            return;
        this.explanation = IModelApp_1.IModelApp.i18n.translate(this.errorKey);
        if (!this.explanation)
            return;
        // Get the "best" rejected hit to augment the error explanation with the hit info...
        if (!theHit)
            theHit = this.aSnapHits ? this.aSnapHits.hits[0] : undefined;
        this.showLocateMessage(viewPt, vp, this.explanation);
    }
    clearInfoBalloon(ev) {
        this.noMotionCount = 0;
        if (!IModelApp_1.IModelApp.viewManager.isInfoWindowUp())
            return;
        if (ev && (5 > ev.viewPoint.distanceXY(this.infoPt)))
            return;
        IModelApp_1.IModelApp.viewManager.clearInfoWindow();
    }
    /** For a given snap path, display the sprites to indicate its position on the screen and what snap mode it represents. */
    showSnapSprite() {
        const snap = this.getCurrSnapDetail();
        if (!snap)
            return;
        const crossPt = snap.snapPoint;
        const viewport = snap.viewport;
        const crossSprite = Sprites_1.IconSprites.getSprite(snap.isHot() ? "SnapCross" : "SnapUnfocused", viewport);
        if (!snap.isHot() && !this.wantShowHint())
            return;
        this.cross.activate(crossSprite, viewport, crossPt, 0);
        // user can say to skip display of the icon
        if (!this.wantShowIcon())
            return;
        const snapSprite = snap.sprite;
        if (snapSprite)
            this.icon.activate(snapSprite, viewport, AccuSnap.adjustIconLocation(viewport, crossPt, snapSprite.size), 0);
    }
    static adjustIconLocation(vp, input, iconSize) {
        const out = vp.worldToView(input);
        out.x += (iconSize.x / 3.0);
        out.y -= (iconSize.y * 1.3);
        return vp.viewToWorld(out, out);
    }
    /** try to indicate what's wrong with the current point (why we're not snapping). */
    showSnapError(status, ev) {
        this.errorIcon.deactivate();
        const vp = ev.viewport;
        let errorSprite;
        switch (status) {
            case 500 /* FilteredByUser */:
            case 600 /* FilteredByApp */:
                errorSprite = Sprites_1.IconSprites.getSprite("SnapAppFiltered", vp);
                break;
            case 700 /* FilteredByAppQuietly */:
                this.errorKey = undefined;
                break;
            case 300 /* NotSnappable */:
                errorSprite = Sprites_1.IconSprites.getSprite("SnapNotSnappable", vp);
                this.errorKey = ElementLocateManager_1.ElementLocateManager.getFailureMessageKey("NotSnappable");
                break;
            case 301 /* ModelNotSnappable */:
                errorSprite = Sprites_1.IconSprites.getSprite("SnapNotSnappable", vp);
                this.errorKey = ElementLocateManager_1.ElementLocateManager.getFailureMessageKey("ModelNotAllowed");
                break;
        }
        if (!errorSprite)
            return;
        const spriteSize = errorSprite.size;
        const pt = AccuSnap.adjustIconLocation(vp, ev.rawPoint, spriteSize);
        if (this.wantShowIcon())
            this.errorIcon.activate(errorSprite, vp, pt, 0);
    }
    clearSprites() {
        this.errorIcon.deactivate();
        this.cross.deactivate();
        this.icon.deactivate();
    }
    /** determine whether a hit should be hilited or not. */
    hitShouldBeHilited(hit) {
        if (!hit)
            return false;
        const snap = AccuSnap.toSnapDetail(hit);
        return !snap || snap.isHot() || this.wantHiliteColdHits();
    }
    unFlashViews() {
        this.needFlash.clear();
        this.areFlashed.forEach((vp) => {
            // eventHandlers.CallAllHandlers(UnFlashCaller(vp.get()));
            vp.setFlashed(undefined, 0.0);
        });
        this.areFlashed.clear();
    }
    adjustPointIfHot(pt, view) {
        const currSnap = this.getCurrSnapDetail();
        if (!currSnap || !currSnap.isHot() || view !== currSnap.viewport)
            return;
        pt.setFrom(currSnap.adjustedPoint);
    }
    onEnabledStateChange(isEnabled, wasEnabled) {
        if (isEnabled === wasEnabled) {
            IModelApp_1.IModelApp.toolAdmin.onAccuSnapSyncUI(); // still need to sync AccuSnap global setting even if we are not changing the actual state for the current tool.
            return;
        }
        if (isEnabled)
            IModelApp_1.IModelApp.toolAdmin.onAccuSnapEnabled();
        else
            IModelApp_1.IModelApp.toolAdmin.onAccuSnapDisabled();
    }
    getHitAndList(holder) {
        const hit = this.currHit;
        if (hit) {
            holder.setHitList(this.aSnapHits);
            this.aSnapHits = undefined;
        }
        return hit;
    }
    initCmdState() { this.toolState.suspended = 0; }
    suspend(doSuspend) {
        const previousDoSnapping = this.doSnapping();
        if (doSuspend)
            this.toolState.suspended++;
        else if (this.toolState.suspended > 0)
            this.toolState.suspended--;
        this.onEnabledStateChange(this.doSnapping(), previousDoSnapping);
    }
    suppress(doSuppress) {
        const previousDoSnapping = this.doSnapping();
        if (doSuppress)
            this.suppressed++;
        else if (this.suppressed > 0)
            this.suppressed--;
        this.onEnabledStateChange(this.doSnapping(), previousDoSnapping);
        return this.suppressed;
    }
    enableSnap(yesNo) {
        const previousDoSnapping = this.doSnapping();
        this.toolState.enabled = yesNo;
        if (!yesNo)
            this.clear();
        this.onEnabledStateChange(this.doSnapping(), previousDoSnapping);
    }
    getNextAccuSnappable(hitList) {
        const thisHit = hitList.getNextHit();
        if (thisHit)
            this.explanation = "";
        return thisHit;
    }
    async requestSnap(thisHit, snapMode, hotDistanceInches, out) {
        const result = await thisHit.viewport.iModel.requestSnap({
            id: thisHit.sourceId,
            closePoint: thisHit.hitPoint,
            worldToView: thisHit.viewport.worldToViewMap.transform0.toJSON(),
            viewFlags: thisHit.viewport.viewFlags,
            snapMode,
            snapAperture: thisHit.viewport.pixelsFromInches(hotDistanceInches),
            snapDivisor: this.getKeypointDivisor(),
        }); // ### TODO offSubCategories...
        if (out)
            out.snapStatus = result.status;
        if (result.status !== 0 /* Success */)
            return undefined;
        const snap = new HitDetail_1.SnapDetail(thisHit, snapMode, result.heat, result.snapPoint);
        snap.setCurvePrimitive(undefined !== result.curve ? IModelJsonSchema_1.IModelJson.Reader.parse(result.curve) : undefined, undefined !== result.localToWorld ? geometry_core_1.Transform.fromJSON(result.localToWorld) : undefined, result.geomType);
        if (undefined !== result.normal)
            snap.normal = geometry_core_1.Vector3d.fromJSON(result.normal);
        IModelApp_1.IModelApp.accuDraw.onSnap(snap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...
        return snap;
    }
    async getAccuSnapDetail(hitList, out) {
        let bestDist = 1e200;
        let bestSnap;
        let bestHit;
        const ignore = new ElementLocateManager_1.LocateResponse();
        for (let thisHit; undefined !== (thisHit = this.getNextAccuSnappable(hitList)); out = ignore) {
            // if there are multiple hits at the same dist, then find the best snap from all of them. Otherwise, the snap
            // from the first one is the one we want.
            if (bestHit && 0 !== hitList.compare(thisHit, bestHit))
                break;
            const thisSnap = await this.requestSnap(thisHit, this.getSnapMode(), this.getHotDistanceInches(), out);
            if (undefined === thisSnap)
                continue;
            // Pass the snap path instead of the hit path in case a filter modifies the path contents.
            let filtered = false;
            if (this.doLocateTesting())
                filtered = IModelApp_1.IModelApp.locateManager.filterHit(thisSnap, 1 /* AutoLocate */, out);
            const thisDist = thisSnap.hitPoint.distance(thisSnap.snapPoint);
            if (!filtered && !(bestSnap && (thisDist >= bestDist))) {
                bestHit = thisHit;
                bestSnap = thisSnap;
                bestDist = thisDist;
            }
            else if (filtered)
                out.snapStatus = 600 /* FilteredByApp */;
        }
        if (bestHit) {
            hitList.setCurrentHit(bestHit);
            return bestSnap;
        }
        return undefined;
    }
    findHits(ev, force = false) {
        // When using AccuSnap to locate elements, we have to start with the datapoint adjusted
        // for locks and not the raw point. Otherwise, when grid/unit lock are on, we locate elements by
        // points not on the grid. This causes them to be "pulled" off the grid when they are accepted. On
        // the other hand, when NOT locating, we need to use the raw point so we can snap to elements
        // away from the grid.
        const testPoint = this.isLocateEnabled() ? ev.point : ev.rawPoint;
        const vp = ev.viewport;
        const picker = IModelApp_1.IModelApp.locateManager.getElementPicker();
        const options = IModelApp_1.IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...
        // NOTE: Since TestHit will use the same HitSource as the input hit we only need to sets this for DoPick...
        options.hitSource = this.isSnapEnabled() ? 3 /* AccuSnap */ : 2 /* MotionLocate */;
        let aperture = (vp.pixelsFromInches(IModelApp_1.IModelApp.locateManager.getApertureInches()) / 2.0) + 1.5;
        this.initializeForCheckMotion();
        aperture *= this.getSearchDistance();
        if (0 === picker.doPick(vp, testPoint, aperture, options)) {
            this.aSnapHits = undefined; // Clear any previous hit list so reset won't cycle through hits cursor is no longer over, etc.
            return 2 /* NoElements */;
        }
        this.aSnapHits = picker.getHitList(true); // take ownership of the pickElem hit list.
        // see if we should keep the current hit
        const canBeSticky = !force && this.aSnapHits.length > 1 && this.currHit && (3 /* Intersection */ !== this.currHit.getHitType() && this.currHit.priority < 4 /* PlanarSurface */);
        if (canBeSticky) {
            for (let iHit = 1; iHit < this.aSnapHits.length; ++iHit) {
                const thisHit = this.aSnapHits.hits[iHit];
                if (!thisHit.isSameHit(this.currHit))
                    continue;
                this.aSnapHits.removeHit(iHit);
                this.aSnapHits.insertHit(0, thisHit);
                break;
            }
        }
        return 0 /* Success */;
    }
    /**
     * If AccuSnap is active, search under cursor for new hits and generate the best AccuSnap point from that list, if any.
     * @return the best hit.
     */
    async getNewSnapDetail(out, ev) {
        out.snapStatus = this.findHits(ev);
        return (0 /* Success */ !== out.snapStatus) ? undefined : this.getAccuSnapDetail(this.aSnapHits, out);
    }
    findLocatableHit(ev, newSearch, out) {
        out.snapStatus = 2 /* NoElements */;
        if (newSearch) {
            this.aSnapHits = undefined;
            // search for new hits, but if the cursor is still close to the current hit, don't throw away list.
            if (0 /* Success */ !== (out.snapStatus = this.findHits(ev)))
                return undefined;
        }
        else {
            if (!this.aSnapHits) {
                out.snapStatus = 2 /* NoElements */;
                return undefined;
            }
        }
        const thisList = this.aSnapHits;
        let thisHit;
        const ignore = new ElementLocateManager_1.LocateResponse();
        // keep looking through hits until we find one that is accu-snappable.
        while (undefined !== (thisHit = thisList.getNextHit())) {
            if (!IModelApp_1.IModelApp.locateManager.filterHit(thisHit, 1 /* AutoLocate */, out))
                return thisHit;
            // we only care about the status of the first hit.
            out = ignore;
        }
        // Reset current hit index to go back to first hit on next AccuSnap reset event...
        thisList.resetCurrentHit();
        return undefined;
    }
    /** When in auto-locate mode, advance to the next hit without searching again. */
    async resetButton() {
        let hit;
        const out = new ElementLocateManager_1.LocateResponse();
        out.snapStatus = 100 /* Disabled */;
        this.clearInfoBalloon(undefined);
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        if (this.doSnapping()) {
            // if we don't have any more candidate hits, get a new list at the current location
            if (!this.aSnapHits || (0 === this.aSnapHits.length)) {
                hit = await this.getNewSnapDetail(out, ev);
            }
            else {
                // drop the current hit from the list and then retest the list (without the dropped hit) to find the new "best" snap
                this.aSnapHits.removeCurrentHit();
                hit = await this.getAccuSnapDetail(this.aSnapHits, out);
            }
        }
        else if (this.doLocateTesting()) {
            hit = this.findLocatableHit(ev, false, out); // get next AccuSnap path (or undefined)
        }
        // set the current hit
        if (hit || this.currHit)
            this.setCurrHit(hit);
        // indicate errors
        this.showSnapError(out.snapStatus, ev);
        return out.snapStatus;
    }
    doIntersectSnap(_ev, _usingMultipleSnaps, _out) {
        // const hitList = this.aSnapHits;
        // const testHits: HitDetail[] = [];
        // const testPoint = this.isLocateEnabled() ? ev.point : ev.rawPoint;
        // let count = 0;
        // // if there's a tentative point, use it
        // const tpHit = Application.tentativePoint.getCurrSnap();
        // if (tpHit) {
        //   testHits[count++] = tpHit;
        //   // if the tentative snap is already an intersection, use both elements
        //   if (HitDetailType.Intersection === tpHit.getHitType() && (HitSource.TentativeSnap === tpHit.locateSource))
        //     testHits[count++] = ((IntersectDetail *) tpHit) -> GetSecondHit();
        // }
        // if (count < 2) {
        //   // multiple snaps: must repeat the locate logic each time, in case previous locate was done
        //   //                  by a non-intersection snap at a location far from here
        //   if (SnapStatus:: Success != FindHits(& hitList, ev, usingMultipleSnaps))
        //   return SnapStatus:: NoElements;
        //   hitList -> ResetCurrentHit();
        //   testHits[count++] = GetNextIntersectable(& status, hitList);
        // }
        // if (nullptr == testHits[0])
        //   return SnapStatus:: NoElements;
        // if (nullptr == testHits[1])
        //   testHits[1] = GetNextIntersectable(& status, hitList);
        // // test all possible intersections, finding the "best" one
        // HitList intsctList;
        // for (; testHits[1]; testHits[1] = GetNextIntersectable(& status, hitList)) {
        //   SnapDetailP thisIntsct = nullptr;
        //   if (SnapStatus:: Success == snapContext.IntersectDetails(& thisIntsct, testHits[0], testHits[1], testPoint, TentativePoint:: GetInstance().IsSnapped()))
        //   {
        //     intsctList.AddHit(thisIntsct, false, false);
        //     thisIntsct -> Release(); // ref count was incremented when we added to list
        //   }
        // }
        // * intsctSnap = (SnapDetailP) intsctList.GetHit(0);
        // if (nullptr != * intsctSnap) {
        //   (* intsctSnap) -> AddRef();
        //   return SnapStatus:: Success;
        // }
        // return SnapStatus:: NoSnapPossible;
        return undefined;
    }
    /* Choose one snap from the set of all active snaps. If the snapOverride is a simple
      snap like keypoint, then the set will contain a single snap and this choosing
      process just returns it. If the snapOverride is a multi-snap, then the set contains
      all of the point snaps that it represents. If the snapOverride is a constraint snap,
      then the set contains all of the point snaps that underlie it.
  
      Just consider the snaps in the set in the order given by the user and pick the
      first hot one. If none are hot, pick the one that's closest to the cursor.
  
      Exception: If snap point is not on the curve, then we ignore its hot-ness.
  
      Depending on element type, the center (centroid) and origin snap locations may not lie
      on on the target element. For lineString, shape, bspline, etc. center snap may not even be
      on a keypoint. To make them choose-able, AccuSnap makes them hot all of the time. As a result,
      if these snaps are first in the list, they may take precedence over all others. To combat
      this problem, we apply this exception.
  
      Note: Sometimes keypoint and intersection snaps can be crowded close together.
      There's nothing we can do about this here. The user may be able to choose one over the
      other by sneaking up from right or left. Otherwise, the first one in the list is chosen.
  */
    async getPreferredSnap(ev, out) {
        // Get the list of point snap modes to consider
        let snapModes;
        // Special case: If tentative point is active, then we can only do intersections.
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            snapModes = [];
            snapModes.push(64 /* Intersection */);
        }
        else {
            // The user's finger is likely to create unwanted AccuSnaps, so don't snap unless source is a mouse.
            if (IModelApp_1.IModelApp.toolAdmin.isCurrentInputSourceMouse())
                snapModes = this.getActiveSnapModes();
            else
                snapModes = [];
        }
        // Consider each point snap mode and find the preferred one.
        let preferred;
        let preferredDistance = 1.0e200;
        for (const snapMode of snapModes) {
            // Try to generate a snap for this snap mode and compare it with the others.
            this.candidateSnapMode = snapMode;
            const snap = (this.candidateSnapMode !== 64 /* Intersection */) ? await this.getNewSnapDetail(out, ev) : await this.doIntersectSnap(ev, snapModes.length > 1, out);
            if (1 /* Aborted */ === out.snapStatus)
                return undefined;
            if ((0 /* Success */ === out.snapStatus) && snap) {
                if (snap.isHot() && (8 /* Center */ === this.candidateSnapMode || 2 /* InRange */ === snap.heat)) {
                    preferred = snap;
                    break;
                }
                else {
                    const dist = snap.hitPoint.distance(snap.snapPoint);
                    if (dist < preferredDistance) {
                        // Snap is not hot, but it is the closest we've seen so far => prefer it and keep searching for a closer one or a hot one.
                        preferred = snap;
                        preferredDistance = dist;
                    }
                }
            }
        }
        if (!preferred) {
            out.snapStatus = 2 /* NoElements */;
            return undefined;
        }
        return preferred;
    }
    /** Find the best snap point according to the current cursor location */
    async onMotion(ev) {
        await ev.viewport.iModel.cancelSnap(); // if there is an outstanding snap, cancel it.
        const out = new ElementLocateManager_1.LocateResponse();
        out.snapStatus = 100 /* Disabled */;
        this.clearInfoBalloon(ev);
        let hit;
        if (this.isActive()) {
            if (this.doSnapping())
                hit = await this.getPreferredSnap(ev, out);
            else if (this.doLocateTesting())
                hit = this.findLocatableHit(ev, true, out);
        }
        // set the current hit and display the sprite (based on snap's KeypointType)
        if (hit || this.currHit)
            this.setCurrHit(hit);
        // indicate errors
        this.showSnapError(out.snapStatus, ev);
    }
    onMotionStopped(_ev) { }
    onNoMotion(ev) {
        this.noMotionCount++;
        // if (1 === this.noMotionCount)
        //   this.flashInOtherViews();
        this.displayInfoBalloon(ev.viewPoint, ev.viewport, ev.rawPoint);
    }
    flashElements(context) {
        const viewport = context.viewport;
        if (this.currHit) {
            if (this.needsFlash(viewport))
                this.flashHitInView(this.currHit, context);
            return;
        }
        const hit = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
        if (hit)
            hit.draw(context);
    }
    decorate(context) {
        this.flashElements(context);
        if (this.cross.isActive) {
            this.cross.decorate(context);
            this.icon.decorate(context);
        }
        this.errorIcon.decorate(context);
    }
    clearElemFromHitList(element) {
        if (this.aSnapHits)
            this.aSnapHits.removeHitsFrom(element);
    }
    clearIfElement(sourceId) {
        this.clearElemFromHitList(sourceId);
        const hit = this.currHit;
        if (hit && hit.sourceId === sourceId) {
            this.destroy();
        }
    }
    /** Enable locating elements. */
    enableLocate(yesNo) { this.toolState.locate = yesNo; }
    /** Called whenever a new [[Tool]] is started. */
    onStartTool() {
        this.initCmdState();
        this.enableSnap(false);
        this.enableLocate(false);
        IModelApp_1.IModelApp.tentativePoint.clear(true);
    }
    /**
     * Force AccuSnap to reevaluate the snap at the current cursor location.
     * This is useful of an application changes the snap mode and wants AccuSnap to choose it immediately, without
     * requiring the user to move the mouse.
     */
    reEvaluate() {
        if (this.getCurrSnapDetail()) {
            const ev = new Tool_1.BeButtonEvent();
            IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
            this.onMotion(ev);
        }
    }
}
exports.AccuSnap = AccuSnap;
class TentativeOrAccuSnap {
    static isHot() { return IModelApp_1.IModelApp.accuSnap.isHot() || IModelApp_1.IModelApp.tentativePoint.isSnapped(); }
    static getCurrentSnap(checkIsHot = true) {
        // Checking for a hot AccuSnap hit before checking tentative is probably necessary for extended intersections?
        if (IModelApp_1.IModelApp.accuSnap.isHot())
            return IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        if (IModelApp_1.IModelApp.tentativePoint.isSnapped())
            return IModelApp_1.IModelApp.tentativePoint.currSnap;
        return (checkIsHot ? undefined : IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail());
    }
    static getCurrentPoint() {
        if (IModelApp_1.IModelApp.accuSnap.isHot()) {
            const pathP = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
            if (pathP)
                return pathP.adjustedPoint;
        }
        return IModelApp_1.IModelApp.tentativePoint.getPoint();
    }
    static getCurrentView() {
        const snap = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        return snap ? snap.viewport : IModelApp_1.IModelApp.tentativePoint.viewport;
    }
}
exports.TentativeOrAccuSnap = TentativeOrAccuSnap;


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this.observers = {};
  }

  EventEmitter.prototype.on = function on(events, listener) {
    var _this = this;

    events.split(' ').forEach(function (event) {
      _this.observers[event] = _this.observers[event] || [];
      _this.observers[event].push(listener);
    });
  };

  EventEmitter.prototype.off = function off(event, listener) {
    var _this2 = this;

    if (!this.observers[event]) {
      return;
    }

    this.observers[event].forEach(function () {
      if (!listener) {
        delete _this2.observers[event];
      } else {
        var index = _this2.observers[event].indexOf(listener);
        if (index > -1) {
          _this2.observers[event].splice(index, 1);
        }
      }
    });
  };

  EventEmitter.prototype.emit = function emit(event) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (this.observers[event]) {
      var cloned = [].concat(this.observers[event]);
      cloned.forEach(function (observer) {
        observer.apply(undefined, args);
      });
    }

    if (this.observers['*']) {
      var _cloned = [].concat(this.observers['*']);
      _cloned.forEach(function (observer) {
        var _ref;

        observer.apply(observer, (_ref = [event]).concat.apply(_ref, args));
      });
    }
  };

  return EventEmitter;
}();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
class Matrix3 {
    constructor() {
        this.data = new Float32Array(3 * 3);
    }
    initIdentity() {
        this.setValues(1, 0, 0, 0, 1, 0, 0, 0, 1);
    }
    static fromIdentity(out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.initIdentity();
        return mat;
    }
    copyFrom(src) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] = src.data[i];
        }
    }
    clone(out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.copyFrom(this);
        return mat;
    }
    setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
        this.m20 = m20;
        this.m21 = m21;
        this.m22 = m22;
    }
    static fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22, out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22);
        return mat;
    }
    initFromRotMatrix(rot) {
        this.setValues(rot.at(0, 0), rot.at(0, 1), rot.at(0, 2), rot.at(1, 0), rot.at(1, 1), rot.at(1, 2), rot.at(2, 0), rot.at(2, 1), rot.at(2, 2));
    }
    static fromRotMatrix(rot, out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.initFromRotMatrix(rot);
        return mat;
    }
    toRotMatrix() {
        const data = this.data;
        return geometry_core_1.RotMatrix.createRowValues(data[0], data[3], data[6], data[1], data[4], data[7], data[2], data[5], data[8]);
    }
    swap(firstIndex, secondIndex) {
        bentleyjs_core_1.assert(firstIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex !== firstIndex);
        const tmp = this.data[firstIndex];
        this.data[firstIndex] = this.data[secondIndex];
        this.data[secondIndex] = tmp;
    }
    transpose() {
        this.swap(1, 3);
        this.swap(5, 7);
        this.swap(2, 6);
    }
    static fromTranspose(src, out) {
        const mat = src.clone(out);
        mat.transpose();
        return mat;
    }
    get(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    set(index, value) { bentleyjs_core_1.assert(index < this.data.length); this.data[index] = value; }
    at(row, col) { return this.get(col * 3 + row); }
    setAt(row, col, value) { this.set(col * 3 + row, value); }
    get m00() { return this.at(0, 0); }
    set m00(value) { this.setAt(0, 0, value); }
    get m01() { return this.at(0, 1); }
    set m01(value) { this.setAt(0, 1, value); }
    get m02() { return this.at(0, 2); }
    set m02(value) { this.setAt(0, 2, value); }
    get m10() { return this.at(1, 0); }
    set m10(value) { this.setAt(1, 0, value); }
    get m11() { return this.at(1, 1); }
    set m11(value) { this.setAt(1, 1, value); }
    get m12() { return this.at(1, 2); }
    set m12(value) { this.setAt(1, 2, value); }
    get m20() { return this.at(2, 0); }
    set m20(value) { this.setAt(2, 0, value); }
    get m21() { return this.at(2, 1); }
    set m21(value) { this.setAt(2, 1, value); }
    get m22() { return this.at(2, 2); }
    set m22(value) { this.setAt(2, 2, value); }
}
exports.Matrix3 = Matrix3;
class Matrix4 {
    constructor() {
        this.data = new Float32Array(4 * 4);
    }
    copyFrom(src) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] = src.data[i];
        }
    }
    clone(out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.copyFrom(this);
        return mat;
    }
    initIdentity() {
        this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    static fromIdentity(out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.initIdentity();
        return mat;
    }
    setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
        this.m13 = m13;
        this.m20 = m20;
        this.m21 = m21;
        this.m22 = m22;
        this.m23 = m23;
        this.m30 = m30;
        this.m31 = m31;
        this.m32 = m32;
        this.m33 = m33;
    }
    static fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
        return mat;
    }
    getRotation(out) {
        const rot = undefined !== out ? out : new Matrix3();
        rot.setValues(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);
        return rot;
    }
    initFromTransform(transform) {
        const mat = transform.matrix;
        const org = transform.origin;
        this.setValues(mat.at(0, 0), mat.at(0, 1), mat.at(0, 2), org.x, mat.at(1, 0), mat.at(1, 1), mat.at(1, 2), org.y, mat.at(2, 0), mat.at(2, 1), mat.at(2, 2), org.z, 0, 0, 0, 1);
    }
    static fromTransform(transform, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.initFromTransform(transform);
        return mat;
    }
    toTransform() {
        const data = this.data;
        bentleyjs_core_1.assert(0.0 === data[3] && 0.0 === data[7] && 0.0 === data[11] && 1.0 === data[15]);
        const origin = new geometry_core_1.Point3d(data[12], data[13], data[14]);
        const rotMat = geometry_core_1.RotMatrix.createIdentity();
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                rotMat.setAt(i, j, data[i + j * 4]);
        return geometry_core_1.Transform.createRefs(origin, rotMat);
    }
    initFromMatrix4d(mat) {
        this.setValues(mat.atIJ(0, 0), mat.atIJ(0, 1), mat.atIJ(0, 2), mat.atIJ(0, 3), mat.atIJ(1, 0), mat.atIJ(1, 1), mat.atIJ(1, 2), mat.atIJ(1, 3), mat.atIJ(2, 0), mat.atIJ(2, 1), mat.atIJ(2, 2), mat.atIJ(2, 3), mat.atIJ(3, 0), mat.atIJ(3, 1), mat.atIJ(3, 2), mat.atIJ(3, 3));
    }
    static fromMatrix4d(mat, out) {
        const result = undefined !== out ? out : new Matrix4();
        result.initFromMatrix4d(mat);
        return result;
    }
    toMatrix4d() {
        const data = this.data;
        return geometry_core_1.Matrix4d.createRowValues(data[0], data[4], data[8], data[12], data[1], data[5], data[9], data[13], data[2], data[6], data[10], data[14], data[3], data[7], data[11], data[15]);
    }
    lookAt(eye, center, up) {
        const f = normalizedDifference(center, eye);
        if (undefined === f) {
            return false;
        }
        const s = fromNormalizedCrossProduct(f, up);
        if (undefined === s) {
            return false;
        }
        const u = geometry_core_1.Vector3d.createCrossProduct(s.x, s.y, s.z, f.x, f.y, f.z);
        this.setValues(s.x, s.y, s.z, -s.dotProduct(eye), u.x, u.y, u.z, -u.dotProduct(eye), -f.x, -f.y, -f.z, f.dotProduct(eye), 0, 0, 0, 1);
        return true;
    }
    static fromLookAt(eye, center, up, out) {
        const mat = undefined !== out ? out : new Matrix4();
        return mat.lookAt(eye, center, up) ? mat : undefined;
    }
    // left, right, bottom, top, near, far
    frustum(l, r, b, t, n, f) {
        this.setValues((2 * n) / (r - l), 0, (r + l) / (r - l), 0, 0, (2 * n) / (t - b), (t + b) / (t - b), 0, 0, 0, -(f + n) / (f - n), -(2 * f * n) / (f - n), 0, 0, -1, 0);
    }
    static fromFrustum(l, r, b, t, n, f, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.frustum(l, r, b, t, n, f);
        return mat;
    }
    perspective(fovY, aspectRatio, nearZ, farZ) {
        const frustumHeight = Math.tan(fovY / 360 * Math.PI) * nearZ;
        const frustumWidth = frustumHeight * aspectRatio;
        this.frustum(-frustumWidth, frustumWidth, -frustumHeight, frustumHeight, nearZ, farZ);
    }
    static fromPerspective(fovY, aspectRatio, nearZ, farZ, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.perspective(fovY, aspectRatio, nearZ, farZ);
        return mat;
    }
    ortho(l, r, b, t, n, f) {
        this.setValues(2 / (r - l), 0, 0, -(r + l) / (r - l), 0, 2 / (t - b), 0, -(t + b) / (t - b), 0, 0, -2 / (f - n), -(f + n) / (f - n), 0, 0, 0, 1);
    }
    static fromOrtho(l, r, b, t, n, f, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.ortho(l, r, b, t, n, f);
        return mat;
    }
    invert() {
        const d = this.data;
        const d0 = d[0];
        const d1 = d[1];
        const d2 = d[2];
        const d3 = d[3];
        this.setValues(d[5] * d[10] * d[15] - d[5] * d[11] * d[14] - d[9] * d[6] * d[15] + d[9] * d[7] * d[14] + d[13] * d[6] * d[11] - d[13] * d[7] * d[10], -d[4] * d[10] * d[15] + d[4] * d[11] * d[14] + d[8] * d[6] * d[15] - d[8] * d[7] * d[14] - d[12] * d[6] * d[11] + d[12] * d[7] * d[10], d[4] * d[9] * d[15] - d[4] * d[11] * d[13] - d[8] * d[5] * d[15] + d[8] * d[7] * d[13] + d[12] * d[5] * d[11] - d[12] * d[7] * d[9], -d[4] * d[9] * d[14] + d[4] * d[10] * d[13] + d[8] * d[5] * d[14] - d[8] * d[6] * d[13] - d[12] * d[5] * d[10] + d[12] * d[6] * d[9], -d[1] * d[10] * d[15] + d[1] * d[11] * d[14] + d[9] * d[2] * d[15] - d[9] * d[3] * d[14] - d[13] * d[2] * d[11] + d[13] * d[3] * d[10], d[0] * d[10] * d[15] - d[0] * d[11] * d[14] - d[8] * d[2] * d[15] + d[8] * d[3] * d[14] + d[12] * d[2] * d[11] - d[12] * d[3] * d[10], -d[0] * d[9] * d[15] + d[0] * d[11] * d[13] + d[8] * d[1] * d[15] - d[8] * d[3] * d[13] - d[12] * d[1] * d[11] + d[12] * d[3] * d[9], d[0] * d[9] * d[14] - d[0] * d[10] * d[13] - d[8] * d[1] * d[14] + d[8] * d[2] * d[13] + d[12] * d[1] * d[10] - d[12] * d[2] * d[9], d[1] * d[6] * d[15] - d[1] * d[7] * d[14] - d[5] * d[2] * d[15] + d[5] * d[3] * d[14] + d[13] * d[2] * d[7] - d[13] * d[3] * d[6], -d[0] * d[6] * d[15] + d[0] * d[7] * d[14] + d[4] * d[2] * d[15] - d[4] * d[3] * d[14] - d[12] * d[2] * d[7] + d[12] * d[3] * d[6], d[0] * d[5] * d[15] - d[0] * d[7] * d[13] - d[4] * d[1] * d[15] + d[4] * d[3] * d[13] + d[12] * d[1] * d[7] - d[12] * d[3] * d[5], -d[0] * d[5] * d[14] + d[0] * d[6] * d[13] + d[4] * d[1] * d[14] - d[4] * d[2] * d[13] - d[12] * d[1] * d[6] + d[12] * d[2] * d[5], -d[1] * d[6] * d[11] + d[1] * d[7] * d[10] + d[5] * d[2] * d[11] - d[5] * d[3] * d[10] - d[9] * d[2] * d[7] + d[9] * d[3] * d[6], d[0] * d[6] * d[11] - d[0] * d[7] * d[10] - d[4] * d[2] * d[11] + d[4] * d[3] * d[10] + d[8] * d[2] * d[7] - d[8] * d[3] * d[6], -d[0] * d[5] * d[11] + d[0] * d[7] * d[9] + d[4] * d[1] * d[11] - d[4] * d[3] * d[9] - d[8] * d[1] * d[7] + d[8] * d[3] * d[5], d[0] * d[5] * d[10] - d[0] * d[6] * d[9] - d[4] * d[1] * d[10] + d[4] * d[2] * d[9] + d[8] * d[1] * d[6] - d[8] * d[2] * d[5]);
        const determinant = d0 * d[0] + d1 * d[4] + d2 * d[8] + d3 * d[12];
        if (0 === determinant) {
            this.initIdentity();
            return false;
        }
        this.multiplyByScalar(1 / determinant);
        return true;
    }
    static fromInverse(src, out) {
        const mat = src.clone(out);
        return mat.invert() ? mat : undefined;
    }
    swap(firstIndex, secondIndex) {
        bentleyjs_core_1.assert(firstIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex !== firstIndex);
        const tmp = this.data[firstIndex];
        this.data[firstIndex] = this.data[secondIndex];
        this.data[secondIndex] = tmp;
    }
    transpose() {
        this.swap(1, 4);
        this.swap(2, 8);
        this.swap(3, 12);
        this.swap(6, 9);
        this.swap(7, 13);
        this.swap(11, 14);
    }
    static fromTranspose(src, out) {
        const mat = src.clone(out);
        mat.transpose();
        return mat;
    }
    multiplyBy(other) {
        const a = this.data;
        const b = other.data;
        this.setValues(a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]);
    }
    static fromProduct(a, b, out) {
        const mat = a.clone(out);
        mat.multiplyBy(b);
        return mat;
    }
    multiplyByScalar(scalar) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] *= scalar;
        }
    }
    get(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    set(index, value) { bentleyjs_core_1.assert(index < this.data.length); this.data[index] = value; }
    at(row, col) { return this.get(col * 4 + row); }
    setAt(row, col, value) { this.set(col * 4 + row, value); }
    get m00() { return this.at(0, 0); }
    set m00(value) { this.setAt(0, 0, value); }
    get m01() { return this.at(0, 1); }
    set m01(value) { this.setAt(0, 1, value); }
    get m02() { return this.at(0, 2); }
    set m02(value) { this.setAt(0, 2, value); }
    get m03() { return this.at(0, 3); }
    set m03(value) { this.setAt(0, 3, value); }
    get m10() { return this.at(1, 0); }
    set m10(value) { this.setAt(1, 0, value); }
    get m11() { return this.at(1, 1); }
    set m11(value) { this.setAt(1, 1, value); }
    get m12() { return this.at(1, 2); }
    set m12(value) { this.setAt(1, 2, value); }
    get m13() { return this.at(1, 3); }
    set m13(value) { this.setAt(1, 3, value); }
    get m20() { return this.at(2, 0); }
    set m20(value) { this.setAt(2, 0, value); }
    get m21() { return this.at(2, 1); }
    set m21(value) { this.setAt(2, 1, value); }
    get m22() { return this.at(2, 2); }
    set m22(value) { this.setAt(2, 2, value); }
    get m23() { return this.at(2, 3); }
    set m23(value) { this.setAt(2, 3, value); }
    get m30() { return this.at(3, 0); }
    set m30(value) { this.setAt(3, 0, value); }
    get m31() { return this.at(3, 1); }
    set m31(value) { this.setAt(3, 1, value); }
    get m32() { return this.at(3, 2); }
    set m32(value) { this.setAt(3, 2, value); }
    get m33() { return this.at(3, 3); }
    set m33(value) { this.setAt(3, 3, value); }
}
exports.Matrix4 = Matrix4;
// missing Vector3d functions
function fromNormalizedCrossProduct(vec0, vec1) {
    return vec0.unitCrossProduct(vec1);
}
exports.fromNormalizedCrossProduct = fromNormalizedCrossProduct;
function normalizedDifference(target, origin) {
    return geometry_core_1.Vector3d.createStartEnd(origin, target).normalize();
}
exports.normalizedDifference = normalizedDifference;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
class RenderStateFlags {
    constructor(src) {
        this.cull = false;
        this.depthTest = false;
        this.blend = false;
        this.stencilTest = false;
        this.depthMask = true;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.cull = src.cull;
        this.depthTest = src.depthTest;
        this.blend = src.blend;
        this.stencilTest = src.stencilTest;
        this.depthMask = src.depthMask;
    }
    clone(result) {
        if (!result) {
            return new RenderStateFlags(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.cull === rhs.cull
            && this.depthTest === rhs.depthTest
            && this.blend === rhs.blend
            && this.stencilTest === rhs.stencilTest
            && this.depthMask === rhs.depthMask;
    }
    apply(previousFlags) {
        RenderStateFlags.enableOrDisable(this.cull, GL_1.GL.Capability.CullFace, previousFlags.cull);
        RenderStateFlags.enableOrDisable(this.depthTest, GL_1.GL.Capability.DepthTest, previousFlags.depthTest);
        RenderStateFlags.enableOrDisable(this.blend, GL_1.GL.Capability.Blend, previousFlags.blend);
        RenderStateFlags.enableOrDisable(this.stencilTest, GL_1.GL.Capability.StencilTest, previousFlags.stencilTest);
        if (previousFlags.depthMask !== this.depthMask) {
            System_1.System.instance.context.depthMask(this.depthMask);
        }
    }
    static enableOrDisable(currentFlag, value, previousFlag) {
        if (currentFlag !== previousFlag) {
            const gl = System_1.System.instance.context;
            if (currentFlag) {
                gl.enable(value);
            }
            else {
                gl.disable(value);
            }
        }
    }
}
exports.RenderStateFlags = RenderStateFlags;
class RenderStateBlend {
    constructor(src) {
        this.color = [0.0, 0.0, 0.0, 0.0];
        this.equationRgb = GL_1.GL.BlendEquation.Default;
        this.equationAlpha = GL_1.GL.BlendEquation.Default;
        this.functionSourceRgb = GL_1.GL.BlendFactor.DefaultSrc;
        this.functionSourceAlpha = GL_1.GL.BlendFactor.DefaultSrc;
        this.functionDestRgb = GL_1.GL.BlendFactor.DefaultDst;
        this.functionDestAlpha = GL_1.GL.BlendFactor.DefaultDst;
        if (src) {
            this.copyFrom(src);
        }
    }
    apply(previousBlend) {
        const gl = System_1.System.instance.context;
        if (previousBlend === undefined || !this.equalColors(previousBlend)) {
            gl.blendColor(this.color[0], this.color[1], this.color[2], this.color[3]);
        }
        if (previousBlend === undefined || previousBlend.equationRgb !== this.equationRgb || previousBlend.equationAlpha !== this.equationAlpha) {
            gl.blendEquationSeparate(this.equationRgb, this.equationAlpha);
        }
        if (previousBlend === undefined || previousBlend.functionSourceRgb !== this.functionSourceRgb || previousBlend.functionSourceAlpha !== this.functionSourceAlpha
            || previousBlend.functionDestRgb !== this.functionDestRgb || previousBlend.functionDestAlpha !== this.functionDestAlpha) {
            gl.blendFuncSeparate(this.functionSourceRgb, this.functionDestRgb, this.functionSourceAlpha, this.functionDestAlpha);
        }
    }
    copyFrom(src) {
        this.setColor(src.color);
        this.equationRgb = src.equationRgb;
        this.equationAlpha = src.equationAlpha;
        this.functionSourceRgb = src.functionSourceRgb;
        this.functionSourceAlpha = src.functionSourceAlpha;
        this.functionDestRgb = src.functionDestRgb;
        this.functionDestAlpha = src.functionDestAlpha;
    }
    clone(result) {
        if (!result) {
            return new RenderStateBlend(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.equalColors(rhs)
            && this.equationRgb === rhs.equationRgb
            && this.equationAlpha === rhs.equationAlpha
            && this.functionSourceRgb === rhs.functionSourceRgb
            && this.functionSourceAlpha === rhs.functionSourceAlpha
            && this.functionDestRgb === rhs.functionDestRgb
            && this.functionDestAlpha === rhs.functionDestAlpha;
    }
    equalColors(rhs) {
        return this.color[0] === rhs.color[0] &&
            this.color[1] === rhs.color[1] &&
            this.color[2] === rhs.color[2] &&
            this.color[3] === rhs.color[3];
    }
    setColor(color) {
        this.color[0] = color[0];
        this.color[1] = color[1];
        this.color[2] = color[2];
        this.color[3] = color[3];
    }
    setBlendFunc(src, dst) {
        this.setBlendFuncSeparate(src, src, dst, dst);
    }
    setBlendFuncSeparate(srcRgb, srcAlpha, dstRgb, dstAlpha) {
        this.functionSourceRgb = srcRgb;
        this.functionSourceAlpha = srcAlpha;
        this.functionDestRgb = dstRgb;
        this.functionDestAlpha = dstAlpha;
    }
}
exports.RenderStateBlend = RenderStateBlend;
/* Stenciling commented out for now since it is not used */
// export class RenderStateStencilOperation {
//   public fail: GL.StencilOperation = GL.StencilOperation.Default;
//   public zFail: GL.StencilOperation = GL.StencilOperation.Default;
//   public zPass: GL.StencilOperation = GL.StencilOperation.Default;
//   public constructor(src?: RenderStateStencilOperation) {
//     if (src) {
//       this.copyFrom(src);
//     }
//   }
//   public copyFrom(src: RenderStateStencilOperation): void {
//     this.fail = src.fail;
//     this.zFail = src.zFail;
//     this.zPass = src.zPass;
//   }
//   public clone(result?: RenderStateStencilOperation): RenderStateStencilOperation {
//     if (!result) {
//       return new RenderStateStencilOperation(this);
//     } else {
//       result.copyFrom(this);
//       return result;
//     }
//   }
//   public equals(rhs: RenderStateStencilOperation): boolean {
//     return this.fail === rhs.fail
//         && this.zFail === rhs.zFail
//         && this.zPass === rhs.zPass;
//   }
// }
// export class RenderStateStencil {
//   public frontFunction: GL.StencilFunction = GL.StencilFunction.Default;
//   public backFunction: GL.StencilFunction = GL.StencilFunction.Default;
//   public frontRef: number = 0;
//   public backRef: number = 0;
//   public frontMask: number = 0xFFFFFFFF;
//   public backMask: number = 0xFFFFFFFF;
//   public frontOperation: RenderStateStencilOperation = new RenderStateStencilOperation();
//   public backOperation: RenderStateStencilOperation = new RenderStateStencilOperation();
//   public constructor(src?: RenderStateStencil) {
//     if (src) {
//       this.copyFrom(src);
//     }
//   }
//   public apply(gl: WebGLRenderingContext, previousStencil?: RenderStateStencil): void {
//     if (previousStencil === undefined || previousStencil.frontFunction !== this.frontFunction || previousStencil.frontRef !== this.frontRef || previousStencil.frontMask !== this.frontMask) {
//       gl.stencilFuncSeparate(GL.CullFace.Front, this.frontFunction, this.frontRef, this.frontMask);
//     }
//     if (previousStencil === undefined || previousStencil.backFunction !== this.backFunction || previousStencil.backRef !== this.backRef || previousStencil.backMask !== this.backMask) {
//       gl.stencilFuncSeparate(GL.CullFace.Back, this.backFunction, this.backRef, this.backMask);
//     }
//     if (previousStencil === undefined || !previousStencil.frontOperation.equals(this.frontOperation)) {
//       gl.stencilOpSeparate(GL.CullFace.Front, this.frontOperation.fail, this.frontOperation.zFail, this.frontOperation.zPass);
//     }
//     if (previousStencil === undefined || !previousStencil.backOperation.equals(this.backOperation)) {
//       gl.stencilOpSeparate(GL.CullFace.Back, this.backOperation.fail, this.backOperation.zFail, this.backOperation.zPass);
//     }
//   }
//   public copyFrom(src: RenderStateStencil): void {
//     this.frontFunction = src.frontFunction;
//     this.backFunction = src.backFunction;
//     this.frontRef = src.frontRef;
//     this.backRef = src.backRef;
//     this.frontMask = src.frontMask;
//     this.backMask = src.backMask;
//     this.frontOperation.copyFrom(src.frontOperation);
//     this.backOperation.copyFrom(src.backOperation);
//   }
//   public clone(result?: RenderStateStencil): RenderStateStencil {
//     if (!result) {
//       return new RenderStateStencil(this);
//     } else {
//       result.copyFrom(this);
//       return result;
//     }
//   }
//   public equals(rhs: RenderStateStencil): boolean {
//     return this.frontFunction === rhs.frontFunction
//         && this.backFunction === rhs.backFunction
//         && this.frontRef === rhs.frontRef
//         && this.backRef === rhs.backRef
//         && this.frontMask === rhs.frontMask
//         && this.backMask === rhs.backMask
//         && this.frontOperation.equals(rhs.frontOperation)
//         && this.backOperation.equals(rhs.backOperation);
//   }
// }
/** Encapsulates the state of an OpenGL context.
 * to modify the context for a rendering operation, do *not* directly call
 * functions like glDepthMask(), glBlendFunc(), etc - otherwise such calls may adversely
 * affect subsequent rendering operations.
 * Instead, set up a RenderState as desired and invoke Target::ApplyRenderState() or
 * System::ApplyRenderState().
 * The context tracks the most-recently applied RenderState, allowing it to minimize
 * the number of GL state changes actually invoked, improving performance.
 */
class RenderState {
    constructor(src) {
        this.flags = new RenderStateFlags();
        this.blend = new RenderStateBlend();
        // public stencil: RenderStateStencil = new RenderStateStencil();
        this.frontFace = GL_1.GL.FrontFace.Default;
        this.cullFace = GL_1.GL.CullFace.Default;
        this.depthFunc = GL_1.GL.DepthFunc.Default;
        this.stencilMask = 0xFFFFFFFF;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.flags.copyFrom(src.flags);
        this.blend.copyFrom(src.blend);
        // this.stencil.copyFrom(src.stencil);
        this.frontFace = src.frontFace;
        this.cullFace = src.cullFace;
        this.depthFunc = src.depthFunc;
        this.stencilMask = src.stencilMask;
    }
    clone(result) {
        if (!result) {
            return new RenderState(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    set clockwiseFrontFace(clockwise) {
        this.frontFace = clockwise ? GL_1.GL.FrontFace.Clockwise : GL_1.GL.FrontFace.CounterClockwise;
    }
    equals(rhs) {
        return this.flags.equals(rhs.flags)
            && this.blend.equals(rhs.blend)
            // && this.stencil.equals(rhs.stencil)
            && this.frontFace === rhs.frontFace
            && this.cullFace === rhs.cullFace
            && this.depthFunc === rhs.depthFunc
            && this.stencilMask === rhs.stencilMask;
    }
    apply(prevState) {
        this.flags.apply(prevState.flags);
        if (this.flags.blend) {
            if (prevState.flags.blend)
                this.blend.apply(prevState.blend);
            else
                this.blend.apply();
        }
        if (this.flags.cull) {
            if (!prevState.flags.cull || prevState.cullFace !== this.cullFace) {
                System_1.System.instance.context.cullFace(this.cullFace);
            }
        }
        if (this.flags.depthTest) {
            if (!prevState.flags.depthTest || prevState.depthFunc !== this.depthFunc) {
                System_1.System.instance.context.depthFunc(this.depthFunc);
            }
        }
        /* Stenciling commented out for now since it is not used */
        // if (this.flags.stencilTest) {
        //   if (prevState.flags.stencilTest)
        //     this.stencil.apply(gl, prevState.stencil);
        //   else
        //     this.stencil.apply(gl);
        // }
        if (this.frontFace !== prevState.frontFace) {
            System_1.System.instance.context.frontFace(this.frontFace);
        }
        if (this.stencilMask !== prevState.stencilMask) {
            System_1.System.instance.context.stencilMask(this.stencilMask);
        }
    }
}
RenderState.defaults = new RenderState();
exports.RenderState = RenderState;
Object.freeze(RenderState.defaults);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const Texture_1 = __webpack_require__(19);
const RenderBuffer_1 = __webpack_require__(124);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
const debugPrint_1 = __webpack_require__(219);
class FrameBuffer {
    constructor(fbo, colorTextures, depthBuffer) {
        this._bindState = 0 /* Unbound */;
        this.colorTextures = [];
        this.colorAttachments = [];
        this._fbo = fbo;
        const gl = System_1.System.instance.context;
        this.bind(false);
        let i = 0;
        for (const colTex of colorTextures) {
            const attachmentEnum = gl.COLOR_ATTACHMENT0 + i;
            this.colorAttachments.push(attachmentEnum);
            this.colorTextures.push(colTex);
            const texHandle = colTex.getHandle();
            if (undefined !== texHandle)
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentEnum, gl.TEXTURE_2D, texHandle, 0);
            i++;
        }
        if (depthBuffer !== undefined) {
            this.depthBuffer = depthBuffer;
            const dbHandle = depthBuffer.getHandle();
            if (undefined !== dbHandle) {
                if (depthBuffer instanceof RenderBuffer_1.RenderBuffer) {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dbHandle);
                }
                else {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);
                }
            }
        }
        this.unbind();
    }
    get isDisposed() { return this._fbo === undefined; }
    get isValid() { return System_1.System.instance.context.FRAMEBUFFER_COMPLETE === this.checkStatus(); }
    get isBound() { return 1 /* Bound */ === this._bindState || 2 /* BoundWithAttachments */ === this._bindState; }
    get isSuspended() { return 3 /* Suspended */ === this._bindState; }
    getColor(ndx) {
        bentleyjs_core_1.assert(ndx < this.colorTextures.length);
        return this.colorTextures[ndx];
    }
    static create(colorTextures, depthBuffer) {
        const fbo = System_1.System.instance.context.createFramebuffer();
        if (null === fbo) {
            return undefined;
        }
        return new FrameBuffer(fbo, colorTextures, depthBuffer);
    }
    dispose() {
        // NB: The FrameBuffer does not *own* the textures and depth buffer.
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteFramebuffer(this._fbo);
            this._fbo = undefined;
        }
    }
    getDebugAttachmentsString() {
        let str = "[";
        for (const tx of this.colorTextures)
            str += " " + tx.getHandle()._debugId;
        return str + " ]";
    }
    bind(bindAttachments = false) {
        bentleyjs_core_1.assert(undefined !== this._fbo);
        bentleyjs_core_1.assert(!this.isBound);
        if (undefined === this._fbo)
            return false;
        const gl = System_1.System.instance.context;
        gl.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, this._fbo);
        if (bindAttachments) {
            System_1.System.instance.setDrawBuffers(this.colorAttachments);
            this._bindState = 2 /* BoundWithAttachments */;
            if (Texture_1.TextureHandle.wantDebugIds)
                debugPrint_1.debugPrint("Bound attachments " + this.getDebugAttachmentsString());
        }
        else {
            this._bindState = 1 /* Bound */;
        }
        return true;
    }
    unbind() {
        bentleyjs_core_1.assert(this.isBound);
        System_1.System.instance.context.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, null);
        this._bindState = 0 /* Unbound */;
        if (Texture_1.TextureHandle.wantDebugIds)
            debugPrint_1.debugPrint("Unbound attachments " + this.getDebugAttachmentsString());
    }
    suspend() { bentleyjs_core_1.assert(this.isBound); this._bindState = 3 /* Suspended */; }
    checkStatus() {
        const status = System_1.System.instance.context.checkFramebufferStatus(GL_1.GL.FrameBuffer.TARGET);
        return status;
    }
    // Chiefly for debugging currently - assumes RGBA, unsigned byte, want all pixels.
    get debugPixels() {
        if (!this.isBound || 0 === this.colorTextures.length)
            return undefined;
        const tex = this.colorTextures[0];
        if (GL_1.GL.Texture.Format.Rgba !== tex.format || GL_1.GL.Texture.DataType.UnsignedByte !== tex.dataType)
            return undefined;
        const buffer = new Uint8Array(tex.width * tex.height * 4);
        for (let i = 0; i < buffer.length; i += 4) {
            buffer[i] = 0xba;
            buffer[i + 1] = 0xad;
            buffer[i + 2] = 0xf0;
            buffer[i + 3] = 0x0d;
        }
        System_1.System.instance.context.readPixels(0, 0, tex.width, tex.height, tex.format, tex.dataType, buffer);
        return buffer;
    }
}
exports.FrameBuffer = FrameBuffer;
class FrameBufferStack {
    constructor() {
        // FrameBuffers within this array are not owned, as this is only a storage device holding references
        this._stack = [];
    }
    get top() { return !this.isEmpty ? this._stack[this._stack.length - 1] : undefined; }
    push(fbo, withAttachments) {
        if (undefined !== this.top) {
            this.top.fbo.suspend();
        }
        bentleyjs_core_1.assert(!fbo.isBound);
        fbo.bind(withAttachments);
        bentleyjs_core_1.assert(fbo.isBound);
        this._stack.push({ fbo, withAttachments });
    }
    pop() {
        bentleyjs_core_1.assert(!this.isEmpty);
        if (undefined === this.top) {
            return;
        }
        const fbo = this.top.fbo;
        this._stack.pop();
        bentleyjs_core_1.assert(fbo.isBound);
        fbo.unbind();
        bentleyjs_core_1.assert(!fbo.isBound);
        if (this.isEmpty) {
            System_1.System.instance.context.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, null);
        }
        else {
            const top = this.top;
            bentleyjs_core_1.assert(top.fbo.isSuspended);
            top.fbo.bind(top.withAttachments);
            bentleyjs_core_1.assert(top.fbo.isBound);
        }
    }
    get currentColorBuffer() {
        bentleyjs_core_1.assert(!this.isEmpty);
        return undefined !== this.top ? this.top.fbo.getColor(0) : undefined;
    }
    get isEmpty() { return 0 === this._stack.length; }
    execute(fbo, withAttachments, func) {
        this.push(fbo, withAttachments);
        func();
        this.pop();
    }
}
exports.FrameBufferStack = FrameBufferStack;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
 |  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(30);
// Positions are in NDC [-1..1]. Compute UV params in [0..1]
const computeTexCoord = "v_texCoord = (rawPosition.xy + 1.0) * 0.5;";
const computePosition = "return rawPos;";
function addTexture(prog) {
    prog.addInlineComputedVarying("v_texCoord", 4 /* Vec2 */, computeTexCoord);
}
function createViewportQuadBuilder(textured) {
    const prog = new ShaderBuilder_1.ProgramBuilder(false);
    prog.vert.set(3 /* ComputePosition */, computePosition);
    if (textured) {
        addTexture(prog);
    }
    return prog;
}
exports.createViewportQuadBuilder = createViewportQuadBuilder;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/** GLSLDecode */
var GLSLDecode;
(function (GLSLDecode) {
    GLSLDecode.uint16 = `
float decodeUInt16(vec2 v) {
  v = v * vec2(1.0, 256.0); // v.y <<= 8
  return dot(v, vec2(1.0)); // v.x+v.y => v.x | v.y
}
`;
    GLSLDecode.uint32 = `
float decodeUInt32(vec3 v) {
  v = v * vec3(1.0, 256.0, 256.0*256.0); // v.y <<= 8; v.z <<= 16
  return dot(v, vec3(1.0)); // v.x+v.y+v.z => v.x | v.y | v.z
}
`;
    GLSLDecode.unquantize3d = `
vec3 unquantize3d(vec3 qpos, vec3 origin, vec3 scale) { return origin + scale * qpos; }
`;
    GLSLDecode.unquantize2d = `
// params.xy = origin. params.zw = scale.
vec2 unquantize2d(vec2 qpos, vec4 params) { return params.xy + params.zw * qpos; }
`;
    GLSLDecode.depthRgb = `
float decodeDepthRgb(vec3 rgb) { return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0)); }
`;
    GLSLDecode.encodeDepthRgb = `
vec3 encodeDepthRgb(float depth) {
  // 1.0 must be reduced slightly; otherwise decoding will produce zero. It's the far plane, so we don't care (and decoding produces 1.0 anyway).
  depth = min(depth, 16777215.0/16777216.0);

  vec3 enc = vec3(1.0, 255.0, 65025.0) * depth;
  enc = fract(enc);
  enc.xy -= enc.yz / 255.0;
  return enc;
}
`;
})(GLSLDecode = exports.GLSLDecode || (exports.GLSLDecode = {}));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(24);
const FloatRGBA_1 = __webpack_require__(35);
const Vertex_1 = __webpack_require__(20);
const Fragment_1 = __webpack_require__(25);
const Common_1 = __webpack_require__(45);
const Decode_1 = __webpack_require__(85);
const LookupTable_1 = __webpack_require__(230);
const FeatureDimensions_1 = __webpack_require__(100);
const bentleyjs_core_1 = __webpack_require__(0);
const RenderPass_1 = __webpack_require__(129);
const System_1 = __webpack_require__(7);
function addFlagConstants(builder) {
    // NB: These are the bit positions of each flag in OvrFlags enum - not the flag values
    builder.addConstant("kOvrBit_Visibility", 3 /* Float */, "0.0");
    builder.addConstant("kOvrBit_Rgb", 3 /* Float */, "1.0");
    builder.addConstant("kOvrBit_Alpha", 3 /* Float */, "2.0");
    builder.addConstant("kOvrBit_Weight", 3 /* Float */, "3.0");
    builder.addConstant("kOvrBit_Flashed", 3 /* Float */, "4.0");
    builder.addConstant("kOvrBit_Hilited", 3 /* Float */, "5.0");
    builder.addConstant("kOvrBit_LineCode", 3 /* Float */, "6.0");
    builder.addConstant("kOvrBit_IgnoreMaterial", 3 /* Float */, "7.0");
}
function addDimensionConstants(shader) {
    shader.addConstant("kFeatureDimension_Empty", 3 /* Float */, "0.0");
    shader.addConstant("kFeatureDimension_SingleUniform", 3 /* Float */, "1.0");
    shader.addConstant("kFeatureDimension_SingleNonUniform", 3 /* Float */, "2.0");
    shader.addConstant("kFeatureDimension_Multiple", 3 /* Float */, "3.0");
}
const getFeatureIndex = `
float getFeatureIndex() {
  if (u_featureInfo.x <= kFeatureDimension_SingleNonUniform)
      return u_featureInfo.y;

  vec2 tc = g_featureIndexCoords;
  vec4 enc = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  return decodeUInt32(enc.xyz);
}
`;
// Returns 1.0 if the specified flag is not globally overridden and is set in flags
const extractNthLinearFeatureBit = `
float extractNthFeatureBit(float flags, float n) {
  return 0.0 == extractNthBit(u_globalOvrFlags, n) ? extractNthBit(flags, n) : 0.0;
}
`;
const extractNthSurfaceFeatureBit = `
float extractNthFeatureBit(float flags, float n) {
  return extractNthBit(flags, n);
}
`;
const computeFeatureTextureCoords = `
vec2 computeFeatureTextureCoords() { return compute_feature_coords(getFeatureIndex()); }
`;
const getFirstFeatureRgba = `
vec4 getFirstFeatureRgba() {
  if (u_featureInfo.x <= kFeatureDimension_SingleUniform)
    return u_featureOverrides1;

  feature_texCoord = computeFeatureTextureCoords();
  return TEXTURE(u_featureLUT, feature_texCoord);
}
`;
const getSecondFeatureRgba = `
vec4 getSecondFeatureRgba() {
  if (u_featureInfo.x <= kFeatureDimension_SingleUniform)
    return u_featureOverrides2;

  vec2 coord = feature_texCoord;
  coord.x += g_feature_stepX;
  return TEXTURE(u_featureLUT, coord);
}
`;
const computeLineWeight = `
float ComputeLineWeight() {
  return 1.0 == linear_feature_overrides.x ? linear_feature_overrides.y : u_lineWeight;
}
`;
const computeLineCode = `
float ComputeLineCode() {
  return 1.0 == linear_feature_overrides.z ? linear_feature_overrides.w : u_lineCode;
}
`;
function addFeatureIndex(vert) {
    addDimensionConstants(vert);
    vert.addUniform("u_featureInfo", 4 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_featureInfo", (uniform, params) => {
            let dims = 0 /* Empty */;
            const value = [0, 0];
            const features = params.geometry.featuresInfo;
            const featureIndexType = undefined !== features ? features.type : 0 /* Empty */;
            if (1 /* Uniform */ === featureIndexType)
                value[1] = features.uniform;
            const ovrs = params.target.currentOverrides;
            if (undefined !== ovrs) {
                if (params.target.areDecorationOverridesActive)
                    dims = FeatureDimensions_1.computeFeatureDimension(0 /* Uniform */, 1 /* Uniform */);
                else
                    dims = FeatureDimensions_1.computeFeatureDimension(ovrs.dimension, featureIndexType);
            }
            else {
                const pickTable = params.target.currentPickTable;
                if (undefined !== pickTable)
                    dims = FeatureDimensions_1.computeFeatureDimension(undefined !== pickTable.nonUniform ? 1 /* NonUniform */ : 0 /* Uniform */, featureIndexType);
            }
            value[0] = dims;
            uniform.setUniform2fv(value);
        });
    });
    vert.addFunction(getFeatureIndex);
}
// Discards vertex if feature is invisible; or rendering opaque during translucent pass or vice-versa
// (The latter occurs when some translucent feature is overridden to be opaque, or vice-versa)
const checkVertexDiscard = `
  if (feature_invisible)
    return true;

  bool hasAlpha = 1.0 == u_hasAlpha;
  if (v_feature_alpha_flashed.y > 0.0) {
    const float s_minTransparency = 15.0; // NB: See DisplayParams.getMinTransparency() - this must match!
    const float s_maxAlpha = (255.0 - s_minTransparency) / 255.0;
    hasAlpha = v_feature_alpha_flashed.x < s_maxAlpha;
  }

  bool isOpaquePass = (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);
  bool isTranslucentPass = kRenderPass_Translucent == u_renderPass;
  return (isOpaquePass && hasAlpha) || (isTranslucentPass && !hasAlpha);
`;
function addCommon(builder, mode, opts) {
    if (0 /* None */ === mode)
        return false;
    const vert = builder.vert;
    addFeatureIndex(vert);
    if (0 /* None */ === (opts & 4 /* HasOverrides */))
        return true;
    const wantWeight = 0 /* None */ !== (opts & 1 /* Weight */);
    const wantLineCode = 0 /* None */ !== (opts & 2 /* LineCode */);
    const wantColor = 0 /* None */ !== (opts & 8 /* Color */);
    vert.addGlobal("feature_invisible", 0 /* Boolean */, "false");
    vert.addFunction(Common_1.GLSLCommon.extractNthBit);
    addFlagConstants(vert);
    vert.addGlobal("linear_feature_overrides", 6 /* Vec4 */, "vec4(0.0)");
    vert.addGlobal("feature_ignore_material", 0 /* Boolean */, "false");
    if (wantWeight || wantLineCode) {
        vert.addFunction(extractNthLinearFeatureBit);
        if (wantLineCode)
            vert.replaceFunction(Vertex_1.GLSLVertex.computeLineCode, computeLineCode);
        if (wantWeight) {
            vert.replaceFunction(Vertex_1.GLSLVertex.computeLineWeight, computeLineWeight);
            vert.addUniform("u_globalOvrFlags", 3 /* Float */, (prog) => {
                prog.addGraphicUniform("u_globalOvrFlags", (uniform, params) => {
                    let flags = 0.0;
                    if (params.geometry.isEdge) {
                        const edgeOvrs = params.target.getEdgeOverrides(params.renderPass);
                        if (undefined !== edgeOvrs)
                            flags = edgeOvrs.computeOvrFlags();
                    }
                    uniform.setUniform1f(flags);
                });
            });
        }
    }
    else {
        vert.addFunction(extractNthSurfaceFeatureBit);
    }
    LookupTable_1.addLookupTable(vert, "feature", "2.0");
    vert.addGlobal("feature_texCoord", 4 /* Vec2 */);
    vert.addFunction(computeFeatureTextureCoords);
    vert.addFunction(getFirstFeatureRgba);
    vert.addUniform("u_featureLUT", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_featureLUT", (uniform, params) => {
            const ovr = params.target.currentOverrides;
            bentleyjs_core_1.assert(undefined !== ovr);
            if (ovr.isNonUniform)
                ovr.lut.bindSampler(uniform, RenderFlags_1.TextureUnit.FeatureSymbology);
        });
    });
    vert.addUniform("u_featureParams", 4 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_featureParams", (uniform, params) => {
            const ovr = params.target.currentOverrides;
            if (ovr.isNonUniform)
                uniform.setUniform2fv([ovr.lut.width, ovr.lut.height]);
        });
    });
    vert.addUniform("u_featureOverrides1", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_featureOverrides1", (uniform, params) => {
            const ovr = params.target.currentOverrides;
            if (ovr.isUniform)
                uniform.setUniform4fv(ovr.uniform1);
        });
    });
    if (wantColor) {
        vert.addFunction(getSecondFeatureRgba);
        Vertex_1.addAlpha(vert);
        vert.addUniform("u_featureOverrides2", 6 /* Vec4 */, (prog) => {
            prog.addGraphicUniform("u_featureOverrides2", (uniform, params) => {
                const ovr = params.target.currentOverrides;
                if (ovr.isUniform)
                    uniform.setUniform4fv(ovr.uniform2);
            });
        });
        vert.set(2 /* CheckForDiscard */, checkVertexDiscard);
    }
    return true;
}
function addHiliteSettings(frag) {
    frag.addUniform("u_hilite_color", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_hilite_color", (uniform, params) => {
            const vf = params.target.currentViewFlags;
            const useLighting = 6 /* SmoothShade */ === vf.renderMode && params.geometry.isLitSurface &&
                (vf.showSourceLights() || vf.showCameraLights() || vf.showSolarLight());
            const transparency = useLighting ? 0 : 255;
            const hiliteColor = FloatRGBA_1.FloatRgba.fromColorDef(params.target.hiliteSettings.color, transparency);
            hiliteColor.bind(uniform);
        });
    });
    frag.addUniform("u_hilite_settings", 5 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_hilite_settings", (uniform, params) => {
            const hilite = params.target.hiliteSettings;
            let silhouette = 2.0;
            switch (hilite.silhouette) {
                case 0 /* None */:
                    silhouette = 0.0;
                    break;
                case 1 /* Thin */:
                    silhouette = 1.0;
                    break;
            }
            // During the normal pass (with depth testing), we mix the hilite color with the element color.
            // During the compositing pass, we mix the hilite color with the fragment color.
            // We have no idea if we're hiliting an occluded or visible portion of the hilited element.
            const hidden = hilite.hiddenRatio;
            const visible = Math.max(0, hilite.visibleRatio - hidden);
            uniform.setUniform3fv([visible, hidden, silhouette]);
        });
    });
}
exports.addHiliteSettings = addHiliteSettings;
// If feature is not hilited, discard it.
const checkVertexHiliteDiscard = "return 0.0 == v_feature_hilited;";
// The result is a mask in which each highlighted pixel is white, all other pixels are black.
const computeHiliteColor = "return vec4(ceil(v_feature_hilited));";
const computeHiliteOverrides = `
  vec4 value = getFirstFeatureRgba();
  float flags = value.r * 256.0;
  feature_invisible = 1.0 == extractNthFeatureBit(flags, kOvrBit_Visibility);
  v_feature_hilited = extractNthFeatureBit(flags, kOvrBit_Hilited);
`;
const computeHiliteOverridesWithWeight = computeHiliteOverrides + `
  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),
  value.g * 256.0,
  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),
  value.b * 256.0);
`;
function addHiliter(builder, wantWeight = false) {
    let opts = 4 /* HasOverrides */;
    if (wantWeight)
        opts |= 1 /* Weight */; // hiliter never needs line code or color...
    if (!addCommon(builder, 2 /* Overrides */, opts))
        return;
    builder.addVarying("v_feature_hilited", 3 /* Float */);
    builder.vert.set(1 /* ComputeFeatureOverrides */, wantWeight ? computeHiliteOverridesWithWeight : computeHiliteOverrides);
    builder.vert.set(2 /* CheckForDiscard */, checkVertexHiliteDiscard);
    builder.frag.set(1 /* ComputeBaseColor */, computeHiliteColor);
    builder.frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
}
exports.addHiliter = addHiliter;
function addSamplers(frag, testElementId) {
    if (testElementId) {
        frag.addUniform("u_pickElementId0", 9 /* Sampler2D */, (prog) => {
            prog.addProgramUniform("u_pickElementId0", (uniform, params) => {
                params.target.compositor.elementId0.bindSampler(uniform, RenderFlags_1.TextureUnit.PickElementId0);
            });
        }, 3 /* High */);
        frag.addUniform("u_pickElementId1", 9 /* Sampler2D */, (prog) => {
            prog.addProgramUniform("u_pickElementId1", (uniform, params) => {
                params.target.compositor.elementId1.bindSampler(uniform, RenderFlags_1.TextureUnit.PickElementId1);
            });
        }, 3 /* High */);
    }
    frag.addUniform("u_pickDepthAndOrder", 9 /* Sampler2D */, (prog) => {
        prog.addProgramUniform("u_pickDepthAndOrder", (uniform, params) => {
            params.target.compositor.depthAndOrder.bindSampler(uniform, RenderFlags_1.TextureUnit.PickDepthAndOrder);
        });
    }, 3 /* High */);
}
const readDepthAndOrder = `
vec2 readDepthAndOrder(vec2 tc) {
  vec4 pdo = TEXTURE(u_pickDepthAndOrder, tc);
  float order = floor(pdo.x * 16.0 + 0.5);
  return vec2(order, decodeDepthRgb(pdo.yzw));
}
`;
exports.computeEyeSpace = "v_eyeSpace = (u_mv * rawPosition).xyz;";
const checkForEarlySurfaceDiscard = `
  if (u_renderPass > kRenderPass_Translucent || u_renderPass <= kRenderPass_Background)
    return false;

  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec2 depthAndOrder = readDepthAndOrder(tc);
  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);
  return depthAndOrder.x > u_renderOrder && abs(depthAndOrder.y - surfaceDepth) < 4.0e-5;
`;
const checkForEarlySurfaceDiscardWithElemID = `
  if (u_renderPass > kRenderPass_Translucent || u_renderPass <= kRenderPass_Background)
    return false;

  if (!isSurfaceBitSet(kSurfaceBit_HasNormals))
    return false; // no normal == never-lit geometry == never rendered with edges == don't have to test further

  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec2 depthAndOrder = readDepthAndOrder(tc);
  if (depthAndOrder.x <= u_renderOrder)
    return false; // just do normal z-testing.

  // Calculate depthTolerance for letting edges show through their own surfaces
  vec3 eyeDir;
  float dtWidthFactor;
  if (u_frustum.z == kFrustumType_Perspective) {
    eyeDir = normalize(-v_eyeSpace);
    dtWidthFactor = -v_eyeSpace.z * u_pixelWidthFactor;
  } else {
    eyeDir = vec3(0.0, 0.0, 1.0);
    dtWidthFactor = u_pixelWidthFactor;
  }

  // Compute depth tolerance based on angle of triangle to screen
  float dSq = dot(eyeDir, v_n);
  if (depthAndOrder.x == kRenderOrder_Silhouette) // curved surface
    dSq *= 0.5;
  else
    dSq *= 0.9;

  dSq = dSq * dSq;
  dSq = max(dSq, 0.0001);
  dSq = min(dSq, 0.999);

  float depthTolerance = dtWidthFactor * v_lineWeight * sqrt((1.0 - dSq) / dSq);
  if (depthAndOrder.x == kRenderOrder_Silhouette) // curved surface
    depthTolerance = depthTolerance * 1.333;

  // Make sure stuff behind camera doesn't get pushed in front of it
  depthTolerance = max(depthTolerance, 0.0);

  // Convert depthTolerance from eye space to linear depth
  depthTolerance /= (u_frustum.y - u_frustum.x);

  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);
  float depthDelta = abs(depthAndOrder.y - surfaceDepth);
  if (depthDelta > depthTolerance)
    return false; // don't discard and let normal z-testing happen

  // Does pick buffer contain same element?
  vec4 elemId0 = TEXTURE(u_pickElementId0, tc);

  // Converting to ints to test since varying floats can be interpolated incorrectly
  ivec4 elemId0_i = ivec4(elemId0 * 255.0 + 0.5);
  ivec4 v_element_id0_i = ivec4(v_element_id0 * 255.0 + 0.5);
  bool isSameElement = elemId0_i == v_element_id0_i;
  if (isSameElement) {
    vec4 elemId1 = TEXTURE(u_pickElementId1, tc);
    ivec4 elemId1_i = ivec4(elemId1 * 255.0 + 0.5);
    ivec4 v_element_id1_i = ivec4(v_element_id1 * 255.0 + 0.5);
    isSameElement = elemId1_i == v_element_id1_i;
  }
  if (!isSameElement) {
    // If what was in the pick buffer is a planar line/edge/silhouette then we've already tested the depth so return true to discard.
    // If it was a planar surface then use a tighter and constant tolerance to see if we want to let it show through since we're only fighting roundoff error.
    return (depthAndOrder.x > kRenderOrder_PlanarSurface) || ((depthAndOrder.x == kRenderOrder_PlanarSurface) && (depthDelta <= 4.0e-5));
  }

  return true; // discard surface in favor of pick buffer contents.
`;
function addEdgeWidth(builder) {
    builder.addUniform("u_lineWeight", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_lineWeight", (uniform, params) => {
            const mesh = params.geometry;
            const width = params.target.getEdgeWeight(params, mesh.edgeWidth);
            uniform.setUniform1f(width < 1.0 ? 1.0 : width);
        });
    });
}
exports.computeElementId = `
  if (u_featureInfo.x <= kFeatureDimension_SingleUniform) {
    v_element_id0 = u_element_id0;
    v_element_id1 = u_element_id1;
  } else {
    vec2 texc = computeElementIdTextureCoords();
    v_element_id0 = TEXTURE(u_elementIdLUT, texc);
    texc.x += g_elementId_stepX;
    v_element_id1 = TEXTURE(u_elementIdLUT, texc);
  }
`;
function addRenderOrderConstants(builder) {
    builder.addConstant("kRenderOrder_None", 3 /* Float */, "0.0");
    builder.addConstant("kRenderOrder_BlankingRegion", 3 /* Float */, "1.0");
    builder.addConstant("kRenderOrder_Surface", 3 /* Float */, "2.0");
    builder.addConstant("kRenderOrder_Linear", 3 /* Float */, "3.0");
    builder.addConstant("kRenderOrder_Edge", 3 /* Float */, "4.0");
    builder.addConstant("kRenderOrder_Silhouette", 3 /* Float */, "5.0");
    builder.addConstant("kRenderOrder_PlanarSurface", 3 /* Float */, "10.0");
    builder.addConstant("kRenderOrder_PlanarLinear", 3 /* Float */, "11.0");
    builder.addConstant("kRenderOrder_PlanarEdge", 3 /* Float */, "12.0");
    builder.addConstant("kRenderOrder_PlanarSilhouette", 3 /* Float */, "13.0");
}
function addRenderOrder(builder) {
    builder.addUniform("u_renderOrder", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_renderOrder", (uniform, params) => {
            uniform.setUniform1f(params.geometry.renderOrder);
        });
    });
}
exports.addRenderOrder = addRenderOrder;
function setPixelWidthFactor(uniform, params) {
    const rect = params.target.viewRect;
    const width = rect.width;
    const height = rect.height;
    const frustumPlanes = params.target.frustumUniforms.frustumPlanes;
    const top = frustumPlanes[0];
    const bottom = frustumPlanes[1];
    const left = frustumPlanes[2];
    const right = frustumPlanes[3];
    let halfPixelWidth;
    let halfPixelHeight;
    const frustum = params.target.frustumUniforms.frustum;
    if (2.0 === frustum[2]) {
        const inverseNear = 1.0 / frustum[0];
        const tanTheta = top * inverseNear;
        halfPixelHeight = tanTheta / height;
        halfPixelWidth = tanTheta / width;
    }
    else {
        halfPixelWidth = 0.5 * (right - left) / width;
        halfPixelHeight = 0.5 * (top - bottom) / height;
    }
    const pixelWidthFactor = Math.sqrt(halfPixelWidth * halfPixelWidth + halfPixelHeight * halfPixelHeight);
    uniform.setUniform1f(pixelWidthFactor);
}
function addPixelWidthFactor(builder) {
    builder.addUniform("u_pixelWidthFactor", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_pixelWidthFactor", (uniform, params) => { setPixelWidthFactor(uniform, params); });
    });
}
const computeElementIdTextureCoords = `
vec2 computeElementIdTextureCoords() {
  return compute_elementId_coords(getFeatureIndex());
}
`;
function addElementId(builder) {
    builder.addVarying("v_element_id0", 6 /* Vec4 */);
    builder.addVarying("v_element_id1", 6 /* Vec4 */);
    const vert = builder.vert;
    LookupTable_1.addLookupTable(vert, "elementId", "2.0");
    vert.addFunction(computeElementIdTextureCoords);
    vert.addFunction("void computeElementId()", exports.computeElementId);
    vert.addUniform("u_elementIdLUT", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_elementIdLUT", (uniform, params) => {
            bentleyjs_core_1.assert(undefined !== params.target.currentPickTable);
            const table = params.target.currentPickTable;
            if (undefined !== table.nonUniform)
                table.nonUniform.bindSampler(uniform, RenderFlags_1.TextureUnit.ElementId);
            else if (undefined !== System_1.System.instance && undefined !== System_1.System.instance.lineCodeTexture) {
                // Bind the linecode texture just so that we have something bound to this texture unit for the shader.
                System_1.System.instance.lineCodeTexture.bindSampler(uniform, RenderFlags_1.TextureUnit.ElementId);
            }
        });
    });
    vert.addUniform("u_elementIdParams", 4 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_elementIdParams", (uniform, params) => {
            const table = params.target.currentPickTable;
            if (undefined !== table.nonUniform)
                uniform.setUniform2fv([table.nonUniform.width, table.nonUniform.height]);
        });
    });
    vert.addUniform("u_element_id0", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_element_id0", (uniform, params) => {
            const table = params.target.currentPickTable;
            if (undefined !== table.uniform)
                uniform.setUniform4fv(table.uniform.elemId0);
        });
    });
    vert.addUniform("u_element_id1", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_element_id1", (uniform, params) => {
            const table = params.target.currentPickTable;
            if (undefined !== table.uniform)
                uniform.setUniform4fv(table.uniform.elemId1);
        });
    });
}
exports.addElementId = addElementId;
function addSurfaceDiscard(builder, feat) {
    const frag = builder.frag;
    Fragment_1.addWindowToTexCoords(frag);
    if (0 /* None */ === feat) {
        addSamplers(frag, false);
        frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
        frag.addFunction(Decode_1.GLSLDecode.depthRgb);
        frag.addFunction(readDepthAndOrder);
        builder.addInlineComputedVarying("v_eyeSpace", 5 /* Vec3 */, exports.computeEyeSpace);
        frag.set(0 /* CheckForEarlyDiscard */, checkForEarlySurfaceDiscard);
    }
    else {
        const vert = builder.vert;
        addFeatureIndex(vert);
        addEdgeWidth(vert);
        vert.addFunction(Vertex_1.GLSLVertex.computeLineWeight);
        vert.set(5 /* AddComputeElementId */, exports.computeElementId);
        addSamplers(frag, true);
        addRenderOrderConstants(frag);
        addPixelWidthFactor(frag);
        frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
        frag.addFunction(Decode_1.GLSLDecode.depthRgb);
        frag.addFunction(readDepthAndOrder);
        frag.set(0 /* CheckForEarlyDiscard */, checkForEarlySurfaceDiscardWithElemID);
        builder.addInlineComputedVarying("v_eyeSpace", 5 /* Vec3 */, exports.computeEyeSpace);
        builder.addInlineComputedVarying("v_lineWeight", 3 /* Float */, "v_lineWeight = ComputeLineWeight();");
        addElementId(builder);
    }
    addRenderOrder(frag);
    RenderPass_1.addRenderPass(frag);
}
exports.addSurfaceDiscard = addSurfaceDiscard;
// bool feature_invisible = false;
// varying vec4 v_feature_rgb; // alpha > 0.0 if overridden
// varying vec4 v_feature_alpha_flashed; // y > 0.0 if overridden. z > 0.0 if flashed. w > 0.0 if hilited.
// vec4 linear_feature_overrides; // x: weight overridden y: weight z: line code overridden w: line code
const computeFeatureOverrides = `
  v_feature_rgb = vec4(1.0);
  v_feature_alpha_flashed = vec4(1.0);
  vec4 value = getFirstFeatureRgba();

  // 2 RGBA values per feature - first R is override flags mask
  if (0.0 == value.r) {
    v_feature_rgb.a = 0.0;
    v_feature_alpha_flashed.yzw = vec3(0.0);
    return; // nothing overridden for this feature
  }

  float flags = value.r * 256.0;
  feature_invisible = 1.0 == extractNthFeatureBit(flags, kOvrBit_Visibility);
  if (feature_invisible)
    return;

  v_feature_rgb.a = extractNthFeatureBit(flags, kOvrBit_Rgb);
  v_feature_alpha_flashed.y = extractNthFeatureBit(flags, kOvrBit_Alpha);
  if (v_feature_alpha_flashed.y > 0.0 || v_feature_rgb.a > 0.0) {
    vec4 rgba = getSecondFeatureRgba();
    v_feature_rgb.rgb = rgba.rgb;
    v_feature_alpha_flashed.x = rgba.a;
  }

  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),
                                  value.g * 256.0,
                                  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),
                                  value.b * 256.0);

  feature_ignore_material = 0.0 != extractNthFeatureBit(flags, kOvrBit_IgnoreMaterial);
  v_feature_alpha_flashed.z = extractNthFeatureBit(flags, kOvrBit_Flashed);
  v_feature_alpha_flashed.w = extractNthFeatureBit(flags, kOvrBit_Hilited);
`;
const applyFeatureColor = `
  if (floatToBool(v_feature_rgb.a))
    baseColor.rgb = v_feature_rgb.rgb * baseColor.a;

  if (floatToBool(v_feature_alpha_flashed.y))
    baseColor = adjustPreMultipliedAlpha(baseColor, v_feature_alpha_flashed.x);

  return baseColor;
`;
const applyFlash = `
  float isFlashed = floatToBool(v_feature_alpha_flashed.z) ? 1.0 : 0.0;
  float isHilited = floatToBool(v_feature_alpha_flashed.w) ? 1.0 : 0.0;

  float hiliteRatio = u_hilite_settings.x * isHilited;
  baseColor = revertPreMultipliedAlpha(baseColor);
  baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, hiliteRatio);

  if (u_hilite_color.a == 1.0) { // .a indicates lit geometry - brighten it
    const float maxBrighten = 0.2;
    float brighten = u_flash_intensity * maxBrighten;
    baseColor.rgb += isFlashed * brighten;
  } else { // unlit geometry - tween it toward flash color
    float maxTween = 0.75;
    float hiliteFraction = u_flash_intensity * isFlashed * maxTween;
    baseColor.rgb *= (1.0 - hiliteFraction);
    baseColor.rgb += u_hilite_color.rgb * hiliteFraction;
  }

  return applyPreMultipliedAlpha(baseColor);
`;
function addFeatureSymbology(builder, feat, opts) {
    if (!addCommon(builder, feat, opts) || 0 /* None */ === opts)
        return;
    bentleyjs_core_1.assert((4 /* HasOverrides */ | 8 /* Color */) === (opts & (4 /* HasOverrides */ | 8 /* Color */)));
    builder.addVarying("v_feature_rgb", 6 /* Vec4 */);
    builder.addVarying("v_feature_alpha_flashed", 6 /* Vec4 */);
    const vert = builder.vert;
    vert.set(1 /* ComputeFeatureOverrides */, computeFeatureOverrides);
    const frag = builder.frag;
    addHiliteSettings(frag);
    frag.addFunction(Common_1.GLSLCommon.floatToBool);
    frag.set(3 /* ApplyFeatureColor */, applyFeatureColor);
    frag.addFunction(Fragment_1.GLSLFragment.revertPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.applyPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    frag.set(11 /* ApplyFlash */, applyFlash);
    frag.addUniform("u_flash_intensity", 3 /* Float */, (prog) => {
        prog.addProgramUniform("u_flash_intensity", (uniform, params) => {
            uniform.setUniform1f(params.target.flashIntensity);
        });
    });
}
exports.addFeatureSymbology = addFeatureSymbology;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
class FeaturesInfo {
    constructor(uniform) { this.uniform = uniform; }
    static create(featureIndex) {
        switch (featureIndex.type) {
            case 0 /* Empty */: return undefined;
            case 1 /* Uniform */: return new FeaturesInfo(featureIndex.featureID);
            default: return FeaturesInfo.nonUniform;
        }
    }
    static createUniform(id) { return new FeaturesInfo(id); }
    get type() { return undefined !== this.uniform ? 1 /* Uniform */ : 2 /* NonUniform */; }
    get isUniform() { return 1 /* Uniform */ === this.type; }
    get isNonUniform() { return !this.isUniform; }
}
FeaturesInfo.nonUniform = new FeaturesInfo(undefined);
exports.FeaturesInfo = FeaturesInfo;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const FeatureDimensions_1 = __webpack_require__(100);
const ColorInfo_1 = __webpack_require__(101);
const Texture_1 = __webpack_require__(19);
const Handle_1 = __webpack_require__(36);
var VertexLUT;
(function (VertexLUT) {
    /**
     * Stores vertex data (position, color ID, normal, UV params, etc) in a rectangular array
     * which will later be converted to a texture. Given a vertex ID, vertex shaders can sample
     * that texture to extract the vertex data. If vertex data contains indices into a color table,
     * the color table itself will be appended to the array following the vertex data.
     */
    class Params {
        /** Construct a VertexLUT.Params using the vertex data supplied by the Builder */
        constructor(builder, colorIndex) {
            this.numVertices = builder.numVertices;
            this.numRgbaPerVertex = builder.numRgbaPerVertex;
            const numColors = colorIndex.isUniform ? 0 : colorIndex.numColors;
            this.colorInfo = new ColorInfo_1.ColorInfo(colorIndex);
            this.dimensions = new FeatureDimensions_1.LUTDimensions(this.numVertices, this.numRgbaPerVertex, numColors);
            bentleyjs_core_1.assert(0 === this.dimensions.width % this.numRgbaPerVertex || (0 < numColors && 1 === this.dimensions.height));
            this.data = new Uint8Array(this.dimensions.width * this.dimensions.height * 4);
            builder.params = this;
            for (let i = 0; i < this.numVertices; i++) {
                builder.appendVertex(i);
            }
            builder.appendColorTable(colorIndex);
            builder.params = undefined;
        }
        toTexture() {
            return Texture_1.TextureHandle.createForData(this.dimensions.width, this.dimensions.height, this.data);
        }
        toData(qparams, uvParams) {
            return Data.create(this, qparams, uvParams);
        }
    }
    VertexLUT.Params = Params;
    /** Represents the finished lookup table ready for submittal to GPU. */
    class Data {
        constructor(texture, params, qparams, uvParams) {
            this.texture = texture;
            this.numVertices = params.numVertices;
            this.numRgbaPerVertex = params.numRgbaPerVertex;
            this.colorInfo = params.colorInfo;
            this.qOrigin = Handle_1.qorigin3dToArray(qparams.origin);
            this.qScale = Handle_1.qscale3dToArray(qparams.scale);
            if (undefined !== uvParams) {
                this.uvQParams = Handle_1.qparams2dToArray(uvParams);
            }
        }
        static create(params, qparams, uvParams) {
            const texture = params.toTexture();
            return undefined !== texture ? new Data(texture, params, qparams, uvParams) : undefined;
        }
        dispose() {
            bentleyjs_core_1.dispose(this.texture);
        }
    }
    VertexLUT.Data = Data;
    const scratchColorDef = new imodeljs_common_1.ColorDef();
    /** Builds a VertexLUT.Params from some data type supplying the vertex data. */
    class Builder {
        constructor() {
            this._curIndex = 0;
        }
        appendColorTable(colorIndex) {
            if (undefined !== colorIndex.nonUniform) {
                for (const color of colorIndex.nonUniform.colors) {
                    this.appendColor(color);
                }
            }
        }
        advance(nBytes) {
            this._curIndex += nBytes;
            bentleyjs_core_1.assert(this._curIndex <= this.params.data.length);
        }
        append8(val) {
            bentleyjs_core_1.assert(0 <= val);
            bentleyjs_core_1.assert(val <= 0xff);
            bentleyjs_core_1.assert(val === Math.floor(val));
            this.params.data[this._curIndex] = val;
            this.advance(1);
        }
        append16(val) {
            this.append8(val & 0x00ff);
            this.append8(val >>> 8);
        }
        append32(val) {
            this.append16(val & 0x0000ffff);
            this.append16(val >>> 16);
        }
        appendColor(tbgr) {
            const colorDef = scratchColorDef;
            colorDef.tbgr = tbgr;
            const colors = colorDef.colors;
            // invert transparency => alpha
            colors.t = 255 - colors.t;
            // premultiply alpha...
            switch (colors.t) {
                case 0:
                    colors.r = colors.g = colors.b = 0;
                    break;
                case 255:
                    break;
                default: {
                    const f = colors.t / 255.0;
                    colors.r = Math.floor(colors.r * f + 0.5);
                    colors.g = Math.floor(colors.g * f + 0.5);
                    colors.b = Math.floor(colors.b * f + 0.5);
                    break;
                }
            }
            // Store 32-bit value in little-endian order (red first)
            this.append8(colors.r);
            this.append8(colors.g);
            this.append8(colors.b);
            this.append8(colors.t);
        }
    }
    VertexLUT.Builder = Builder;
    /**
     * Supplies vertex data from a PolylineArgs or MeshArgs. Each vertex consists of 12 bytes:
     *  pos.x           00
     *  pos.y           02
     *  pos.z           04
     *  colorIndex      06
     *  featureIndex    08
     */
    class SimpleBuilder extends Builder {
        constructor(args) {
            super();
            this.args = args;
            bentleyjs_core_1.assert(undefined !== this.args.points);
        }
        get numVertices() { return this.args.points.length; }
        get numRgbaPerVertex() { return 3; }
        appendVertex(vertIndex) {
            this.appendPosition(vertIndex);
            this.appendColorIndex(vertIndex);
            this.appendFeatureIndex(vertIndex);
        }
        appendPosition(vertIndex) {
            const points = this.args.points;
            this.append16(points.list[vertIndex].x);
            this.append16(points.list[vertIndex].y);
            this.append16(points.list[vertIndex].z);
        }
        appendColorIndex(vertIndex) {
            if (undefined !== this.args.colors.nonUniform) {
                this.append16(this.args.colors.nonUniform.indices[vertIndex]);
            }
            else {
                this.advance(2);
            }
        }
        appendFeatureIndex(vertIndex) {
            if (undefined !== this.args.features.featureIDs) {
                this.append32(this.args.features.featureIDs[vertIndex]);
            }
            else {
                this.advance(4);
            }
        }
    }
    VertexLUT.SimpleBuilder = SimpleBuilder;
    /** Supplies vertex data from a MeshArgs. */
    class MeshBuilder extends SimpleBuilder {
        constructor(args) { super(args); }
    }
    VertexLUT.MeshBuilder = MeshBuilder;
    /** Supplies vertex data from a MeshArgs where each vertex consists of 16 bytes.
     * In addition to the SimpleBuilder data, the final 4 bytes hold the quantized UV params
     * The color index is left uninitialized as it is unused.
     */
    class TexturedMeshBuilder extends MeshBuilder {
        constructor(args, qparams) {
            super(args);
            this.qpoint = new imodeljs_common_1.QPoint2d();
            this.qparams = qparams;
            bentleyjs_core_1.assert(undefined !== args.textureUv);
        }
        get numRgbaPerVertex() { return 4; }
        appendVertex(vertIndex) {
            this.appendPosition(vertIndex);
            this.appendNormal(vertIndex);
            this.appendFeatureIndex(vertIndex);
            this.appendUVParams(vertIndex);
        }
        appendNormal(_vertIndex) { this.advance(2); } // no normal for unlit meshes
        appendUVParams(vertIndex) {
            this.qpoint.init(this.args.textureUv[vertIndex], this.qparams);
            this.append16(this.qpoint.x);
            this.append16(this.qpoint.y);
        }
    }
    VertexLUT.TexturedMeshBuilder = TexturedMeshBuilder;
    /** As with TexturedMeshBuilder, but the color index is replaced with the oct-encoded normal value. */
    class TexturedLitMeshBuilder extends TexturedMeshBuilder {
        constructor(args, qparams) {
            super(args, qparams);
            bentleyjs_core_1.assert(undefined !== args.normals);
        }
        appendNormal(vertIndex) { this.append16(this.args.normals[vertIndex].value); }
    }
    VertexLUT.TexturedLitMeshBuilder = TexturedLitMeshBuilder;
    /** 16 bytes. The last 2 bytes are unused; the 2 immediately preceding it hold the oct-encoded normal value. */
    class LitMeshBuilder extends MeshBuilder {
        constructor(args) {
            super(args);
            bentleyjs_core_1.assert(undefined !== args.normals);
        }
        get numRgbaPerVertex() { return 4; }
        appendVertex(vertIndex) {
            super.appendVertex(vertIndex);
            this.append16(this.args.normals[vertIndex].value);
            this.advance(2); // 2 unused bytes
        }
    }
    VertexLUT.LitMeshBuilder = LitMeshBuilder;
    // Given 32-bit unsigned integer vertex indices, convert each to a vec3 in which each component is one byte of the index.
    // Requires the high 8 bits of the indices are unused.
    // These are decoded in the vertex shader to obtain the index as a float (hence the 24-bit restriction).
    function convertIndicesToTriplets(indices) {
        const bytes = new Uint8Array(indices.length * 3);
        for (let i = 0; i < indices.length; i++) {
            const index = indices[i];
            const j = i * 3;
            bytes[j + 0] = index & 0x000000ff;
            bytes[j + 1] = (index & 0x0000ff00) >> 8;
            bytes[j + 2] = (index & 0x00ff0000) >> 16;
        }
        return bytes;
    }
    VertexLUT.convertIndicesToTriplets = convertIndicesToTriplets;
})(VertexLUT = exports.VertexLUT || (exports.VertexLUT = {}));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Vertex_1 = __webpack_require__(20);
const Fragment_1 = __webpack_require__(25);
const RenderFlags_1 = __webpack_require__(24);
const calcClipDist = `
  if (u_numClips > 0) {
    vec4 camPos = u_mv * rawPos;
    v_clipDist[0] = dot(camPos, u_clipPlane[0]);
    v_clipDist[1] = (u_numClips > 1) ? dot(camPos, u_clipPlane[1]) : 0.0;
    v_clipDist[2] = (u_numClips > 2) ? dot(camPos, u_clipPlane[2]) : 0.0;
    v_clipDist[3] = (u_numClips > 3) ? dot(camPos, u_clipPlane[3]) : 0.0;
    v_clipDist[4] = (u_numClips > 4) ? dot(camPos, u_clipPlane[4]) : 0.0;
    v_clipDist[5] = (u_numClips > 5) ? dot(camPos, u_clipPlane[5]) : 0.0;
  }
`;
const applyClipping = `
  if (u_numClips > 0) {
    for (int i = 0; i < 6; i++) {
      if (v_clipDist[i] < 0.0)
        discard;
    }
  }

  if (u_clipMask > 0) {
    vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
    vec4 texel = TEXTURE(s_clipMask, tc);
    if (texel.r < 0.5)
      discard;
  }
`;
function addClipping(builder) {
    const frag = builder.frag;
    const vert = builder.vert;
    builder.addVarying("v_clipDist[6]", 3 /* Float */);
    builder.addUniform("u_numClips", 1 /* Int */, (prog) => {
        prog.addGraphicUniform("u_numClips", (uniform, params) => {
            const numClips = params.target.hasClipVolume ? params.target.clips.length : 0;
            uniform.setUniform1i(numClips);
        });
    });
    Vertex_1.addModelViewMatrix(vert);
    vert.set(4 /* CalcClipDist */, calcClipDist);
    vert.addUniform("u_clipPlane[6]", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_clipPlane[0]", (uniform, params) => {
            if (params.target.hasClipVolume)
                uniform.setUniform4fv(params.target.clips.clips); // ###TODO confirm this is equivalent to glUniform4fv(6, ...)
        });
    });
    frag.addUniform("u_clipMask", 1 /* Int */, (prog) => {
        prog.addGraphicUniform("u_clipMask", (uniform, params) => {
            uniform.setUniform1i(params.target.hasClipMask ? 1 : 0);
        });
    });
    frag.addUniform("s_clipMask", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_clipMask", (uniform, params) => {
            const mask = params.target.clipMask;
            if (undefined !== mask)
                mask.bindSampler(uniform, RenderFlags_1.TextureUnit.ClipMask);
        });
    });
    Fragment_1.addWindowToTexCoords(frag);
    frag.set(10 /* ApplyClipping */, applyClipping);
}
exports.addClipping = addClipping;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
class GeometryHandler {
    handleCurveCollection(_g) { }
    handlePath(g) { return this.handleCurveCollection(g); }
    handleLoop(g) { return this.handleCurveCollection(g); }
    handleParityRegion(g) { return this.handleCurveCollection(g); }
    handleUnionRegion(g) { return this.handleCurveCollection(g); }
    handleBagOfCurves(g) { return this.handleCurveCollection(g); }
}
exports.GeometryHandler = GeometryHandler;
/**
 * `NullGeometryHandler` is a base class for dispatching various geometry types to
 * appliation specific implementation of some service.
 *
 * To use:
 * * Derive a class from `NullGeometryHandler`
 * * Reimplement any or all of the specific `handleXXXX` methods
 * * Create a handler instance `myHandler`
 * * To send a `GeometryQuery` object `candidateGeometry` through the (fast) dispatch, invoke   `candidateGeometry.dispatchToHandler (myHandler)
 * * The appropriate method or methods will get called with a strongly typed `_g ` value.
 */
class NullGeometryHandler extends GeometryHandler {
    handleLineSegment3d(_g) { return undefined; }
    handleLineString3d(_g) { return undefined; }
    handleArc3d(_g) { return undefined; }
    handleCurveCollection(_g) { return undefined; }
    handleBSplineCurve3d(_g) { return undefined; }
    handleBSplineSurface3d(_g) { return undefined; }
    handleCoordinateXYZ(_g) { return undefined; }
    handleBSplineSurface3dH(_g) { return undefined; }
    handleIndexedPolyface(_g) { return undefined; }
    handleTransitionSpiral(_g) { return undefined; }
    handlePath(_g) { return undefined; }
    handleLoop(_g) { return undefined; }
    handleParityRegion(_g) { return undefined; }
    handleUnionRegion(_g) { return undefined; }
    handleBagOfCurves(_g) { return undefined; }
    handleSphere(_g) { return undefined; }
    handleCone(_g) { return undefined; }
    handleBox(_g) { return undefined; }
    handleTorusPipe(_g) { return undefined; }
    handleLinearSweep(_g) { return undefined; }
    handleRotationalSweep(_g) { return undefined; }
    handleRuledSweep(_g) { return undefined; }
    handlePointString3d(_g) { return undefined; }
}
exports.NullGeometryHandler = NullGeometryHandler;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const FrameBuilder_1 = __webpack_require__(250);
const PolyfaceBuilder_1 = __webpack_require__(147);
const Triangulation_1 = __webpack_require__(150);
const LineString3d_1 = __webpack_require__(10);
const CurveChain_1 = __webpack_require__(14);
const PointHelpers_1 = __webpack_require__(22);
/**
 * Sweepable contour with Transform for local to world interaction.
 */
class SweepContour {
    constructor(contour, map) {
        this.curves = contour;
        this.localToWorld = map;
    }
    static createForLinearSweep(contour, defaultNormal) {
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(defaultNormal, contour);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld);
        }
        return undefined;
    }
    static createForRotation(contour, axis) {
        // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(undefined, contour, axis);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld);
        }
        return undefined;
    }
    getCurves() { return this.curves; }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    clone() {
        return new SweepContour(this.curves.clone(), this.localToWorld.clone());
    }
    cloneTransformed(transform) {
        const newContour = this.clone();
        if (newContour.tryTransformInPlace(transform))
            return newContour;
        return undefined;
    }
    isAlmostEqual(other) {
        if (other instanceof SweepContour) {
            return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);
        }
        return false;
    }
    /**
     * build the (cached) internal facets.
     * @param _builder (NOT USED -- an internal builder is constructed for the triangulation)
     * @param options options for stroking the curves.
     */
    buildFacets(_builder, options) {
        if (!this.facets) {
            if (this.curves instanceof CurveChain_1.Loop) {
                this.xyStrokes = this.curves.cloneStroked(options);
                if (this.xyStrokes instanceof CurveChain_1.Loop && this.xyStrokes.children.length === 1) {
                    const children = this.xyStrokes.children;
                    const linestring = children[0];
                    const points = linestring.points;
                    this.localToWorld.multiplyInversePoint3dArrayInPlace(points);
                    if (PointHelpers_1.PolygonOps.sumTriangleAreasXY(points) < 0)
                        points.reverse();
                    const graph = Triangulation_1.Triangulator.earcutFromPoints(points);
                    const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                    this.facets = unflippedPoly;
                    this.facets.tryTransformInPlace(this.localToWorld);
                }
            }
            else if (this.curves instanceof CurveChain_1.ParityRegion) {
                this.xyStrokes = this.curves.cloneStroked(options);
                if (this.xyStrokes instanceof (CurveChain_1.ParityRegion)) {
                    this.xyStrokes.tryTransformInPlace(this.localToWorld);
                    const strokes = [];
                    for (const childLoop of this.xyStrokes.children) {
                        const loopCurves = childLoop.children;
                        if (loopCurves.length === 1) {
                            const c = loopCurves[0];
                            if (c instanceof LineString3d_1.LineString3d)
                                strokes.push(c.packedPoints);
                        }
                    }
                    const graph = Triangulation_1.Triangulator.triangulateStrokedLoops(strokes);
                    if (graph) {
                        const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                        this.facets = unflippedPoly;
                        this.facets.tryTransformInPlace(this.localToWorld);
                    }
                }
            }
        }
    }
    /** Emit facets to a builder.
     * This method may cache and reuse facets over multiple calls.
     */
    emitFacets(builder, reverse, transform) {
        this.buildFacets(builder, builder.options);
        if (this.facets)
            builder.addIndexedPolyface(this.facets, reverse, transform);
    }
}
exports.SweepContour = SweepContour;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Geometry } from "./Geometry";
const PointVector_1 = __webpack_require__(4);
const Range_1 = __webpack_require__(21);
const PointHelpers_1 = __webpack_require__(22);
const GrowableArray_1 = __webpack_require__(37);
const CurvePrimitive_1 = __webpack_require__(12);
const ClusterableArray_1 = __webpack_require__(251);
/**
 * Check validity of indices into a data array.
 * * It is valid to have  both indices and data undeinfed.
 * * It is NOT valid for just one to be defined.
 * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.
 * @param indices array of indices.
 * @param indexPositionA first index to test
 * @param indexPositionB one past final index to test
 * @param data data array.  Only its length is referenced.
 */
function areIndicesValid(indices, indexPositionA, indexPositionB, data) {
    if (indices === undefined && data === undefined)
        return true;
    if (!indices || !data)
        return false;
    const dataLength = data.length;
    if (indexPositionA < 0 || indexPositionA >= indices.length)
        return false;
    if (indexPositionB < indexPositionA || indexPositionB > indices.length)
        return false;
    for (let i = indexPositionA; i < indexPositionB; i++)
        if (indices[i] < 0 || indices[i] >= dataLength)
            return false;
    return true;
}
function allDefined(valueA, valueB, valueC) {
    return valueA !== undefined && valueB !== undefined && valueC !== undefined;
}
/**
 * Test if facetStartIndex is (minimally!) valid:
 * * length must be nonzero (recall that for "no facets" the facetStartIndexArray still must contain a 0)
 * * Each entry must be strictly smaller than the one that follows.
 * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`
 */
function isValidFacetStartIndexArray(facetStartIndex) {
    // facetStartIndex for empty facets has a single entry "0" -- empty array is not allowed
    if (facetStartIndex.length === 0)
        return false;
    for (let i = 0; i + 1 < facetStartIndex.length; i++)
        if (facetStartIndex[i] >= facetStartIndex[i + 1])
            return false;
    return true;
}
function reverseIndices(facetStartIndex, indices, preserveStart) {
    if (!indices || indices.length === 0)
        return true; // empty case
    if (indices.length > 0) {
        if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {
            for (let i = 0; i + 1 < facetStartIndex.length; i++) {
                let index0 = facetStartIndex[i];
                let index1 = facetStartIndex[i + 1];
                if (preserveStart) {
                    // leave [index0] as is so reversed facet starts at same vertex
                    while (index1 > index0 + 2) {
                        index1--;
                        index0++;
                        const a = indices[index0];
                        indices[index0] = indices[index1];
                        indices[index1] = a;
                    }
                }
                else {
                    // reverse all
                    while (index1 > index0 + 1) {
                        index1--;
                        const a = indices[index0];
                        indices[index0] = indices[index1];
                        indices[index1] = a;
                        index0++;
                    }
                }
            }
            return true;
        }
    }
    return false;
}
/**
 * Data for a face in a polyface containing facets.
 * This is built up cooperatively by the PolyfaceBuilder and its
 * callers, and stored as a FaceData array in PolyfaceData.
 */
class FacetFaceData {
    get paramDistanceRange() { return this._paramDistanceRange; }
    get paramRange() { return this._paramRange; }
    constructor(distanceRange, paramRange) {
        this._paramDistanceRange = distanceRange;
        this._paramRange = paramRange;
    }
    /** Create a FacetFaceData with null ranges. */
    static createNull() {
        return new FacetFaceData(Range_1.Range2d.createNull(), Range_1.Range2d.createNull());
    }
    /** Create a deep copy of this FacetFaceData object. */
    clone(result) {
        if (result) {
            this._paramDistanceRange.clone(result._paramDistanceRange);
            this._paramRange.clone(result._paramRange);
            return result;
        }
        return new FacetFaceData(this._paramDistanceRange.clone(), this._paramRange.clone());
    }
    /** Restore this FacetFaceData to its null constructor state. */
    null() {
        this._paramDistanceRange.setNull();
        this._paramRange.setNull();
    }
    /** Return distance-based parameter from stored parameter value. */
    convertParamToDistance(param, result) {
        result = result ? result : PointVector_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0 === paramDelta.x) ? param.x : (this._paramDistanceRange.low.x + (param.x - this._paramRange.low.x)
            * (this._paramDistanceRange.high.x - this._paramDistanceRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? param.y : (this.paramDistanceRange.low.y + (param.y - this._paramRange.low.y)
            * (this._paramDistanceRange.high.y - this._paramDistanceRange.low.y) / paramDelta.y);
        return result;
    }
    /** Return normalized (0-1) parameter from stored parameter value. */
    convertParamToNormalized(param, result) {
        result = result ? result : PointVector_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0.0 === paramDelta.x) ? param.x : ((param.x - this._paramRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? param.y : ((param.y - this._paramRange.low.y) / paramDelta.y);
        return result;
    }
    /** Scale distance paramaters. */
    scaleDistances(distanceScale) {
        this._paramDistanceRange.low.x *= distanceScale;
        this._paramDistanceRange.low.y *= distanceScale;
        this._paramDistanceRange.high.x *= distanceScale;
        this._paramDistanceRange.high.y *= distanceScale;
    }
    /**
     * Sets the paramDistance range of this FacetFaceData based on the newly terminated facets that make it up.
     * Takes the polyface itself, the first and last indexes of the facets to be included in the face.
     * Returns true on success, false otherwise.
     */
    setParamDistanceRangeFromNewFaceData(polyface, facetStart, facetEnd) {
        const dSTotal = PointVector_1.Point2d.create();
        const dSSquaredTotal = PointVector_1.Point2d.create();
        let aveTotal = 0;
        const visitor = IndexedPolyfaceVisitor.create(polyface, 0);
        if (!visitor.moveToReadIndex(facetStart))
            return false;
        do {
            const numPointsInFacet = visitor.numEdgesThisFacet;
            const visitorPoints = visitor.point;
            const trianglePointIndexes = [];
            const visitorParams = visitor.param;
            const triangleParamIndexes = [];
            if (!visitorParams)
                return false;
            for (let k = 0; k < numPointsInFacet; k++) {
                trianglePointIndexes[2] = k;
                triangleParamIndexes[2] = k;
                if (k > 1) {
                    const dUV0 = visitorParams[triangleParamIndexes[0]].minus(visitorParams[triangleParamIndexes[1]]);
                    const dUV1 = visitorParams[triangleParamIndexes[1]].minus(visitorParams[triangleParamIndexes[2]]);
                    const delta0 = visitorPoints.getPoint3dAt(trianglePointIndexes[0]).minus(visitorPoints.getPoint3dAt(trianglePointIndexes[1]));
                    const delta1 = visitorPoints.getPoint3dAt(trianglePointIndexes[1]).minus(visitorPoints.getPoint3dAt(trianglePointIndexes[2]));
                    const uvCross = Math.abs(dUV0.x * dUV1.y - dUV1.x * dUV0.y);
                    if (uvCross) {
                        const dwDu = PointVector_1.Point3d.createFrom(delta0);
                        dwDu.scaleInPlace(dUV1.y);
                        dwDu.addScaledInPlace(delta1, -dUV0.y);
                        const dwDv = PointVector_1.Point3d.createFrom(delta1);
                        dwDv.scaleInPlace(dUV0.x);
                        dwDv.addScaledInPlace(delta0, -dUV1.x);
                        const dS = PointVector_1.Point2d.create(dwDu.magnitude() / uvCross, dwDv.magnitude() / uvCross);
                        dSTotal.x += dS.x;
                        dSTotal.y += dS.y;
                        dSSquaredTotal.x += dS.x * dS.x;
                        dSSquaredTotal.y += dS.y * dS.y;
                        aveTotal++;
                    }
                }
                triangleParamIndexes[0] = triangleParamIndexes[1];
                triangleParamIndexes[1] = triangleParamIndexes[2];
                trianglePointIndexes[0] = trianglePointIndexes[1];
                trianglePointIndexes[1] = trianglePointIndexes[2];
            }
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < facetEnd);
        if (aveTotal !== 0) {
            const dS = PointVector_1.Point2d.create(dSTotal.x / aveTotal, dSTotal.y / aveTotal);
            const standardDeviation = PointVector_1.Point2d.create(Math.sqrt(Math.abs((dSSquaredTotal.x / aveTotal) - dS.x * dS.x)), Math.sqrt(Math.abs((dSSquaredTotal.y / aveTotal) - dS.y * dS.y)));
            // TR# 268980 - Add standard deviation to match QV....
            this._paramDistanceRange.low.set(0, 0);
            this._paramDistanceRange.high.set((dS.x + standardDeviation.x) * (this._paramRange.high.x - this._paramRange.low.x), (dS.y + standardDeviation.y) * (this._paramRange.high.y - this._paramRange.low.y));
        }
        return true;
    }
}
exports.FacetFaceData = FacetFaceData;
/**
 * PolyfaceData carries data arrays for point, normal, param, color and their indices.
 *
 * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)
 * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.
 */
class PolyfaceData {
    constructor(needNormals = false, needParams = false, needColors = false) {
        this.point = new GrowableArray_1.GrowableXYZArray();
        this.pointIndex = [];
        this.edgeVisible = [];
        this.face = [];
        if (needNormals) {
            this.normal = [];
            this.normalIndex = [];
        }
        if (needParams) {
            this.param = [];
            this.paramIndex = [];
        }
        if (needColors) {
            this.color = [];
            this.colorIndex = [];
        }
    }
    clone() {
        const result = new PolyfaceData();
        result.point = this.point.clone();
        result.pointIndex = this.pointIndex.slice();
        result.edgeVisible = this.edgeVisible.slice();
        result.face = this.face.slice();
        if (this.normal)
            result.normal = PointHelpers_1.Vector3dArray.cloneVector3dArray(this.normal);
        if (this.param)
            result.param = PointHelpers_1.Point2dArray.clonePoint2dArray(this.param);
        if (this.color)
            result.color = this.color.slice();
        if (this.normalIndex)
            result.normalIndex = this.normalIndex.slice();
        if (this.paramIndex)
            result.paramIndex = this.paramIndex.slice();
        if (this.colorIndex)
            result.colorIndex = this.colorIndex.slice();
        return result;
    }
    isAlmostEqual(other) {
        if (!GrowableArray_1.GrowableXYZArray.isAlmostEqual(this.point, other.point))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.pointIndex, other.pointIndex))
            return false;
        if (!PointHelpers_1.Vector3dArray.isAlmostEqual(this.normal, other.normal))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.normalIndex, other.normalIndex))
            return false;
        if (!PointHelpers_1.Point2dArray.isAlmostEqual(this.param, other.param))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.paramIndex, other.paramIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.color, other.color))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.colorIndex, other.colorIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible))
            return false;
        return true;
    }
    get requireNormals() { return undefined !== this.normal; }
    get pointCount() { return this.point.length; }
    get normalCount() { return this.normal ? this.normal.length : 0; }
    get paramCount() { return this.param ? this.param.length : 0; }
    get colorCount() { return this.color ? this.color.length : 0; }
    get indexCount() { return this.pointIndex.length; } // ALWAYS INDEXED ... all index vectors must have same length.
    /** Will return 0 if no faces were specified during construction. */
    get faceCount() { return this.face.length; }
    /** return indexed point. This is a copy of the coordinates, not a referenc. */
    getPoint(i) { return this.point.getPoint3dAt(i); }
    /** return indexed normal. This is the REFERENCE to the normal, not a copy. */
    getNormal(i) { return this.normal ? this.normal[i] : PointVector_1.Vector3d.create(); }
    /** return indexed param. This is the REFERENCE to the param, not a copy. */
    getParam(i) { return this.param ? this.param[i] : PointVector_1.Point2d.create(); }
    /** return indexed color */
    getColor(i) { return this.color ? this.color[i] : 0; }
    /** return indexed visibility */
    getEdgeVisible(i) { return this.edgeVisible[i]; }
    /** Copy the contents (not pointer) of point[i] into dest. */
    copyPointTo(i, dest) { this.point.getPoint3dAt(i, dest); }
    /** Copy the contents (not pointer) of normal[i] into dest. */
    copyNormalTo(i, dest) { if (this.normal)
        dest.setFrom(this.normal[i]); }
    /** Copy the contents (not pointer) of param[i] into dest. */
    copyParamTo(i, dest) { if (this.param)
        dest.setFrom(this.param[i]); }
    /**
     * * Copy data from other to this.
     * * This is the essense of transfering coordinates spread throughout a large polyface into a visitor's single facet.
     * * "other" is the large polyface
     * * "this" is the visitor
     * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!
     * @param other polyface data being mined.
     * @param index0 start index in other's index arrays
     * @param index1 end index (one beyond last data accessed0 in other's index arrays
     * @param numWrap number of points to replicate as wraparound.
     */
    gatherIndexedData(other, index0, index1, numWrap) {
        const numEdge = index1 - index0;
        const numTotal = numEdge + numWrap;
        this.resizeAllDataArrays(numTotal);
        // copy wrapped points
        for (let i = 0; i < numEdge; i++)
            this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);
        for (let i = 0; i < numWrap; i++)
            this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);
        // copy wrapped pointIndex
        for (let i = 0; i < numEdge; i++)
            this.pointIndex[i] = other.pointIndex[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.pointIndex[numEdge + i] = this.pointIndex[i];
        // copy wrapped edge visibility
        for (let i = 0; i < numEdge; i++)
            this.edgeVisible[i] = other.edgeVisible[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.edgeVisible[numEdge + i] = this.edgeVisible[i];
        if (this.normal && this.normalIndex && other.normal && other.normalIndex) {
            for (let i = 0; i < numEdge; i++)
                this.normal[i].setFrom(other.normal[other.normalIndex[index0 + i]]);
            for (let i = 0; i < numWrap; i++)
                this.normal[numEdge + i].setFrom(this.normal[i]);
            for (let i = 0; i < numEdge; i++)
                this.normalIndex[i] = other.normalIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.normalIndex[numEdge + i] = this.normalIndex[i];
        }
        if (this.param && this.paramIndex && other.param && other.paramIndex) {
            for (let i = 0; i < numEdge; i++)
                this.param[i].setFrom(other.param[other.paramIndex[index0 + i]]);
            for (let i = 0; i < numWrap; i++)
                this.param[numEdge + i].setFrom(this.param[i]);
            for (let i = 0; i < numEdge; i++)
                this.paramIndex[i] = other.paramIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.paramIndex[numEdge + i] = this.paramIndex[i];
        }
        if (this.color && this.colorIndex && other.color && other.colorIndex) {
            for (let i = 0; i < numEdge; i++)
                this.color[i] = other.color[this.colorIndex[index0 + i]];
            for (let i = 0; i < numWrap; i++)
                this.color[numEdge + i] = this.color[i];
            for (let i = 0; i < numEdge; i++)
                this.colorIndex[i] = other.colorIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.colorIndex[numEdge + i] = this.colorIndex[i];
        }
    }
    static trimArray(data, length) { if (data && length < data.length)
        data.length = length; }
    trimAllIndexArrays(length) {
        PolyfaceData.trimArray(this.pointIndex, length);
        PolyfaceData.trimArray(this.paramIndex, length);
        PolyfaceData.trimArray(this.normalIndex, length);
        PolyfaceData.trimArray(this.colorIndex, length);
        PolyfaceData.trimArray(this.edgeVisible, length);
    }
    resizeAllDataArrays(length) {
        if (length > this.point.length) {
            while (this.point.length < length)
                this.point.push(PointVector_1.Point3d.create());
            while (this.pointIndex.length < length)
                this.pointIndex.push(-1);
            while (this.edgeVisible.length < length)
                this.edgeVisible.push(false);
            if (this.normal)
                while (this.normal.length < length)
                    this.normal.push(PointVector_1.Vector3d.create());
            if (this.param)
                while (this.param.length < length)
                    this.param.push(PointVector_1.Point2d.create());
            if (this.color)
                while (this.color.length < length)
                    this.color.push(0);
        }
        else if (length < this.point.length) {
            this.point.resize(length);
            this.edgeVisible.length = length;
            this.pointIndex.length = length;
            if (this.normal)
                this.normal.length = length;
            if (this.param)
                this.param.length = length;
            if (this.color)
                this.color.length = length;
        }
    }
    range(result, transform) {
        result = result ? result : Range_1.Range3d.createNull();
        result.extendArray(this.point, transform);
        return result;
    }
    /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.
     *
     * * facetStartIndex[0] == 0 always -- start of facet zero.
     * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]
     * * hence for "internal" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.
     * *
     */
    reverseIndices(facetStartIndex) {
        if (facetStartIndex && isValidFacetStartIndexArray(facetStartIndex)) {
            reverseIndices(facetStartIndex, this.pointIndex, true);
            reverseIndices(facetStartIndex, this.normalIndex, true);
            reverseIndices(facetStartIndex, this.paramIndex, true);
            reverseIndices(facetStartIndex, this.colorIndex, true);
            reverseIndices(facetStartIndex, this.edgeVisible, false);
        }
    }
    reverseNormals() {
        if (this.normal)
            for (const normal of this.normal)
                normal.scaleInPlace(-1.0);
    }
    // This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.
    // 1) Caller must reverse normals if semanitically needed.
    // 2) Caller must reverse indices if semantically needed.
    tryTransformInPlace(transform) {
        const inverseTranspose = transform.matrix.inverse();
        this.point.transformInPlace(transform);
        if (inverseTranspose) {
            // apply simple RotMatrix to normals ...
            if (this.normal) {
                inverseTranspose.multiplyVectorArrayInPlace(this.normal);
            }
        }
        return true;
    }
    compress() {
        const packedData = ClusterableArray_1.ClusterableArray.clusterGrowablePoint3dArray(this.point);
        this.point = packedData.growablePackedPoints;
        packedData.updateIndices(this.pointIndex);
        //    if (this.paramIndex)  // Tracking uv params
        //      packedData.updateIndices(this.paramIndex);
        //    if (this.normalIndex) // Tracking normals
        //      packedData.updateIndices(this.normalIndex);
    }
}
// <ul
// <li>optional arrays (normal, uv, color) must be indicated at constructor time.
// <li>all arrays are (independently) indexed.
// <li>with regret, the point, param, normal, and color arrays are exposed publicly.
// <li>getX methods are "trusting" -- no bounds check
// <li>getX methods return references to X.
// <li> EXCEPT -- for optional arrays, the return 000.
// <li>copyX methods move data to caller-supplied result..
// </ul>
PolyfaceData.planarityLocalRelTol = 1.0e-13;
exports.PolyfaceData = PolyfaceData;
/**
 * A Polyface is n abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor
 * to iterate over its facets.
 */
class Polyface extends CurvePrimitive_1.GeometryQuery {
    constructor(data) {
        super();
        this._twoSided = false;
        this.data = data;
    }
    get twoSided() { return this._twoSided; }
    set twoSided(value) { this._twoSided = value; }
}
exports.Polyface = Polyface;
class IndexedPolyface extends Polyface {
    isSameGeometryClass(other) { return other instanceof IndexedPolyface; }
    /** Tests for equivalence between two IndexedPolyfaces. */
    isAlmostEqual(other) {
        if (other instanceof IndexedPolyface) {
            return this.data.isAlmostEqual(other.data) && PointHelpers_1.NumberArray.isExactEqual(this.facetStart, other.facetStart) &&
                PointHelpers_1.NumberArray.isExactEqual(this.facetToFaceData, other.facetToFaceData);
        }
        return false;
    }
    tryTransformInPlace(transform) {
        if (this.data.tryTransformInPlace(transform)) {
            const determinant = transform.matrix.determinant();
            if (determinant < 0) {
                this.reverseIndices();
                this.reverseNormals();
            }
        }
        return false;
    }
    clone() {
        return new IndexedPolyface(this.data.clone(), this.facetStart.slice(), this.facetToFaceData.slice());
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    reverseIndices() { this.data.reverseIndices(this.facetStart); }
    reverseNormals() { this.data.reverseNormals(); }
    /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */
    tryGetFaceData(i) {
        const faceIndex = this.facetToFaceData[i];
        if (faceIndex >= this.data.face.length)
            return undefined;
        return this.data.face[faceIndex];
    }
    constructor(data, facetStart, facetToFaceData) {
        super(data);
        if (facetStart)
            this.facetStart = facetStart.slice();
        else {
            this.facetStart = [];
            this.facetStart.push(0);
        }
        if (facetToFaceData)
            this.facetToFaceData = facetToFaceData.slice();
        else
            this.facetToFaceData = [];
    }
    /**
     * * Add facets from source to this polyface.
     * * optionally reverse the facets.
     * * optionally apply a transform to points.
     * * will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them
     */
    addIndexedPolyface(source, reversed, transform) {
        const copyParams = allDefined(this.data.param, source.data.param, source.data.paramIndex);
        const copyNormals = allDefined(this.data.normal, source.data.normal, source.data.normalIndex);
        // Add point data
        const sourceToDestPointIndex = new GrowableArray_1.GrowableFloat64Array();
        sourceToDestPointIndex.ensureCapacity(source.data.pointCount);
        const sourcePoints = source.data.point;
        const xyz = PointVector_1.Point3d.create();
        for (let i = 0, n = source.data.point.length; i < n; i++) {
            sourcePoints.getPoint3dAt(i, xyz);
            if (transform) {
                transform.multiplyPoint3d(xyz, xyz);
                sourceToDestPointIndex.push(this.addPoint(xyz));
            }
            else
                sourceToDestPointIndex.push(this.addPoint(xyz));
        }
        // Add point index and facet data
        const numSourceFacets = source.facetStart.length - 1;
        for (let i = 0; i < numSourceFacets; i++) {
            const i0 = source.facetStart[i];
            const i1 = source.facetStart[i + 1];
            if (reversed) {
                for (let j = i1; j-- > i0;) {
                    this.addPointIndex(sourceToDestPointIndex.at(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            else {
                for (let j = i0; j < i1; j++) {
                    this.addPointIndex(sourceToDestPointIndex.at(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            this.terminateFacet(false);
        }
        // Add param and param index data
        if (copyParams) {
            const startOfNewParams = this.data.param.length;
            for (const param of source.data.param) {
                const sourceParam = param.clone();
                if (transform) {
                    // TODO: Perform transformation
                    this.addParam(sourceParam);
                }
                else {
                    this.addParam(sourceParam);
                }
            }
            for (let i = 0; i < source.facetStart.length; i++) {
                const i0 = source.facetStart[i];
                const i1 = source.facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);
                }
            }
        }
        // Add normal and normal index data
        if (copyNormals) {
            const startOfNewNormals = this.data.normal.length;
            for (const normal of source.data.normal) {
                const sourceNormal = normal.clone();
                if (transform) {
                    transform.multiplyVector(sourceNormal, sourceNormal);
                    this.addNormal(sourceNormal);
                }
                else {
                    this.addNormal(sourceNormal);
                }
            }
            for (let i = 0; i < source.facetStart.length; i++) {
                const i0 = source.facetStart[i];
                const i1 = source.facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);
                }
            }
        }
        // Add color and color index data
        if (this.data.color && source.data.color && source.data.colorIndex) {
            const startOfNewColors = this.data.color.length;
            for (const sourceColor of source.data.color) {
                this.addColor(sourceColor);
            }
            for (let i = 0; i < source.facetStart.length; i++) {
                const i0 = source.facetStart[i];
                const i1 = source.facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);
                }
            }
        }
        // Add face and facetToFace index data
        if (source.data.face.length !== 0) {
            const startOfNewFaceData = this.data.face.length;
            for (const face of source.data.face) {
                const sourceFaceData = face.clone();
                this.data.face.push(sourceFaceData);
            }
            for (const facetToFaceIdx of source.facetToFaceData) {
                this.facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);
            }
        }
    }
    /** @returns Return the total number of param indices in zero-terminated style, which includes
     * * all the indices in the packed zero-based table
     * * one additional index for the zero-terminator of each facet.
     * @note Note that all index arrays (point, normal, param, color) have the same counts, so there
     * is not a separate query for each of them.
     */
    get zeroTerminatedIndexCount() { return this.data.pointIndex.length + this.facetStart.length - 1; }
    static create(needNormals = false, needParams = false, needColors = false) {
        return new IndexedPolyface(new PolyfaceData(needNormals, needParams, needColors));
    }
    /** add (a clone of ) a point. return its 0 based index.
     * @returns Returns the zero-based index of the added point.
     */
    addPoint(point) { this.data.point.pushXYZ(point.x, point.y, point.z); return this.data.point.length - 1; }
    /** add a point.
     * @returns Returns the zero-based index of the added point.
     */
    addPointXYZ(x, y, z) { this.data.point.push(PointVector_1.Point3d.create(x, y, z)); return this.data.point.length - 1; }
    addParam(param) {
        if (!this.data.param)
            this.data.param = [];
        this.data.param.push(param.clone());
        return this.data.param.length - 1;
    }
    addParamXY(x, y) {
        if (!this.data.param)
            this.data.param = [];
        this.data.param.push(PointVector_1.Point2d.create(x, y));
        return this.data.param.length - 1;
    }
    addNormal(normal) {
        if (!this.data.normal)
            this.data.normal = [];
        this.data.normal.push(normal.clone());
        return this.data.normal.length - 1;
    }
    addNormalXYZ(x, y, z) {
        if (!this.data.normal)
            this.data.normal = [];
        this.data.normal.push(PointVector_1.Vector3d.create(x, y, z));
        return this.data.normal.length - 1;
    }
    addColor(color) {
        if (!this.data.color)
            this.data.color = [];
        this.data.color.push(color);
        return this.data.color.length - 1;
    }
    addPointIndex(index, visible = true) { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }
    addNormalIndex(index) {
        if (!this.data.normalIndex)
            this.data.normalIndex = [];
        this.data.normalIndex.push(index);
    }
    addParamIndex(index) {
        if (!this.data.paramIndex)
            this.data.paramIndex = [];
        this.data.paramIndex.push(index);
    }
    addColorIndex(index) {
        if (!this.data.colorIndex)
            this.data.colorIndex = [];
        this.data.colorIndex.push(index);
    }
    /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet("message")) */
    cleanupOpenFacet() {
        this.data.trimAllIndexArrays(this.data.pointIndex.length);
    }
    /** announce the end of construction of a facet.
     *
     * * The "open" facet is checked for:
     *
     * **  Same number of indices among all active index arrays --  point, normal, param, color
     * **  All indices are within bounds of the respective data arrays.
     * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.
     * *  "undefined" return is normal.   Any other return is a description of an error.
     */
    terminateFacet(validateAllIndices = true) {
        const numFacets = this.facetStart.length - 1;
        const lengthA = this.facetStart[numFacets]; // number of indices in accepted facets
        const lengthB = this.data.pointIndex.length; // number of indices including the open facet
        if (validateAllIndices) {
            const messages = [];
            if (lengthB < lengthA + 2)
                messages.push("Less than 3 indices in open facet");
            if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)
                messages.push("normalIndex count must match pointIndex count");
            if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)
                messages.push("paramIndex count must equal pointIndex count");
            if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)
                messages.push("colorIndex count must equal pointIndex count");
            if (this.data.edgeVisible.length !== lengthB)
                messages.push("visibleIndex count must equal pointIndex count");
            if (!areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal))
                messages.push("invalid normal indices in open facet");
            if (messages.length > 0) {
                this.cleanupOpenFacet();
                return messages;
            }
        }
        // appending to facetStart accepts the facet !!!
        this.facetStart.push(lengthB);
        return undefined;
    }
    /**
     * All terminated facets added since the declaration of the previous face
     * will be grouped into a new face with their own 2D range.
     */
    /** (read-only property) number of facets */
    get facetCount() { return this.facetStart.length - 1; }
    /** (read-only property) number of faces */
    get faceCount() { return this.data.face.length; }
    /** (read-only property) number of points */
    get pointCount() { return this.data.pointCount; }
    /** (read-only property) number of colors */
    get colorCount() { return this.data.colorCount; }
    /** (read-only property) number of parameters */
    get paramCount() { return this.data.paramCount; }
    /** (read-only property) number of normals */
    get normalCount() { return this.data.normalCount; }
    numEdgeInFacet(facetIndex) {
        if (this.isValidFacetIndex(facetIndex))
            return this.facetStart[facetIndex + 1] - this.facetStart[facetIndex];
        return 0;
    }
    isValidFacetIndex(index) { return index >= 0 && index + 1 < this.facetStart.length; }
    /** ASSUME valid facet index . .. return its start index in index arrays. */
    facetIndex0(index) { return this.facetStart[index]; }
    /** ASSUME valid facet index . .. return its end index in index arrays. */
    facetIndex1(index) { return this.facetStart[index + 1]; }
    /** create a visitor for this polyface */
    createVisitor(numWrap = 0) { return IndexedPolyfaceVisitor.create(this, numWrap); }
    range(transform, result) { return this.data.range(result, transform); }
    extendRange(range, transform) { this.data.range(range, transform); }
    /** Given the index of a facet, return the data pertaining to the face it is a part of. */
    getFaceDataByFacetIndex(facetIndex) {
        return this.data.face[this.facetToFaceData[facetIndex]];
    }
    /** Given the index of a face, return the range of that face. */
    getFaceDataByFaceIndex(faceIndex) {
        return this.data.face[faceIndex];
    }
    /**
     * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object
     * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.
     */
    setNewFaceData(endFacetIndex = 0) {
        const facetStart = this.facetToFaceData.length;
        if (facetStart >= this.facetStart.length)
            return false;
        if (0 === endFacetIndex)
            endFacetIndex = this.facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one
        const faceData = FacetFaceData.createNull();
        const visitor = IndexedPolyfaceVisitor.create(this, 0);
        if (!visitor.moveToReadIndex(facetStart)) {
            return false;
        }
        // If parameter range is provided (by the polyface planeset clipper) then use it
        const paramDefined = this.data.param !== undefined;
        const setParamRange = faceData.paramRange.isNull() && paramDefined;
        do {
            for (let i = 0; i < visitor.numEdgesThisFacet; i++) {
                if (setParamRange && visitor.param !== undefined)
                    faceData.paramRange.extendPoint(visitor.param[i]);
            }
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);
        if (paramDefined && !(this.data.param.length === 0) && faceData.paramDistanceRange.isNull())
            faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);
        this.data.face.push(faceData);
        const faceDataIndex = this.data.face.length - 1;
        for (let i = this.facetToFaceData.length; i < endFacetIndex; i++)
            this.facetToFaceData.push(0 === this.facetStart[i] ? 0 : faceDataIndex);
        return true;
    }
    /** TODO: IMPLEMENT */
    isClosedByEdgePairing() {
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleIndexedPolyface(this);
    }
}
exports.IndexedPolyface = IndexedPolyface;
class IndexedPolyfaceVisitor extends PolyfaceData {
    // to be called from static factory method that validates the polyface ...
    constructor(facets, numWrap) {
        super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0);
        this.polyface = facets;
        this.numWrap = numWrap;
        this.reset();
        this.numEdges = 0;
        this.nextFacetIndex = 0;
        this.currentFacetIndex = -1;
    }
    get numEdgesThisFacet() { return this.numEdges; }
    static create(polyface, numWrap) {
        return new IndexedPolyfaceVisitor(polyface, numWrap);
    }
    moveToReadIndex(facetIndex) {
        if (!this.polyface.isValidFacetIndex(facetIndex))
            return false;
        this.currentFacetIndex = facetIndex;
        this.nextFacetIndex = facetIndex + 1;
        this.numEdges = this.polyface.numEdgeInFacet(facetIndex);
        this.resizeAllDataArrays(this.numEdges + this.numWrap);
        this.gatherIndexedData(this.polyface.data, this.polyface.facetIndex0(this.currentFacetIndex), this.polyface.facetIndex1(this.currentFacetIndex), this.numWrap);
        return true;
    }
    moveToNextFacet() {
        if (this.nextFacetIndex !== this.currentFacetIndex)
            return this.moveToReadIndex(this.nextFacetIndex);
        this.nextFacetIndex++;
        return true;
    }
    reset() {
        this.moveToReadIndex(0);
        this.nextFacetIndex = 0; // so immediate moveToNextFacet stays here.
    }
    /**
     * Attempts to extract the distance parameter for the face of a given point index.
     * Returns the distance parameter as a point. Returns undefined on failure.
     */
    tryGetDistanceParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this.polyface.data.face.length === 0)
            return undefined;
        const faceData = this.polyface.tryGetFaceData(this.currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamToDistance(this.param[index], result);
    }
    /**
     * Attempts to extract the normalized parameter (0,1) for the face of a given point index.
     * Returns the normalized parameter as a point. Returns undefined on failure.
     */
    tryGetNormalizedParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this.polyface.data.face.length === 0)
            return undefined;
        const faceData = this.polyface.tryGetFaceData(this.currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamToNormalized(this.param[index], result);
    }
    currentReadIndex() { return this.currentFacetIndex; }
    clientPointIndex(i) { return this.pointIndex[i]; }
    clientParamIndex(i) { return this.paramIndex ? this.paramIndex[i] : -1; }
    clientNormalIndex(i) { return this.normalIndex ? this.normalIndex[i] : -1; }
    clientColorIndex(i) { return this.colorIndex ? this.colorIndex[i] : -1; }
}
exports.IndexedPolyfaceVisitor = IndexedPolyfaceVisitor;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
// @todo Needs to be commented out in a production environment.
/**
 * Assert by throwing a programmer error
 */
function assert(condition, msg) {
    if (!condition)
        throw new Error("Assert: " + ((msg !== undefined) ? msg : "Programmer Error"));
}
exports.assert = assert;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(40)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const AnalyticGeometry_1 = __webpack_require__(11);
const GraphicBuilder_1 = __webpack_require__(122);
const imodeljs_common_1 = __webpack_require__(2);
const System_1 = __webpack_require__(17);
const FeatureSymbology_1 = __webpack_require__(73);
const gridConstants = { maxGridPoints: 50, maxGridRefs: 25, maxGridDotsInRow: 250, maxHorizonGrids: 500, gridDotTransparency: 100, gridLineTransparency: 200, gridPlaneTransparency: 225 };
class ViewContext {
    constructor(vp) {
        this.viewport = vp;
        this.viewFlags = vp.viewFlags.clone(); // viewFlags can diverge from viewport after attachment
        this.frustum = vp.getFrustum();
        this.frustumPlanes = new imodeljs_common_1.FrustumPlanes(this.frustum);
    }
    getPixelSizeAtPoint(inPoint) {
        const vp = this.viewport;
        const viewPt = !!inPoint ? vp.worldToView(inPoint) : vp.npcToView(new geometry_core_1.Point3d(0.5, 0.5, 0.5));
        const viewPt2 = new geometry_core_1.Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);
        return vp.viewToWorld(viewPt).distance(vp.viewToWorld(viewPt2));
    }
}
exports.ViewContext = ViewContext;
class NullContext extends ViewContext {
}
exports.NullContext = NullContext;
class DynamicsContext extends ViewContext {
}
exports.DynamicsContext = DynamicsContext;
class RenderContext extends ViewContext {
    constructor(vp) { super(vp); }
    get target() { return this.viewport.target; }
    createGraphic(tf, type) {
        return this.target.createGraphic(GraphicBuilder_1.GraphicBuilderCreateParams.create(type, this.viewport, tf));
    }
    createBranch(branch, location, clip) {
        return this.target.renderSystem.createBranch(branch, location, clip);
    }
}
exports.RenderContext = RenderContext;
class DecorateContext extends RenderContext {
    constructor(vp, decorations = new System_1.Decorations()) {
        super(vp);
        this.decorations = decorations;
    }
    /** wrapped nRepetitions and min in object to preserve changes */
    static getGridDimension(props, gridSize, org, dir, points) {
        // initialized only to avoid warning.
        let distLow = 0.0;
        let distHigh = 0.0;
        for (let i = 0, n = points.length; i < n; ++i) {
            const distance = org.vectorTo(points[i]).dotProduct(dir);
            if (i) {
                if (distance < distLow)
                    distLow = distance;
                if (distance > distHigh)
                    distHigh = distance;
            }
            else {
                distLow = distHigh = distance;
            }
        }
        if (distHigh <= distLow)
            return false;
        props.min = Math.floor(distLow / gridSize); // NOTE: Should be ok to let grid extend outside project extents since view extends padded for ground plane...
        const max = Math.ceil(distHigh / gridSize);
        props.nRepetitions = max - props.min;
        props.min *= gridSize;
        return true;
    }
    static getGridPlaneViewIntersections(planePoint, planeNormal, vp, useProjectExtents) {
        const limitRange = useProjectExtents && vp.view.isSpatialView();
        let range = new geometry_core_1.Range3d();
        // Limit non-view aligned grid to project extents in spatial views...
        if (limitRange) {
            range = vp.view.iModel.projectExtents.clone();
            if (range.isNull())
                return [];
        }
        const index = new Array(
        // lines connecting front to back
        [0 /* _000 */, 4 /* _001 */], [1 /* _100 */, 5 /* _101 */], [2 /* _010 */, 6 /* _011 */], [3 /* _110 */, 7 /* _111 */], 
        // around front face
        [0 /* _000 */, 1 /* _100 */], [1 /* _100 */, 3 /* _110 */], [3 /* _110 */, 2 /* _010 */], [2 /* _010 */, 0 /* _000 */], 
        // around back face.
        [4 /* _001 */, 5 /* _101 */], [5 /* _101 */, 7 /* _111 */], [7 /* _111 */, 6 /* _011 */], [6 /* _011 */, 4 /* _001 */]);
        const frust = vp.getFrustum();
        limitRange ? range.intersect(frust.toRange(), range) : frust.toRange(range);
        frust.initFromRange(range); // equivalent to: range.Get8Corners(frust.m_pts);
        const plane = AnalyticGeometry_1.Plane3dByOriginAndUnitNormal.create(planePoint, planeNormal);
        if (undefined === plane)
            return [];
        const intersections = [];
        for (let i = 0, n = index.length; i < n; ++i) {
            const corner1 = frust.getCorner(index[i][0]), corner2 = frust.getCorner(index[i][1]);
            const lineSegment = geometry_core_1.LineSegment3d.create(corner1, corner2);
            lineSegment.appendPlaneIntersectionPoints(plane, intersections);
        }
        return intersections.map((cld) => cld.point.clone());
    }
    addNormal(graphic) {
        if (undefined === this.decorations.normal)
            this.decorations.normal = [];
        this.decorations.normal.push(graphic);
    }
    /** Display world coordinate graphic with smooth shading, default lighting, and z testing enabled. */
    addWorldDecoration(graphic, ovr) {
        if (!this.decorations.world)
            this.decorations.world = new System_1.DecorationList();
        this.decorations.world.add(graphic, ovr);
    }
    /** Display world coordinate graphic with smooth shading, default lighting, and z testing disabled. */
    addWorldOverlay(graphic, ovr) {
        if (!this.decorations.worldOverlay)
            this.decorations.worldOverlay = new System_1.DecorationList();
        this.decorations.worldOverlay.add(graphic, ovr);
    }
    /** Display view coordinate graphic with smooth shading, default lighting, and z testing disabled. */
    addViewOverlay(graphic, ovr) {
        if (!this.decorations.viewOverlay)
            this.decorations.viewOverlay = new System_1.DecorationList();
        this.decorations.viewOverlay.add(graphic, ovr);
    }
    /**
     * Display a sprite as view overlay graphic.
     * @param sprite The sprite to draw
     * @param location The location of the sprite, in view coordinates
     * @param xVec The orientation of the sprite, in view coordinates
     * @param transparency The transparency of the sprite (0-255, 0 == fully opaque)
     */
    addSprite(sprite, location, xVec, transparency) {
        if (!sprite.texture)
            return; // sprite not loaded
        const xVector = new geometry_core_1.Vector3d(xVec.x, xVec.y, 0);
        const yVector = xVector.rotate90CCWXY();
        xVector.scaleToLength(sprite.size.x, xVector);
        yVector.scaleToLength(sprite.size.y, yVector);
        const org = new geometry_core_1.Point3d(location.x - (sprite.size.x * 0.5), location.y - (sprite.size.y * 0.5), 0.0);
        const xCorn = org.plus(xVector);
        let ovr;
        if (transparency > 0)
            ovr = FeatureSymbology_1.FeatureSymbology.Appearance.fromJSON({ alpha: 255 - transparency });
        this.addViewOverlay(this.target.renderSystem.createTile(sprite.texture, [org, xCorn, org.plus(yVector), xCorn.plus(yVector)]), ovr);
    }
    /** @private */
    drawStandardGrid(gridOrigin, rMatrix, spacing, gridsPerRef, isoGrid = false, fixedRepetitions) {
        const vp = this.viewport;
        // rotMatrix returns new Vectors instead of references
        const xVec = rMatrix.rowX(), yVec = rMatrix.rowY(), zVec = rMatrix.rowZ(), viewZ = vp.rotMatrix.getRow(2);
        if (!vp.isCameraOn() && Math.abs(viewZ.dotProduct(zVec)) < 0.005)
            return;
        const refScale = (0 === gridsPerRef) ? 1.0 : gridsPerRef;
        const refSpacing = geometry_core_1.Vector2d.create(spacing.x, spacing.y).scale(refScale);
        let gridOrg = new geometry_core_1.Point3d();
        let repetitions = new geometry_core_1.Point2d();
        if (undefined === fixedRepetitions || 0 === fixedRepetitions.x || 0 === fixedRepetitions.y) {
            // expect gridOrigin and zVec to be modified from this call
            const intersections = DecorateContext.getGridPlaneViewIntersections(gridOrigin, zVec, vp, undefined !== fixedRepetitions);
            if (intersections.length < 3)
                return;
            const min = new geometry_core_1.Point2d(), xProps = { nRepetitions: repetitions.x, min: min.x }, yProps = { nRepetitions: repetitions.y, min: min.y };
            if (!DecorateContext.getGridDimension(xProps, refSpacing.x, gridOrigin, geometry_core_1.Point3d.createFrom(xVec), intersections) ||
                !DecorateContext.getGridDimension(yProps, refSpacing.y, gridOrigin, geometry_core_1.Point3d.createFrom(yVec), intersections))
                return;
            // update vectors. (workaround for native passing primitives by reference)
            repetitions.x = xProps.nRepetitions;
            min.x = xProps.min;
            repetitions.y = yProps.nRepetitions;
            min.y = yProps.min;
            gridOrg.plus3Scaled(gridOrigin, 1, xVec, min.x, yVec, min.y, gridOrg);
        }
        else {
            gridOrg = gridOrigin;
            repetitions = fixedRepetitions;
        }
        if (0 === repetitions.x || 0 === repetitions.y)
            return;
        const gridX = xVec.scale(refSpacing.x), gridY = yVec.scale(refSpacing.y);
        const testPt = gridOrg.plus2Scaled(gridX, repetitions.x / 2.0, gridY, repetitions.y / 2.0);
        let maxGridPts = gridConstants.maxGridPoints;
        let maxGridRefs = gridConstants.maxGridRefs;
        if (maxGridPts < 10)
            maxGridPts = 10;
        if (maxGridRefs < 10)
            maxGridRefs = 10;
        // values are "per 1000 pixels"
        const minGridSeparationPixels = 1000 / maxGridPts, minRefSeparation = 1000 / maxGridRefs;
        let uorPerPixel = vp.getPixelSizeAtPoint(testPt);
        if ((refSpacing.x / uorPerPixel) < minRefSeparation || (refSpacing.y / uorPerPixel) < minRefSeparation)
            gridsPerRef = 0;
        // Avoid z fighting with coincident geometry
        gridOrg.plusScaled(viewZ, uorPerPixel, gridOrg); // was SumOf(DPoint2dCR point, DPoint2dCR vector, double s)
        uorPerPixel *= refScale;
        const drawDots = ((refSpacing.x / uorPerPixel) > minGridSeparationPixels) && ((refSpacing.y / uorPerPixel) > minGridSeparationPixels);
        const graphic = this.createWorldDecoration();
        DecorateContext.drawGrid(graphic, isoGrid, drawDots, gridOrg, gridX, gridY, gridsPerRef, repetitions, vp);
        this.addWorldDecoration(graphic.finish());
    }
    static drawGrid(graphic, doIsogrid, drawDots, gridOrigin, xVec, yVec, gridsPerRef, repetitions, vp) {
        const eyePoint = vp.worldToViewMap.transform1.columnZ();
        const viewZ = geometry_core_1.Vector3d.createFrom(eyePoint);
        const aa = geometry_core_1.Geometry.conditionalDivideFraction(1, eyePoint.w);
        if (aa !== undefined) {
            const xyzEye = viewZ.scale(aa);
            viewZ.setFrom(gridOrigin.vectorTo(xyzEye));
        }
        let normResult = viewZ.normalize(viewZ);
        if (!normResult)
            return;
        const zVec = xVec.crossProduct(yVec);
        normResult = zVec.normalize(zVec);
        if (!normResult)
            return;
        const color = vp.getContrastToBackgroundColor();
        const lineColor = color.clone();
        const dotColor = color.clone();
        const planeColor = color.clone();
        lineColor.setTransparency(gridConstants.gridLineTransparency);
        dotColor.setTransparency(gridConstants.gridDotTransparency);
        planeColor.setTransparency(gridConstants.gridPlaneTransparency);
        let linePat = 0 /* Solid */;
        if (viewZ.dotProduct(zVec) < 0.0) {
            planeColor.setFrom(imodeljs_common_1.ColorDef.red);
            planeColor.setTransparency(gridConstants.gridPlaneTransparency);
            linePat = 4177066232 /* Code2 */;
        }
        const gpr = gridsPerRef > 0 ? gridsPerRef : 1;
        const rpg = 1 / gpr;
        if (doIsogrid)
            gridsPerRef = 0; // turn off reference grid for iso
        if (drawDots) {
            const dotXVec = geometry_core_1.Vector3d.createFrom(xVec);
            const dotYVec = geometry_core_1.Vector3d.createFrom(yVec);
            dotXVec.scale(rpg, dotXVec);
            dotYVec.scale(rpg, dotYVec);
            graphic.setSymbology(dotColor, planeColor, 1);
            DecorateContext.drawGridDots(graphic, doIsogrid, gridOrigin, dotYVec, repetitions.y * gpr, dotXVec, repetitions.x * gpr, gridsPerRef, vp);
        }
        if (0 < gridsPerRef) {
            graphic.setSymbology(lineColor, planeColor, 1, linePat);
            DecorateContext.drawGridRefs(graphic, gridOrigin, xVec, yVec, repetitions.x, repetitions.y);
            DecorateContext.drawGridRefs(graphic, gridOrigin, yVec, xVec, repetitions.y, repetitions.x);
        }
        // don't draw grid plane if perpendicular to view
        if (viewZ.isPerpendicularTo(xVec))
            return;
        // grid refs or points will give visual indication of grid plane...
        // note: references to same points here are okay
        const shapePoints = [
            gridOrigin,
            gridOrigin.plusScaled(xVec, repetitions.x),
            gridOrigin.plus2Scaled(xVec, repetitions.x, yVec, repetitions.y),
            gridOrigin.plusScaled(yVec, repetitions.y),
            gridOrigin,
        ];
        if (0 === gridsPerRef) {
            graphic.setSymbology(lineColor, planeColor, 1, linePat);
            graphic.addLineString(shapePoints);
        }
        graphic.setBlankingFill(planeColor);
        graphic.addShape(shapePoints);
    }
    /** Private grid-specific function for computing intersections of a ray with a convex set of clipping planes. */
    static getClipPlaneIntersection(clipDistance, origin, direction, convexSet) {
        clipDistance.min = -Number.MAX_VALUE;
        clipDistance.max = Number.MAX_VALUE;
        for (let i = 0; i < 6; i++) {
            const plane = convexSet.planes[i];
            const vD = plane.dotProductVector(direction);
            const vN = plane.evaluatePoint(origin);
            const testValue = -vN / vD;
            if (vD > 0.0) {
                if (testValue > clipDistance.min)
                    clipDistance.min = testValue;
            }
            else if (vD < 0.0) {
                if (testValue < clipDistance.max)
                    clipDistance.max = testValue;
            }
        }
        return clipDistance.min < clipDistance.max;
    }
    static drawGridDots(graphic, doIsoGrid, origin, rowVec, rowRepetitions, colVec, colRepetitions, refSpacing, vp) {
        const colSpacing = colVec.magnitude();
        const colNormal = colVec.normalize();
        if (!colNormal)
            return;
        const points = [];
        const cameraOn = vp.isCameraOn();
        let zCamera = 0.0;
        let zCameraLimit = 0.0;
        const viewZ = geometry_core_1.Vector3d.create();
        if (cameraOn) {
            const view = vp.view;
            const camera = view.camera;
            const sizeLimit = gridConstants.maxHorizonGrids * colSpacing / vp.viewDelta.x;
            vp.rotMatrix.rowZ(viewZ);
            zCamera = viewZ.dotProduct(camera.getEyePoint());
            zCameraLimit = zCamera - camera.focusDist * sizeLimit;
        }
        const corners = vp.getFrustum();
        const clipPlanes = corners.getRangePlanes(true, true, 0);
        const clipDistance = { min: 0, max: 0 };
        for (let i = 0; i < rowRepetitions; i++) {
            if (0 !== refSpacing && 0 === (i % refSpacing))
                continue;
            const dotOrigin = origin.plusScaled(rowVec, i);
            if (DecorateContext.getClipPlaneIntersection(clipDistance, dotOrigin, colNormal, clipPlanes)) {
                if (cameraOn) {
                    const startPoint = dotOrigin.plusScaled(colNormal, clipDistance.min);
                    const endPoint = dotOrigin.plusScaled(colNormal, clipDistance.max);
                    if (viewZ.dotProduct(startPoint) < zCameraLimit && viewZ.dotProduct(endPoint) < zCameraLimit)
                        continue;
                }
                let nToDisplay = 0;
                let jMin = Math.floor(clipDistance.min / colSpacing);
                let jMax = Math.ceil(clipDistance.max / colSpacing);
                // Choose values that result in the least amount of dots between jMin-jMax and 0-colRepetitions...
                jMin = jMin < 0 ? 0 : jMin;
                jMax = jMax > colRepetitions ? colRepetitions : jMax;
                const isoOffset = doIsoGrid && (i & 1) ? 0.5 : 0.0;
                for (let j = jMin; j <= jMax && nToDisplay < gridConstants.maxGridDotsInRow; j++) {
                    if (0 !== refSpacing && 0 === (j % refSpacing))
                        continue;
                    const point = dotOrigin.plusScaled(colVec, j + isoOffset);
                    if (cameraOn) {
                        const pointZ = viewZ.dotProduct(point);
                        if (pointZ < zCamera && pointZ > zCameraLimit)
                            points.push(point);
                    }
                    else {
                        points.push(point);
                    }
                    nToDisplay++;
                }
            }
        }
        if (points.length !== 0)
            graphic.addPointString(points);
    }
    static drawGridRefs(graphic, org, rowVec, colVec, rowRepetitions, colRepetitions) {
        const gridEnd = org.plusScaled(colVec, colRepetitions);
        for (let i = 0; i <= rowRepetitions; i += 1) {
            const linePoints = [
                org.plusScaled(rowVec, i),
                gridEnd.plusScaled(rowVec, i),
            ];
            graphic.addLineString(linePoints);
        }
    }
    /** Display skyBox (cube) graphic which encompasses entire scene and rotates with camera.  See RenderSystem.createSkyBox(). */
    setSkyBox(graphic) { this.decorations.skyBox = graphic; }
    /** Display view coordinate graphic as background with smooth shading, default lighting, and z testing disabled. e.g., a sky box. */
    setViewBackground(graphic) { this.decorations.viewBackground = graphic; }
    createViewBackground(tf = geometry_core_1.Transform.createIdentity()) { return this.createGraphic(tf, 0 /* ViewBackground */); }
    createWorldDecoration(tf = geometry_core_1.Transform.createIdentity()) { return this.createGraphic(tf, 2 /* WorldDecoration */); }
    createWorldOverlay(tf = geometry_core_1.Transform.createIdentity()) { return this.createGraphic(tf, 3 /* WorldOverlay */); }
    createViewOverlay(tf = geometry_core_1.Transform.createIdentity()) { return this.createGraphic(tf, 4 /* ViewOverlay */); }
}
exports.DecorateContext = DecorateContext;
class SceneContext extends RenderContext {
    constructor(vp, requests) {
        super(vp);
        this.graphics = [];
        this.requests = requests;
    }
    outputGraphic(graphic) { this.graphics.push(graphic); }
}
exports.SceneContext = SceneContext;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const IModelApp_1 = __webpack_require__(5);
const ImageUtil_1 = __webpack_require__(72);
/**
 * Sprites are small raster images that are drawn *on top* of Viewports by a ViewDecoration.
 * Their purpose is to draw the user's attention to something of importance.
 *
 * There are two classes in the Sprites subsystem: Sprite (a Sprite Definition) and SpriteLocation.
 * Sprite Definitions are the images that define the way a type of sprite looks and are generally
 * loaded one time and saved for the rest of a session. A SpriteLocation defines the current
 * position of a single Sprite in a Viewport.
 *
 * A SpriteLocation can be either active or inactive. It becomes active by specifying a location
 * (an x,y point) and a Sprite Definition to draw at that point. It should be obvious that a single Sprite
 * Definition can be used many times by many Sprite Locations and that a single Sprite Location can
 * change both position and which Sprite Definition is shown at that position over time.
 *
 * Sprites can be of varying sizes and color depths and can have both opaque and transparent pixels.
 *
 * Element Manipulator handles and the AccuSnap indicators are examples of Sprites.
 * @note It is also possible to draw a Sprite onto a Viewport directly
 * without ever using a SpritLocation. SpriteLocations are merely provided as a convenience.
 */
class Sprite {
    constructor() {
        /** The size of the sprite, in pixels */
        this.size = new geometry_core_1.Point2d();
    }
    /** Dispose of this Sprite. Disposes of texture, if present. */
    dispose() { this.texture = bentleyjs_core_1.dispose(this.texture); }
    /** Initialize this sprite from a .png file located in the imodeljs-native assets directory.
     * @param filePath The file path of the PNG file holding the sprite texture (relative to the assets directory.)
     * @param iModel An IModelConnection used to locate the backend server. Note that this method does not associate this Sprite with the iModel
     * in any way. It is merely necessary to route the request to the backend.
     * @note This method loads the .png file asynchronously. The [[texture]] member will be undefined until the data is loaded.
     */
    fromNativePng(filePath, iModel) {
        iModel.loadNativeAsset(filePath).then((val) => this.fromImageSource(new imodeljs_common_1.ImageSource(val, 2 /* Png */))).catch(() => {
            bentleyjs_core_1.Logger.logError("imodeljs-frontend.Sprites", "can't load sprite from asset file: " + filePath);
        });
    }
    /** Initialize this Sprite from an ImageSource.
     * @param src The ImageSource holding an image to create the texture for this Sprite.
     * @note This method creates the texture from the ImageSource asynchronously. The texture will appear as a white square until it is fully loaded.
     */
    fromImageSource(src) {
        ImageUtil_1.ImageUtil.extractImage(src).then((image) => {
            this.size.x = image.naturalWidth;
            this.size.y = image.naturalHeight;
            if (IModelApp_1.IModelApp.hasRenderSystem)
                this.texture = IModelApp_1.IModelApp.renderSystem.createTextureFromImage(image, true, undefined, new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */));
        });
    }
}
exports.Sprite = Sprite;
/** Icon sprites are loaded from .png files in the assets directory of imodeljs-native.
 * They are cached by name, and the cache is cleared when the ToolAdmin is shut down.
 */
class IconSprites {
    /** Look up an IconSprite by name. If not loaded, create and load it.
     * @param spriteName The base name (without ".png") of a PNG file in the `decorators/dgncore` subdirectory of the `Assets` directory of the imodeljs-native package.
     * @param vp A Viewport used to find the IModelConnection
     */
    static getSprite(spriteName, vp) {
        let sprite = this._sprites.get(spriteName);
        if (!sprite) {
            sprite = new Sprite();
            this._sprites.set(spriteName, sprite);
            sprite.fromNativePng("decorators/dgncore/" + spriteName + ".png", vp.iModel); // note: asynchronous
        }
        return sprite;
    }
    /** Empty the cache, disposing all existing Sprites. */
    static emptyAll() { this._sprites.forEach((sprite) => sprite.dispose()); this._sprites.clear(); }
}
IconSprites._sprites = new Map();
exports.IconSprites = IconSprites;
/**
 * A Sprite Location. Sprites generally move around on the screen and this object holds the current location
 * and current Sprite for an image of a sprite within a Viewport. SpriteLocations can be either
 * inactive (not visible) or active.
 *
 * A SpriteLocation can also specify that a Sprite should be drawn partially transparent so that
 * you can "see through" the Sprite.
 */
class SpriteLocation {
    constructor() {
        /** The location of the sprite, in *view* coordinates. */
        this.viewLocation = new geometry_core_1.Point3d();
        this.transparency = 0;
    }
    get isActive() { return this.viewport !== undefined; }
    /** Change the location of this SpriteLocation from a point in *world* coordinates. */
    setLocationWorld(location) { this.viewport.worldToView(location, this.viewLocation); }
    /**
     * Activate this SpriteLocation to show a Sprite at a location in a Viewport.
     * This call does not display the Sprite in the Viewport. Rather, subsequent calls to
     * [[decorate]] from  will show the Sprite.
     * This SpriteLocation remains active until [[deactivate]] is called.
     * @param sprite  The Sprite to draw at this SpriteLocation
     * @param viewport The Viewport onto which the Sprite is drawn
     * @param location The position, in world coordinates
     * @param transparency The transparency to draw the Sprite (0=opaque, 255=invisible)
     */
    activate(sprite, viewport, location, transparency) {
        viewport.invalidateDecorations();
        this.viewport = viewport;
        this.sprite = sprite;
        this.transparency = transparency;
        this.setLocationWorld(location);
    }
    /** Turn this SpriteLocation off so it will no longer show in its Viewport. */
    deactivate() {
        if (!this.isActive)
            return;
        this.viewport.invalidateDecorations();
        this.viewport = undefined;
        this.sprite = undefined;
    }
    /** If this SpriteLocation is active and the supplied DecorateContext is for its Viewport, add the Sprite to the context at the current location. */
    decorate(context) {
        if (context.viewport === this.viewport && this.sprite)
            context.addSprite(this.sprite, this.viewLocation, geometry_core_1.Vector3d.unitX(), this.transparency);
    }
}
exports.SpriteLocation = SpriteLocation;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(15);
const bentleyjs_core_1 = __webpack_require__(0);
const IModelApp_1 = __webpack_require__(5);
const AccuDrawTool_1 = __webpack_require__(132);
const NotificationManager_1 = __webpack_require__(123);
/**
 * The PrimitiveTool class can be used to implement a primitive command. Placement
 * tools that don't need to locate or modify elements are good candidates for a PrimitiveTool.
 */
class PrimitiveTool extends Tool_1.InteractiveTool {
    constructor() {
        super(...arguments);
        this.targetModelId = new bentleyjs_core_1.Id64();
        this.targetIsLocked = false; // If target model is known, set this to true in constructor and override getTargetModel.
        this.toolStateId = ""; // Tool State Id can be used to determine prompts and control UI control state.
        // //! Ensures that any locks and/or codes required for the operation are obtained from iModelServer before making any changes to the iModel.
        // //! Default implementation invokes _PopulateRequest() and forwards request to server.
        //  RepositoryStatus _AcquireLocks();
        // //! Called from _AcquireLocks() to identify any locks and/or codes required to perform the operation
        // virtual RepositoryStatus _PopulateRequest(IBriefcaseManager:: Request & request) { return RepositoryStatus:: Success; }
        // //! Query availability of locks, potentially notifying user of result
        //  bool AreLocksAvailable(IBriefcaseManager:: Request & request, iModelR db, bool fastQuery = true);
        // //! Acquire locks on this tools behalf, potentially notifying user of result
        //  RepositoryStatus AcquireLocks(IBriefcaseManager:: Request & request, iModelR db);
        // //! Acquire a shared lock on the specified model (e.g., for placement tools which create new elements)
        //  RepositoryStatus LockModelForPlacement(DgnModelR model);
        // //! Acquires any locks and/or codes required to perform the specified operation on the element
        // //! If your tool operates on more than one element it should batch all such requests rather than calling this convenience function repeatedly.
        //  RepositoryStatus LockElementForOperation(DgnElementCR element, BeSQLite:: DbOpcode operation);
    }
    /** Get the iModel the tool is operating against. */
    get iModel() { return this.targetView.view.iModel; }
    /**
     * ( was DgnPrimitiveTool::_InstallToolImplementation )
     * can be directly called ( instead of the code that would execute when installTool is called )
     * Establish this tool as the active PrimitiveTool.
     * @return SUCCESS if this tool is now the active PrimitiveTool.
     * @see InteractiveTool.onInstall
     * @see InteractiveTool.onPostInstall
     */
    run() {
        const { toolAdmin, viewManager } = IModelApp_1.IModelApp;
        if (!this.isCompatibleViewport(viewManager.selectedView, false) || !toolAdmin.onInstallTool(this))
            return false;
        toolAdmin.startPrimitiveTool(this);
        toolAdmin.setPrimitiveTool(this);
        // The tool may exit in _OnPostInstall causing "this" to be
        // deleted so _InstallToolImplementation must not call any
        // methods on "this" after _OnPostInstall returns.
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    /**
     * Determine whether the supplied Viewport is compatible with this tool.
     * @param vp the Viewport to check
     */
    isCompatibleViewport(vp, isSelectedViewChange) {
        if (undefined === vp)
            return false; // No views are open...
        const view = vp.view;
        const iModel = view.iModel;
        if (this.requireWriteableTarget()) {
            if (iModel.isReadonly()) {
                // IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, IModelApp.i18n.translate("DgnViewL10N::MSG_UnableToStartTool_FileIsReadOnly"))); ###TODO find correct i18n message code
                return false; // Tool can't be used when iModel is read only.
            }
            // ###TODO lock specific code
            // IBriefcaseManager:: Request req;
            // req.Locks().Insert(db, LockLevel:: Shared);
            // if (!db.BriefcaseManager().AreResourcesAvailable(req, nullptr, IBriefcaseManager:: FastQuery:: Yes))
            //   return false;   // another briefcase has locked the db for editing
        }
        if (undefined === this.targetView)
            this.targetView = vp; // Update target to newly selected view.
        else if (iModel !== this.iModel)
            return false; // Once a ViewState has been established, only accept viewport showing the same iModel.
        if (!this.targetIsLocked) {
            if (isSelectedViewChange)
                this.targetView = vp; // Update target to newly selected view.
            return true; // Any type of model/view is still ok and target is still free to change.
        }
        if (this.targetModelId.isValid() && !view.viewsModel(this.targetModelId))
            return false; // Only allow view where target is being viewed.
        if (this.requireWriteableTarget()) {
            // ###TODO lock specific code
            //   IBriefcaseManager:: Request req;
            //   req.Locks().Insert(* targetModel, LockLevel:: Shared);
            //   if (!db.BriefcaseManager().AreResourcesAvailable(req, nullptr, IBriefcaseManager:: FastQuery:: Yes))
            //     return false; // another briefcase has locked the model for editing
        }
        return true;
    }
    /**
     * Checks that the adjusted point from the supplied button event is within the project extents for spatial views. The range of physical geometry
     * should always be fully inside the project extents. Only checking the adjusted point won't absolutely guarantee that a tool doesn't create/move geometry
     * outside the project extents, but it will be sufficient to handle most cases and provide good feedback to the user.
     * @return true if ev is acceptable.
     */
    isValidLocation(ev, isButtonEvent) {
        const vp = ev.viewport;
        if (undefined === vp)
            return false;
        const view = vp.view;
        const iModel = view.iModel;
        if (!view.isSpatialView() || iModel.isReadonly() || !this.requireWriteableTarget())
            return true;
        // NOTE: If points aren't being adjusted then the tool shouldn't be creating geometry currently (ex. locating elements) and we shouldn't filter point...
        if (0 !== (IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr & 2 /* ACS */))
            return true;
        // We know the tool isn't doing a locate, we don't know what it will do with this point. Minimize erroneous filtering by restricting the check to when AccuSnap is tool enable (not user enabled)...
        if (!IModelApp_1.IModelApp.accuSnap.isSnapEnabled())
            return true;
        const extents = iModel.projectExtents;
        if (extents.containsPoint(ev.point))
            return true;
        if (isButtonEvent && ev.isDown) {
            IModelApp_1.IModelApp.notifications.outputMessage(new NotificationManager_1.NotifyMessageDetails(10 /* Error */, IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ElementSet.Error.ProjectExtents")));
        }
        return false;
    }
    getCursor() { return Tool_1.BeCursor.Arrow; }
    /** Called on data button down event to lock the tool to its current target model. */
    autoLockTarget() { if (undefined !== this.targetView)
        return; this.targetIsLocked = true; }
    /**  Returns the prompt based on the tool's current state. */
    getPrompt() { return ""; }
    /** Called from isCompatibleViewport to check for a read only iModel, which is not a valid target for tools that create or modify elements. */
    requireWriteableTarget() { return true; }
    /** Invoked to allow tools to filter which elements can be located.
     * return true to reject hit (fill out response with reason, if it is defined)
     */
    onPostLocate(_hit, _out) { return false; }
    /**
     * Called when active view changes. Tool may choose to restart or exit based on current view type.
     * @param previous The previously active view.
     * @param current The new active view.
     */
    onSelectedViewportChanged(_previous, current) {
        if (this.isCompatibleViewport(current, true))
            return;
        this.onRestartTool();
    }
    /**
     * Called to reset tool to initial state. This method is provided here for convenience; the only
     * external caller is ElementSetTool. PrimitiveTool implements this method to call _OnRestartTool.
     */
    onReinitialize() { this.onRestartTool(); }
    exitTool() {
        const { toolAdmin } = IModelApp_1.IModelApp;
        toolAdmin.activeToolChanged.raiseEvent(this);
        toolAdmin.startDefaultTool();
    }
    /**
     * Called to revert to a previous tool state (ex. undo last data button).
     * @return false to instead reverse the most recent transaction.
     */
    onUndoPreviousStep() { return false; }
    undoPreviousStep() {
        if (!this.onUndoPreviousStep())
            return false;
        AccuDrawTool_1.AccuDrawShortcuts.processPendingHints(); // Process any hints the active tool setup in _OnUndoPreviousStep now...
        IModelApp_1.IModelApp.toolAdmin.updateDynamics();
        return true;
    }
    /**
     * Tools need to call SaveChanges to commit any elements they have added/changes they have made.
     * This helper method supplies the tool name for the undo string to iModel.saveChanges.
     */
    saveChanges() { return this.iModel.saveChanges(this.toolId); }
}
exports.PrimitiveTool = PrimitiveTool;


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = makeString;
/* harmony export (immutable) */ __webpack_exports__["a"] = copy;
/* harmony export (immutable) */ __webpack_exports__["h"] = setPath;
/* harmony export (immutable) */ __webpack_exports__["f"] = pushPath;
/* harmony export (immutable) */ __webpack_exports__["d"] = getPath;
/* harmony export (immutable) */ __webpack_exports__["b"] = deepExtend;
/* harmony export (immutable) */ __webpack_exports__["g"] = regexEscape;
/* harmony export (immutable) */ __webpack_exports__["c"] = escape;
function makeString(object) {
  if (object == null) return '';
  /* eslint prefer-template: 0 */
  return '' + object;
}

function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};

    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

function deepExtend(target, source, overwrite) {
  /* eslint no-restricted-syntax: 0 */
  for (var prop in source) {
    if (prop in target) {
      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
        if (overwrite) target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }
  return target;
}

function regexEscape(str) {
  /* eslint no-useless-escape: 0 */
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

/* eslint-disable */
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': '&quot;',
  "'": '&#39;',
  "/": '&#x2F;'
};
/* eslint-enable */

function escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const System_1 = __webpack_require__(7);
class LUTParams {
    constructor(width, height) { this.width = width; this.height = height; }
}
exports.LUTParams = LUTParams;
/** Describes the dimensions of a texture used as a look-up table */
class LUTDimensions {
    constructor(nEntries, nRgbaPerEntry, nExtraRgba = 0, nTables = 1) {
        const dims = LUTDimensions.computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba, nTables);
        this.width = dims.width;
        this.height = dims.height;
    }
    static computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba = 0, nTables = 1) {
        const maxSize = System_1.System.instance.capabilities.maxTextureSize;
        const nRgba = nEntries * nRgbaPerEntry * nTables + nExtraRgba;
        if (nRgba < maxSize)
            return { width: nRgba, height: 1 };
        // Make roughly square to reduce unused space in last row
        let width = Math.ceil(Math.sqrt(nRgba));
        // Ensure a given entry's RGBA values all fit on the same row.
        const remainder = width % nRgbaPerEntry;
        if (0 !== remainder) {
            width += nRgbaPerEntry - remainder;
        }
        // Compute height
        const height = Math.ceil(nRgba / width);
        bentleyjs_core_1.assert(height <= maxSize);
        bentleyjs_core_1.assert(width <= maxSize);
        bentleyjs_core_1.assert(width * height >= nRgba);
        bentleyjs_core_1.assert(Math.floor(height) === height);
        bentleyjs_core_1.assert(Math.floor(width) === width);
        // Row padding should never be necessary...
        bentleyjs_core_1.assert(0 === width % nRgbaPerEntry);
        return { width, height };
    }
}
exports.LUTDimensions = LUTDimensions;
function getFeatureName(dim) {
    switch (dim) {
        case 0 /* Empty */: return "Empty";
        case 1 /* SingleUniform */: return "Single/Uniform";
        case 2 /* SingleNonUniform */: return "Single/Non-uniform";
        case 3 /* Multiple */: return "Multiple";
        default:
            bentleyjs_core_1.assert(false);
            return "Invalid";
    }
}
exports.getFeatureName = getFeatureName;
function computeFeatureDimension(dim, type) {
    switch (type) {
        case 0 /* Empty */:
            return 0 /* Empty */;
        case 2 /* NonUniform */:
            bentleyjs_core_1.assert(0 /* Uniform */ !== dim);
            return 3 /* Multiple */;
        default:
            return 0 /* Uniform */ === dim ? 1 /* SingleUniform */ : 2 /* SingleNonUniform */;
    }
}
exports.computeFeatureDimension = computeFeatureDimension;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const FloatRGBA_1 = __webpack_require__(35);
/* Describes a primitive's basic color properties */
class ColorInfo {
    constructor(arg) {
        if (arg instanceof FloatRGBA_1.FloatPreMulRgba) {
            this.hasTranslucency = arg.hasTranslucency;
            this._uniform = arg;
        }
        else {
            this.hasTranslucency = arg.hasAlpha;
            if (undefined !== arg.uniform) {
                this._uniform = FloatRGBA_1.FloatPreMulRgba.fromColorDef(arg.uniform);
            }
        }
    }
    get isUniform() { return undefined !== this._uniform; }
    get isNonUniform() { return !this.isUniform; }
    get uniform() { bentleyjs_core_1.assert(this.isUniform); return this._uniform; }
}
exports.ColorInfo = ColorInfo;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const CachedGeometry_1 = __webpack_require__(29);
const EdgeOverrides_1 = __webpack_require__(55);
const Graphic_1 = __webpack_require__(64);
const FeaturesInfo_1 = __webpack_require__(87);
const VertexLUT_1 = __webpack_require__(88);
const Primitive_1 = __webpack_require__(65);
const Surface_1 = __webpack_require__(127);
const imodeljs_common_1 = __webpack_require__(2);
const System_1 = __webpack_require__(7);
const Handle_1 = __webpack_require__(36);
const GL_1 = __webpack_require__(8);
const Polyline_1 = __webpack_require__(128);
class MeshInfo {
    constructor(type, edgeWidth, lineCode, fillFlags, isPlanar, features, texture) {
        this.edgeWidth = edgeWidth;
        this.features = features;
        this.texture = texture;
        this.type = type;
        this.fillFlags = fillFlags;
        this.edgeLineCode = lineCode;
        this.isPlanar = isPlanar;
    }
}
exports.MeshInfo = MeshInfo;
class MeshData extends MeshInfo {
    static create(params) {
        const lut = params.lutParams.toData(params.vertexParams, params.uvParams);
        return undefined !== lut ? new MeshData(lut, params) : undefined;
    }
    constructor(lut, params) {
        super(params.type, params.edgeWidth, params.edgeLineCode, params.fillFlags, params.isPlanar, params.features, params.texture);
        this.lut = lut;
        this.material = params.material;
        this.animation = undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
    }
}
exports.MeshData = MeshData;
class MeshParams extends MeshInfo {
    constructor(args) {
        // ###TODO: MeshArgs.normals should be undefined unless it is non-empty
        const isLit = undefined !== args.normals && 0 < args.normals.length;
        const isTextured = undefined !== args.texture;
        const surfaceType = isTextured ? (isLit ? 3 /* TexturedLit */ : 2 /* Textured */) : isLit ? 1 /* Lit */ : 0 /* Unlit */;
        super(surfaceType, args.edges.width, EdgeOverrides_1.LineCode.valueFromLinePixels(args.edges.linePixels), args.fillFlags, args.isPlanar, FeaturesInfo_1.FeaturesInfo.create(args.features), args.texture);
        // ###TODO: MeshArgs should quantize texture UV for us...
        // ###TODO: MeshArgs.textureUV should be undefined unless it is non-empty
        const uvRange = geometry_core_1.Range2d.createNull();
        const fpts = args.textureUv;
        if (undefined !== fpts && fpts.length !== 0) {
            for (let i = 0; i < args.points.length; i++) {
                uvRange.extendPoint(geometry_core_1.Point2d.createFrom({ x: fpts[i].x, y: fpts[i].y }));
            }
        }
        this.uvParams = uvRange.isNull() ? undefined : imodeljs_common_1.QParams2d.fromRange(uvRange);
        this.vertexParams = args.points.params;
        this.material = args.material;
        switch (this.type) {
            case 1 /* Lit */:
                this.lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.LitMeshBuilder(args), args.colors);
                break;
            case 2 /* Textured */:
                this.lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.TexturedMeshBuilder(args, this.uvParams), args.colors);
                break;
            case 3 /* TexturedLit */:
                this.lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.TexturedLitMeshBuilder(args, this.uvParams), args.colors);
                break;
            case 0 /* Unlit */:
            default:
                this.lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.MeshBuilder(args), args.colors);
                break;
        }
        // if (args.auxData.isAnimatable()) { this.animationLUTParams = new AnimationLUTParams(args); }
    }
}
exports.MeshParams = MeshParams;
var MeshGraphicType;
(function (MeshGraphicType) {
    MeshGraphicType[MeshGraphicType["kSurface"] = 0] = "kSurface";
    MeshGraphicType[MeshGraphicType["kEdge"] = 1] = "kEdge";
    MeshGraphicType[MeshGraphicType["kSilhouette"] = 2] = "kSilhouette";
    MeshGraphicType[MeshGraphicType["kPolyline"] = 3] = "kPolyline";
    MeshGraphicType[MeshGraphicType["kCOUNT"] = 4] = "kCOUNT";
})(MeshGraphicType = exports.MeshGraphicType || (exports.MeshGraphicType = {}));
class MeshGraphic extends Graphic_1.Graphic {
    constructor(data, args) {
        super();
        this._primitives = [];
        this.meshData = data;
        const surface = Surface_1.SurfacePrimitive.create(args, this);
        if (undefined !== surface)
            this._primitives.push(surface);
        if (args.edges.silhouettes.isValid) {
            const silPrim = SilhouetteEdgePrimitive.create(args.edges.silhouettes, this);
            if (undefined !== silPrim)
                this._primitives[MeshGraphicType.kSilhouette] = silPrim;
        }
        const convertPolylineEdges = args.edges.polylines.isValid && !Graphic_1.wantJointTriangles(args.edges.width, args.is2d);
        if (convertPolylineEdges) {
            const edgePrim = EdgePrimitive.createSimple(args.edges.polylines, args.edges.edges, this);
            if (undefined !== edgePrim)
                this._primitives[MeshGraphicType.kEdge] = edgePrim;
        }
        else {
            if (args.edges.edges.isValid) {
                const edgePrim = EdgePrimitive.create(args.edges.edges, this);
                if (undefined !== edgePrim)
                    this._primitives[MeshGraphicType.kEdge] = edgePrim;
            }
            if (args.edges.polylines.isValid) {
                const pePrim = PolylineEdgePrimitive.create(args, this);
                if (undefined !== pePrim)
                    this._primitives[MeshGraphicType.kPolyline] = pePrim;
            }
        }
    }
    static create(args) {
        const data = MeshData.create(new MeshParams(args));
        return undefined !== data ? new MeshGraphic(data, args) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.meshData);
        for (const primitive of this._primitives)
            bentleyjs_core_1.dispose(primitive);
        this._primitives.length = 0;
    }
    addCommands(cmds) { this._primitives.forEach((prim) => prim.addCommands(cmds)); }
    addHiliteCommands(cmds, batch) { this._primitives.forEach((prim) => prim.addHiliteCommands(cmds, batch)); }
    setUniformFeatureIndices(id) {
        this.meshData.features = FeaturesInfo_1.FeaturesInfo.createUniform(id);
    }
    setIsPixelMode() {
        // this.primitives.forEach((prim) => {
        //   if (true /*prim.isValid()*/) { prim.setIsPixelMode(); } // TODO: setIsPixelMode() has not been implemented yet
        // });
    }
    get surfaceType() { return this.meshData.type; }
}
exports.MeshGraphic = MeshGraphic;
// Defines one aspect of the geometry of a mesh (surface or edges)
class MeshGeometry extends CachedGeometry_1.LUTGeometry {
    // Convenience accessors...
    get edgeWidth() { return this.mesh.edgeWidth; }
    get edgeLineCode() { return this.mesh.edgeLineCode; }
    get featuresInfo() { return this.mesh.features; }
    get surfaceType() { return this.mesh.type; }
    get fillFlags() { return this.mesh.fillFlags; }
    get isPlanar() { return this.mesh.isPlanar; }
    get colorInfo() { return this.mesh.lut.colorInfo; }
    get uniformColor() { return this.colorInfo.isUniform ? this.colorInfo.uniform : undefined; }
    get texture() { return this.mesh.texture; }
    get lut() { return this.mesh.lut; }
    constructor(mesh, numIndices) {
        super();
        this.numIndices = numIndices;
        this.mesh = mesh;
    }
    computeEdgeWeight(params) { return params.target.getEdgeWeight(params, this.edgeWidth); }
    computeEdgeLineCode(params) { return params.target.getEdgeLineCode(params, this.edgeLineCode); }
    computeEdgeColor(target) { return target.isEdgeColorOverridden ? target.edgeColor : this.colorInfo; }
    computeEdgePass(target) {
        const vf = target.currentViewFlags;
        if (6 /* SmoothShade */ === vf.renderMode && !vf.showVisibleEdges()) {
            return 255 /* None */;
        }
        // Only want translucent edges in wireframe mode.
        const isTranslucent = 0 /* Wireframe */ === vf.renderMode && vf.showTransparency() && this.colorInfo.hasTranslucency;
        return isTranslucent ? 4 /* Translucent */ : 1 /* OpaqueLinear */;
    }
}
exports.MeshGeometry = MeshGeometry;
class MeshPrimitive extends Primitive_1.Primitive {
    get meshData() { return this.mesh.meshData; }
    constructor(cachedGeom, mesh) {
        super(cachedGeom);
        this.mesh = mesh;
    }
    assignUniformFeatureIndices(_index) { bentleyjs_core_1.assert(false); } // handled by MeshGraphic...
}
exports.MeshPrimitive = MeshPrimitive;
class EdgeBytes {
    constructor(numIndices) {
        this.numIndices = numIndices;
        // Each primary vertex identified by vec3-encoded index into LUT
        this.indexBytes = new Uint8Array(numIndices * 3);
        // Each 'other endpoint' vertex identified by vec3-encoded index into LUT plus a quad index in [0,3]
        this.endPointAndQuadIndexBytes = new Uint8Array(numIndices * 4);
    }
}
exports.EdgeBytes = EdgeBytes;
class EdgeGeometry extends MeshGeometry {
    static convertPolylinesAndEdges(polylines, edges) {
        // Each adjacent pair of polyline indices and each mesh edge becomes 2 triangles with 6 vertices.
        let numIndices = 0;
        if (undefined !== edges)
            numIndices += edges.length;
        if (undefined !== polylines) {
            for (const pd of polylines)
                numIndices += (pd.vertIndices.length - 1);
        }
        if (0 === numIndices)
            return undefined;
        numIndices *= 6;
        // Allocate bytes for edge data.
        const data = new EdgeBytes(numIndices);
        let ndx = 0;
        let ndx2 = 0;
        const addPoint = (p0, p1, quadIndex) => {
            data.indexBytes[ndx++] = p0 & 0x000000ff;
            data.indexBytes[ndx++] = (p0 & 0x0000ff00) >> 8;
            data.indexBytes[ndx++] = (p0 & 0x00ff0000) >> 16;
            data.endPointAndQuadIndexBytes[ndx2++] = p1 & 0x000000ff;
            data.endPointAndQuadIndexBytes[ndx2++] = (p1 & 0x0000ff00) >> 8;
            data.endPointAndQuadIndexBytes[ndx2++] = (p1 & 0x00ff0000) >> 16;
            data.endPointAndQuadIndexBytes[ndx2++] = quadIndex;
        };
        if (undefined !== polylines) {
            for (const pd of polylines) {
                const num = pd.vertIndices.length - 1;
                for (let i = 0; i < num; ++i) {
                    let p0 = pd.vertIndices[i];
                    let p1 = pd.vertIndices[i + 1];
                    if (p1 < p0) {
                        p0 = p1;
                        p1 = pd.vertIndices[i];
                    }
                    addPoint(p0, p1, 0);
                    addPoint(p1, p0, 2);
                    addPoint(p0, p1, 1);
                    addPoint(p0, p1, 1);
                    addPoint(p1, p0, 2);
                    addPoint(p1, p0, 3);
                }
            }
        }
        if (undefined !== edges) {
            for (const meshEdge of edges) {
                const p0 = meshEdge.indices[0];
                const p1 = meshEdge.indices[1];
                addPoint(p0, p1, 0);
                addPoint(p1, p0, 2);
                addPoint(p0, p1, 1);
                addPoint(p0, p1, 1);
                addPoint(p1, p0, 2);
                addPoint(p1, p0, 3);
            }
        }
        return data;
    }
    static create(mesh, polylines, edges) {
        const data = this.convertPolylinesAndEdges(polylines, edges);
        if (undefined !== data) {
            const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(data.indexBytes);
            if (undefined !== indexBuffer) {
                const endPointAndQuadIndexBuffer = Handle_1.BufferHandle.createArrayBuffer(data.endPointAndQuadIndexBytes);
                if (undefined !== endPointAndQuadIndexBuffer)
                    return new EdgeGeometry(indexBuffer, endPointAndQuadIndexBuffer, data.numIndices, mesh);
            }
        }
        return undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._indices);
        bentleyjs_core_1.dispose(this._endPointAndQuadIndices);
    }
    bindVertexArray(attr) {
        attr.enableArray(this._indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    draw() {
        const gl = System_1.System.instance.context;
        this._indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this.numIndices);
    }
    _wantWoWReversal(_target) { return true; }
    _getLineWeight(params) { return this.computeEdgeWeight(params); }
    _getLineCode(params) { return this.computeEdgeLineCode(params); }
    getTechniqueId(_target) { return 4 /* Edge */; }
    getRenderPass(target) { return this.computeEdgePass(target); }
    get renderOrder() { return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    getColor(target) { return this.computeEdgeColor(target); }
    get endPointAndQuadIndices() { return this._endPointAndQuadIndices; }
    constructor(indices, endPointAndQuadsIndices, numIndices, mesh) {
        super(mesh, numIndices);
        this._indices = indices;
        this._endPointAndQuadIndices = endPointAndQuadsIndices;
    }
}
exports.EdgeGeometry = EdgeGeometry;
class EdgePrimitive extends MeshPrimitive {
    static create(args, mesh) {
        if (undefined === args.edges) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        const geom = EdgeGeometry.create(mesh.meshData, undefined, args.edges);
        return undefined !== geom ? new EdgePrimitive(geom, mesh) : undefined;
    }
    static createSimple(pArgs, eArgs, mesh) {
        if (undefined === eArgs.edges && undefined === pArgs.lines) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        const geom = EdgeGeometry.create(mesh.meshData, pArgs.lines, eArgs.edges);
        return undefined !== geom ? new EdgePrimitive(geom, mesh) : undefined;
    }
    constructor(cachedGeom, mesh) { super(cachedGeom, mesh); }
    get renderOrder() { return this.meshData.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    get isEdge() { return true; }
}
exports.EdgePrimitive = EdgePrimitive;
class SilhouetteEdgeGeometry extends EdgeGeometry {
    static convertNormalPairs(normalPairs) {
        // The indices for the edges get expanded to 6 triangle indices, so we must also expand the normal pairs by 6.
        // Each pair of oct encoded normals is 4 byts (2 for each normal).
        const normalPairBytes = new Uint8Array(normalPairs.length * 6 * 4);
        const normalPair16 = new Uint16Array(normalPairBytes.buffer);
        let ndx = 0;
        for (const pair of normalPairs) {
            for (let i = 0; i < 6; ++i) {
                pair.first.value;
                normalPair16[ndx++] = pair.first.value;
                normalPair16[ndx++] = pair.second.value;
            }
        }
        return normalPairBytes;
    }
    static createSilhouettes(mesh, edges, normalPairs) {
        const data = EdgeGeometry.convertPolylinesAndEdges(undefined, edges);
        if (undefined !== data) {
            const normalPairBytes = this.convertNormalPairs(normalPairs);
            if (undefined !== normalPairBytes) {
                const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(data.indexBytes);
                if (undefined !== indexBuffer) {
                    const endPointAndQuadIndexBuffer = Handle_1.BufferHandle.createArrayBuffer(data.endPointAndQuadIndexBytes);
                    if (undefined !== endPointAndQuadIndexBuffer) {
                        const normalPairsBuffer = Handle_1.BufferHandle.createArrayBuffer(normalPairBytes);
                        if (undefined !== normalPairsBuffer) {
                            return new SilhouetteEdgeGeometry(indexBuffer, endPointAndQuadIndexBuffer, normalPairsBuffer, data.numIndices, mesh);
                        }
                    }
                }
            }
        }
        return undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._normalPairs);
        super.dispose();
    }
    getTechniqueId(_target) { return 5 /* SilhouetteEdge */; }
    get renderOrder() { return this.isPlanar ? 13 /* PlanarSilhouette */ : 5 /* Silhouette */; }
    get normalPairs() { return this._normalPairs; }
    constructor(indices, endPointAndQuadsIndices, normalPairs, numIndices, mesh) {
        super(indices, endPointAndQuadsIndices, numIndices, mesh);
        this._normalPairs = normalPairs;
    }
}
exports.SilhouetteEdgeGeometry = SilhouetteEdgeGeometry;
class SilhouetteEdgePrimitive extends MeshPrimitive {
    static create(args, mesh) {
        if (undefined === args.edges || undefined === args.normals) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        const geom = SilhouetteEdgeGeometry.createSilhouettes(mesh.meshData, args.edges, args.normals);
        return undefined !== geom ? new SilhouetteEdgePrimitive(geom, mesh) : undefined;
    }
    constructor(cachedGeom, mesh) { super(cachedGeom, mesh); }
    get renderOrder() { return this.meshData.isPlanar ? 13 /* PlanarSilhouette */ : 5 /* Silhouette */; }
    get isEdge() { return true; }
}
exports.SilhouetteEdgePrimitive = SilhouetteEdgePrimitive;
class PolylineEdgeGeometry extends MeshGeometry {
    static create(mesh, args) {
        const tess = Polyline_1.PolylineTesselator.fromMesh(args);
        if (undefined !== tess) {
            const tp = tess.tesselate();
            const vBuff = Handle_1.BufferHandle.createArrayBuffer(tp.vertIndex);
            const pBuff = Handle_1.BufferHandle.createArrayBuffer(tp.prevIndex);
            const npBuff = Handle_1.BufferHandle.createArrayBuffer(tp.nextIndexAndParam);
            const dBuff = Handle_1.BufferHandle.createArrayBuffer(tp.distance);
            if (undefined !== vBuff && undefined !== pBuff && undefined !== npBuff && undefined !== dBuff) {
                const pb = new CachedGeometry_1.PolylineBuffers(vBuff, pBuff, npBuff, dBuff);
                return new PolylineEdgeGeometry(tp.numIndices, pb, mesh);
            }
        }
        return undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._buffers);
    }
    _wantWoWReversal(_target) { return true; }
    _getLineWeight(params) { return this.computeEdgeWeight(params); }
    _getLineCode(params) { return this.computeEdgeLineCode(params); }
    getTechniqueId(_target) { return 1 /* Polyline */; }
    getRenderPass(target) { return this.computeEdgePass(target); }
    get renderOrder() { return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    get polylineBuffers() { return this._buffers; }
    bindVertexArray(attr) {
        attr.enableArray(this._buffers.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    draw() {
        const gl = System_1.System.instance.context;
        this._buffers.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this.numIndices);
    }
    constructor(numIndices, buffers, mesh) {
        super(mesh, numIndices);
        this._buffers = buffers;
    }
}
exports.PolylineEdgeGeometry = PolylineEdgeGeometry;
class PolylineEdgePrimitive extends MeshPrimitive {
    static create(args, mesh) {
        if (undefined === args.edges) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        const geom = PolylineEdgeGeometry.create(mesh.meshData, args);
        return undefined !== geom ? new PolylineEdgePrimitive(geom, mesh) : undefined;
    }
    constructor(cachedGeom, mesh) { super(cachedGeom, mesh); }
    get renderOrder() { return this.meshData.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    get isEdge() { return true; }
}
exports.PolylineEdgePrimitive = PolylineEdgePrimitive;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const Fragment_1 = __webpack_require__(25);
const RenderPass_1 = __webpack_require__(129);
// Vertex
const computeColor = `
  vec4 color = u_color;
  if (isShaderBitSet(kShaderBit_NonUniformColor)) {
    // Color table is appended to vertex data. Compute the index of the vertex one-past-the-end of the vertex data
    float colorTableStart = u_vertParams.z * u_vertParams.w; // num rgba per-vertex times num vertices
    float colorIndex = decodeUInt16(g_vertexData2);
    vec2 tc = computeLUTCoords(colorTableStart+colorIndex, u_vertParams.xy, g_vert_center, 1.0);
    color = TEXTURE(u_vertLUT, tc);
  }

  if (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass)
    color = adjustPreMultipliedAlpha(color, 1.0);

  return color;
`;
// Fragment
const computeBaseColor = "return v_color;";
function addColor(builder) {
    // ShaderSource::AddRenderPass
    builder.vert.addUniform("u_color", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_color", (uniform, params) => {
            const lutGeom = params.geometry;
            const color = lutGeom.getColor(params.target);
            if (color.isUniform) {
                const rgba = color.uniform;
                uniform.setUniform4fv(new Float32Array([rgba.red, rgba.green, rgba.blue, rgba.alpha]));
            }
        });
    });
    builder.vert.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    RenderPass_1.addRenderPass(builder.vert);
    builder.addFunctionComputedVarying("v_color", 6 /* Vec4 */, "computeColor", computeColor);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
}
exports.addColor = addColor;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(132));
__export(__webpack_require__(383));
__export(__webpack_require__(384));
__export(__webpack_require__(191));
__export(__webpack_require__(237));
__export(__webpack_require__(98));
__export(__webpack_require__(236));
__export(__webpack_require__(15));
__export(__webpack_require__(214));
__export(__webpack_require__(77));
__export(__webpack_require__(105));
__export(__webpack_require__(79));
__export(__webpack_require__(207));
__export(__webpack_require__(210));
__export(__webpack_require__(211));
__export(__webpack_require__(78));
__export(__webpack_require__(53));
__export(__webpack_require__(385));
__export(__webpack_require__(205));
__export(__webpack_require__(63));
__export(__webpack_require__(120));
__export(__webpack_require__(72));
__export(__webpack_require__(212));
__export(__webpack_require__(76));
__export(__webpack_require__(123));
__export(__webpack_require__(206));
__export(__webpack_require__(97));
__export(__webpack_require__(215));
__export(__webpack_require__(96));
__export(__webpack_require__(190));
__export(__webpack_require__(44));
__export(__webpack_require__(121));
__export(__webpack_require__(5));
__export(__webpack_require__(386));
/** @docs-package-description
 * The ($frontend) package always runs in a web browser. It contains classes for [querying iModels and showing views]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description IModelApp
 * Classes for configuring and administering an iModelJs application.
 */
/**
 * @docs-group-description IModelConnection
 * Classes for working with a connection to an [iModel briefcase]($docs/overview/IModels.md)
 */
/**
 * @docs-group-description ElementState
 * Classes for working with the *state* of Elements in the frontend
 */
/**
 * @docs-group-description ModelState
 * Classes for working with the *state* of Models in the frontend
 */
/**
 * @docs-group-description Tools
 * Classes for [working with Tools]($docs/learning/frontend/Tools.md)
 */
/**
 * @docs-group-description Views
 * Classes for [working with Views]($docs/learning/frontend/Views.md)
 */
/**
 * @docs-group-description LocatingElements
 * Classes for locating and snapping to elements in views
 */
/**
 * @docs-group-description AccuDraw
 * AccuDraw provides helpful assistance for creating and modifying elements in a view.
 */
/**
 * @docs-group-description Notifications
 * Notifications provide feedback to the user of something of interest.
 */
/**
 * @docs-group-description SelectionSet
 * Classes for working with the set of selected elements.
 */
/**
 * @docs-group-description Rendering
 * Classes for rendering the contents of views.
 */
/**
 * @docs-group-description Tile
 * Classes for selecting and drawing tiles in views.
 */
/**
 * @docs-group-description WebGL
 * Classes for interfacing to WebGL in browsers.
 */


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module AccuDraw */
const geometry_core_1 = __webpack_require__(1);
const IModelApp_1 = __webpack_require__(5); // This must be first to avoid import cycles.
const ViewState_1 = __webpack_require__(121);
const imodeljs_common_1 = __webpack_require__(2);
const LegacyMath_1 = __webpack_require__(75);
const Tool_1 = __webpack_require__(15);
const AccuSnap_1 = __webpack_require__(79);
const ViewTool_1 = __webpack_require__(77);
var KeyinStatus;
(function (KeyinStatus) {
    KeyinStatus[KeyinStatus["Dynamic"] = 0] = "Dynamic";
    KeyinStatus[KeyinStatus["Partial"] = 1] = "Partial";
    KeyinStatus[KeyinStatus["DontUpdate"] = 2] = "DontUpdate";
})(KeyinStatus = exports.KeyinStatus || (exports.KeyinStatus = {}));
var Constants;
(function (Constants) {
    Constants[Constants["MAX_SAVED_VALUES"] = 20] = "MAX_SAVED_VALUES";
    Constants[Constants["SMALL_ANGLE"] = 1e-12] = "SMALL_ANGLE";
    Constants[Constants["SMALL_DELTA"] = 0.00001] = "SMALL_DELTA";
})(Constants || (Constants = {}));
class AccudrawData {
    constructor() {
        this.flags = 0; // AccuDrawFlags
        this.origin = new geometry_core_1.Point3d(); // used if ACCUDRAW_SetOrigin
        this.delta = new geometry_core_1.Point3d(); // if ACCUDRAW_Lock_X, etc.
        this.rMatrix = new geometry_core_1.RotMatrix(); // if ACCUDRAW_SetRMatrix/ACCUDRAW_Set3dMatrix
        this.vector = new geometry_core_1.Vector3d(); // if ACCUDRAW_SetXAxis, etc.
        this.distance = 0; // if ACCUDRAW_SetDistance
        this.angle = 0; // if ACCUDRAW_SetAngle
    }
    zero() { this.flags = this.distance = this.angle = 0; this.origin.setZero(); this.delta.setZero(); this.vector.setZero(); this.rMatrix.setIdentity(); }
}
exports.AccudrawData = AccudrawData;
class Flags {
    constructor() {
        this.redrawCompass = false;
        this.dialogNeedsUpdate = false;
        this.rotationNeedsUpdate = true;
        this.lockedRotation = false;
        this.indexLocked = false;
        this.haveValidOrigin = false;
        this.fixedOrg = false;
        this.auxRotationPlane = 1 /* Top */;
        this.contextRotMode = 0;
        this.baseRotation = 4 /* View */;
        this.baseMode = 0;
        this.pointIsOnPlane = false; // whether rawPointOnPlane is on compass plane
        this.softAngleLock = false; // don't remember what this was about...
        this.bearingFixToPlane2D = false;
        this.inDataPoint = false;
        this.ignoreDataButton = false;
        this.animateRotation = false;
    }
}
exports.Flags = Flags;
class RoundOff {
    constructor() {
        this.active = false;
        this.units = new Set();
    }
}
exports.RoundOff = RoundOff;
class SavedState {
    constructor() {
        this.state = 0 /* NotEnabled */;
        this.mode = 0 /* Polar */;
        this.rotationMode = 4 /* View */;
        this.axes = new ThreeAxes();
        this.origin = new geometry_core_1.Point3d();
        this.auxRotationPlane = 0;
        this.contextRotMode = 0;
        this.fixedOrg = false;
        this.ignoreDataButton = false; // Allow data point that terminates an input collector to be ignored...
    }
    init() { this.state = 0 /* NotEnabled */; this.view = undefined; this.mode = 0 /* Polar */; this.rotationMode = 4 /* View */; }
    setFrom(other) {
        this.state = other.state;
        this.view = other.view;
        this.mode = other.mode;
        this.rotationMode = other.rotationMode;
        this.axes.setFrom(other.axes);
        this.origin.setFrom(other.origin);
        this.auxRotationPlane = other.auxRotationPlane;
        this.contextRotMode = other.contextRotMode;
        this.fixedOrg = other.fixedOrg;
        this.ignoreDataButton = other.ignoreDataButton;
    }
}
exports.SavedState = SavedState;
class SavedCoords {
    constructor() {
        this.nSaveValues = 0;
        this.savedValues = [];
        this.savedValIsAngle = [];
    }
}
class ThreeAxes {
    constructor() {
        this.x = geometry_core_1.Vector3d.unitX();
        this.y = geometry_core_1.Vector3d.unitY();
        this.z = geometry_core_1.Vector3d.unitZ();
    }
    setFrom(other) {
        this.x.setFrom(other.x);
        this.y.setFrom(other.y);
        this.z.setFrom(other.z);
    }
    fromRotMatrix(rMatrix) {
        rMatrix.getRow(0, this.x);
        rMatrix.getRow(1, this.y);
        rMatrix.getRow(2, this.z);
    }
    static createFromRotMatrix(rMatrix, result) {
        result = result ? result : new ThreeAxes();
        result.fromRotMatrix(rMatrix);
        return result;
    }
    toRotMatrix(out) { return geometry_core_1.RotMatrix.createRows(this.x, this.y, this.z, out); }
    clone() { const out = new ThreeAxes(); out.setFrom(this); return out; }
    equals(other) { return this.x.isExactEqual(other.x) && this.y.isExactEqual(other.y) && this.z.isExactEqual(other.z); }
}
exports.ThreeAxes = ThreeAxes;
/**
 * Accudraw is an aide for entering coordinate data.
 */
class AccuDraw {
    constructor() {
        this.currentState = 0 /* NotEnabled */; // Compass state
        this.currentMode = 1 /* Rectangular */; // Compass mode
        this.rotationMode = 4 /* View */; // Compass rotation
        this.published = new AccudrawData(); // Staging area for hints
        this.origin = new geometry_core_1.Point3d(); // origin point...not on compass plane when z != 0.0
        this.axes = new ThreeAxes(); // X, Y and Z vectors (3d rotation matrix)
        this.delta = geometry_core_1.Vector3d.unitZ(); // dialog items (x, y & z)
        this.distance = 0; // current distance
        this.angle = 0; // current angle
        this.locked = 0 /* NONE_LOCKED */; // axis/distance locked bit mask
        this.indexed = 0 /* NONE_LOCKED */; // axis/distance indexed bit mask
        this.distanceRoundOff = new RoundOff(); // distance round off enabled and unit
        this.angleRoundOff = new RoundOff(); // angle round off enabled and unit
        this.flags = new Flags(); // current state flags
        this.fieldLocked = []; // locked state of fields
        this.keyinStatus = []; // state of input field
        this.savedState = new SavedState(); // Restore point for shortcuts/tools...
        this.savedCoords = new SavedCoords(); // History of previous angles/distances...
        this.baseAxes = new ThreeAxes(); // Used for "context" base rotation to hold arbitrary rotation w/o needing to change ACS...
        this.lastAxes = new ThreeAxes(); // Last result from UpdateRotation, replaces cM.rMatrix...
        this.lastDistance = 0; // previous saved distance or distance indexing tick
        this.tolerance = 0; // computed view based indexing tolerance
        this.percentChanged = 0; // Compass animation state
        this.threshold = 0; // Threshold for automatic x/y field focus change.
        this.planePt = new geometry_core_1.Point3d(); // same as origin unless non-zero locked z value
        this.rawDelta = new geometry_core_1.Point2d(); // used by rect fix point
        this.rawPoint = new geometry_core_1.Point3d(); // raw uor point passed to fix point
        this.rawPointOnPlane = new geometry_core_1.Point3d(); // adjusted rawPoint by applying hard/soft construction plane
        this.point = new geometry_core_1.Point3d(); // current cursor point
        this.vector = geometry_core_1.Vector3d.unitZ(); // current/last good locked direction
        this.xIsNegative = false; // Last delta.x was negative
        this.yIsNegative = false; // Last delta.y was negative
        this.xIsExplicit = false; // Sign of delta.x established from user input input, don't allow +/- side flip.
        this.yIsExplicit = false; // Sign of delta.y established from user input input, don't allow +/- side flip.
        this.dontMoveFocus = false; // Disable automatic focus change when user is entering input.
        this.newFocus = 2 /* X_Item */; // Item to move focus to (X_Item or Y_Item) for automatic focus change.
        this.rMatrix = new geometry_core_1.RotMatrix();
        // Compass Display Preferences...
        this.compassSizeInches = 0.44;
        this.animationFrames = 12;
        this.indexToleranceInches = 0.11;
        this.frameColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.lightGrey);
        this.fillColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.blue);
        this.xColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.red);
        this.yColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.green);
        this.indexColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.white);
        // User Preference Settings...
        this.smartKeyin = true;
        this.floatingOrigin = true;
        this.stickyZLock = false;
        this.alwaysShowCompass = false;
        this.contextSensitive = true;
        this.axisIndexing = true;
        this.distanceIndexing = true;
        this.autoFocusFields = true;
        this.autoPointPlacement = false;
        this.enableDisplay = false; // ###TODO: Don't try to display yet...we will throw an exception...
    }
    onInitialized() { this.enableForSession(); }
    getRotation(rMatrix) { if (!rMatrix)
        rMatrix = this.rMatrix; geometry_core_1.RotMatrix.createRows(this.axes.x, this.axes.y, this.axes.z, rMatrix); return rMatrix; }
    getCompassMode() { return this.currentMode; }
    isActive() { return 3 /* Active */ === this.currentState; }
    isEnabled() { return (this.currentState > 0 /* NotEnabled */); }
    isInactive() { return (2 /* Inactive */ === this.currentState); }
    isDeactivated() { return (1 /* Deactivated */ === this.currentState); }
    animateCompassChanges() { return true; }
    setNewFocus(index) { this.newFocus = index; }
    getFieldLock(index) { return this.fieldLocked[index]; }
    getKeyinStatus(index) { return this.keyinStatus[index]; }
    grabInputFocus() { }
    activate() {
        // Upgrade state to inactive so OnBeginDynamics knows it is ok to move to active...
        if (1 /* Deactivated */ === this.currentState)
            this.currentState = 2 /* Inactive */;
        this.onBeginDynamics();
    }
    deactivate() {
        this.onEndDynamics();
        // Don't allow compass to come back until user re-enables it...
        if (2 /* Inactive */ === this.currentState)
            this.currentState = 1 /* Deactivated */;
    }
    setCompassMode(mode) {
        if (mode === this.currentMode)
            return;
        this.currentMode = mode;
        this.onCompassModeChange();
    }
    setRotationMode(mode) {
        if (mode === this.rotationMode)
            return;
        this.rotationMode = mode;
        this.onRotationModeChange();
    }
    setFieldLock(index, locked) {
        if (locked === this.fieldLocked[index])
            return;
        this.fieldLocked[index] = locked;
        this.onFieldLockChange(index);
    }
    setKeyinStatus(index, status) {
        this.keyinStatus[index] = status;
        if (KeyinStatus.Dynamic !== status)
            this.dontMoveFocus = true;
        if (KeyinStatus.Partial === status)
            this.threshold = Math.abs(2 /* X_Item */ === index ? this.rawDelta.y : this.rawDelta.x) + this.tolerance;
    }
    needsRefresh(vp) {
        if (!this.isEnabled() || this.isDeactivated())
            return false;
        // Get snap point from AccuSnap/Tentative or use raw point...
        let distance = 0.0;
        let snapPt = this.rawPoint;
        const ptP = this.point;
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap();
        if (snap) {
            snapPt = snap.snapPoint;
            distance = ptP.distance(snapPt);
        }
        const isRectMode = (1 /* Rectangular */ === this.getCompassMode());
        const offsetSnap = ((AccuSnap_1.TentativeOrAccuSnap.isHot() || IModelApp_1.IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));
        // XY Offset:
        if (offsetSnap) {
            if (isRectMode) {
                let xIsOffset = false, yIsOffset = false;
                let xOffset = 0.0, yOffset = 0.0;
                const vec = ptP.vectorTo(this.rawPointOnPlane);
                xIsOffset = (Math.abs(xOffset = vec.dotProduct(this.axes.x)) > 1.0);
                yIsOffset = (Math.abs(yOffset = vec.dotProduct(this.axes.y)) > 1.0);
                if (xIsOffset || yIsOffset)
                    return true;
            }
        }
        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));
        // Z Offset:
        if (offsetSnap) {
            if (isOnCompassPlane) {
                const zOffset = snapPt.distance(this.rawPointOnPlane);
                if (zOffset > Constants.SMALL_ANGLE || zOffset < -Constants.SMALL_ANGLE)
                    return true;
            }
        }
        // Fat Point:
        if (offsetSnap)
            return true;
        let axisIsIndexed = false;
        // Axis Indexing:
        if (isRectMode) {
            if ((this.indexed & 3 /* XY_BM */) && (this.flags.pointIsOnPlane || this.fieldLocked[4 /* Z_Item */]))
                axisIsIndexed = true;
        }
        else {
            if ((this.indexed & 7 /* ANGLE_BM */ || this.locked & 7 /* ANGLE_BM */) && (this.flags.pointIsOnPlane || this.fieldLocked[4 /* Z_Item */]))
                axisIsIndexed = true;
        }
        if (axisIsIndexed)
            return true;
        // Distance Indexing:
        if (this.indexed & 8 /* DIST_BM */)
            return true;
        // XY Lock:
        if (isRectMode && !axisIsIndexed) {
            const locked = this.locked & 3 /* XY_BM */;
            if ((0 !== locked) && isOnCompassPlane) {
                switch (locked) {
                    case 1 /* X_BM */:
                    case 2 /* Y_BM */:
                    case 3 /* XY_BM */:
                        return true;
                }
            }
        }
        return false;
    }
    adjustPoint(pointActive, vp, fromSnap) {
        if (!this.isEnabled())
            return false;
        const lastWasIndexed = (0 !== this.indexed);
        let pointChanged = false, handled = false;
        if (0.0 !== pointActive.z && !vp.isPointAdjustmentRequired())
            pointActive.z = 0.0;
        if (this.isInactive()) {
            this.point.setFrom(pointActive);
            this.currentView = vp;
            this.fixPoint(pointActive, vp);
            if (!fromSnap && IModelApp_1.IModelApp.accuSnap.currHit)
                this.flags.redrawCompass = true;
        }
        else if (this.isActive()) {
            const lastPt = this.point.clone();
            this.fixPoint(pointActive, vp);
            pointChanged = !lastPt.isExactEqual(this.point);
            if (this.published.flags)
                this.processHints();
            handled = true;
        }
        else {
            this.currentView = vp; // Keep view up to date...
        }
        // If redraw of compass isn't required (yet!) check if needed...
        if (!this.flags.redrawCompass && this.isActive()) {
            // Redraw required to erase/draw old/new indexing geometry...
            if (pointChanged && (lastWasIndexed || this.needsRefresh(vp)))
                this.flags.redrawCompass = true;
        }
        // Redraw is necessary, force decorators to be called...
        if (this.flags.redrawCompass)
            vp.invalidateDecorations();
        return handled;
    }
    setDefaultOrigin(vp) {
        if (!vp || this.locked || this.fieldLocked[4 /* Z_Item */])
            return;
        const view = vp.view;
        const rMatrix = view.getRotation();
        const acsOrigin = vp.getAuxCoordOrigin();
        rMatrix.multiplyVectorInPlace(acsOrigin);
        const origin = view.getCenter();
        view.getRotation().multiplyVectorInPlace(origin);
        origin.z = acsOrigin.z;
        view.getRotation().multiplyTransposeVectorInPlace(origin);
        this.origin.setFrom(origin); // View center at acs z...
        this.planePt.setFrom(origin);
    }
    isZLocked(vp) {
        if (this.fieldLocked[4 /* Z_Item */])
            return true;
        if (vp.isSnapAdjustmentRequired())
            return true;
        return false;
    }
    accountForAuxRotationPlane(rot, plane) {
        // ACS mode now can have "front" and "side" variations...
        switch (plane) {
            case 1 /* Top */:
                return;
            case 2 /* Front */:
                const temp = rot.y.clone();
                rot.y.setFrom(rot.z);
                temp.scale(-1.0, rot.z);
                return;
            case 3 /* Side */:
                const temp0 = rot.x.clone();
                rot.x.setFrom(rot.y);
                rot.y.setFrom(rot.z);
                rot.z.setFrom(temp0);
        }
    }
    accountForACSContextLock(vec) {
        // Base rotation is relative to ACS when ACS context lock is enabled...
        if (!this.currentView || !this.currentView.isContextRotationRequired())
            return;
        const rMatrix = AccuDraw.getStandardRotation(0 /* Top */, this.currentView, true);
        rMatrix.multiplyTransposeVectorInPlace(vec);
    }
    static useACSContextRotation(vp, isSnap) {
        if (isSnap) {
            if (!vp.isSnapAdjustmentRequired())
                return false;
        }
        else {
            if (!vp.isContextRotationRequired())
                return false;
        }
        return true;
    }
    /** Gets X, Y or Z vector from top, front, (right) side, ACS, or View. */
    getStandardVector(whichVec) {
        const vp = this.currentView;
        let rMatrix;
        let myAxes;
        const vecP = geometry_core_1.Vector3d.createZero();
        switch (this.flags.baseRotation) {
            case 1 /* Top */:
                switch (whichVec) {
                    case 0:
                        vecP.x = 1.0;
                        break;
                    case 1:
                        vecP.y = 1.0;
                        break;
                    case 2:
                        vecP.z = 1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case 2 /* Front */:
                switch (whichVec) {
                    case 0:
                        vecP.x = 1.0;
                        break;
                    case 1:
                        vecP.z = 1.0;
                        break;
                    case 2:
                        vecP.y = -1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case 3 /* Side */:
                switch (whichVec) {
                    case 0:
                        vecP.y = 1.0;
                        break;
                    case 1:
                        vecP.z = 1.0;
                        break;
                    case 2:
                        vecP.x = 1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case 5 /* ACS */:
                rMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.RotMatrix.createIdentity();
                myAxes = ThreeAxes.createFromRotMatrix(rMatrix);
                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);
                switch (whichVec) {
                    case 0:
                        vecP.setFrom(myAxes.x);
                        break;
                    case 1:
                        vecP.setFrom(myAxes.y);
                        break;
                    case 2:
                        vecP.setFrom(myAxes.z);
                        break;
                }
                break;
            case 4 /* View */:
                rMatrix = vp ? vp.rotMatrix : geometry_core_1.RotMatrix.createIdentity();
                rMatrix.getRow(whichVec, vecP);
                break;
            case 6 /* Context */:
                myAxes = this.baseAxes.clone();
                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);
                switch (whichVec) {
                    case 0:
                        vecP.setFrom(myAxes.x);
                        break;
                    case 1:
                        vecP.setFrom(myAxes.y);
                        break;
                    case 2:
                        vecP.setFrom(myAxes.z);
                        break;
                }
                break;
        }
        return vecP;
    }
    getBestViewedRotationFromXVector(rotation, vp) {
        const viewZ = vp.rotMatrix.getRow(2);
        const vec1 = this.getStandardVector(2);
        const vec2 = this.getStandardVector(1);
        const vec3 = this.getStandardVector(0);
        const rot1 = vec1.crossProduct(rotation.x);
        const rot2 = vec2.crossProduct(rotation.x);
        const rot3 = vec3.crossProduct(rotation.x);
        const useRot1 = (rot1.normalizeWithLength(rot1).mag > 0.00001);
        const useRot2 = (rot2.normalizeWithLength(rot2).mag > 0.00001);
        const useRot3 = (rot3.normalizeWithLength(rot3).mag > 0.00001);
        const dot1 = (useRot1 ? Math.abs(rotation.x.crossProduct(rot1).dotProduct(viewZ)) : -1.0);
        const dot2 = (useRot2 ? Math.abs(rotation.x.crossProduct(rot2).dotProduct(viewZ)) : -1.0);
        const dot3 = (useRot3 ? Math.abs(rotation.x.crossProduct(rot3).dotProduct(viewZ)) : -1.0);
        const max = Math.max(dot1, dot2, dot3);
        if (geometry_core_1.Geometry.isDistanceWithinTol(dot1 - dot2, 0.1) && (max !== dot3))
            rotation.y.setFrom(rot1);
        else if (max === dot1)
            rotation.y.setFrom(rot1);
        else if (max === dot2)
            rotation.y.setFrom(rot2);
        else
            rotation.y.setFrom(rot3);
        rotation.z.setFrom(rotation.x.crossProduct(rotation.y));
    }
    getRotationFromVector(rotation, whichVec) {
        let vec;
        switch (whichVec) {
            case 0:
                vec = this.getStandardVector(2);
                vec.crossProduct(rotation.x, rotation.y);
                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {
                    vec = this.getStandardVector(1);
                    vec.crossProduct(rotation.x, rotation.y);
                    rotation.y.normalizeInPlace();
                }
                rotation.x.crossProduct(rotation.y, rotation.z);
                break;
            case 1:
                vec = this.getStandardVector(2);
                vec.crossProduct(rotation.y, rotation.x);
                if (rotation.x.normalizeWithLength(rotation.x).mag < .00001) {
                    vec = this.getStandardVector(0);
                    vec.crossProduct(rotation.y, rotation.x);
                    rotation.x.normalizeInPlace();
                }
                rotation.x.crossProduct(rotation.y, rotation.z);
                break;
            case 2:
                vec = this.getStandardVector(0);
                rotation.z.crossProduct(vec, rotation.y);
                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {
                    vec = this.getStandardVector(1);
                    vec.crossProduct(rotation.z, rotation.x);
                    rotation.x.normalizeInPlace();
                    rotation.z.crossProduct(rotation.x, rotation.y);
                }
                else {
                    rotation.y.crossProduct(rotation.z, rotation.x);
                }
                break;
        }
    }
    updateRotation(animate = false, newRotationIn) {
        let clearLocks = true;
        const oldRotation = this.axes.clone();
        let rMatrix;
        let newRotation;
        if (!newRotationIn)
            newRotation = this.axes.clone(); // for axis based
        else
            newRotation = ThreeAxes.createFromRotMatrix(newRotationIn); // for animating context rotation change...
        const vp = this.currentView;
        const useACS = vp ? vp.isContextRotationRequired() : false;
        if (this.rotationMode === 7 /* Restore */) {
            newRotation = this.savedState.axes.clone();
            this.flags.contextRotMode = this.savedState.contextRotMode;
            this.rotationMode = 6 /* Context */;
        }
        switch (this.rotationMode) {
            case 1 /* Top */:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromRotMatrix(AccuDraw.getStandardRotation(0 /* Top */, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case 2 /* Front */:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromRotMatrix(AccuDraw.getStandardRotation(4 /* Front */, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case 3 /* Side */:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromRotMatrix(AccuDraw.getStandardRotation(3 /* Right */, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case 5 /* ACS */:
                rMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.RotMatrix.createIdentity();
                newRotation.fromRotMatrix(rMatrix);
                this.accountForAuxRotationPlane(newRotation, this.flags.auxRotationPlane);
                this.flags.lockedRotation = true;
                break;
            case 4 /* View */:
                rMatrix = vp ? vp.rotMatrix : geometry_core_1.RotMatrix.createIdentity();
                newRotation.fromRotMatrix(rMatrix);
                this.flags.lockedRotation = false;
                break;
            case 6 /* Context */:
                switch (this.flags.contextRotMode) {
                    case 1 /* XAxis */:
                        this.getRotationFromVector(newRotation, 0);
                        clearLocks = (2 /* Y_BM */ !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case 4 /* XAxis2 */:
                        if (vp)
                            this.getBestViewedRotationFromXVector(newRotation, vp); // Use base rotation axis that results in compass being most closely aligned to view direction....
                        else
                            this.getRotationFromVector(newRotation, 0);
                        clearLocks = (2 /* Y_BM */ !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case 2 /* YAxis */:
                        this.getRotationFromVector(newRotation, 1);
                        clearLocks = (1 /* X_BM */ !== this.locked || !oldRotation.y.isExactEqual(newRotation.y)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case 3 /* ZAxis */:
                        this.getRotationFromVector(newRotation, 2);
                        break;
                    case 0 /* Locked */:
                        break;
                }
                break;
        }
        const isChanged = !oldRotation.equals(newRotation);
        // unlock stuff if rotation has changed
        if (isChanged && clearLocks && (1 /* Rectangular */ === this.getCompassMode() || !this.fieldLocked[0 /* DIST_Item */] || animate)) {
            this.locked = this.indexed = 0 /* NONE_LOCKED */;
            this.unlockAllFields();
        }
        this.axes.setFrom(newRotation);
        this.lastAxes.setFrom(newRotation);
        this.flags.redrawCompass = true;
        // If animate frame preference is set...
        if (!animate || !this.animateCompassChanges || !vp)
            return;
        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();
        // viewport -> SetAnimator(* animator);
        // animator -> ChangeOfRotation(RotMatrix:: FromColumnVectors(oldRotation[0], oldRotation[1], oldRotation[2]));
    }
    enableForSession() { if (0 /* NotEnabled */ === this.currentState)
        this.currentState = 2 /* Inactive */; }
    disableForSession() {
        this.currentState = 0 /* NotEnabled */;
        this.flags.redrawCompass = true; // Make sure decorators are called so we don't draw (i.e. erase AccuDraw compass)
    }
    setLastPoint(pt) {
        const vp = this.currentView;
        if (!vp)
            return;
        const ev = new Tool_1.BeButtonEvent();
        ev.initEvent(pt, pt, vp.worldToView(pt), vp, 0 /* User */, 0 /* None */);
        IModelApp_1.IModelApp.toolAdmin.setAdjustedDataPoint(ev);
    }
    sendDataPoint(pt, vp) {
        const ev = new Tool_1.BeButtonEvent();
        ev.initEvent(pt, pt, vp.worldToView(pt), vp, 0 /* User */, 0 /* None */);
        // Send both down and up events...
        IModelApp_1.IModelApp.toolAdmin.sendDataPoint(ev);
        ev.isDown = false;
        IModelApp_1.IModelApp.toolAdmin.sendDataPoint(ev);
    }
    clearTentative() {
        if (!IModelApp_1.IModelApp.tentativePoint.isActive)
            return false;
        const wasSnapped = IModelApp_1.IModelApp.tentativePoint.isSnapped();
        IModelApp_1.IModelApp.tentativePoint.clear(true);
        return wasSnapped;
    }
    doAutoPoint(index, mode) {
        const vp = this.currentView;
        if (!vp)
            return;
        if (0 /* Polar */ === mode) {
            if (!this.autoPointPlacement)
                return;
            if (this.fieldLocked[0 /* DIST_Item */] && (this.fieldLocked[1 /* ANGLE_Item */] || this.indexed & 7 /* ANGLE_BM */) && KeyinStatus.Dynamic === this.keyinStatus[index]) {
                this.fixPointPolar(vp);
                this.sendDataPoint(this.point, vp);
            }
            return;
        }
        if (this.fieldLocked[2 /* X_Item */] && this.fieldLocked[3 /* Y_Item */]) {
            if (!this.isActive()) {
                if (!vp.view.is3d() || this.fieldLocked[4 /* Z_Item */]) {
                    const globalOrigin = new geometry_core_1.Point3d();
                    if (vp.view.isSpatialView())
                        globalOrigin.setFrom(vp.view.iModel.globalOrigin);
                    this.sendDataPoint(globalOrigin.plus(this.delta), vp);
                }
                return;
            }
            if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this.keyinStatus[index])
                return;
            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);
            this.sendDataPoint(this.point, vp);
            return;
        }
        if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this.keyinStatus[index])
            return;
        if ((2 /* X_Item */ === index && this.fieldLocked[2 /* X_Item */] && (this.indexed & 2 /* Y_BM */)) || (3 /* Y_Item */ === index && this.fieldLocked[3 /* Y_Item */] && (this.indexed & 1 /* X_BM */))) {
            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);
            this.sendDataPoint(this.point, vp);
        }
    }
    getValueByIndex(index) {
        switch (index) {
            case 2 /* X_Item */: return this.delta.x;
            case 3 /* Y_Item */: return this.delta.y;
            case 4 /* Z_Item */: return this.delta.z;
            case 0 /* DIST_Item */: return this.distance;
            case 1 /* ANGLE_Item */: return this.angle;
            default:
                return 0.0;
        }
    }
    setValueByIndex(index, value) {
        switch (index) {
            case 2 /* X_Item */:
                this.delta.x = value;
                break;
            case 3 /* Y_Item */:
                this.delta.y = value;
                break;
            case 4 /* Z_Item */:
                this.delta.z = value;
                break;
            case 0 /* DIST_Item */:
                this.distance = value;
                break;
            case 1 /* ANGLE_Item */:
                this.angle = value;
                break;
        }
    }
    updateVector(angle) {
        this.vector.set(Math.cos(angle), Math.sin(angle), 0.0);
        const rMatrix = this.getRotation();
        rMatrix.multiplyTransposeVector(this.vector);
    }
    stringToUORs(_uors, _str) {
        // DistanceParserPtr parser = DistanceParser:: Create();
        // DgnViewportP   vp = GetCompassViewport();
        // if (NULL == vp)
        //   parser = DistanceParser:: Create();
        //   else
        // parser = DistanceParser:: Create(* vp);
        // if (SUCCESS != parser.ToValue(uors, str))
        //   return ERROR;
        return 0 /* SUCCESS */;
    }
    stringToAngle(_angle, _out, _inString, _restrict) {
        // WString     buffer(inString, BentleyCharEncoding:: Utf8);
        // WChar * p1, * p2, * string;
        // int         north = 0, east = 0;
        // bool        bearing = false;
        // if (isBearing)
        //       * isBearing = false;
        // string = buffer.begin();
        // if ((p1 = wcspbrk(string, L"NnSs")) != NULL) {
        //   string = p1 + 1;
        //   if ((p2 = wcspbrk(string, L"EeWw")) == NULL)
        //     return ERROR;
        //   north = (towupper(* p1) == L'N');
        //   east = (towupper(* p2) == L'E');
        //       * p2 = 0; // terminate string
        //   bearing = true;
        // }
        // else if (string[1] == L' ')
        // {
        //   bearing = true;
        //   switch (string[0]) {
        //     case L'1':
        //       north = true;
        //       east = true;
        //       break;
        //     case L'2':
        //       north = false;
        //       east = true;
        //       break;
        //     case L'3':
        //       north = false;
        //       east = false;
        //       break;
        //     case L'4':
        //       north = true;
        //       east = false;
        //       break;
        //     default:
        //       bearing = false;
        //       break;
        //   }
        //   if (bearing)
        //     string += 2;
        // }
        //   else
        // {
        //   bearing = false;
        // }
        // while (* string == L' ')
        // string++;
        // AngleParserPtr parser = AngleParser:: Create();
        // _SetupAngleParser(* parser);
        // if (SUCCESS != parser -> ToValue(angle, Utf8String(string).c_str()))
        //   return ERROR;
        // if (bearing) {
        //   if (north) {
        //     if (east)
        //       angle = 90.0 - angle;
        //     else
        //       angle = 90.0 + angle;
        //   }
        //   else {
        //     if (east)
        //       angle = 270.0 + angle;
        //     else
        //       angle = 270.0 - angle;
        //   }
        // }
        // else {
        //   DirectionFormatterPtr  formatter;
        //   DgnViewportP vp = GetCompassViewport();
        //   if (vp)
        //     formatter = DirectionFormatter:: Create(* vp -> GetViewController().GetTargetModel());
        //       else
        //   formatter = DirectionFormatter:: Create();
        //   if (DirectionMode:: Azimuth == formatter -> GetDirectionMode())
        //   {
        //     if (formatter -> GetClockwise())
        //       angle = formatter -> GetBaseDirection() - angle;
        //     else
        //       angle = angle - formatter -> GetBaseDirection();
        //   }
        // }
        // if (restrict == true) {
        //   while (angle >= 360.0)
        //     angle -= 360.0;
        //   while (angle < 0.0)
        //     angle += 360.0;
        // }
        // angle *= (msGeomConst_pi / 180.0);
        // if (isBearing)
        //       * isBearing = bearing;
        return 0 /* SUCCESS */;
    }
    updateFieldValue(index, input, out) {
        if (input.length === 0)
            return 32768 /* ERROR */;
        if (input.length === 1)
            switch (input) {
                case ":":
                case "-":
                case "+":
                case ".":
                    return 32768 /* ERROR */;
            }
        switch (index) {
            case 0 /* DIST_Item */:
                if (0 /* SUCCESS */ !== this.stringToUORs([this.distance], input))
                    return 32768 /* ERROR */;
                break;
            case 1 /* ANGLE_Item */:
                if (0 /* SUCCESS */ !== this.stringToAngle([this.angle], out, input, true))
                    return 32768 /* ERROR */;
                break;
            case 2 /* X_Item */:
                if (0 /* SUCCESS */ !== this.stringToUORs([this.delta.x], input))
                    return 32768 /* ERROR */;
                this.xIsExplicit = (input[0] === "+" || input[0] === "-");
                if (!this.xIsExplicit) {
                    if (this.smartKeyin && this.isActive() && this.xIsNegative === (this.delta.x >= 0.0))
                        this.delta.x = -this.delta.x;
                }
                break;
            case 3 /* Y_Item */:
                if (0 /* SUCCESS */ !== this.stringToUORs([this.delta.y], input))
                    return 32768 /* ERROR */;
                this.yIsExplicit = (input[0] === "+" || input[0] === "-");
                if (!this.yIsExplicit) {
                    if (this.smartKeyin && this.isActive() && this.yIsNegative === (this.delta.y >= 0.0))
                        this.delta.y = -this.delta.y;
                }
                break;
            case 4 /* Z_Item */:
                if (0 /* SUCCESS */ !== this.stringToUORs([this.delta.z], input))
                    return 32768 /* ERROR */;
                break;
        }
        return 0 /* SUCCESS */;
    }
    unlockAllFields() {
        this.locked = 0;
        if (0 /* Polar */ === this.getCompassMode()) {
            if (this.fieldLocked[0 /* DIST_Item */])
                this.setFieldLock(0 /* DIST_Item */, false);
            if (this.fieldLocked[1 /* ANGLE_Item */])
                this.setFieldLock(1 /* ANGLE_Item */, false);
        }
        else {
            if (this.fieldLocked[2 /* X_Item */])
                this.setFieldLock(2 /* X_Item */, false);
            if (this.fieldLocked[3 /* Y_Item */])
                this.setFieldLock(3 /* Y_Item */, false);
        }
        if (this.fieldLocked[4 /* Z_Item */]) {
            if (this.stickyZLock)
                this.delta.z = 0.0;
            else
                this.setFieldLock(4 /* Z_Item */, false);
        }
        this.setKeyinStatus(0 /* DIST_Item */, KeyinStatus.Dynamic);
        this.setKeyinStatus(1 /* ANGLE_Item */, KeyinStatus.Dynamic);
        this.setKeyinStatus(2 /* X_Item */, KeyinStatus.Dynamic);
        this.setKeyinStatus(3 /* Y_Item */, KeyinStatus.Dynamic);
        this.setKeyinStatus(4 /* Z_Item */, KeyinStatus.Dynamic);
        if (!this.smartKeyin)
            this.setFocusItem(0 /* Polar */ === this.getCompassMode() ? 0 /* DIST_Item */ : 2 /* X_Item */);
        this.dontMoveFocus = false;
    }
    /** produces the normal vector of the closest plane to the view which
     * contains inVec (uses true view rotation, never auxiliary)
     */
    planeByVectorAndView(normalVec, inVec, vp) {
        if (!vp.view.is3d()) {
            normalVec.setFrom(geometry_core_1.Vector3d.unitZ());
            return true;
        }
        const viewNormal = vp.rotMatrix.getRow(2);
        const yVec = viewNormal.crossProduct(inVec);
        if (!yVec.normalizeInPlace()) {
            normalVec = viewNormal;
            return false;
        }
        inVec.crossProduct(yVec, normalVec);
        return true;
    }
    handleDegeneratePolarCase() {
        if (!(this.locked & 8 /* DIST_BM */))
            this.distance = 0.0;
        if (this.locked & 4 /* VEC_BM */) {
            this.angle = Math.acos(this.vector.dotProduct(this.axes.x));
        }
        else if (this.locked & 2 /* Y_BM */) {
            this.vector.setFrom(this.axes.y);
            this.angle = Math.PI / 2.0;
            this.indexed = this.locked;
        }
        else if (this.locked & 1 /* X_BM */) {
            this.vector.setFrom(this.axes.x);
            this.angle = 0.0;
            this.indexed = this.locked;
        }
        else {
            // use last good vector
            this.angle = Math.acos(this.vector.dotProduct(this.axes.x));
        }
        this.origin.plusScaled(this.vector, this.distance, this.point);
    }
    rawDeltaIsValid(rawDelta) {
        /* Cursor Distance (*(+/-)) sense testing is not valid when raw delta is
           meaningless (0.0)...to make this change safer only reject the
           raw delta if unit or grid lock is also on. */
        if (0.0 !== rawDelta)
            return true;
        // The "I don't want grid lock" flag can be set by tools to override the default behavior...
        if (0 === (IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr & 4 /* Grid */))
            return true;
        return (!IModelApp_1.IModelApp.toolAdmin.gridLock);
    }
    processFieldInput(index, input, synchText) {
        const isBearing = false;
        if (0 /* SUCCESS */ !== this.updateFieldValue(index, input, { isBearing })) {
            const saveKeyinStatus = this.keyinStatus[index]; // Don't want this to change when entering '.', etc.
            this.updateFieldLock(index, false);
            this.keyinStatus[index] = saveKeyinStatus;
            return;
        }
        switch (index) {
            case 0 /* DIST_Item */:
                this.distanceLock(synchText, true);
                this.doAutoPoint(index, 0 /* Polar */);
                break;
            case 1 /* ANGLE_Item */:
                this.setFieldLock(index, true);
                if (synchText) {
                    this.onFieldValueChange(index);
                    this.setKeyinStatus(index, KeyinStatus.Dynamic);
                }
                if (!isBearing || !this.flags.bearingFixToPlane2D)
                    this.updateVector(this.angle);
                else
                    this.vector.set(Math.cos(this.angle), Math.sin(this.angle), 0.0);
                this.locked |= 4 /* VEC_BM */;
                this.doAutoPoint(index, 0 /* Polar */);
                break;
            case 2 /* X_Item */:
            case 3 /* Y_Item */:
                this.locked |= (2 /* X_Item */ === index) ? 1 /* X_BM */ : 2 /* Y_BM */;
            /* falls through */
            case 4 /* Z_Item */:
                this.setFieldLock(index, true);
                if (synchText) {
                    this.onFieldValueChange(index);
                    this.setKeyinStatus(index, KeyinStatus.Dynamic);
                }
                this.doAutoPoint(index, this.getCompassMode());
                break;
        }
        this.refreshDecorationsAndDynamics();
    }
    updateFieldLock(index, locked) {
        if (locked) {
            if (!this.fieldLocked[index]) {
                this.setFieldLock(index, true);
                switch (index) {
                    case 0 /* DIST_Item */:
                        this.distanceLock(true, false);
                        break;
                    case 1 /* ANGLE_Item */:
                        this.angleLock();
                        break;
                    case 2 /* X_Item */:
                        this.locked |= 1 /* X_BM */;
                        break;
                    case 3 /* Y_Item */:
                        this.locked |= 2 /* Y_BM */;
                        break;
                    case 4 /* Z_Item */:
                        break;
                }
            }
            return;
        }
        switch (index) {
            case 0 /* DIST_Item */:
                this.locked &= ~8 /* DIST_BM */;
                break;
            case 1 /* ANGLE_Item */:
                this.locked &= ~4 /* VEC_BM */;
                break;
            case 2 /* X_Item */:
                this.locked &= ~1 /* X_BM */;
                break;
            case 3 /* Y_Item */:
                this.locked &= ~2 /* Y_BM */;
                break;
        }
        if (index !== 4 /* Z_Item */ || !this.stickyZLock)
            this.setFieldLock(index, false);
        this.setKeyinStatus(index, KeyinStatus.Dynamic);
    }
    static getStandardRotation(nStandard, vp, useACS, out) {
        const rMatrix = out ? out : new geometry_core_1.RotMatrix();
        rMatrix.setFrom(ViewState_1.ViewState.getStandardViewMatrix(nStandard));
        const useVp = vp ? vp : IModelApp_1.IModelApp.viewManager.selectedView;
        if (!useACS || !useVp)
            return rMatrix;
        rMatrix.multiplyMatrixMatrix(useVp.getAuxCoordRotation(AccuDraw.tempRot), rMatrix);
        return rMatrix;
    }
    static getCurrentOrientation(vp, checkAccuDraw, checkACS, rMatrix) {
        if (checkAccuDraw && IModelApp_1.IModelApp.accuDraw.isActive())
            return IModelApp_1.IModelApp.accuDraw.getRotation(rMatrix);
        const useVp = vp ? vp : IModelApp_1.IModelApp.viewManager.selectedView;
        if (!useVp)
            return geometry_core_1.RotMatrix.createIdentity(rMatrix);
        if (checkACS && useVp.isContextRotationRequired())
            return useVp.getAuxCoordRotation(rMatrix);
        return useVp.rotMatrix;
    }
    static updateAuxCoordinateSystem(acs, vp, allViews = true) {
        // When modeling with multiple spatial views open, you'd typically want the same ACS in all views...
        if (allViews && vp.view.isSpatialView()) {
            IModelApp_1.IModelApp.viewManager.forEachViewport((otherVp) => {
                if (otherVp !== vp && otherVp.view.isSpatialView())
                    otherVp.view.setAuxiliaryCoordinateSystem(acs);
            });
        }
        vp.view.setAuxiliaryCoordinateSystem(acs);
        // NOTE: Change AccuDraw's base rotation to ACS.
        IModelApp_1.IModelApp.accuDraw.setContext(131072 /* OrientACS */);
    }
    distanceLock(synchText, saveInHistory) {
        this.locked |= 8 /* DIST_BM */;
        if (!this.fieldLocked[0 /* DIST_Item */])
            this.setFieldLock(0 /* DIST_Item */, true);
        if (saveInHistory)
            this.saveCoordinate(0 /* DIST_Item */, this.distance);
        if (synchText) {
            this.onFieldValueChange(0 /* DIST_Item */);
            this.setKeyinStatus(0 /* DIST_Item */, KeyinStatus.Dynamic);
        }
    }
    angleLock() {
        if (this.indexed & 2 /* Y_BM */)
            this.locked |= 2 /* Y_BM */;
        else if (this.indexed & 1 /* X_BM */)
            this.locked |= 1 /* X_BM */;
        else
            this.locked |= 4 /* VEC_BM */;
        this.clearTentative();
        if (!this.fieldLocked[1 /* ANGLE_Item */]) {
            this.setFieldLock(1 /* ANGLE_Item */, true);
            this.setKeyinStatus(1 /* ANGLE_Item */, KeyinStatus.Dynamic);
        }
        this.flags.lockedRotation = true;
        this.flags.softAngleLock = false;
    }
    doLockAngle(isSnapped) {
        if (0 /* Polar */ !== this.getCompassMode()) {
            this.locked = 0 /* NONE_LOCKED */;
            this.rawPoint.setFrom(this.point);
            const vp = this.currentView;
            if (vp)
                this.fixPointPolar(vp);
            this.changeCompassMode(true);
        }
        this.setFieldLock(1 /* ANGLE_Item */, !this.fieldLocked[1 /* ANGLE_Item */]);
        if (this.fieldLocked[1 /* ANGLE_Item */]) {
            // Move focus to angle field...
            if (!isSnapped && this.autoFocusFields)
                this.setFocusItem(1 /* ANGLE_Item */);
            this.angleLock();
            if (!isSnapped)
                this.flags.softAngleLock = true;
        }
        else {
            this.locked &= ~7 /* ANGLE_BM */;
            this.saveCoordinate(1 /* ANGLE_Item */, this.angle);
        }
    }
    saveCoordinate(index, value) {
        const isAngle = (1 /* ANGLE_Item */ === index);
        let currIndex = this.savedCoords.nSaveValues + 1;
        if (currIndex >= Constants.MAX_SAVED_VALUES)
            currIndex = 0;
        if (this.savedCoords.savedValues[this.savedCoords.nSaveValues] === value && this.savedCoords.savedValIsAngle[this.savedCoords.nSaveValues] === isAngle)
            return;
        if (isAngle) {
            // don't accept 0, 90, -90, and 180 degrees
            if (value === 0.0 || value === Math.PI || value === (Math.PI / 2.0) || value === -Math.PI)
                return;
        }
        else {
            // don't accept zero
            value = Math.abs(value);
            if (value < Constants.SMALL_ANGLE)
                return;
        }
        this.savedCoords.savedValues[currIndex] = value;
        this.savedCoords.savedValIsAngle[currIndex] = isAngle;
        this.savedCoords.nSaveValues = currIndex;
        if (!isAngle)
            this.lastDistance = value;
    }
    changeCompassMode(animate = false) {
        this.setCompassMode(0 /* Polar */ === this.getCompassMode() ? 1 /* Rectangular */ : 0 /* Polar */);
        const viewport = this.currentView;
        if (!animate || !this.animateCompassChanges() || !viewport)
            return;
        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();
        // viewport.setAnimator(* animator);
        // animator -> ChangeOfMode();
    }
    changeBaseRotationMode(mode) {
        if (mode > 6 /* Context */)
            return;
        if (6 /* Context */ === mode) {
            // See if it is better to stay with the current base rotation (only care about z)...
            if (6 /* Context */ !== this.flags.baseRotation) {
                const baseRMatrix = this.getBaseRotation();
                const baseZ = baseRMatrix.getRow(2);
                if (baseZ.isParallelTo(this.axes.z))
                    return;
            }
            this.baseAxes.setFrom(this.axes);
            this.flags.auxRotationPlane = 1 /* Top */;
        }
        this.flags.baseRotation = mode;
    }
    getBaseRotation() {
        const vp = this.currentView;
        let baseRMatrix;
        const useAcs = vp ? vp.isContextRotationRequired() : false;
        switch (this.flags.baseRotation) {
            case 1 /* Top */: {
                baseRMatrix = AccuDraw.getStandardRotation(0 /* Top */, vp, useAcs);
                break;
            }
            case 2 /* Front */: {
                baseRMatrix = AccuDraw.getStandardRotation(4 /* Front */, vp, useAcs);
                break;
            }
            case 3 /* Side */: {
                baseRMatrix = AccuDraw.getStandardRotation(3 /* Right */, vp, useAcs);
                break;
            }
            case 5 /* ACS */: {
                baseRMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.RotMatrix.createIdentity();
                const axes = ThreeAxes.createFromRotMatrix(baseRMatrix);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                axes.toRotMatrix(baseRMatrix);
                break;
            }
            case 4 /* View */: {
                baseRMatrix = vp ? vp.rotMatrix : geometry_core_1.RotMatrix.createIdentity();
                break;
            }
            case 6 /* Context */: {
                const axes = new ThreeAxes();
                axes.setFrom(this.baseAxes);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                baseRMatrix = axes.toRotMatrix();
                break;
            }
            default: {
                baseRMatrix = geometry_core_1.RotMatrix.createIdentity();
                break;
            }
        }
        return baseRMatrix;
    }
    setContextRotation(rMatrix, locked, animate) {
        this.flags.lockedRotation = locked;
        this.flags.contextRotMode = locked ? 0 /* Locked */ : 15 /* None */;
        this.setRotationMode(6 /* Context */);
        this.updateRotation(animate, rMatrix);
    }
    clearContext() {
        this.published.flags = 0;
        this.flags.rotationNeedsUpdate = true;
        this.flags.fixedOrg = false;
        this.setNewFocus(2 /* X_Item */);
        this.unlockAllFields();
        if (this.rotationMode !== this.flags.baseRotation)
            this.setRotationMode(this.flags.baseRotation);
        if (this.getCompassMode() !== this.flags.baseMode)
            this.setCompassMode(this.flags.baseMode);
    }
    setContext(flags, originP, orientationP, deltaP, distanceP, angleP, transP) {
        this.published.flags |= flags;
        if (flags & 4 /* SetOrigin */ && originP) {
            this.published.origin.setFrom(originP);
            if (transP)
                transP.multiplyPoint3d(this.published.origin, this.published.origin);
        }
        if (deltaP) {
            this.published.delta.setFrom(deltaP);
            if (transP)
                this.published.delta.scaleInPlace(transP.matrix.columnX().magnitude());
        }
        if (typeof distanceP === "number") {
            this.published.distance = distanceP;
            if (transP)
                this.published.distance *= transP.matrix.columnX().magnitude();
        }
        if (typeof angleP === "number")
            this.published.angle = angleP;
        if (orientationP) {
            if (flags & 32 /* SetXAxis */ || flags & 64 /* SetNormal */ || flags & 262144 /* SetXAxis2 */) {
                this.published.vector.setFrom(orientationP);
                if (transP)
                    transP.matrix.multiplyVectorInPlace(this.published.vector);
                this.published.vector.normalizeInPlace();
            }
            else if (flags & 16 /* SetRMatrix */) {
                this.published.rMatrix.setFrom(orientationP);
                if (transP) {
                    this.published.rMatrix.multiplyMatrixMatrix(transP.matrix, this.published.rMatrix);
                    this.published.rMatrix.normalizeColumnsInPlace();
                }
            }
        }
        if (flags) {
            this.onEventCommon();
            if (!this.flags.haveValidOrigin)
                this.setDefaultOrigin(this.currentView);
        }
        return this.isEnabled() ? 0 /* SUCCESS */ : 32768 /* ERROR */;
    }
    onEventCommon() {
        if (this.published.flags & 4194304 /* RedrawCompass */) {
            this.flags.indexLocked = true;
            this.flags.redrawCompass = true;
        }
        if (this.published.flags & 8388608 /* UpdateRotation */) {
            this.flags.indexLocked = true;
            this.flags.contextRotMode = 1 /* XAxis */;
            this.setRotationMode(6 /* Context */);
            this.updateRotation();
            this.flags.indexLocked = true;
        }
    }
    onPrimitiveToolInstall() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        this.saveLockedCoords();
        // Setup default starting tool state...
        this.currentState = 2 /* Inactive */;
        this.clearContext();
        if (this.alwaysShowCompass)
            this.activate();
        return false;
    }
    onViewToolInstall() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        // Save current primitive command AccuDraw state...
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (tool && !(tool instanceof ViewTool_1.ViewTool))
            this.saveState(false);
        // Setup viewing tool defaults, disabled, etc.
        this.currentState = 1 /* Deactivated */;
        return false;
    }
    onViewToolExit() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        // NOTE: If a data button terminates a view command...exit is called between pre-data and data point event and needs to be ignored...
        this.savedState.ignoreDataButton = true;
        this.saveState(true); // Restore previous AccuDraw state...
        return false;
    }
    saveState(restore, stateBuffer) {
        if (!stateBuffer)
            stateBuffer = this.savedState;
        if (restore) {
            this.currentState = stateBuffer.state;
            this.currentView = stateBuffer.view;
            this.flags.auxRotationPlane = stateBuffer.auxRotationPlane;
            this.flags.contextRotMode = stateBuffer.contextRotMode;
            this.flags.fixedOrg = stateBuffer.fixedOrg;
            this.axes.setFrom(stateBuffer.axes);
            this.origin.setFrom(stateBuffer.origin);
            this.planePt.setFrom(stateBuffer.origin);
            this.setCompassMode(stateBuffer.mode);
            this.setRotationMode(stateBuffer.rotationMode);
            this.updateRotation();
            if (stateBuffer.ignoreDataButton)
                this.flags.ignoreDataButton = (this.flags.inDataPoint ? true : false);
            return;
        }
        stateBuffer.state = this.currentState;
        stateBuffer.view = this.currentView;
        stateBuffer.auxRotationPlane = this.flags.auxRotationPlane;
        stateBuffer.contextRotMode = this.flags.contextRotMode;
        stateBuffer.fixedOrg = this.flags.fixedOrg;
        stateBuffer.ignoreDataButton = false;
        stateBuffer.axes.setFrom(this.axes);
        stateBuffer.origin.setFrom(this.origin);
        stateBuffer.mode = this.getCompassMode();
        stateBuffer.rotationMode = this.rotationMode;
    }
    getCompassPlanePoint(point, vp) {
        point.setFrom(this.origin); // Isn't this just planePt?!? Maybe at display time it is not setup yet?!?
        if (this.fieldLocked[4 /* Z_Item */] && vp.view.is3d()) {
            if (0.0 !== this.delta.z && !(this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE)) {
                point.addScaledInPlace(this.axes.z, this.delta.z);
                return true;
            }
        }
        return false;
    }
    getDisplayTransform(vp) {
        const rMatrix = (!this.flags.animateRotation || 0.0 === this.percentChanged) ? this.axes.toRotMatrix() : this.lastAxes.toRotMatrix();
        const origin = new geometry_core_1.Point3d(); // Compass origin is adjusted by active z-lock...
        this.getCompassPlanePoint(origin, vp);
        const scale = vp.pixelsFromInches(this.compassSizeInches) * vp.getPixelSizeAtPoint(origin);
        rMatrix.scaleColumns(scale, scale, scale, rMatrix);
        return geometry_core_1.Transform.createRefs(origin, rMatrix);
    }
    setIndexingTolerance(vp) {
        const origin = new geometry_core_1.Point3d(); // Compass origin is adjusted by active z-lock...
        this.getCompassPlanePoint(origin, vp);
        this.tolerance = vp.pixelsFromInches(this.indexToleranceInches) * vp.getPixelSizeAtPoint(origin);
        if (Constants.SMALL_ANGLE > this.tolerance)
            this.tolerance = Constants.SMALL_ANGLE;
    }
    displayAlignments(graphic, vp) {
        const bgColor = vp.view.backgroundColor;
        const colorIndex = this.indexColor.adjustForContrast(bgColor, 125);
        const pts = [];
        pts[0] = new geometry_core_1.Point3d();
        // For non-zero Z value draw indicator line from plane point to compass origin...
        if (this.getCompassPlanePoint(pts[0], vp)) {
            const colorZ = this.frameColor.adjustForContrast(bgColor, 100);
            pts[1] = this.origin;
            graphic.setSymbology(colorZ, colorZ, 2);
            graphic.addLineString(pts);
            pts[0] = pts[1];
            graphic.setSymbology(colorZ, colorZ, 4);
            graphic.addLineString(pts);
        }
        // Get snap point from AccuSnap/Tentative or use raw point...
        let distance = 0.0;
        let snapPt = this.rawPoint;
        const ptP = this.point;
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap();
        if (snap) {
            snapPt = snap.snapPoint;
            distance = ptP.distance(snapPt);
        }
        const isRectMode = (1 /* Rectangular */ === this.getCompassMode());
        const offsetSnap = ((AccuSnap_1.TentativeOrAccuSnap.isHot() || IModelApp_1.IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));
        // XY Offset:
        if (offsetSnap) {
            pts[0] = ptP;
            if (isRectMode) {
                pts[1] = this.rawPointOnPlane;
                const vec = pts[0].vectorTo(pts[1]);
                const xOffset = vec.dotProduct(this.axes.x);
                const yOffset = vec.dotProduct(this.axes.y);
                const xIsOffset = (Math.abs(xOffset) > 1.0);
                const yIsOffset = (Math.abs(yOffset) > 1.0);
                if (xIsOffset) {
                    if (yIsOffset) {
                        pts[2] = pts[1];
                        pts[1] = pts[0].plusScaled(this.axes.y, yOffset);
                        pts[3] = pts[0].plusScaled(this.axes.x, xOffset);
                        pts[4] = pts[0];
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString(pts);
                        pts[1] = pts[2]; /* used by z offset */
                    }
                    else {
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString(pts);
                    }
                }
                else if (yIsOffset) {
                    graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                    graphic.addLineString(pts);
                }
            }
        }
        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));
        // Z Offset:
        if (offsetSnap) {
            if (isOnCompassPlane) {
                if (isRectMode) {
                    const zOffset = snapPt.distance(this.rawPointOnPlane);
                    if (zOffset > Constants.SMALL_ANGLE || zOffset < -Constants.SMALL_ANGLE) {
                        pts[2] = this.rawPoint;
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString([pts[1], pts[2]]);
                    }
                }
                else {
                    pts[1] = this.rawPoint;
                    graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                    graphic.addLineString(pts);
                }
            }
        }
        // Fat Point:
        if (offsetSnap) {
            pts[0] = ptP;
            pts[1] = ptP;
            const graphicParams = imodeljs_common_1.GraphicParams.fromSymbology(colorIndex, colorIndex, 8);
            graphicParams.fillFlags |= imodeljs_common_1.FillFlags.ByView; // Mark as filled
            graphic.activateGraphicParams(graphicParams);
            graphic.addPointString(pts);
            graphicParams.fillFlags &= ~(imodeljs_common_1.FillFlags.ByView); // Mark as not filled
            graphic.activateGraphicParams(graphicParams);
        }
        let axisIsIndexed = false;
        // Axis Indexing:
        if (isRectMode) {
            if ((this.indexed & 3 /* XY_BM */) && (this.flags.pointIsOnPlane || this.fieldLocked[4 /* Z_Item */])) {
                pts[1] = this.planePt;
                axisIsIndexed = true;
            }
        }
        else {
            if ((this.indexed & 7 /* ANGLE_BM */ || this.locked & 7 /* ANGLE_BM */) && (this.flags.pointIsOnPlane || this.fieldLocked[4 /* Z_Item */])) {
                pts[1] = this.planePt;
                axisIsIndexed = true;
            }
        }
        if (axisIsIndexed) {
            pts[0] = ptP;
            graphic.setSymbology(colorIndex, colorIndex, 4);
            graphic.addLineString(pts);
        }
        // Distance Indexing:
        if (this.indexed & 8 /* DIST_BM */) {
            const len = this.tolerance; // Show tick mark based on _GetIndexToleranceInches for length...
            let vec;
            if (isRectMode) {
                let index = this.indexed & 3 /* XY_BM */;
                if (!index)
                    index = this.locked & 3 /* XY_BM */;
                vec = (index === 1 /* X_BM */) ? this.axes.x : this.axes.y;
            }
            else {
                const deltaVec = this.origin.vectorTo(ptP);
                vec = this.axes.z.crossProduct(deltaVec);
                vec.normalizeInPlace();
            }
            pts[0] = ptP.plusScaled(vec, len);
            pts[1] = ptP.plusScaled(vec, -len);
            graphic.setSymbology(colorIndex, colorIndex, 3);
            graphic.addLineString(pts);
        }
        // XY Lock:
        if (isRectMode && !axisIsIndexed) {
            const locked = this.locked & 3 /* XY_BM */;
            if ((0 !== locked) && isOnCompassPlane) {
                if (locked & 1 /* X_BM */)
                    pts[2] = this.planePt.plusScaled(this.axes.x, this.delta.x);
                if (locked & 2 /* Y_BM */)
                    pts[0] = this.planePt.plusScaled(this.axes.y, this.delta.y);
                pts[1] = ptP;
                switch (locked) {
                    case 1 /* X_BM */:
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString([pts[1], pts[2]]);
                        break;
                    case 2 /* Y_BM */:
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString(pts);
                        break;
                    case 3 /* XY_BM */:
                        graphic.setSymbology(colorIndex, colorIndex, 2, 3772834016 /* Code5 */);
                        graphic.addLineString(pts);
                        break;
                }
            }
        }
    }
    decorate(context) {
        // Make sure this is cleared even if we do nothing...redraw might have been to make compass go away...
        this.flags.redrawCompass = false;
        // Check that AccuDraw is enabled...
        if (!this.isActive || !this.enableDisplay)
            return;
        const vp = context.viewport;
        if (this.currentView !== vp)
            return;
        this.setIndexingTolerance(vp);
        // Display indexing lines, distance locks, etc. without compass transform...
        let graphic = context.createWorldOverlay();
        this.displayAlignments(graphic, vp);
        context.addWorldOverlay(graphic.finish());
        const transform = this.getDisplayTransform(vp);
        // Create a new graphics with the compass transform and scale so that compass size is 1.0...
        graphic = context.createWorldOverlay(transform);
        const hasFocus = this.hasInputFocus;
        const bgColor = vp.view.backgroundColor;
        const darkGrey = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.darkGrey);
        const lightGrey = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.lightGrey);
        const frameColor = (hasFocus ? this.frameColor : darkGrey).adjustForContrast(bgColor, 100);
        const fillColor = (hasFocus ? this.fillColor : lightGrey).adjustForContrast(bgColor, 180);
        const xColor = (hasFocus ? this.xColor : darkGrey).adjustForContrast(bgColor, 100);
        const yColor = (hasFocus ? this.yColor : darkGrey).adjustForContrast(bgColor, 100);
        const shadowColor = frameColor;
        // Display compass frame...
        const graphicParams = imodeljs_common_1.GraphicParams.fromSymbology(shadowColor, fillColor, 1);
        const center = geometry_core_1.Point3d.createZero();
        if (this.flags.animateRotation || 0.0 === this.percentChanged) {
            if (0 /* Polar */ === this.getCompassMode()) {
                const ellipse = geometry_core_1.Arc3d.createXYEllipse(center, 1, 1);
                graphic.activateGraphicParams(graphicParams);
                graphic.addArc(ellipse, true, true);
                graphic.addArc(ellipse, false, false);
            }
            else {
                const shapePts = [
                    new geometry_core_1.Point3d(-1.0, 1.0, 0.0),
                    new geometry_core_1.Point3d(1.0, 1.0, 0.0),
                    new geometry_core_1.Point3d(1.0, -1.0, 0.0),
                    new geometry_core_1.Point3d(-1.0, -1.0, 0.0)
                ];
                shapePts[4] = shapePts[0];
                graphicParams.fillFlags |= imodeljs_common_1.FillFlags.ByView; // Mark as filled
                graphic.activateGraphicParams(graphicParams);
                graphic.addShape(shapePts);
                graphicParams.fillFlags &= ~(imodeljs_common_1.FillFlags.ByView); // Mark as not filled
                graphic.activateGraphicParams(graphicParams);
            }
        }
        else {
            let nSides, radius;
            const minSides = 7, maxSides = 24, factor = 1.0 / 5.0;
            // if currently animating change to polar need to get larger radius...go between 1.0 && 1.0 * sqrt (2.0)
            if (0 /* Polar */ === this.getCompassMode()) {
                nSides = minSides + Math.floor(maxSides * this.percentChanged);
                radius = 1.0 + factor - (factor * this.percentChanged);
            }
            else {
                nSides = (maxSides - Math.floor(maxSides * this.percentChanged)) + minSides;
                radius = 1.0 + (factor * this.percentChanged);
            }
            let angle = 0.0;
            const delta = (Math.PI * 2) / nSides;
            const shapePtsP = [];
            for (let iSide = 0; iSide < nSides; iSide++, angle += delta)
                shapePtsP[iSide] = new geometry_core_1.Point3d(radius * Math.cos(angle), radius * Math.sin(angle), 0.0);
            shapePtsP[nSides] = shapePtsP[0];
            graphicParams.fillFlags |= imodeljs_common_1.FillFlags.ByView; // Mark as filled
            graphic.activateGraphicParams(graphicParams);
            graphic.addShape(shapePtsP);
            graphicParams.fillFlags &= ~(imodeljs_common_1.FillFlags.ByView); // Mark as not filled
            graphic.activateGraphicParams(graphicParams);
            graphic.addLineString(shapePtsP);
        }
        // Display sticky z-lock indicator as frame inset...
        if (this.fieldLocked[4 /* Z_Item */] && this.stickyZLock && vp.view.is3d()) {
            graphic.setSymbology(frameColor, fillColor, 1);
            if (0 /* Polar */ === this.getCompassMode()) {
                const ellipse = geometry_core_1.Arc3d.createXYEllipse(center, .5, .5);
                graphic.addArc(ellipse, false, false);
            }
            else {
                const shapePts = [
                    new geometry_core_1.Point3d(-0.5, 0.5, 0.0),
                    new geometry_core_1.Point3d(0.5, 0.5, 0.0),
                    new geometry_core_1.Point3d(0.5, -0.5, 0.0),
                    new geometry_core_1.Point3d(-0.5, -0.5, 0.0)
                ];
                shapePts[4] = shapePts[0];
                graphic.addLineString(shapePts);
            }
        }
        // Display compass center mark...
        graphic.setSymbology(frameColor, frameColor, 8);
        graphic.addPointString([center]);
        // Display positive "X" tick...
        graphic.setSymbology(xColor, xColor, 4);
        const linePts = [];
        linePts[0] = new geometry_core_1.Point3d(1.2, 0.0, 0.0);
        linePts[1] = new geometry_core_1.Point3d(0.8, 0.0, 0.0);
        graphic.addLineString(linePts);
        // Display negative "X" tick...
        graphic.setSymbology(frameColor, frameColor, 1);
        linePts[0].set(-1.2, 0.0, 0.0);
        linePts[1].set(-0.8, 0.0, 0.0);
        graphic.addLineString(linePts);
        // Display positive "Y" tick...
        graphic.setSymbology(yColor, yColor, 4);
        linePts[0].set(0.0, 1.2, 0.0);
        linePts[1].set(0.0, 0.8, 0.0);
        graphic.addLineString(linePts);
        // Display negative "Y" tick...
        graphic.setSymbology(frameColor, frameColor, 1);
        linePts[0].set(0.0, -1.2, 0.0);
        linePts[1].set(0.0, -0.8, 0.0);
        graphic.addLineString(linePts);
        context.addWorldOverlay(graphic.finish()); // add compass as world overlay decorator
    }
    checkRotation() {
        this.updateRotation();
        if (4 /* View */ === this.rotationMode || !this.flags.lockedRotation)
            return;
        const vp = this.currentView;
        if (!vp || vp.isCameraOn())
            return;
        const viewZRoot = vp.rotMatrix.getRow(2);
        if (!this.axes.z.isPerpendicularTo(viewZRoot))
            return;
        const preferY = (Math.abs(this.axes.x.dotProduct(viewZRoot)) < Math.abs(this.axes.y.dotProduct(viewZRoot)));
        // NOTE: Cycle rotation to get one that isn't edge-on...
        switch (this.rotationMode) {
            case 1 /* Top */:
                this.setRotationMode(preferY ? 2 /* Front */ : 3 /* Side */);
                break;
            case 2 /* Front */:
                this.setRotationMode(preferY ? 1 /* Top */ : 3 /* Side */);
                break;
            case 3 /* Side */:
                this.setRotationMode(preferY ? 1 /* Top */ : 2 /* Front */);
                break;
            case 5 /* ACS */:
                switch (this.flags.auxRotationPlane) {
                    case 1 /* Top */:
                        this.flags.auxRotationPlane = preferY ? 2 /* Front */ : 3 /* Side */;
                        break;
                    case 2 /* Front */:
                        this.flags.auxRotationPlane = preferY ? 1 /* Top */ : 3 /* Side */;
                        break;
                    case 3 /* Side */:
                        this.flags.auxRotationPlane = preferY ? 1 /* Top */ : 2 /* Front */;
                        break;
                    default:
                        return;
                }
                break;
            default:
                return;
        }
        this.updateRotation();
        this.flags.baseRotation = this.rotationMode;
    }
    saveLockedCoords() {
        if (0 /* Polar */ === this.currentMode) {
            if (this.fieldLocked[0 /* DIST_Item */])
                this.saveCoordinate(0 /* DIST_Item */, this.distance);
            if (this.fieldLocked[1 /* ANGLE_Item */])
                this.saveCoordinate(1 /* ANGLE_Item */, this.angle);
        }
        else {
            if (this.fieldLocked[2 /* X_Item */])
                this.saveCoordinate(2 /* X_Item */, this.delta.x);
            if (this.fieldLocked[3 /* Y_Item */])
                this.saveCoordinate(3 /* Y_Item */, this.delta.y);
        }
        const vp = this.currentView;
        if (vp && vp.view.is3d()) {
            if (this.fieldLocked[4 /* Z_Item */])
                this.saveCoordinate(4 /* Z_Item */, this.delta.z);
        }
    }
    onCompassModeChange() { }
    onRotationModeChange() { }
    onFieldLockChange(_index) { }
    onFieldValueChange(_index) { }
    hasInputFocus() { return true; }
    setFocusItem(_index) { }
    static getMinPolarMag(origin) {
        return (1.0e-12 * (1.0 + origin.magnitude()));
    }
    /** projects cursor onto plane in view, or returns an error */
    constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, perpendicular) {
        let fromPtP;
        let dotProduct;
        let distance;
        let projectionVector = new geometry_core_1.Vector3d();
        if (perpendicular) {
            if (AccuDraw.useACSContextRotation(vp, true)) {
                const rMatrix = vp.getAuxCoordRotation(AccuDraw.tempRot);
                const axes = ThreeAxes.createFromRotMatrix(rMatrix);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                LegacyMath_1.LegacyMath.linePlaneIntersect(outPtP, inPtP, axes.z, pointOnPlaneP, normalVectorP, false);
            }
            else {
                projectionVector = inPtP.vectorTo(pointOnPlaneP);
                distance = projectionVector.dotProduct(normalVectorP);
                inPtP.plusScaled(normalVectorP, distance, outPtP);
            }
        }
        else {
            const isCamera = vp.isCameraOn();
            if (vp.view.is3d() && isCamera) {
                const cameraPos = vp.view.getEyePoint();
                fromPtP = cameraPos;
                fromPtP.vectorTo(inPtP, projectionVector).normalizeInPlace();
            }
            else {
                const rMatrix = vp.rotMatrix;
                fromPtP = inPtP;
                rMatrix.getRow(2, projectionVector);
            }
            dotProduct = projectionVector.dotProduct(normalVectorP);
            if (Math.abs(dotProduct) < Constants.SMALL_DELTA)
                return 32768 /* ERROR */; // PARALLEL;
            distance = (normalVectorP.dotProduct(pointOnPlaneP) - normalVectorP.dotProduct(fromPtP)) / dotProduct;
            if (isCamera && distance < Constants.SMALL_DELTA)
                return 32768 /* ERROR */; // BEHIND_EYE_POINT;
            fromPtP.plusScaled(projectionVector, distance, outPtP);
        }
        return 0 /* SUCCESS */;
    }
    softConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {
        if (!vp.isPointAdjustmentRequired()) {
            outPtP.setFrom(inPtP);
            return true;
        }
        if (isSnap) {
            outPtP.setFrom(inPtP);
            const delta = pointOnPlaneP.vectorTo(outPtP);
            return (Math.abs(normalVectorP.dotProduct(delta)) < Constants.SMALL_DELTA);
        }
        if (0 /* SUCCESS */ !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, false)) {
            const viewNormal = vp.rotMatrix.getRow(2);
            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);
            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);
            return false;
        }
        return true;
    }
    /** snap projects normal, always produces point */
    hardConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {
        if (!vp.isPointAdjustmentRequired()) {
            outPtP.setFrom(inPtP);
            return true;
        }
        if (0 /* SUCCESS */ !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap)) {
            const viewNormal = vp.rotMatrix.getRow(2);
            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);
            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);
        }
        return true;
    }
    static allowAxisIndexing(pointIsOnPlane) {
        // NOTE: Normally we don't want indexing overriding a hot snap location. The
        //       exception to this is nearest snap. If the nearest snap is in the plane
        //       of the AccuDraw compass, it is confusing not having axis indexing.
        if (!AccuSnap_1.TentativeOrAccuSnap.isHot())
            return true;
        if (!pointIsOnPlane)
            return false;
        const snapDetail = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        return (!!snapDetail && (1 /* Nearest */ === snapDetail.snapMode));
    }
    applyDistanceRoundOff(distance, vp) {
        if (!this.distanceRoundOff.active || !this.distanceRoundOff.units.size)
            return undefined;
        let roundValue = this.distanceRoundOff.units.values().next().value;
        if (this.distanceRoundOff.units.size > 1) {
            // NOTE: Set isn't ordered, find smallest entry...
            this.distanceRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue < roundValue)
                    roundValue = thisRoundValue;
            });
            if (vp.viewDelta.magnitudeXY() < roundValue)
                return undefined; // Smallest rounding value is larger than view...don't use...
            const smallScreenDist = 0.0787402; // ~2 mm...
            const pixelSize = vp.getPixelSizeAtPoint(this.origin);
            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;
            this.distanceRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue > roundValue && thisRoundValue < screenDist)
                    roundValue = thisRoundValue;
            });
        }
        if (roundValue <= 0.0)
            return undefined;
        return roundValue * Math.floor((distance / roundValue) + 0.5);
    }
    applyAngleRoundOff(angle, distance, vp) {
        if (!this.angleRoundOff.active || !this.angleRoundOff.units.size)
            return undefined;
        let roundValue = this.angleRoundOff.units.values().next().value;
        if (this.angleRoundOff.units.size > 1) {
            // NOTE: Set isn't ordered, find smallest entry...
            this.angleRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue < roundValue)
                    roundValue = thisRoundValue;
            });
            const circumference = 2.0 * Math.PI * distance;
            const roundDist = circumference / ((2.0 * Math.PI) / roundValue);
            if (vp.viewDelta.magnitudeXY() < roundDist)
                return undefined; // Smallest rounding value is larger than view...don't use...
            const smallScreenDist = 0.0787402; // ~2 mm...
            const pixelSize = vp.getPixelSizeAtPoint(this.origin);
            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;
            this.angleRoundOff.units.forEach((thisRoundValue) => {
                const thisRoundDist = circumference / ((2.0 * Math.PI) / thisRoundValue);
                if (thisRoundValue > roundValue && thisRoundDist < screenDist)
                    roundValue = thisRoundValue;
            });
        }
        if (roundValue <= 0.0)
            return undefined;
        return roundValue * Math.floor((angle / roundValue) + 0.5);
    }
    fixPointPolar(vp) {
        let angleChanged = false;
        let distChanged = false;
        const zLocked = this.isZLocked(vp);
        const xyCorrection = new geometry_core_1.Point3d();
        this.planePt.setFrom(this.origin);
        if (zLocked && !(this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE))
            this.planePt.addScaledInPlace(this.axes.z, this.delta.z);
        if (this.locked & 4 /* VEC_BM */) {
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot()) {
                const normVec = new geometry_core_1.Vector3d();
                this.planeByVectorAndView(normVec, this.vector, vp);
                this.softConstructionPlane(this.rawPointOnPlane, this.rawPoint, this.planePt, normVec, vp, false);
            }
            else {
                this.rawPointOnPlane.setFrom(this.rawPoint);
                this.flags.pointIsOnPlane = false;
            }
        }
        else {
            if (zLocked) {
                this.hardConstructionPlane(this.rawPointOnPlane, this.rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot());
                this.flags.pointIsOnPlane = true;
            }
            else {
                this.flags.pointIsOnPlane = (this.softConstructionPlane(this.rawPointOnPlane, this.rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot()) || !!(this.locked & 3 /* XY_BM */));
            }
        }
        let delta;
        if (zLocked)
            delta = this.planePt.vectorTo(this.rawPointOnPlane);
        else
            delta = this.origin.vectorTo(this.rawPointOnPlane);
        const minPolarMag = AccuDraw.getMinPolarMag(this.origin);
        let mag;
        if (this.locked & 4 /* VEC_BM */) {
            mag = delta.dotProduct(this.vector);
            xyCorrection.x -= delta.x - mag * this.vector.x;
            xyCorrection.y -= delta.y - mag * this.vector.y;
            xyCorrection.z -= delta.z - mag * this.vector.z;
            this.vector.scale(mag, delta);
            if (mag < 0.0)
                mag = -mag;
            if (mag < minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
            this.flags.pointIsOnPlane = (Math.abs(this.axes.z.dotProduct(delta)) < Constants.SMALL_DELTA);
        }
        else {
            mag = delta.magnitude();
            if (mag < minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
        }
        const newPt = this.rawPointOnPlane.plus(xyCorrection);
        xyCorrection.setZero();
        // measure angle
        const rotVec = new geometry_core_1.Point3d();
        rotVec.x = this.axes.x.dotProduct(delta);
        // NOTE: Always return angle relative to compass plane...used to return "angle out of plane" for points off plane.
        rotVec.y = this.axes.y.dotProduct(delta);
        this.angle = Math.atan2(rotVec.y, rotVec.x);
        // constrain angle
        if (this.flags.pointIsOnPlane && !(this.locked & 4 /* VEC_BM */)) {
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot()) {
                const newAngle = this.applyAngleRoundOff(this.angle, mag, vp);
                if (undefined !== newAngle) {
                    angleChanged = true;
                    this.angle = newAngle;
                    xyCorrection.x += Math.cos(this.angle) * mag - rotVec.x;
                    xyCorrection.y += Math.sin(this.angle) * mag - rotVec.y;
                    rotVec.x = Math.cos(this.angle) * mag;
                    rotVec.y = Math.sin(this.angle) * mag;
                }
            }
            if (this.locked & 1 /* X_BM */ || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.x < this.tolerance && rotVec.x > -this.tolerance) && !this.flags.indexLocked && this.axisIndexing)) {
                this.indexed |= 1 /* X_BM */; // indexed in X
                xyCorrection.x -= rotVec.x;
                rotVec.x = 0.0;
                if (AccuSnap_1.TentativeOrAccuSnap.isHot())
                    xyCorrection.z -= delta.dotProduct(this.axes.z);
                this.angle = (rotVec.y < 0.0) ? -Math.PI / 2.0 : Math.PI / 2.0;
                angleChanged = true;
            }
            if (this.locked & 2 /* Y_BM */ || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.y < this.tolerance && rotVec.y > -this.tolerance) && !this.flags.indexLocked && this.axisIndexing)) {
                if (this.indexed & 1 /* X_BM */) {
                    this.handleDegeneratePolarCase();
                    return;
                }
                this.indexed |= 2 /* Y_BM */; // indexed in Y
                xyCorrection.y -= rotVec.y;
                if (AccuSnap_1.TentativeOrAccuSnap.isHot())
                    xyCorrection.z -= delta.dotProduct(this.axes.z);
                rotVec.y = 0.0;
                this.angle = (rotVec.x < 0.0) ? Math.PI : 0.0;
                angleChanged = true;
            }
            if (angleChanged) {
                delta.addScaledInPlace(this.axes.x, rotVec.x);
                delta.addScaledInPlace(this.axes.y, rotVec.y);
                mag = delta.magnitude();
                if (mag < minPolarMag) {
                    this.handleDegeneratePolarCase();
                    return;
                }
            }
        }
        // constrain distance
        const oldMag = mag;
        if (this.locked & 8 /* DIST_BM */) {
            mag = this.distance;
            distChanged = true;
            this.indexed &= ~8 /* DIST_BM */;
        }
        else if (!AccuSnap_1.TentativeOrAccuSnap.isHot()) {
            const newDist = this.applyDistanceRoundOff(mag, vp);
            if (undefined !== newDist) {
                distChanged = true;
                mag = newDist;
            }
            if (geometry_core_1.Geometry.isDistanceWithinTol(mag - this.lastDistance, this.tolerance) && !this.flags.indexLocked && this.distanceIndexing) {
                this.indexed |= 8 /* DIST_BM */; // distance indexed
                mag = this.lastDistance;
                distChanged = true;
            }
        }
        // project to corrected point
        newPt.plus3Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.axes.z, xyCorrection.z, newPt);
        // display index highlight even if snapped
        if (AccuSnap_1.TentativeOrAccuSnap.isHot() && this.flags.pointIsOnPlane) {
            if (Math.abs(rotVec.x) < Constants.SMALL_ANGLE)
                this.indexed |= 1 /* X_BM */;
            else if (Math.abs(rotVec.y) < Constants.SMALL_ANGLE)
                this.indexed |= 2 /* Y_BM */;
        }
        if (distChanged) {
            if (mag < minPolarMag && mag > -minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
            // adjust corrected point for distance indexing
            newPt.addScaledInPlace(delta, mag / oldMag - 1.0);
            delta.scaleInPlace(mag / oldMag);
        }
        // save corrected point
        this.point.setFrom(newPt);
        // finish up
        this.distance = mag;
        if (!(this.locked & 4 /* VEC_BM */))
            delta.scale(1.0 / mag, this.vector);
        if (this.locked & 3 /* XY_BM */)
            this.indexed |= this.locked;
        if (!zLocked)
            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : delta.dotProduct(this.axes.z);
    }
    fixPointRectangular(vp) {
        const zLocked = this.isZLocked(vp);
        const xyCorrection = new geometry_core_1.Vector3d();
        this.planePt.setFrom(this.origin);
        this.indexed = 0;
        if (zLocked) {
            this.flags.pointIsOnPlane = (this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE);
            if (!this.flags.pointIsOnPlane)
                this.planePt.addScaledInPlace(this.axes.z, this.delta.z);
            this.hardConstructionPlane(this.rawPointOnPlane, this.rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot());
        }
        else {
            this.flags.pointIsOnPlane = this.softConstructionPlane(this.rawPointOnPlane, this.rawPoint, this.origin, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot());
        }
        const trueDelta = this.origin.vectorTo(this.rawPointOnPlane);
        this.rawDelta.x = trueDelta.dotProduct(this.axes.x);
        this.xIsNegative = (this.rawDelta.x < -Constants.SMALL_ANGLE);
        this.rawDelta.y = trueDelta.dotProduct(this.axes.y);
        this.yIsNegative = (this.rawDelta.y < -Constants.SMALL_ANGLE);
        if (!zLocked)
            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : trueDelta.dotProduct(this.axes.z);
        if (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane)) {
            if (!(this.locked & 1 /* X_BM */)) {
                const roundedDeltaX = this.applyDistanceRoundOff(this.rawDelta.x, vp); // round x
                if (undefined !== roundedDeltaX) {
                    xyCorrection.x = roundedDeltaX - this.rawDelta.x;
                    this.rawDelta.x = roundedDeltaX;
                }
                if (this.rawDelta.x < this.tolerance && this.rawDelta.x > -this.tolerance &&
                    !this.flags.indexLocked && this.axisIndexing) {
                    this.indexed |= 1 /* X_BM */; // indexed in X
                    xyCorrection.x -= this.rawDelta.x;
                    this.rawDelta.x = 0.0;
                }
            }
            if (!(this.locked & 2 /* Y_BM */)) {
                const roundedDeltaY = this.applyDistanceRoundOff(this.rawDelta.y, vp); // round y
                if (undefined !== roundedDeltaY) {
                    xyCorrection.y = roundedDeltaY - this.rawDelta.y;
                    this.rawDelta.y = roundedDeltaY;
                }
                if (this.rawDelta.y < this.tolerance && this.rawDelta.y > -this.tolerance &&
                    !this.flags.indexLocked && this.axisIndexing) {
                    this.indexed |= 2 /* Y_BM */; // indexed in Y
                    xyCorrection.y -= this.rawDelta.y;
                    this.rawDelta.y = 0.0;
                }
            }
        }
        if (this.locked & 1 /* X_BM */) {
            if (this.rawDeltaIsValid(this.rawDelta.x)) {
                // cursor changed sides, reverse value
                if ((this.delta.x < -Constants.SMALL_ANGLE) !== this.xIsNegative &&
                    this.smartKeyin && this.keyinStatus[2 /* X_Item */] === KeyinStatus.Partial &&
                    !this.xIsExplicit)
                    this.delta.x = -this.delta.x;
            }
            xyCorrection.x = this.delta.x - this.rawDelta.x;
        }
        else {
            const lastDist = (this.rawDelta.x < 0.0) ? (-this.lastDistance) : this.lastDistance;
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot() && ((this.locked & 2 /* Y_BM */) || (this.indexed & 2 /* Y_BM */)) && !(this.indexed & 1 /* X_BM */) &&
                geometry_core_1.Geometry.isDistanceWithinTol(this.rawDelta.x - lastDist, this.tolerance) &&
                !this.flags.indexLocked && this.distanceIndexing) {
                xyCorrection.x += lastDist - this.rawDelta.x;
                this.delta.x = lastDist;
                this.indexed |= 8 /* DIST_BM */;
            }
            else {
                this.delta.x = this.rawDelta.x;
            }
        }
        if (this.locked & 2 /* Y_BM */) {
            if (this.rawDeltaIsValid(this.rawDelta.y)) {
                // cursor changed sides, reverse value
                if ((this.delta.y < -Constants.SMALL_ANGLE) !== this.yIsNegative &&
                    this.smartKeyin && this.keyinStatus[3 /* Y_Item */] === KeyinStatus.Partial &&
                    !this.yIsExplicit)
                    this.delta.y = -this.delta.y;
            }
            xyCorrection.y = this.delta.y - this.rawDelta.y;
        }
        else {
            const lastDist = (this.rawDelta.y < Constants.SMALL_ANGLE) ? -this.lastDistance : this.lastDistance;
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot() && ((this.locked & 1 /* X_BM */) || (this.indexed & 1 /* X_BM */)) && !(this.indexed & 2 /* Y_BM */) &&
                geometry_core_1.Geometry.isDistanceWithinTol(this.rawDelta.y - lastDist, this.tolerance) &&
                !this.flags.indexLocked && this.distanceIndexing) {
                xyCorrection.y += lastDist - this.rawDelta.y;
                this.delta.y = lastDist;
                this.indexed |= 8 /* DIST_BM */;
            }
            else {
                this.delta.y = this.rawDelta.y;
            }
        }
        this.rawPointOnPlane.plus2Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.point);
        if (zLocked && !this.flags.pointIsOnPlane)
            this.hardConstructionPlane(this.point, this.point, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot());
        if ((this.locked & 1 /* X_BM */ && this.delta.x === 0.0) || (this.locked & 2 /* Y_BM */ && this.delta.y === 0.0)) {
            this.indexed |= this.locked; // to display index highlight
        }
        else if (AccuSnap_1.TentativeOrAccuSnap.isHot()) {
            if (Math.abs(this.delta.x) < Constants.SMALL_ANGLE)
                this.indexed |= 1 /* X_BM */;
            else if (Math.abs(this.delta.y) < Constants.SMALL_ANGLE)
                this.indexed |= 2 /* Y_BM */;
        }
        const lock = this.locked & 3 /* XY_BM */;
        const index = this.indexed & 3 /* XY_BM */;
        if (lock === 2 /* Y_BM */ && index !== 1 /* X_BM */) {
            if (this.keyinStatus[3 /* Y_Item */] !== KeyinStatus.Dynamic) {
                if (Math.abs(this.rawDelta.x) < this.threshold)
                    return;
            }
            this.newFocus = 2 /* X_Item */;
            this.dontMoveFocus = false;
        }
        else if (lock === 1 /* X_BM */ && index !== 2 /* Y_BM */) {
            if (this.keyinStatus[2 /* X_Item */] !== KeyinStatus.Dynamic) {
                if (Math.abs(this.rawDelta.y) < this.threshold)
                    return;
            }
            this.newFocus = 3 /* Y_Item */;
            this.dontMoveFocus = false;
        }
        else {
            this.newFocus = ((Math.abs(this.rawDelta.x) > Math.abs(this.rawDelta.y)) ? 2 /* X_Item */ : 3 /* Y_Item */);
        }
    }
    fixPoint(pointActive, vp) {
        if (this.isActive() && ((vp !== this.currentView) || this.flags.rotationNeedsUpdate)) {
            this.currentView = vp;
            if (!(this.locked & 7 /* ANGLE_BM */ || this.fieldLocked[4 /* Z_Item */])) {
                // origin not locked down...may change when vie changes...
                if (!this.flags.haveValidOrigin)
                    this.setDefaultOrigin(vp);
                // in a view based rotation, and the view has changed, so update the rotation...
                if (!this.flags.lockedRotation) {
                    this.updateRotation();
                    this.flags.rotationNeedsUpdate = false;
                }
            }
        }
        if (this.isInactive() || this.isDeactivated()) {
            this.point.setFrom(pointActive);
            this.currentView = vp;
            if (this.published.flags)
                this.processHints();
            return;
        }
        if (this.isActive()) {
            this.rawPoint.setFrom(pointActive);
            this.currentView = vp;
            this.flags.dialogNeedsUpdate = true;
            if (AccuSnap_1.TentativeOrAccuSnap.isHot() && 0 /* Polar */ === this.getCompassMode())
                this.indexed = this.locked;
            else
                this.indexed = 0 /* NONE_LOCKED */;
            if (0 /* Polar */ === this.getCompassMode())
                this.fixPointPolar(vp);
            else
                this.fixPointRectangular(vp);
            pointActive.setFrom(this.point);
        }
        else if (1 /* Rectangular */ === this.getCompassMode()) {
            if (this.fieldLocked[2 /* X_Item */])
                pointActive.x = this.delta.x;
            if (this.fieldLocked[3 /* Y_Item */])
                pointActive.y = this.delta.y;
            if (this.fieldLocked[4 /* Z_Item */])
                pointActive.z = this.delta.z;
        }
    }
    refreshDecorationsAndDynamics() {
        // Make sure AccuDraw updates its decorations...
        const vp = this.currentView;
        if (!vp)
            return;
        vp.invalidateDecorations();
        // Make sure active tool updates its dynamics. NOTE: Can't just call updateDynamics, need point adjusted for new locks, etc.
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (!tool)
            return;
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        IModelApp_1.IModelApp.toolAdmin.adjustPoint(ev.point, ev.viewport);
        IModelApp_1.IModelApp.toolAdmin.updateDynamics(ev);
    }
    onBeginDynamics() {
        if (!this.isEnabled())
            return false;
        this.onEventCommon();
        if (!this.isInactive())
            return false;
        const vp = this.currentView;
        if (!vp)
            return false;
        // NOTE: If ACS Plane lock setup initial and base rotation to ACS...
        if (vp && AccuDraw.useACSContextRotation(vp, false)) {
            this.setRotationMode(5 /* ACS */);
            this.flags.baseRotation = 5 /* ACS */;
            this.flags.auxRotationPlane = 1 /* Top */;
        }
        if (this.published.flags & 16777216 /* SmartRotation */) {
            // const hitDetail = TentativeOrAccuSnap.getCurrentSnap(false);
            // NEEDS_WORK
            //   if (!hitDetail)
            //     hitDetail = ElementLocateManager:: GetManager().GetCurrHit();
            //   if (hitDetail) {
            //     DPoint3d                origin;
            //     RotMatrix               rMatrix;
            //     RotateToElemToolHelper  rotateHelper;
            //     // NOTE: Surface normal stored in HitDetail is for hit point, not snap/adjusted point...get normal at correct location...
            //     if (rotateHelper.GetOrientation(* hitDetail, origin, rMatrix)) {
            //       this.setContextRotation(rMatrix);
            //       this.changeBaseRotationMode(RotationMode.Context);
            //     }
            //   }
        }
        this.checkRotation();
        // Compass will jump to correct location when fixPoint is called...but we don't want to see the jump...
        if (!this.flags.haveValidOrigin)
            this.setDefaultOrigin(vp);
        // Initialize rawPoint data...invalid for alignments until next fixPoint...
        this.rawPoint.setFrom(this.point);
        this.rawPointOnPlane.setFrom(this.point);
        // Upgrade state to enabled...want compass to display...
        this.currentState = 3 /* Active */;
        return false;
    }
    onEndDynamics() {
        if (!this.isEnabled())
            return false;
        this.onEventCommon();
        if (!this.isActive())
            return false;
        // Downgrade state back to inactive...
        this.currentState = 2 /* Inactive */;
        return false;
    }
    onPreDataButton(ev) {
        if (!this.isEnabled())
            return false;
        this.onEventCommon();
        this.flags.inDataPoint = true;
        if (this.currentState < 2 /* Inactive */)
            return false;
        if (!this.currentView)
            this.currentView = ev.viewport;
        this.updateRotation();
        return false;
    }
    onPostDataButton(ev) {
        if (!this.isEnabled())
            return false;
        this.onEventCommon();
        if (this.flags.ignoreDataButton) {
            // NOTE: Ignore this data point, was used to terminate a viewing command or input collector...
            this.flags.ignoreDataButton = false;
        }
        else if (!this.flags.fixedOrg && this.currentState >= 2 /* Inactive */) {
            /* set origin to last point placed unless its being set elsewhere */
            if (((!this.contextSensitive &&
                !(this.published.flags & (2097156 /* AlwaysSetOrigin */ ^ 4 /* SetOrigin */))) ||
                !(this.published.flags & 4 /* SetOrigin */))) {
                this.published.flags |= 4 /* SetOrigin */;
                if (this.currentState >= 2 /* Inactive */)
                    this.published.origin.setFrom(ev.point);
                else
                    this.published.origin.setFrom(this.point);
            }
            this.saveLockedCoords();
            if (this.published.flags)
                this.processHints();
            if (this.currentState >= 2 /* Inactive */)
                this.updateRotation();
        }
        this.flags.inDataPoint = false;
        this.flags.indexLocked = false;
        return false;
    }
    oResetButtonUp(_ev) {
        if (IModelApp_1.IModelApp.tentativePoint.isActive && this.isActive()) {
            IModelApp_1.IModelApp.tentativePoint.clear(true);
            return true;
        }
        if (!this.isEnabled())
            return false;
        this.onEventCommon();
        return false;
    }
    onTentative() {
        if (this.isActive() || this.isInactive())
            this.grabInputFocus(); // AccuDraw gets input focus on a tentative
        return false;
    }
    intersectXYCurve(_snap, _curve) {
        // NEEDSWORK...
    }
    intersectLine(snap, linePt, unitVec) {
        const vec = geometry_core_1.Vector3d.createStartEnd(linePt, snap.getPoint());
        const endPt = linePt.plusScaled(unitVec, vec.dotProduct(unitVec));
        const cpLine = geometry_core_1.LineSegment3d.create(linePt, endPt);
        this.intersectXYCurve(snap, cpLine);
    }
    intersectCircle(snap, center, normal, radius) {
        const matrix = geometry_core_1.RotMatrix.createRigidHeadsUp(normal);
        const vector0 = matrix.columnX();
        const vector90 = matrix.columnY();
        vector0.scaleToLength(radius);
        vector90.scaleToLength(radius);
        const cpArc = geometry_core_1.Arc3d.create(center, vector0, vector90);
        this.intersectXYCurve(snap, cpArc);
    }
    onSnap(snap) {
        // If accudraw is locked, adjust near snap point to be the nearest point on this element, CONSTRAINED by the accudraw lock.
        if (!this.isActive || !this.locked)
            return false;
        if (1 /* Nearest */ !== snap.snapMode)
            return false;
        if (!snap.primitive)
            return false;
        switch (this.locked) {
            case 4 /* VEC_BM */: {
                this.intersectLine(snap, this.origin, this.vector);
                break;
            }
            case 1 /* X_BM */: {
                const refPt = (1 /* Rectangular */ === this.getCompassMode()) ? this.planePt.plusScaled(this.axes.x, this.delta.x) : this.origin;
                this.intersectLine(snap, refPt, this.axes.y);
                break;
            }
            case 2 /* Y_BM */: {
                const refPt = (1 /* Rectangular */ === this.getCompassMode()) ? this.planePt.plusScaled(this.axes.y, this.delta.y) : this.origin;
                this.intersectLine(snap, refPt, this.axes.x);
                break;
            }
            case 8 /* DIST_BM */: {
                this.intersectCircle(snap, this.origin, this.axes.z, this.distance);
                break;
            }
        }
        return false;
    }
    onSelectedViewportChanged(previous, current) {
        // In case previous is closing, always update AccuDraw to current view...
        if (undefined !== this.currentView && this.currentView === previous)
            this.currentView = current;
        // Reset AccuDraw when iModel or view type changes...
        if (undefined !== current && undefined !== previous &&
            (current.view.classFullName === previous.view.classFullName) &&
            (current.view.iModel === previous.view.iModel))
            return;
        this.currentView = undefined;
        this.flags.redrawCompass = false;
        this.flags.baseRotation = 4 /* View */;
        this.flags.auxRotationPlane = 1 /* Top */;
        this.flags.rotationNeedsUpdate = true;
        this.flags.haveValidOrigin = false;
        this.flags.indexLocked = false;
        this.flags.bearingFixToPlane2D = false;
        this.savedState.init();
        this.setRotationMode(4 /* View */);
        this.updateRotation();
    }
    doProcessHints() {
        if (!this.floatingOrigin) {
            if (this.published.flags & 4 /* SetOrigin */)
                this.unlockAllFields();
            return;
        }
        // Set Context Origin
        if (this.published.flags & 4 /* SetOrigin */) {
            if (this.floatingOrigin) {
                this.origin.setFrom(this.published.origin);
                this.point.setFrom(this.origin);
                this.planePt.setFrom(this.origin);
            }
            this.flags.haveValidOrigin = true;
            this.setLastPoint(this.origin);
            this.unlockAllFields();
            this.updateRotation();
        }
        if (!this.contextSensitive)
            return;
        // Mode -- Polar or Rectangular
        if (this.published.flags & (1 /* SetModePolar */ | 2 /* SetModeRect */)) {
            if (this.getCompassMode() !== ((this.published.flags & 1 /* SetModePolar */) ? 0 /* Polar */ : 1 /* Rectangular */))
                this.changeCompassMode();
        }
        // Fixed Origin
        if (this.published.flags & 8 /* FixedOrigin */)
            this.flags.fixedOrg = true;
        // Save Distance
        if (this.published.flags & (128 /* SetDistance */ | 256 /* LockDistance */))
            this.saveCoordinate(0 /* DIST_Item */, this.published.distance);
        const vp = this.currentView;
        // Do Context Rotation
        if (this.published.flags & 16 /* SetRMatrix */) {
            this.axes.fromRotMatrix(this.published.rMatrix);
            this.flags.lockedRotation = true;
            this.flags.contextRotMode = 0 /* Locked */;
            this.setRotationMode(6 /* Context */);
            this.updateRotation();
        }
        else if (this.published.flags & 32 /* SetXAxis */) {
            this.axes.x.setFrom(this.published.vector);
            this.flags.contextRotMode = 1 /* XAxis */;
            this.setRotationMode(6 /* Context */);
            this.updateRotation();
        }
        else if (this.published.flags & 262144 /* SetXAxis2 */) {
            this.axes.x.setFrom(this.published.vector);
            this.flags.contextRotMode = 4 /* XAxis2 */;
            this.setRotationMode(6 /* Context */);
            this.updateRotation();
        }
        else if (this.published.flags & 64 /* SetNormal */) {
            if (vp && vp.view.is3d()) {
                this.axes.z.setFrom(this.published.vector);
                this.flags.contextRotMode = 3 /* ZAxis */;
                this.setRotationMode(6 /* Context */);
                this.updateRotation();
            }
        }
        else if (this.published.flags & 131072 /* OrientACS */) {
            this.flags.lockedRotation = true;
            this.flags.baseRotation = 5 /* ACS */;
            this.setRotationMode(5 /* ACS */);
            this.updateRotation();
        }
        else if (this.isInactive() || (this.published.flags & 16384 /* OrientDefault */)) {
            this.setRotationMode(this.flags.baseRotation);
            this.updateRotation();
        }
        if (this.published.flags & (16 /* SetRMatrix */ | 32 /* SetXAxis */ | 262144 /* SetXAxis2 */ | 64 /* SetNormal */ | 131072 /* OrientACS */)) {
            this.savedState.axes.setFrom(this.axes);
            this.savedState.contextRotMode = this.flags.contextRotMode;
        }
        // Lock Items
        switch (this.getCompassMode()) {
            case 0 /* Polar */:
                if (this.published.flags & 256 /* LockDistance */) {
                    this.distance = this.published.distance;
                    this.distanceLock(true, true);
                }
                if (this.published.flags & 524288 /* LockAngle */) {
                    this.updateVector(this.published.angle);
                    this.indexed = 0 /* NONE_LOCKED */;
                    this.angleLock();
                    this.saveCoordinate(1 /* ANGLE_Item */, this.published.angle);
                }
                break;
            case 1 /* Rectangular */:
                if ((this.published.flags & 512 /* Lock_X */)) {
                    this.locked |= 1 /* X_BM */;
                    this.delta.x = this.published.delta.x;
                    this.setFieldLock(2 /* X_Item */, true);
                    this.saveCoordinate(2 /* X_Item */, this.published.delta.x);
                }
                if ((this.published.flags & 1024 /* Lock_Y */)) {
                    this.locked |= 2 /* Y_BM */;
                    this.delta.y = this.published.delta.y;
                    this.setFieldLock(3 /* Y_Item */, true);
                    this.saveCoordinate(3 /* Y_Item */, this.published.delta.y);
                }
                if ((this.published.flags & 2048 /* Lock_Z */)) {
                    if (vp && vp.view.is3d()) {
                        this.delta.z = this.published.delta.z;
                        this.setFieldLock(4 /* Z_Item */, true);
                        this.saveCoordinate(4 /* Z_Item */, this.published.delta.z);
                    }
                }
                break;
        }
    }
    processHints() {
        if (!this.published.flags || !this.isEnabled())
            return;
        if (this.published.flags & 4096 /* Disable */) {
            this.published.flags = 0;
            this.currentState = 1 /* Deactivated */;
            return;
        }
        const setFocus = !!(this.published.flags & 32768 /* SetFocus */);
        this.doProcessHints();
        this.published.zero();
        if (this.isEnabled() || setFocus)
            this.grabInputFocus();
    }
}
AccuDraw.tempRot = new geometry_core_1.RotMatrix();
exports.AccuDraw = AccuDraw;
/**
 * AccuDrawHintBuilder is a Tool helper class that facilitates AccuDraw interaction.
 * The tool does not directly change the current AccuDraw state; the tool's job is merely
 * to supply "hints" to AccuDraw regarding its preferred AccuDraw configuration for the
 * current tool state. User settings such as "Context Sensitivity" and "Floating Origin"
 * affect how/which hints get applied.
 */
class AccuDrawHintBuilder {
    constructor() {
        this.flagOrigin = false;
        this.flagNormal = false;
        this.flagRotation = false;
        this.flagXAxis = false;
        this.flagXAxis2 = false;
        this.flagDistance = false;
        this.flagAngle = false;
        this.flagModePolar = false;
        this.flagModeRectangular = false;
        this.distance = 0;
        this.angle = 0;
        this.setOriginFixed = false;
        this.setOriginAlways = false;
        this.setLockDistance = false;
        this.setLockAngle = false;
        this.setLockX = false;
        this.setLockY = false;
        this.setLockZ = false;
        this.enableSmartRotation = false;
    }
    setOrigin(origin) { this.origin = origin.clone(); this.flagOrigin = true; }
    setRotation(rMatrix) { this.rMatrix = rMatrix.clone(); this.flagRotation = true; this.flagXAxis = this.flagNormal = false; }
    setXAxis(xAxis) { this.axis = xAxis.clone(); this.flagXAxis = true; this.flagRotation = this.flagNormal = this.flagXAxis2 = false; }
    setXAxis2(xAxis) { this.axis = xAxis.clone(); this.flagXAxis2 = true; this.flagRotation = this.flagNormal = this.flagXAxis = false; }
    setNormal(normal) { this.axis = normal.clone(); this.flagNormal = true; this.flagRotation = this.flagXAxis = this.flagXAxis2 = false; }
    setModePolar() { this.flagModePolar = true; this.flagModeRectangular = false; }
    setModeRectangular() { this.flagModeRectangular = true; this.flagModePolar = false; }
    setDistance(distance) { this.distance = distance; this.flagDistance = true; }
    setAngle(angle) { this.angle = angle; this.flagAngle = true; }
    /**
     * Calls AccuDraw.setContext using the current builder state.
     * @return true if hints were successfully sent.
     */
    sendHints(activate = true) {
        let flags = 0;
        if (this.flagOrigin)
            flags |= 4 /* SetOrigin */;
        if (this.setOriginFixed)
            flags |= 8 /* FixedOrigin */;
        if (this.setOriginAlways)
            flags |= 2097156 /* AlwaysSetOrigin */;
        if (this.flagRotation)
            flags |= 16 /* SetRMatrix */;
        if (this.flagXAxis)
            flags |= 32 /* SetXAxis */;
        if (this.flagXAxis2)
            flags |= 262144 /* SetXAxis2 */;
        if (this.flagNormal)
            flags |= 64 /* SetNormal */;
        if (this.flagModePolar)
            flags |= 1 /* SetModePolar */;
        if (this.flagModeRectangular)
            flags |= 2 /* SetModeRect */;
        if (this.setLockDistance)
            flags |= 256 /* LockDistance */;
        if (this.setLockAngle)
            flags |= 524288 /* LockAngle */;
        if (this.setLockX)
            flags |= 512 /* Lock_X */;
        if (this.setLockY)
            flags |= 1024 /* Lock_Y */;
        if (this.setLockZ)
            flags |= 2048 /* Lock_Z */;
        if (this.enableSmartRotation)
            flags |= 16777216 /* SmartRotation */;
        const accuDraw = IModelApp_1.IModelApp.accuDraw;
        if (0 /* SUCCESS */ !== accuDraw.setContext(flags, this.origin, this.flagRotation ? this.rMatrix : this.axis, undefined, this.flagDistance ? this.distance : undefined, this.flagAngle ? this.angle : undefined))
            return false; // Not enabled for this session...
        if (activate)
            accuDraw.activate(); // If not already enabled (ex. dynamics not started) most/all callers would want to enable it now (optional activate arg provided just in case)...
        return true;
    }
}
exports.AccuDrawHintBuilder = AccuDrawHintBuilder;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
/** Support class for quadrature -- approximate integrals by summing weighted function values.
 * These are filled with x and weight for quadrature between xA and xB
 *
 * Since quadrature is done in side tight loops, these methods are structured for minimum object
 * allocation.
 * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped
 * The method installs particular x and weight values.
 */
class Quadrature {
    /**
     * Given points and weights in a reference interval (usually 0 to 1):
     *
     * * map each xRef[i] to xA + h * xRef[i];
     * * scale each weight wRef[i] to h * wRef[i]
     * * all arrays are assumed to have xRef.length entries.
     * * the return value is xRef.length
     * @param xA beginning of target interval
     * @param h length of target interval
     * @param xRef x coordinates in reference interval
     * @param wRef weights for integration in the reference interval
     * @param xMapped x coordinates to evaluate integrands
     * @param wMapped weights for evaluated integrands
     */
    static mapWeights(xA, h, xRef, wRef, xMapped, wMapped) {
        const n = xRef.length;
        for (let i = 0; i < n; i++) {
            xMapped[i] = xA + h * xRef[i];
            wMapped[i] = h * wRef[i];
        }
        return n;
    }
    /* Install 2 (TWO) x and weight values for quadrature from xA to xB. */
    static setupGauss2(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
            const x0 = 0.5 * (xA + xB);
                const h = 0.5 * (xB - xA);
                const dx = h / Math.sqrt(3);
                xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;
                wMapped[0] = wMapped[1] = h;
                */
    }
    /* Install 3 (THREE) x and weight values for quadrature from xA to xB. */
    static setupGauss3(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const a = Math.sqrt(0.6);
        const b = h * 5.0 / 9.0;
        const dx = a * h;
        xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;
        wMapped[0] = wMapped[2] = b;
        wMapped[1] = h * 8.0 / 9.0;
        return 3;
        */
    }
    /** Caller allocates and passes Float6dArray of length
     * These are filled with x and weight for quadrature between xA and xB
     */
    static setupGauss5(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const q = 2.0 * Math.sqrt(10.0 / 7.0);
        const b = 13.0 * Math.sqrt(70.0);
        const a1 = h * Math.sqrt(5.0 - q) / 3.0;
        const a2 = h * Math.sqrt(5.0 + q) / 3.0;
        const w1 = h * (322.0 + b) / 900.0;
        const w2 = h * (322.0 - b) / 900;
        const w0 = h * 128.0 / 225.0;
        xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;
        wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;
        return 5;
        */
    }
    static setupGauss4(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
    const x0 = 0.5 * (xA + xB);
    const h = 0.5 * (xB - xA);
    const q = 2.0 * Math.sqrt(6.0 / 5.0);
    const r = Math.sqrt(30.0);
    const a1 = h * Math.sqrt((3 - q) / 7.0);
    const w1 = h * (18.0 + r) / 36.0;
    const a2 = h * Math.sqrt((3 + q) / 7.0);
    const w2 = h * (18.0 - r) / 36.0;
    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;
    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;
    return 4;
    */
    }
    /** Sum function values with given weghts and x values. */
    static sum1(xx, ww, n, f) {
        let sum = 0;
        for (let i = 0; i < n; i++)
            sum += ww[i] * f(xx[i]);
        return sum;
    }
}
Quadrature.gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);
Quadrature.gaussW2Interval01 = new Float64Array([0.5, 0.5]);
Quadrature.gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);
Quadrature.gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);
Quadrature.gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);
Quadrature.gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);
Quadrature.gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);
Quadrature.gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);
exports.Quadrature = Quadrature;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const PointVector_1 = __webpack_require__(4);
const AnalyticGeometry_1 = __webpack_require__(11);
const CurvePrimitive_1 = __webpack_require__(12);
const Geometry_1 = __webpack_require__(3);
const KnotVector_1 = __webpack_require__(108);
const PointHelpers_1 = __webpack_require__(22);
/** Bspline knots and poles for 1d-to-Nd. */
class BSpline1dNd {
    get degree() { return this.knots.degree; }
    get order() { return this.knots.degree + 1; }
    get numSpan() { return this.numPoles - this.knots.degree; }
    get numPoles() { return this.coffs.length / this.poleLength; }
    getPoint3dPole(i, result) { return PointVector_1.Point3d.createFromPacked(this.coffs, i, result); }
    /**
     * initialize arrays for given spline dimensions.
     * @param numPoles number of poles
     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weigthed)
     * @param order number of poles in support for a section of the bspline
     */
    constructor(numPoles, poleLength, order, knots) {
        this.knots = knots;
        this.coffs = new Float64Array(numPoles * poleLength);
        this.poleLength = poleLength;
        this.basisBuffer = new Float64Array(order);
        this.poleBuffer = new Float64Array(poleLength);
        this.basisBuffer1 = new Float64Array(order);
        this.basisBuffer2 = new Float64Array(order);
        this.poleBuffer1 = new Float64Array(poleLength);
        this.poleBuffer2 = new Float64Array(poleLength);
    }
    extendRange(rangeToExtend, transform) {
        const buffer = this.poleBuffer;
        const n = buffer.length - 2;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
    static create(numPoles, poleLength, order, knots) {
        return new BSpline1dNd(numPoles, poleLength, order, knots);
    }
    spanFractionToKnot(span, localFraction) {
        return this.knots.spanFractionToKnot(span, localFraction);
    }
    // ASSUME f is sized for {order} basis funtions !!!
    evaluateBasisFunctionsInSpan(spanIndex, spanFraction, f, df, ddf) {
        if (spanIndex < 0)
            spanIndex = 0;
        if (spanIndex >= this.numSpan)
            spanIndex = this.numSpan - 1;
        const knotIndex0 = spanIndex + this.degree - 1;
        const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :
            this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    evaluateBuffersInSpan(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);
        this.sumPoleBufferForSpan(spanIndex);
    }
    evaluateBuffersInSpan1(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);
        this.sumPoleBufferForSpan(spanIndex);
        this.sumPoleBuffer1ForSpan(spanIndex);
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBufferForSpan(spanIndex) {
        this.poleBuffer.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer[j] += f * this.coffs[k++];
            }
        }
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBuffer1ForSpan(spanIndex) {
        this.poleBuffer1.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer1) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer1[j] += f * this.coffs[k++];
            }
        }
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBuffer2ForSpan(spanIndex) {
        this.poleBuffer2.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer2) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer2[j] += f * this.coffs[k++];
            }
        }
    }
    evaluateBuffersAtKnot(u, numDerivative = 0) {
        const knotIndex0 = this.knots.knotToLeftKnotIndex(u);
        if (numDerivative < 1) {
            this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
        }
        else if (numDerivative === 1) {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
        }
        else {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);
        }
    }
    reverseInPlace() {
        // reverse poles in blocks ...
        const b = this.poleLength;
        const data = this.coffs;
        for (let i0 = 0, j0 = b * (this.numPoles - 1); i0 < j0; i0 += b, j0 -= b) {
            let t = 0;
            for (let i = 0; i < b; i++) {
                t = data[i0 + i];
                data[i0 + i] = data[j0 + i];
                data[j0 + i] = t;
            }
        }
        this.knots.reflectKnots();
    }
}
class BSplineCurve3d extends CurvePrimitive_1.CurvePrimitive {
    isSameGeometryClass(other) { return other instanceof BSplineCurve3d; }
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this.bcurve.coffs); return true; }
    get degree() { return this.bcurve.degree; }
    get order() { return this.bcurve.order; }
    get numSpan() { return this.bcurve.numSpan; }
    get numPoles() { return this.bcurve.numPoles; }
    getPole(i, result) { return this.bcurve.getPoint3dPole(i, result); }
    spanFractionToKnot(span, localFraction) {
        return this.bcurve.spanFractionToKnot(span, localFraction);
    }
    constructor(numPoles, order, knots) {
        super();
        this.bcurve = BSpline1dNd.create(numPoles, 3, order, knots);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */
    copyPoints() { return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this.bcurve.coffs, 3); }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this.bcurve.coffs.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) { return this.bcurve.knots.copyKnots(includeExtraEndKnot); }
    /** Create a bspline with uniform knots. */
    static createUniformKnots(poles, order) {
        const numPoles = poles.length;
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.createUniformClamped(poles.length, order - 1, 0.0, 1.0);
        const curve = new BSplineCurve3d(poles.length, order, knots);
        let i = 0;
        for (const p of poles) {
            curve.bcurve.coffs[i++] = p.x;
            curve.bcurve.coffs[i++] = p.y;
            curve.bcurve.coffs[i++] = p.z;
        }
        return curve;
    }
    /** Create a bspline with given knots.
     *
     * *  Two count conditions are recognized:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static create(poleArray, knotArray, order) {
        let numPoles = poleArray.length;
        if (poleArray instanceof Float64Array) {
            numPoles /= 3; // blocked as xyz
        }
        const numKnots = knotArray.length;
        // shift knots-of-interest limits for overclampled case ...
        const skipFirstAndLast = (numPoles + order === numKnots);
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.create(knotArray, order - 1, skipFirstAndLast);
        const curve = new BSplineCurve3d(numPoles, order, knots);
        if (poleArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of poleArray) {
                curve.bcurve.coffs[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of poleArray) {
                curve.bcurve.coffs[i++] = p.x;
                curve.bcurve.coffs[i++] = p.y;
                curve.bcurve.coffs[i++] = p.z;
            }
        }
        return curve;
    }
    clone() {
        const knotVector1 = this.bcurve.knots.clone();
        const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);
        curve1.bcurve.coffs = this.bcurve.coffs.slice();
        return curve1;
    }
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointInSpan(spanIndex, spanFraction) {
        this.bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);
        return PointVector_1.Point3d.createFrom(this.bcurve.poleBuffer);
    }
    evaluatePointAndTangentInSpan(spanIndex, spanFraction) {
        this.bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);
        return AnalyticGeometry_1.Ray3d.createCapture(PointVector_1.Point3d.createFrom(this.bcurve.poleBuffer), PointVector_1.Vector3d.createFrom(this.bcurve.poleBuffer1));
    }
    /** Evaluate at a positioni given by a knot value.  */
    knotToPoint(u, result) {
        this.bcurve.evaluateBuffersAtKnot(u);
        return PointVector_1.Point3d.createFrom(this.bcurve.poleBuffer, result);
    }
    /** Evaluate at a positioni given by a knot value.  */
    knotToPointAndDerivative(u, result) {
        this.bcurve.evaluateBuffersAtKnot(u, 1);
        if (!result)
            return AnalyticGeometry_1.Ray3d.createCapture(PointVector_1.Point3d.createFrom(this.bcurve.poleBuffer), PointVector_1.Vector3d.createFrom(this.bcurve.poleBuffer1));
        result.origin.setFrom(this.bcurve.poleBuffer);
        result.direction.setFrom(this.bcurve.poleBuffer1);
        return result;
    }
    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */
    knotToPointAnd2Derivatives(u, result) {
        this.bcurve.evaluateBuffersAtKnot(u, 2);
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this.bcurve.poleBuffer[0], this.bcurve.poleBuffer[1], this.bcurve.poleBuffer[2], this.bcurve.poleBuffer1[0], this.bcurve.poleBuffer1[1], this.bcurve.poleBuffer1[2], this.bcurve.poleBuffer2[0], this.bcurve.poleBuffer2[1], this.bcurve.poleBuffer2[2], result);
    }
    fractionToPoint(fraction, result) {
        return this.knotToPoint(this.bcurve.knots.fractionToKnot(fraction), result);
    }
    fractionToPointAndDerivative(fraction, result) {
        const knot = this.bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAndDerivative(knot, result);
        result.direction.scaleInPlace(this.bcurve.knots.knotLength01);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const knot = this.bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAnd2Derivatives(knot, result);
        const a = this.bcurve.knots.knotLength01;
        result.vectorU.scaleInPlace(a);
        result.vectorV.scaleInPlace(a * a);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineCurve3d) {
            return this.bcurve.knots.isAlmostEqual(other.bcurve.knots)
                && PointHelpers_1.Point3dArray.isAlmostEqual(this.bcurve.coffs, other.bcurve.coffs);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this.bcurve.coffs, plane);
    }
    startPoint() { return this.evaluatePointInSpan(0, 0.0); }
    endPoint() { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }
    reverseInPlace() { this.bcurve.reverseInPlace(); }
    quickLength() { return PointHelpers_1.Point3dArray.sumLengths(this.bcurve.coffs); }
    emitStrokableParts(handler, _options) {
        const numSpan = this.numSpan;
        const numPerSpan = 5; // NEEDS WORK -- apply stroke options to get better count !!!
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            handler.announceIntervalForUniformStepStrokes(this, numPerSpan, this.bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this.bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
        }
    }
    emitStrokes(dest, _options) {
        const numSpan = this.numSpan;
        const numPerSpan = 5; // NEEDS WORK -- apply stroke options to get better count !!!
        const fractionStep = 1.0 / numPerSpan;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            for (let i = 0; i <= numPerSpan; i++) {
                const spanFraction = i * fractionStep;
                const point = this.evaluatePointInSpan(spanIndex, spanFraction);
                dest.appendStrokePoint(point);
            }
        }
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    isClosable() {
        if (!this.bcurve.knots.wrappable)
            return false;
        const degree = this.degree;
        const leftKnotIndex = this.bcurve.knots.leftKnotIndex;
        const rightKnotIndex = this.bcurve.knots.rightKnotIndex;
        const period = this.bcurve.knots.rightKnot - this.bcurve.knots.leftKnot;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(this.bcurve.knots.knots[k0] + period, this.bcurve.knots.knots[k1]))
                return false;
        }
        const poleIndexDelta = this.numPoles - this.degree;
        for (let p0 = 0; p0 + 1 < degree; p0++) {
            const p1 = p0 + poleIndexDelta;
            if (!Geometry_1.Geometry.isSamePoint3d(this.getPole(p0), this.getPole(p1)))
                return false;
        }
        return true;
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(value) {
        this.bcurve.knots.wrappable = value;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineCurve3d(this);
    }
    extendRange(rangeToExtend, transform) {
        this.bcurve.extendRange(rangeToExtend, transform);
    }
}
exports.BSplineCurve3d = BSplineCurve3d;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Geometry_1 = __webpack_require__(3);
const PointHelpers_1 = __webpack_require__(22);
/**
 * Array of non-decreasing numbers acting as a knot array for bsplines.
 *
 * * Essential identity: numKnots = numPoles + order = numPoles + degree - 1
 * * Various bspline libraries have confusion over how many "end knots" are needed. "Many" libraries (including Microstation)
 *     incorrectly demand "order" knots at each end for clamping.   But only "order - 1" are really needed.
 * * This class uses the "order-1" convention.
 * * This class provides queries to convert among spanIndex and knotIndex
 * * A span is a single interval of the knots.
 * * The left knot of span {k} is knot {k+degree-1}
 * * This class provides queries to convert among spanFraction, fraction of knot range, and knot
 * * core computations (evaluateBasisFucntions) have leftKnotIndex and global knot value as inputs.  Caller's need to
 * know their primary values (global knot, spanFraction).
 */
class KnotVector {
    /**
     *
     * * If knots is a number array or Float64Array, the those values become the local knot array.
     * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.
     * @param knots
     * @param degree
     */
    constructor(knots, degree) {
        this.degree = degree;
        this.possibleWrap = false;
        // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user
        this.knot0 = 0.0;
        this.knot1 = 1.0;
        // satisfy the initialize checker ..
        if (Array.isArray(knots)) {
            this.knots = new Float64Array(knots.length);
            this.setKnots(knots);
            this.setupFixedValues();
        }
        else if (knots instanceof Float64Array) {
            this.knots = knots.slice();
            this.setupFixedValues();
        }
        else {
            this.knots = new Float64Array(knots);
        }
    }
    get leftKnot() { return this.knot0; }
    get rightKnot() { return this.knot1; }
    get leftKnotIndex() { return this.degree - 1; }
    get rightKnotIndex() { return this.knots.length - this.degree; }
    get wrappable() { return this.possibleWrap; }
    set wrappable(value) { this.possibleWrap = value; }
    get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }
    /** copy degree and knots to a new KnotVector. */
    clone() { return new KnotVector(this.knots, this.degree); }
    setupFixedValues() {
        // These should be read-only . ..
        this.knot0 = this.knots[this.degree - 1];
        this.knot1 = this.knots[this.knots.length - this.degree];
    }
    /** @returns Return the total knot distance from beginning to end. */
    get knotLength01() { return this.knot1 - this.knot0; }
    isAlmostEqual(other) {
        if (this.degree !== other.degree)
            return false;
        return PointHelpers_1.NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);
    }
    setKnots(knots, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;
        if (numAllocate !== this.knots.length)
            this.knots = new Float64Array(numAllocate);
        if (skipFirstAndLast) {
            for (let i = 1; i + 1 < knots.length; i++)
                this.knots[i - 1] = knots[i];
        }
        else {
            for (let i = 0; i < knots.length; i++)
                this.knots[i] = knots[i];
        }
        this.setupFixedValues();
    }
    /**
     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.
     * @param numPoles Number of poles
     * @param degree degree of polynomial
     * @param a0 left knot value for active interval
     * @param a1 right knot value for active interval
     */
    static createUniformClamped(numPoles, degree, a0, a1) {
        const knots = new KnotVector(numPoles + degree - 1, degree);
        let k = 0;
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a0;
        const du = 1.0 / (numPoles - degree);
        for (let i = 1; i + degree < numPoles; i++)
            knots.knots[k++] = a0 + i * du * (a1 - a0);
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a1;
        knots.setupFixedValues();
        return knots;
    }
    /**
     * Create knot vector with given knot values and degree.
     * @param knotArray knot values
     * @param degree degree of polynomial
     * @param skipFirstAndLast true to skip class overclamped end knots.
     */
    static create(knotArray, degree, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;
        const knots = new KnotVector(numAllocate, degree);
        knots.setKnots(knotArray, skipFirstAndLast);
        return knots;
    }
    /**
     * Return the average of degree consecutive knots begining at spanIndex.
     */
    grevilleKnot(spanIndex) {
        if (spanIndex < 0)
            return this.leftKnot;
        if (spanIndex > this.rightKnotIndex)
            return this.rightKnot;
        let sum = 0.0;
        for (let i = spanIndex; i < spanIndex + this.degree; i++)
            sum += this.knots[i];
        return sum / this.degree;
    }
    /** Return an array sized for a set of the basis function values. */
    createBasisArray() { return new Float64Array(this.degree + 1); }
    // public createTargetArray(numCoff: number): Float64Array { return new Float64Array(numCoff); }
    baseKnotFractionToKnot(knotIndex0, localFraction) {
        const knot0 = this.knots[knotIndex0];
        return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);
    }
    spanFractionToKnot(spanIndex, localFraction) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);
    }
    spanFractionToFraction(spanIndex, localFraction) {
        const knot = this.spanFractionToKnot(spanIndex, localFraction);
        return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);
    }
    fractionToKnot(fraction) {
        return Geometry_1.Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);
    }
    /**
     * Evaluate basis fucntions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions(knotIndex0, u, f) {
        f[0] = 1.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        f[1] = (u - u0) / (u1 - u0);
        f[0] = 1.0 - f[1];
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                const fraction = (u - tLeft) / (tRight - tLeft);
                const g1 = f[step] * fraction;
                const g0 = f[step] * (1.0 - fraction);
                f[step] = gCarry + g0;
                gCarry = g1;
            }
            f[depth + 1] = gCarry;
        }
    }
    /**
     * Evaluate basis fucntions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions1(knotIndex0, u, f, df, ddf) {
        f[0] = 1.0;
        df[0] = 0.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        // ah = 1/(u1-u0)      is the derivative of fraction0
        // (-ah) is the derivative of fraction1.
        let ah = 1.0 / (u1 - u0);
        f[1] = (u - u0) * ah;
        f[0] = 1.0 - f[1];
        df[0] = -ah;
        df[1] = ah;
        if (ddf) {
            ddf[0] = 0.0;
            ddf[1] = 0.0;
        }
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            let dgCarry = 0.0;
            let ddgCarry = 0.0;
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                ah = 1.0 / (tRight - tLeft);
                const fraction = (u - tLeft) * ah;
                const fraction1 = 1.0 - fraction;
                const g1 = f[step] * fraction;
                const g0 = f[step] * fraction1;
                const dg1 = df[step] * fraction + f[step] * ah;
                const dg0 = df[step] * fraction1 - f[step] * ah;
                f[step] = gCarry + g0;
                df[step] = dgCarry + dg0;
                gCarry = g1;
                dgCarry = dg1;
                if (ddf) {
                    const ddg1 = ddf[step] * fraction + 2.0 * df[step] * ah;
                    const ddg0 = ddf[step] * fraction1 - 2.0 * df[step] * ah;
                    ddf[step] = ddgCarry + ddg0;
                    ddgCarry = ddg1;
                }
            }
            f[depth + 1] = gCarry;
            df[depth + 1] = dgCarry;
            if (ddf)
                ddf[depth + 1] = ddgCarry;
        }
    }
    knotToLeftKnotIndex(u) {
        // Anything to left is in the first span . .
        const firstLeftKnot = this.degree - 1;
        if (u < this.knots[firstLeftKnot + 1])
            return firstLeftKnot;
        // Anything to right is in the last span ...
        const lastLeftKnot = this.knots.length - this.degree - 1;
        if (u >= this.knots.length - this.degree)
            return this.knots[lastLeftKnot];
        // ugh ... linear search ...
        for (let i = firstLeftKnot + 1; i < lastLeftKnot; i++)
            if (u < this.knots[i + 1])
                return i; // testing against right side skips over multiple knot cases???
        return lastLeftKnot;
    }
    spanIndexToLeftKnotIndex(spanIndex) {
        const d = this.degree;
        if (spanIndex <= 0.0)
            return d - 1;
        return Math.min(spanIndex + d - 1, this.knots.length - d);
    }
    spanIndexToSpanLength(spanIndex) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k + 1] - this.knots[k];
    }
    reflectKnots() {
        const a = this.leftKnot;
        const b = this.rightKnot;
        const numKnots = this.knots.length;
        for (let i = 0; i < numKnots; i++)
            this.knots[i] = a + (b - this.knots[i]);
        this.knots.reverse();
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) {
        const values = [];
        if (includeExtraEndKnot)
            values.push(this.knots[0]);
        for (const u of this.knots)
            values.push(u);
        if (includeExtraEndKnot)
            values.push(values[values.length - 1]);
        return values;
    }
}
KnotVector.knotTolerance = 1.0e-9;
exports.KnotVector = KnotVector;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
// import { Geometry, Angle, AxisOrder, BSIJSONValues } from "../Geometry";
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const CurvePrimitive_1 = __webpack_require__(12);
const CurveChain_1 = __webpack_require__(14);
const TransitionSpiral_1 = __webpack_require__(143);
const Transform_2 = __webpack_require__(6);
const CurveChain_2 = __webpack_require__(14);
const Polyface_1 = __webpack_require__(92);
const BSplineCurve_1 = __webpack_require__(107);
const BSplineSurface_1 = __webpack_require__(155);
const Sphere_1 = __webpack_require__(153);
const Cone_1 = __webpack_require__(145);
const Box_1 = __webpack_require__(144);
const TorusPipe_1 = __webpack_require__(154);
const LinearSweep_1 = __webpack_require__(146);
const RotationalSweep_1 = __webpack_require__(151);
const RuledSweep_1 = __webpack_require__(152);
const AnalyticGeometry_1 = __webpack_require__(11);
const GeometryHandler_1 = __webpack_require__(90);
const LineString3d_1 = __webpack_require__(10);
const PointString3d_1 = __webpack_require__(142);
const Arc3d_1 = __webpack_require__(47);
const LineSegment3d_1 = __webpack_require__(38);
/* tslint:disable: object-literal-key-quotes no-console*/
var IModelJson;
(function (IModelJson) {
    /** parser servoces for "iModelJson" schema
     * * 1: create a reader with `new ImodelJsonReader`
     * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`
     */
    class Reader {
        constructor() {
        }
        static parseVector3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return PointVector_1.Vector3d.create(value[0], value[1], value[2]);
                if (PointVector_1.XYZ.isXAndY(value))
                    return PointVector_1.Vector3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parsePoint3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return PointVector_1.Point3d.create(value[0], value[1], value[2]);
                if (PointVector_1.XYZ.isXAndY(value))
                    return PointVector_1.Point3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parseSegment1dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 2))
                    return PointVector_1.Segment1d.create(value[0], value[1]);
            }
            return defaultValue;
        }
        static parseNumberProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Number.isFinite(value))
                    return value;
            }
            return defaultValue;
        }
        /* ==============
            private static parseNumberArrayProperty(json: any, propertyName: string, minValues: number, maxValues: number, defaultValue?: number[] | undefined): number[] | undefined {
              if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)
                  && value.length >= minValues && value.length <= maxValues) {
                  const result = [];
                  for (const a of value) {
                    result.push(a);
                  }
                  return result;
                }
              }
              return defaultValue;
            }
        */
        static parseAngleProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return Geometry_1.Angle.fromJSON(value);
            }
            return defaultValue;
        }
        /**
         * @param defaultFunction function to call if needed to produce a default value
         */
        static parseAngleSweepProps(json, propertyName, defaultFunction) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return Geometry_1.AngleSweep.fromJSON(value);
            }
            if (defaultFunction === undefined)
                return undefined;
            return defaultFunction();
        }
        static parseBooleanProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value === true)
                    return true;
                if (value === false)
                    return false;
            }
            return defaultValue;
        }
        static loadContourArray(json, propertyName) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)) {
                    const result = [];
                    for (const contourData of value) {
                        const contour = Reader.parse(contourData);
                        if (contour instanceof CurveChain_1.CurveCollection) {
                            result.push(contour);
                        }
                    }
                    if (result.length > 0)
                        return result;
                }
            }
            return undefined;
        }
        static parseYawPitchRollAngles(json) {
            const ypr = PointVector_1.YawPitchRollAngles.fromJSON(json);
            return ypr.toRotMatrix();
        }
        static parseStringProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value.type === "string")
                    return value;
            }
            return defaultValue;
        }
        static parseAxesFromVectors(json, axisOrder, createDefaultIdentity) {
            if (Array.isArray(json) && json.length === 2) {
                const xVector = PointVector_1.Vector3d.fromJSON(json[0]);
                const yVector = PointVector_1.Vector3d.fromJSON(json[1]);
                const matrix = Transform_1.RotMatrix.createRigidFromColumns(xVector, yVector, axisOrder);
                if (matrix)
                    return matrix;
            }
            if (createDefaultIdentity)
                return Transform_1.RotMatrix.createIdentity();
            return undefined;
        }
        /**
         * Look for orientation data and convert to RotMatrix.
         * * Search order is:
         * * * yawPitchRollAngles
         * * * xyVectors
         * * * zxVectors
         * @param json [in] json source data
         * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.
         */
        static parseOrientation(json, createDefaultIdentity) {
            if (json.yawPitchRollAngles) {
                return Reader.parseYawPitchRollAngles(json.yawPitchRollAngles);
            }
            else if (json.xyVectors) {
                return Reader.parseAxesFromVectors(json.xyVectors, 0 /* XYZ */, createDefaultIdentity);
            }
            else if (json.zxVectors) {
                return Reader.parseAxesFromVectors(json.zxVectors, 2 /* ZXY */, createDefaultIdentity);
            }
            if (createDefaultIdentity)
                return Transform_1.RotMatrix.createIdentity();
            return undefined;
        }
        static parseArcByVectorProps(data) {
            if (data
                && data.center !== undefined
                && data.vectorX !== undefined
                && data.vectorY !== undefined
                && data.sweepStartEnd !== undefined) {
                return Arc3d_1.Arc3d.create(PointVector_1.Point3d.fromJSON(data.center), PointVector_1.Vector3d.fromJSON(data.vectorX), PointVector_1.Vector3d.fromJSON(data.vectorY), Geometry_1.AngleSweep.fromJSON(data.sweepStartEnd));
            }
            return undefined;
        }
        // remark: Returns LineString3d as last default when give points are colinear.
        static parseArcBy3Points(data) {
            if (Array.isArray(data) && data.length > 2) {
                const pointA = PointVector_1.Point3d.fromJSON(data[0]);
                const pointB = PointVector_1.Point3d.fromJSON(data[1]);
                const pointC = PointVector_1.Point3d.fromJSON(data[2]);
                return Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);
            }
            return undefined;
        }
        static parseArcObject(data) {
            let arc = Reader.parseArcByVectorProps(data);
            if (arc)
                return arc;
            arc = Reader.parseArcBy3Points(data);
            return arc; // possibly undefined.
        }
        static parseCoordinate(data) {
            const point = PointVector_1.Point3d.fromJSON(data);
            if (point)
                return CurvePrimitive_1.CoordinateXYZ.create(point);
            return undefined;
        }
        static parseTransitionSpiral(data) {
            const axes = Reader.parseOrientation(data, true);
            const origin = Reader.parsePoint3dProperty(data, "origin");
            // the create method will juggle any 4 out of these 5 inputs to define the other ..
            const startBearing = Reader.parseAngleProperty(data, "startBearing");
            const endBearing = Reader.parseAngleProperty(data, "endBearing");
            const startRadius = Reader.parseNumberProperty(data, "startRadius");
            const endRadius = Reader.parseNumberProperty(data, "endRadius");
            const length = Reader.parseNumberProperty(data, "curveLength", undefined);
            const interval = Reader.parseSegment1dProperty(data, "fractionInterval", undefined);
            const spiralType = Reader.parseStringProperty(data, "spiralType", "clothoid");
            if (origin)
                return TransitionSpiral_1.TransitionSpiral3d.create(spiralType, startRadius, endRadius, startBearing, endBearing, length, interval, Transform_2.Transform.createOriginAndMatrix(origin, axes));
            return undefined;
        }
        static parseBcurve(data) {
            if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {
                const poles = [];
                for (const p of data.points)
                    poles.push(PointVector_1.Point3d.fromJSON(p));
                const knots = [];
                for (const knot of data.knots)
                    knots.push(knot);
                // TODO -- wrap poles and knots for closed case !!
                if (data.closed) {
                    for (let i = 0; i + 1 < data.order; i++) {
                        poles.push(poles[i].clone());
                    }
                }
                const newCurve = BSplineCurve_1.BSplineCurve3d.create(poles, knots, data.order);
                if (newCurve) {
                    if (data.closed === true)
                        newCurve.setWrappable(true);
                    return newCurve;
                }
            }
            return undefined;
        }
        static parseArray(data) {
            if (Array.isArray(data)) {
                const myArray = [];
                let c;
                for (c of data) {
                    const g = Reader.parse(c);
                    if (g !== undefined)
                        myArray.push(g);
                }
                return myArray;
            }
            return undefined;
        }
        // For each nonzero index, Announce Math.abs (value) -1
        static addZeroBasedIndicesFromSignedOneBased(data, f) {
            if (data && Geometry_1.Geometry.isNumberArray(data)) {
                for (const value of data) {
                    if (value !== 0)
                        f(Math.abs(value) - 1);
                }
            }
        }
        static parseIndexedMesh(data) {
            // {Coord:[[x,y,z],. . . ],   -- simple xyz for each ponit
            // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!
            if (data.hasOwnProperty("point") && Array.isArray(data.point)
                && data.hasOwnProperty("pointIndex") && Array.isArray(data.pointIndex)) {
                const polyface = Polyface_1.IndexedPolyface.create();
                if (data.hasOwnProperty("normal") && Array.isArray(data.normal)) {
                    for (const uvw of data.normal) {
                        if (Geometry_1.Geometry.isNumberArray(uvw, 3))
                            polyface.addNormal(PointVector_1.Vector3d.create(uvw[0], uvw[1], uvw[2]));
                    }
                }
                if (data.hasOwnProperty("param") && Array.isArray(data.param)) {
                    for (const uv of data.param) {
                        if (Geometry_1.Geometry.isNumberArray(uv, 2))
                            polyface.addParam(PointVector_1.Point2d.create(uv[0], uv[1]));
                    }
                }
                if (data.hasOwnProperty("color") && Array.isArray(data.color)) {
                    for (const c of data.color) {
                        polyface.addColor(c);
                    }
                }
                for (const p of data.point)
                    polyface.addPoint(PointVector_1.Point3d.fromJSON(p));
                for (const p of data.pointIndex) {
                    if (p === 0)
                        polyface.terminateFacet(false); // we are responsible for index checking !!!
                    else {
                        const p0 = Math.abs(p) - 1;
                        polyface.addPointIndex(p0, p > 0);
                    }
                }
                if (data.hasOwnProperty("normalIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex, (x) => { polyface.addNormalIndex(x); });
                }
                if (data.hasOwnProperty("paramIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex, (x) => { polyface.addParamIndex(x); });
                }
                if (data.hasOwnProperty("colorIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex, (x) => { polyface.addColorIndex(x); });
                }
                return polyface;
            }
            return undefined;
        }
        static parseCurveCollectionMembers(result, data) {
            if (data && Array.isArray(data)) {
                for (const c of data) {
                    const g = Reader.parse(c);
                    if (g !== undefined)
                        result.tryAddChild(g);
                }
                return result;
            }
            return undefined;
        }
        static parseBsurf(data) {
            if (data.hasOwnProperty("uKnots") && Array.isArray(data.uKnots)
                && data.hasOwnProperty("vKnots") && Array.isArray(data.vKnots)
                && data.hasOwnProperty("orderU") && Number.isFinite(data.orderU)
                && data.hasOwnProperty("orderV") && Number.isFinite(data.orderV)
                && data.hasOwnProperty("points") && Array.isArray(data.points)) {
                const orderU = data.orderU;
                const orderV = data.orderV;
                if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {
                    const d = data.points[0][0].length;
                    /** xyz surface (no weights) */
                    if (d === 3) {
                        return BSplineSurface_1.BSplineSurface3d.createGrid(data.points, orderU, data.uKnots, orderV, data.vKnots);
                    }
                    /** xyzw surface (weights already applied) */
                    if (d === 4) {
                        return BSplineSurface_1.BSplineSurface3dH.createGrid(data.points, BSplineSurface_1.WeightStyle.WeightsAlreadyAppliedToCoordinates, orderU, data.uKnots, orderV, data.vKnots);
                    }
                }
            }
            return undefined;
        }
        /**
         * Create a cone with data from a `ConeByCCRRV`.
         */
        static parseConeProps(json) {
            const axes = Reader.parseOrientation(json, false);
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const startRadius = Reader.parseNumberProperty(json, "startRadius");
            const endRadius = Reader.parseNumberProperty(json, "endRadius", startRadius);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && startRadius !== undefined
                && endRadius !== undefined) {
                if (axes === undefined) {
                    const axisVector = PointVector_1.Vector3d.createStartEnd(start, end);
                    const frame = Transform_1.RotMatrix.createRigidHeadsUp(axisVector, 2 /* ZXY */);
                    const vectorX = frame.columnX();
                    const vectorY = frame.columnY();
                    return Cone_1.Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);
                }
                else {
                    return Cone_1.Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);
                }
            }
            return undefined;
        }
        /**
         * Create a cylinder.
         */
        static parseCylinderProps(json) {
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const radius = Reader.parseNumberProperty(json, "radius");
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && radius !== undefined) {
                return Cone_1.Cone.createAxisPoints(start, end, radius, radius, capped);
            }
            return undefined;
        }
        static parseLineSegmentProps(value) {
            if (Array.isArray(value) && value.length > 1)
                return LineSegment3d_1.LineSegment3d.create(PointVector_1.Point3d.fromJSON(value[0]), PointVector_1.Point3d.fromJSON(value[1]));
        }
        static parseLinearSweep(json) {
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const extrusionVector = Reader.parseVector3dProperty(json, "vector");
            if (contour
                && capped !== undefined
                && extrusionVector) {
                return LinearSweep_1.LinearSweep.create(contour, extrusionVector, capped);
            }
            return undefined;
        }
        static parseRotationalSweep(json) {
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const axisVector = Reader.parseVector3dProperty(json, "axis");
            const center = Reader.parsePoint3dProperty(json, "center");
            const sweepDegrees = Reader.parseNumberProperty(json, "sweepAngle");
            if (contour
                && sweepDegrees !== undefined
                && capped !== undefined
                && axisVector
                && center) {
                return RotationalSweep_1.RotationalSweep.create(contour, AnalyticGeometry_1.Ray3d.createCapture(center, axisVector), Geometry_1.Angle.createDegrees(sweepDegrees), capped);
            }
            return undefined;
        }
        static parseBox(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const baseOrigin = Reader.parsePoint3dProperty(json, "baseOrigin");
            const baseX = Reader.parseNumberProperty(json, "baseX");
            const baseY = Reader.parseNumberProperty(json, "baseY", baseX);
            let topOrigin = Reader.parsePoint3dProperty(json, "topOrigin");
            const topX = Reader.parseNumberProperty(json, "topX", baseX);
            const topY = Reader.parseNumberProperty(json, "topY", baseY);
            const height = Reader.parseNumberProperty(json, "height", baseX);
            const axes = Reader.parseOrientation(json, true);
            if (baseOrigin && !topOrigin)
                topOrigin = Transform_1.RotMatrix.XYZMinusMatrixTimesXYZ(baseOrigin, axes, PointVector_1.Vector3d.create(0, 0, height));
            if (capped !== undefined
                && baseX !== undefined
                && baseY !== undefined
                && topY !== undefined
                && topX !== undefined
                && axes
                && baseOrigin
                && topOrigin) {
                return Box_1.Box.createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped);
            }
            return undefined;
        }
        static parseSphere(json) {
            const center = Reader.parsePoint3dProperty(json, "center");
            // optional unqualified radius . . .
            const radius = Reader.parseNumberProperty(json, "radius");
            // optional specific X
            const radiusX = Reader.parseNumberProperty(json, "radiusX", radius);
            // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)
            const radiusY = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const radiusZ = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const latitudeStartEnd = Reader.parseAngleSweepProps(json, "latitudeStartEnd"); // this may be undfined!!
            const axes = Reader.parseOrientation(json, true);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center !== undefined
                && radiusX !== undefined
                && radiusY !== undefined
                && radiusZ !== undefined
                && capped !== undefined) {
                return Sphere_1.Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);
            }
            return undefined;
        }
        static parseRuledSweep(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const contours = this.loadContourArray(json, "contour");
            if (contours !== undefined
                && capped !== undefined) {
                return RuledSweep_1.RuledSweep.create(contours, capped);
            }
            return undefined;
        }
        static parseTorusPipe(json) {
            const axes = Reader.parseOrientation(json, true);
            const center = Reader.parsePoint3dProperty(json, "center");
            const radiusA = Reader.parseNumberProperty(json, "majorRadius");
            const radiusB = Reader.parseNumberProperty(json, "minorRadius");
            const sweepAngle = Reader.parseAngleProperty(json, "sweepAngle", undefined);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center
                && radiusA !== undefined
                && radiusB !== undefined) {
                return TorusPipe_1.TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(), radiusA, radiusB, sweepAngle ? sweepAngle : Geometry_1.Angle.createDegrees(360), capped);
            }
            return undefined;
        }
        static parsePointArray(json) {
            const points = [];
            if (json && Array.isArray(json)) {
                for (const member of json) {
                    if (PointVector_1.XYZ.isXAndY(member)) {
                        points.push(PointVector_1.Point3d.fromJSON(member));
                    }
                    else if (Geometry_1.Geometry.isNumberArray(member, 2)) {
                        points.push(PointVector_1.Point3d.fromJSON(member));
                    }
                }
            }
            return points;
        }
        static parse(json) {
            if (json !== undefined && json) {
                if (json.lineSegment !== undefined) {
                    return Reader.parseLineSegmentProps(json.lineSegment);
                }
                else if (json.lineString !== undefined) {
                    return LineString3d_1.LineString3d.create(Reader.parsePointArray(json.lineString));
                }
                else if (json.arc !== undefined) {
                    return Reader.parseArcObject(json.arc);
                }
                else if (json.hasOwnProperty("point")) {
                    return Reader.parseCoordinate(json.point);
                }
                else if (json.hasOwnProperty("bcurve")) {
                    return Reader.parseBcurve(json.bcurve);
                }
                else if (json.hasOwnProperty("path")) {
                    return Reader.parseCurveCollectionMembers(new CurveChain_2.Path(), json.path);
                }
                else if (json.hasOwnProperty("loop")) {
                    return Reader.parseCurveCollectionMembers(new CurveChain_2.Loop(), json.loop);
                }
                else if (json.hasOwnProperty("parityRegion")) {
                    return Reader.parseCurveCollectionMembers(new CurveChain_2.ParityRegion(), json.parityRegion);
                }
                else if (json.hasOwnProperty("unionRegion")) {
                    return Reader.parseCurveCollectionMembers(new CurveChain_2.UnionRegion(), json.unionRegion);
                }
                else if (json.hasOwnProperty("bagOfCurves")) {
                    return Reader.parseCurveCollectionMembers(new CurveChain_2.BagOfCurves(), json.bagOfCurves);
                }
                else if (json.hasOwnProperty("indexedMesh")) {
                    return Reader.parseIndexedMesh(json.indexedMesh);
                }
                else if (json.hasOwnProperty("bsurf")) {
                    return Reader.parseBsurf(json.bsurf);
                }
                else if (json.hasOwnProperty("cone")) {
                    return Reader.parseConeProps(json.cone);
                }
                else if (json.hasOwnProperty("cylinder")) {
                    return Reader.parseCylinderProps(json.cylinder);
                }
                else if (json.hasOwnProperty("sphere")) {
                    return Reader.parseSphere(json.sphere);
                }
                else if (json.hasOwnProperty("linearSweep")) {
                    return Reader.parseLinearSweep(json.linearSweep);
                }
                else if (json.hasOwnProperty("box")) {
                    return Reader.parseBox(json.box);
                }
                else if (json.hasOwnProperty("rotationalSweep")) {
                    return Reader.parseRotationalSweep(json.rotationalSweep);
                }
                else if (json.hasOwnProperty("ruledSweep")) {
                    return Reader.parseRuledSweep(json.ruledSweep);
                }
                else if (json.hasOwnProperty("torusPipe")) {
                    return Reader.parseTorusPipe(json.torusPipe);
                }
                else if (json.hasOwnProperty("pointString")) {
                    return PointString3d_1.PointString3d.create(Reader.parsePointArray(json.pointString));
                }
                else if (json.hasOwnProperty("transitionSpiral")) {
                    return Reader.parseTransitionSpiral(json.transitionSpiral);
                }
                else if (Array.isArray(json))
                    return Reader.parseArray(json);
            }
            return undefined;
        }
    }
    IModelJson.Reader = Reader;
    // ISSUE: include 3d in names?
    // ISSUE: would like shorter term than lineSegment
    // ISSUE: is arc clear?
    // ISSUE: label center, vectorX, vector90 on arc?
    // ISSUE: sweep data on arc -- serialize as AngleSweep?
    class Writer extends GeometryHandler_1.GeometryHandler {
        handleLineSegment3d(data) {
            return { "lineSegment": [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };
        }
        handleCoordinateXYZ(data) {
            return { "point": data.point.toJSON() };
        }
        handleArc3d(data) {
            return {
                "arc": {
                    "center": data.center.toJSON(),
                    "vectorX": data.vector0.toJSON(),
                    "vectorY": data.vector90.toJSON(),
                    "sweepStartEnd": [data.sweep.startDegrees, data.sweep.endDegrees],
                },
            };
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromMatrix(data, matrix, omitIfIdentity) {
            if (omitIfIdentity) {
                if (matrix === undefined)
                    return;
                if (matrix.isIdentity())
                    return;
            }
            if (matrix)
                data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];
            else
                data.xyVectors = [[1, 0, 0], [0, 1, 0]];
        }
        static isIdentityXY(xVector, yVector) {
            return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromXYVectors(data, vectorX, vectorY, omitIfIdentity) {
            if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))
                return;
            data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];
        }
        /**
         * Insert orientation description to a data object, with orientation defined by u and v direction
         * vectors.
         * @param vectorX u direction
         * @param vectorV v direction
         * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.
         * @param data AxesProps object to be annotated.
         */
        static insertXYOrientation(data, vectorU, vectorV, omitIfIdentity) {
            if (omitIfIdentity) {
                if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))
                    return;
            }
            data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];
        }
        handleTransitionSpiral(data) {
            // TODO: HANDLE NONRIGID TRANSFORM !!
            // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the orignial data
            // as indication of what current data to use.  (Current data may have changed due to transforms.)
            const originalProperties = data.originalProperties;
            const value = {
                origin: data.localToWorld.origin.toJSON(),
                type: data.getSpiralType(),
            };
            Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);
            if (!data.activeFractionInterval.isExact01())
                Object.defineProperty(value, "fractionInterval", [data.activeFractionInterval.x0, data.activeFractionInterval.x1]);
            // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)
            if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {
                if (originalProperties.radius0 !== undefined)
                    value.startRadius = data.radius01.x0;
                if (originalProperties.radius1 !== undefined)
                    value.endRadius = data.radius01.x1;
                if (originalProperties.bearing0 !== undefined)
                    value.startBearing = data.bearing01.startAngle.toJSON();
                if (originalProperties.bearing1 !== undefined)
                    value.endBearing = data.bearing01.endAngle.toJSON();
                if (originalProperties.curveLength !== undefined)
                    value.curveLength = data.curveLength();
            }
            else {
                // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.
                // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)
                value.startRadius = data.radius01.x0;
                value.endRadius = data.radius01.x1;
                value.startBearing = data.bearing01.startAngle.toJSON();
                value.endBearing = data.bearing01.endAngle.toJSON();
                value.curveLength = data.curveLength();
            }
            return { "transitionSpiral": value };
        }
        handleCone(data) {
            const radiusA = data.getRadiusA();
            const radiusB = data.getRadiusB();
            const centerA = data.getCenterA();
            const centerB = data.getCenterB();
            const vectorX = data.getVectorX();
            const vectorY = data.getVectorY();
            const axisVector = PointVector_1.Vector3d.createStartEnd(centerA, centerB);
            if (Geometry_1.Geometry.isSameCoordinate(radiusA, radiusB)
                && vectorX.isPerpendicularTo(axisVector)
                && vectorY.isPerpendicularTo(axisVector)
                && Geometry_1.Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)
                && Geometry_1.Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {
                return {
                    "cylinder": {
                        "capped": data.capped,
                        "start": data.getCenterA().toJSON(),
                        "end": data.getCenterB().toJSON(),
                        "radius": radiusA,
                    },
                };
            }
            else {
                const coneProps = {
                    "capped": data.capped,
                    "start": data.getCenterA().toJSON(),
                    "end": data.getCenterB().toJSON(),
                    "startRadius": data.getRadiusA(),
                    "endRadius": data.getRadiusB(),
                };
                Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);
                return { "cone": coneProps };
            }
        }
        handleSphere(data) {
            const xData = data.cloneVectorX().normalizeWithLength();
            const yData = data.cloneVectorY().normalizeWithLength();
            const zData = data.cloneVectorZ().normalizeWithLength();
            const latitudeSweep = data.cloneLatitudeSweep();
            const rX = xData.mag;
            const rY = yData.mag;
            const rZ = zData.mag;
            if (xData.v && zData.v) {
                const value = {
                    "center": data.cloneCenter().toJSON(),
                };
                if (!(data.getConstructiveFrame()).matrix.isIdentity())
                    value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];
                const fullSweep = latitudeSweep.isFullLatitudeSweep();
                if (data.capped && !fullSweep)
                    value.capped = data.capped;
                if (Geometry_1.Geometry.isSameCoordinate(rX, rY) && Geometry_1.Geometry.isSameCoordinate(rX, rZ))
                    value.radius = rX;
                else {
                    value.radiusX = rX;
                    value.radiusY = rY;
                    value.radiusZ = rZ;
                }
                if (!fullSweep)
                    value.latitudeStartEnd = latitudeSweep.toJSON();
                return { "sphere": value };
            }
            return undefined;
        }
        handleTorusPipe(data) {
            const vectorX = data.cloneVectorX();
            const vectorY = data.cloneVectorY();
            const radiusA = data.getMajorRadius();
            const radiusB = data.getMinorRadius();
            const sweep = data.getSweepAngle();
            if (data.getIsReversed()) {
                vectorY.scaleInPlace(-1.0);
                sweep.setRadians(-sweep.radians);
            }
            const value = {
                "center": data.cloneCenter().toJSON(),
                "majorRadius": radiusA,
                "minorRadius": radiusB,
                "xyVectors": [vectorX.toJSON(), vectorY.toJSON()],
            };
            if (!sweep.isFullCircle()) {
                value.sweepAngle = sweep.degrees;
                value.capped = data.capped;
            }
            return { "torusPipe": value };
        }
        handleLineString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "lineString": pointsB };
        }
        handlePointString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "pointString": pointsB };
        }
        handlePath(data) {
            return { "path": this.collectChildren(data) };
        }
        handleLoop(data) {
            return { "loop": this.collectChildren(data) };
        }
        handleParityRegion(data) {
            return { "parityRegion": this.collectChildren(data) };
        }
        handleUnionRegion(data) {
            return { "unionRegion": this.collectChildren(data) };
        }
        handleBagOfCurves(data) {
            return { "bagOfCurves": this.collectChildren(data) };
        }
        collectChildren(data) {
            const children = [];
            if (data.children && Array.isArray(data.children)) {
                for (const child of data.children) {
                    const cdata = child.dispatchToGeometryHandler(this);
                    if (cdata)
                        children.push(cdata);
                }
            }
            return children;
        }
        handleLinearSweep(data) {
            const extrusionVector = data.cloneSweepVector();
            const curves = data.getCurvesRef();
            const capped = data.capped;
            if (extrusionVector
                && curves
                && capped !== undefined) {
                return {
                    "linearSweep": {
                        "contour": curves.dispatchToGeometryHandler(this),
                        "capped": capped,
                        "vector": extrusionVector.toJSON(),
                    },
                };
            }
            return undefined;
        }
        handleRuledSweep(data) {
            const contours = data.cloneContours();
            const capped = data.capped;
            if (contours
                && contours.length > 1
                && capped !== undefined) {
                const jsonContours = [];
                for (const c of contours) {
                    jsonContours.push(this.emit(c));
                }
                return {
                    "ruledSweep": {
                        "contour": jsonContours,
                        "capped": capped,
                    },
                };
            }
            return undefined;
        }
        handleRotationalSweep(data) {
            const axisRay = data.cloneAxisRay();
            const curves = data.getCurves();
            const capped = data.capped;
            const sweepAngle = data.getSweep();
            return {
                "rotationalSweep": {
                    "axis": axisRay.direction.toJSON(),
                    "contour": curves.dispatchToGeometryHandler(this),
                    "capped": capped,
                    "center": axisRay.origin.toJSON(),
                    "sweepAngle": sweepAngle.degrees,
                },
            };
        }
        handleBox(box) {
            const out = {
                "box": {
                    "baseOrigin": box.getBaseOrigin().toJSON(),
                    "baseX": box.getBaseX(),
                    "baseY": box.getBaseY(),
                    "capped": box.capped,
                    "topOrigin": box.getTopOrigin().toJSON(),
                },
            };
            Writer.insertXYOrientation(out.box, box.getVectorX(), box.getVectorY(), true);
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))
                out.box.topX = box.getTopX();
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))
                out.box.topY = box.getTopY();
            return out;
        }
        handleIndexedPolyface(pf) {
            const points = [];
            const pointIndex = [];
            const normals = [];
            const params = [];
            const colors = [];
            const p = PointVector_1.Point3d.create();
            for (let i = 0; pf.data.point.atPoint3dIndex(i, p); i++)
                points.push(p.toJSON());
            if (pf.data.normal) {
                for (const value of pf.data.normal)
                    normals.push(value.toJSON());
            }
            if (pf.data.param) {
                for (const value of pf.data.param)
                    params.push(value.toJSON());
            }
            if (pf.data.color) {
                for (const value of pf.data.color)
                    colors.push(value);
            }
            const visitor = pf.createVisitor(0);
            let indexCounter = 0;
            const normalIndex = [];
            const paramIndex = [];
            const colorIndex = [];
            let n;
            while (visitor.moveToNextFacet()) {
                n = visitor.indexCount;
                // All meshes have point and point index ...
                for (let i = 0; i < n; i++) {
                    // Change sign of value to be pushed based on whether or not the edge was originally visible or not
                    const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : -(visitor.clientPointIndex(i) + 1);
                    pointIndex.push(toPush);
                }
                pointIndex.push(0); // facet terminator.
                indexCounter += visitor.indexCount;
                if (visitor.normalIndex) {
                    for (let i = 0; i < n; i++)
                        normalIndex.push(1 + visitor.clientNormalIndex(i));
                    normalIndex.push(0);
                }
                if (visitor.paramIndex) {
                    for (let i = 0; i < n; i++)
                        paramIndex.push(1 + visitor.clientParamIndex(i));
                    paramIndex.push(0);
                }
                if (visitor.colorIndex) {
                    for (let i = 0; i < n; i++)
                        colorIndex.push(1 + visitor.clientColorIndex(i));
                    colorIndex.push(0);
                }
            }
            // assemble the contents in alphabetical order.
            const contents = {};
            if (pf.data.color)
                contents.color = colors;
            if (pf.data.colorIndex)
                contents.colorIndex = colorIndex;
            if (pf.data.normal)
                contents.normal = normals;
            if (pf.data.normalIndex)
                contents.normalIndex = normalIndex;
            if (pf.data.param)
                contents.param = params;
            if (pf.data.paramIndex)
                contents.paramIndex = paramIndex;
            contents.point = points;
            contents.pointIndex = pointIndex;
            return { "indexedMesh": contents };
        }
        handleBSplineCurve3d(curve) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            if (curve.isClosable()) {
                const knots = curve.copyKnots(true);
                const poles = curve.copyPoints();
                const degree = curve.degree;
                for (let i = 0; i < degree; i++)
                    poles.pop();
                // knots have replicated first and last.  Change the values to be periodic.
                const leftIndex = degree;
                const rightIndex = knots.length - degree - 1;
                const knotPeriod = knots[rightIndex] - knots[leftIndex];
                knots[0] = knots[rightIndex - degree] - knotPeriod;
                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else {
                return {
                    "bcurve": {
                        "points": curve.copyPoints(),
                        "knots": curve.copyKnots(true),
                        "closed": false,
                        "order": curve.order,
                    },
                };
            }
        }
        handleBSplineSurface3d(surface) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            if (surface.isClosable(0)
                || surface.isClosable(1)) {
                // TODO
            }
            else {
                return {
                    "bsurf": {
                        "points": surface.getPointArray(false),
                        "uKnots": surface.copyKnots(0, true),
                        "vKnots": surface.copyKnots(1, true),
                        "orderU": surface.orderUV(0),
                        "orderV": surface.orderUV(1),
                    },
                };
            }
        }
        handleBSplineSurface3dH(surface) {
            const data = surface.getPointGridJSON();
            return {
                "bsurf": {
                    "points": data.points,
                    "uKnots": surface.copyKnots(0, true),
                    "vKnots": surface.copyKnots(1, true),
                    "orderU": surface.orderUV(0),
                    "orderV": surface.orderUV(1),
                },
            };
        }
        emitArray(data) {
            const members = [];
            for (const c of data) {
                const toPush = this.emit(c);
                members.push(toPush);
            }
            return members;
        }
        emit(data) {
            if (Array.isArray(data))
                return this.emitArray(data);
            if (data instanceof CurvePrimitive_1.GeometryQuery) {
                return data.dispatchToGeometryHandler(this);
            }
            return undefined;
        }
        /** One-step static method to create a writer and emit a json object */
        static toIModelJson(data) {
            const writer = new Writer();
            return writer.emit(data);
        }
    }
    IModelJson.Writer = Writer;
})(IModelJson = exports.IModelJson || (exports.IModelJson = {}));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An identity function which given a value of type T, returns the same value.
 * Useful as a default argument for functions which can alternatively accept custom logic for cloning values of object type.
 * @param value The value to clone.
 * @returns the input value.
 */
function defaultClone(value) { return value; }
exports.defaultClone = defaultClone;
/**
 * Computes the position at which the specified value should be inserted in order to maintain sorted order within a sorted array.
 * @param value The value whose position is to be computed.
 * @param list An array of U already sorted according to the comparison criterion.
 * @param compare A function accepting a value of type T and a value of type U and returning a negative value if lhs < rhs,
 *        zero if lhs == rhs, and a positive value otherwise.
 * @returns an object with 'index' corresponding to the computed position and 'equal' set to true if an equivalent element already exists at that index.
 */
function lowerBound(value, list, compare) {
    let low = 0;
    let high = list.length;
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        const comp = compare(value, list[mid]);
        if (0 === comp)
            return { index: mid, equal: true };
        else if (comp < 0)
            high = mid;
        else
            low = mid + 1;
    }
    return { index: low, equal: false };
}
exports.lowerBound = lowerBound;
/**
 * Maintains an array of some type T in sorted order. The ordering is specified by a function supplied
 * by the user.
 * By default, only unique elements are permitted; attempting to insert a new element which compares
 * as equal to an element already in the array will not modify the contents of the array.
 *
 * This allows a SortedArray<T> to behave like a Set<T> where T is an object and equality is determined
 * by some criterion other than object identity.
 *
 * Because the array is always sorted, querying for the presence of an element is performed using binary
 * search, which is more efficient than a linear search for reasonably large arrays.
 *
 * The user can also specify how the SortedArray takes ownership of inserted values, e.g., by cloning them.
 *
 * The comparison function must meet the following criteria, given 'lhs' and 'rhs' of type T:
 *  - If lhs is equal to rhs, returns 0
 *  - If lhs is less than rhs, returns a negative value
 *  - If lhs is greater than rhs, returns a positive value
 *  - If compare(lhs, rhs) returns 0, then compare(rhs, lhs) must also return 0
 *  - If compare(lhs, rhs) returns a negative value, then compare(rhs, lhs) must return a positive value, and vice versa.
 *
 * Modifying an element in a way that affects the comparison function will produce unpredictable results, the
 * most likely of which is that the array will cease to be sorted.
 */
class SortedArray {
    /**
     * Construct a new SortedArray<T>.
     * @param compare A function accepting two values of type T and returning a negative value if lhs < rhs,
     *        zero if lhs == rhs, and a positive value otherwise.
     * @param allowDuplicates If true, multiple values comparing equal may exist in the array.
     * @param clone A function that, given a value of type T, returns an equivalent value of type T.
     *        This function is invoked when a new element is inserted into the array.
     *        The default implementation simply returns its input.
     */
    constructor(compare, allowDuplicates = false, clone = defaultClone) {
        this._array = [];
        this._compare = compare;
        this._clone = clone;
        this._allowDuplicates = allowDuplicates;
    }
    /** The number of elements in the array */
    get length() { return this._array.length; }
    /** Clears the contents of the sorted array. */
    clear() { this._array = []; }
    /** Extracts the sorted array as a T[] and empties the contents of this SortedArray.
     * @returns the contents of this SortedArray as a T[].
     */
    extractArray() {
        const result = this._array;
        this.clear();
        return result;
    }
    /**
     * Attempts to insert a new value into the array at a position determined by the ordering.
     * The behavior differs based on whether or not duplicate elements are permitted.
     * If duplicates are **not** permitted, then:
     *  - If an equivalent element already exists in the array, nothing will be inserted and the index of the existing element will be returned.
     *  - Otherwise, the element is inserted and its index is returned.
     * If duplicates **are** permitted, then:
     *  - The element will be inserted in a correct position based on the sorting criterion;
     *  - The position of the element relative to other elements comparing as equal to it is unspecified; and
     *  - The actual index of the newly-inserted element is returned.
     * If the element is to be inserted, then the supplied value will be passed to the clone function supplied to the constructor and the result will be inserted into the array.
     * @param value The value to insert
     * @param onInsert The optional callback method to call if insertion occurs with the inserted value
     * @returns the index in the array of the newly-inserted value, or, if duplicates are not permitted and an equivalent value already exists, the index of the equivalent value.
     */
    insert(value, onInsert) {
        const bound = this.lowerBound(value);
        if (!bound.equal || this._allowDuplicates)
            this._array.splice(bound.index, 0, this._clone(value));
        if (undefined !== onInsert)
            onInsert(value);
        return bound.index;
    }
    /**
     * Looks up the index of an element comparing equal to the specified value using binary search.
     * @param value The value to search for
     * @returns the index of the first equivalent element in the array, or -1 if no such element exists.
     */
    indexOf(value) {
        const bound = this.lowerBound(value);
        return bound.equal ? bound.index : -1;
    }
    /**
     * Looks up an element comparing equal to the specified value using binary search.
     * @param value The value to search for
     * @returns the first equivalent element in the array, or -1 if no such element exists.
     */
    findEqual(value) {
        const index = this.indexOf(value);
        return -1 !== index ? this._array[index] : undefined;
    }
    /**
     * Looks up an element by its index in the array.
     * @param index The array index
     * @returns the element corresponding to that position in the array, or undefined if the supplied index exceeds the length of the array.
     */
    get(index) { return index < this.length ? this._array[index] : undefined; }
    /**
     * Computes the position at which the specified value should be inserted in order to maintain sorted order.
     * @param value The value whose position is to be computed.
     * @returns an object with 'index' corresponding to the computed position and 'equal' set to true if an equivalent element already exists at that index.
     */
    lowerBound(value) { return lowerBound(value, this._array, this._compare); }
}
exports.SortedArray = SortedArray;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const xpath = __webpack_require__(167);
const xmldom_1 = __webpack_require__(168);
const Request_1 = __webpack_require__(23);
const Config_1 = __webpack_require__(31);
const Client_1 = __webpack_require__(68);
const Token_1 = __webpack_require__(165);
/** Client API for the IMS Federated Authentication Service. */
class ImsFederatedAuthentiationClient extends Client_1.Client {
    /**
     * Creates an instance of ImsFederatedAuthentiationClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsFederatedAuthentiationClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return ImsFederatedAuthentiationClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Parses the response from the token request to obtain the token and the user profile.
     * @param authTokenResponse Response for the token request.
     */
    static parseTokenResponse(authTokenResponse) {
        const select = xpath.useNamespaces({
            trust: "http://docs.oasis-open.org/ws-sx/ws-trust/200512",
        });
        const dom = (new xmldom_1.DOMParser()).parseFromString(authTokenResponse);
        const samlAssertion = select("//saml:Assertion", dom).toString();
        if (!samlAssertion)
            return undefined;
        return Token_1.AuthorizationToken.fromSamlAssertion(samlAssertion);
    }
}
ImsFederatedAuthentiationClient.searchKey = "IMS.FederatedAuth.Url";
ImsFederatedAuthentiationClient.defaultUrlDescriptor = {
    DEV: "https://qa-ims.bentley.com",
    QA: "https://qa-ims.bentley.com",
    PROD: "https://ims.bentley.com",
    PERF: "https://qa-ims.bentley.com",
};
exports.ImsFederatedAuthentiationClient = ImsFederatedAuthentiationClient;
/** Client API for the IMS Active Secure Token Service. */
class ImsActiveSecureTokenClient extends Client_1.Client {
    /**
     * Creates an instance of ImsActiveSecureTokenClient.
     * @param deploymentEnv Deployment environment
     */
    constructor(deploymentEnv) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsActiveSecureTokenClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return ImsActiveSecureTokenClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets the authorization token given the credentials.
     * @param userName User name
     * @param password  Password
     * @returns Resolves to the token and user profile.
     */
    async getToken(user, password) {
        const url = await this.getUrl();
        const options = {
            method: "POST",
            auth: {
                user,
                password,
            },
            body: {
                AppliesTo: Config_1.Config.host.relyingPartyUri,
                DeviceId: Config_1.Config.host.deviceId,
                AppId: Config_1.Config.host.name + "/" + Config_1.Config.host.version,
                Lifetime: 7 * 24 * 60,
            },
        };
        await this.setupOptionDefaults(options);
        return Request_1.request(url, options)
            .then((res) => {
            if (!res.body.RequestedSecurityToken)
                return Promise.reject(new Error("Authorization token not in expected format " + JSON.stringify(res)));
            const token = Token_1.AuthorizationToken.fromSamlAssertion(res.body.RequestedSecurityToken);
            if (!token)
                return Promise.reject(new Error("Could not parse the authorization token"));
            return Promise.resolve(token);
        });
    }
}
ImsActiveSecureTokenClient.searchKey = "Mobile.ImsStsAuth";
ImsActiveSecureTokenClient.defaultUrlDescriptor = {
    DEV: "https://qa-ims.bentley.com/rest/ActiveSTSService/json/IssueEx",
    QA: "https://qa-ims.bentley.com/rest/ActiveSTSService/json/IssueEx",
    PROD: "https://ims.bentley.com/rest/ActiveSTSService/json/IssueEx",
    PERF: "https://qa-ims.bentley.com/rest/ActiveSTSService/json/IssueEx",
};
exports.ImsActiveSecureTokenClient = ImsActiveSecureTokenClient;
/** Client API for the IMS Delegation Secure Token Service. */
class ImsDelegationSecureTokenClient extends Client_1.Client {
    /**
     * Creates an instance of ImsDelegationSecureTokenClient.
     * @param {DeploymentEnv} deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsDelegationSecureTokenClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return ImsDelegationSecureTokenClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets the (delegation) access token given the authorization token.
     * @param authTokenInfo Access token.
     * @param relyingPartyUri Relying party URI required by the service - defaults to a value defined by the configuration.
     * @returns Resolves to the (delegation) access token.
     */
    async getToken(authorizationToken, relyingPartyUri = Config_1.Config.host.relyingPartyUri) {
        const url = await this.getUrl() + "/json/IssueEx";
        const options = {
            method: "POST",
            headers: {
                authorization: authorizationToken.toTokenString(),
            },
            body: {
                ActAs: authorizationToken.getSamlAssertion(),
                AppliesTo: relyingPartyUri,
                AppliesToBootstrapToken: relyingPartyUri,
                DeviceId: Config_1.Config.host.deviceId,
                AppId: Config_1.Config.host.name + "/" + Config_1.Config.host.version,
                Lifetime: 60,
            },
        };
        await this.setupOptionDefaults(options);
        return Request_1.request(url, options)
            .then((res) => {
            if (!res.body.RequestedSecurityToken)
                return Promise.reject(new Error("Authorization token not in expected format " + JSON.stringify(res)));
            const accessToken = Token_1.AccessToken.fromSamlAssertion(res.body.RequestedSecurityToken);
            if (!accessToken)
                return Promise.reject(new Error("Could not parse the accessToken token"));
            return Promise.resolve(accessToken);
        });
    }
}
ImsDelegationSecureTokenClient.searchKey = "ActiveSTSDelegationServiceUrl";
ImsDelegationSecureTokenClient.defaultUrlDescriptor = {
    DEV: "https://qa-ims.bentley.com/rest/DelegationSTSService",
    QA: "https://qa-ims.bentley.com/rest/DelegationSTSService",
    PROD: "https://ims.bentley.com/rest/DelegationSTSService",
    PERF: "https://qa-ims.bentley.com/rest/DelegationSTSService",
};
exports.ImsDelegationSecureTokenClient = ImsDelegationSecureTokenClient;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WsgClient_1 = __webpack_require__(32);
const Errors_1 = __webpack_require__(49);
const ImsClients_1 = __webpack_require__(111);
const https = __webpack_require__(277);
const __1 = __webpack_require__(18);
const CustomRequestOptions_1 = __webpack_require__(296);
/**
 * Provides default options for iModel Hub requests.
 */
class DefaultIModelHubRequestOptionsProvider extends WsgClient_1.DefaultWsgRequestOptionsProvider {
    constructor(agent) {
        super();
        this.defaultOptions.errorCallback = Errors_1.IModelHubError.parse;
        this.defaultOptions.retryCallback = Errors_1.IModelHubError.shouldRetry;
        this.defaultOptions.agent = agent;
    }
}
/**
 * This class acts as the WsgClient for other iModel Hub Handlers.
 */
class IModelBaseHandler extends WsgClient_1.WsgClient {
    /**
     * Creates an instance of IModelBaseHandler.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv, keepAliveDuration = 30000, fileHandler) {
        super(deploymentEnv, "sv1.1", "https://connect-wsg20.bentley.com");
        this.deploymentEnv = deploymentEnv;
        this._customRequestOptions = new CustomRequestOptions_1.CustomRequestOptions();
        this._fileHandler = fileHandler;
        if (!__1.Config.isBrowser())
            this._agent = new https.Agent({ keepAlive: keepAliveDuration > 0, keepAliveMsecs: keepAliveDuration });
    }
    formatProjectIdForUrl(projectId) { return projectId; }
    getFileHandler() { return this._fileHandler; }
    /**
     * Augments request options with defaults returned by the DefaultIModelHubRequestOptionsProvider.
     * Note that the options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!this._defaultIModelHubOptionsProvider)
            this._defaultIModelHubOptionsProvider = new DefaultIModelHubRequestOptionsProvider(this._agent);
        return this._defaultIModelHubOptionsProvider.assignOptions(options);
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return IModelBaseHandler.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return IModelBaseHandler.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets the agenet used for imodelhub connection pooling.
     * @returns The agenet used for imodelhub connection pooling.
     */
    getAgent() {
        return this._agent;
    }
    /**
     * Gets the URL of the service.
     * Attempts to discover and cache the URL from the URL Discovery Service. If not
     * found uses the default URL provided by client implementations. Note that for consistency
     * sake, the URL is stripped of any trailing "/"
     * @returns URL for the service
     */
    getUrl() {
        return super.getUrl();
    }
    /**
     * Gets the (delegation) access token to acess the service
     * @param authorizationToken Authorization token.
     * @returns Resolves to the (delegation) access token.
     */
    async getAccessToken(authorizationToken) {
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient(this.deploymentEnv);
        return imsClient.getToken(authorizationToken, this.relyingPartyUri);
    }
    /**
     * Used by clients to send delete requests without body.
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @returns Promise resolves after successfully deleting REST resource at the specified path.
     */
    delete(token, relativeUrlPath) {
        return super.delete(token, relativeUrlPath);
    }
    /**
     * Used by clients to delete strongly typed instances through the standard WSG REST API
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Instance to be deleted.
     * @param requestOptions WSG options for the request.
     * @returns Promise resolves after successfully deleting instance.
     */
    deleteInstance(token, relativeUrlPath, instance, requestOptions) {
        if (this._customRequestOptions.isSet()) {
            if (!requestOptions) {
                requestOptions = {};
            }
            requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);
        }
        return super.deleteInstance(token, relativeUrlPath, instance, requestOptions);
    }
    /**
     * Used by clients to post strongly typed instances through standard WSG REST API
     * @param typedConstructor Used by clients to post a strongly typed instance through the REST API that's expected to return a standard response.
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Strongly typed instance to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instance that's returned back from the server.
     */
    postInstance(typedConstructor, token, relativeUrlPath, instance, requestOptions) {
        if (this._customRequestOptions.isSet()) {
            if (!requestOptions) {
                requestOptions = {};
            }
            requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);
        }
        return super.postInstance(typedConstructor, token, relativeUrlPath, instance, requestOptions);
    }
    /**
     * Used by clients to post multiple strongly typed instances through standard WSG REST API
     * @param typedConstructor Used by clients to post a strongly typed instances through the REST API that's expected to return a standard response.
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instances Strongly typed instances to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instances that's returned back from the server.
     */
    postInstances(typedConstructor, token, relativeUrlPath, instances, requestOptions) {
        return super.postInstances(typedConstructor, token, relativeUrlPath, instances, requestOptions);
    }
    /**
     * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param typedConstructor Constructor function for the type
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    getInstances(typedConstructor, token, relativeUrlPath, queryOptions) {
        return super.getInstances(typedConstructor, token, relativeUrlPath, queryOptions);
    }
    /**
     * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param typedConstructor Constructor function for the type
     * @param token Delegation token
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    postQuery(typedConstructor, token, relativeUrlPath, queryOptions) {
        return super.postQuery(typedConstructor, token, relativeUrlPath, queryOptions);
    }
    /**
     * Used by clients to set custom request parameters for all future requests made by this handler.
     */
    getCustomRequestOptions() {
        return this._customRequestOptions;
    }
}
IModelBaseHandler.searchKey = "iModelHubApi";
IModelBaseHandler.defaultUrlDescriptor = {
    DEV: "https://dev-imodelhubapi.bentley.com",
    QA: "https://qa-imodelhubapi.bentley.com",
    PROD: "https://imodelhubapi.bentley.com",
    PERF: "https://perf-imodelhubapi.bentley.com",
};
exports.IModelBaseHandler = IModelBaseHandler;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(290);
var util = __webpack_require__(292);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(293);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(69);
const Thumbnails_1 = __webpack_require__(184);
const GlobalEvents_1 = __webpack_require__(182);
const UserStatistics_1 = __webpack_require__(185);
/** Class that allows access to different iModel related Class handlers.
 * Handlers should be accessed through an instance of this class, rather than constructed directly.
 */
class IModelClient {
    /**
     * Creates an instance of IModelClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(baseHandler, deploymentEnv = "PROD", fileHandler) {
        this.deploymentEnv = deploymentEnv;
        this._handler = baseHandler;
        this._fileHandler = fileHandler || this._handler.getFileHandler();
        if (this._fileHandler)
            this._fileHandler.agent = this._handler.getAgent();
    }
    /**
     * Sets file handler for file upload/download.
     * @param fileHandler File handler.
     */
    setFileHandler(fileHandler) {
        this._fileHandler = fileHandler;
        this._fileHandler.agent = this._handler.getAgent();
    }
    /**
     * Get the handler for @see IModel related methods.
     */
    IModels() {
        return new index_1.IModelHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for @see Briefcase related methods.
     */
    Briefcases() {
        return new index_1.BriefcaseHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for @see ChangeSet related methods.
     */
    ChangeSets() {
        return new index_1.ChangeSetHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for @see Lock related methods.
     */
    Locks() {
        return new index_1.LockHandler(this._handler);
    }
    /**
     * Get the handler for @see Code related methods.
     */
    Codes() {
        return new index_1.CodeHandler(this._handler);
    }
    /**
     * Get the handler for @see UserInfo related methods.
     */
    Users() {
        return new index_1.UserInfoHandler(this._handler);
    }
    /**
     * Get the handler for @see Version related methods.
     */
    Versions() {
        return new index_1.VersionHandler(this._handler);
    }
    /**
     * Get the handler for Thumbnail related methods.
     */
    Thumbnails() {
        return new Thumbnails_1.ThumbnailHandler(this._handler);
    }
    /**
     * Get the handler for @see IModelHubEvent related methods.
     */
    Events() {
        return new index_1.EventHandler(this._handler);
    }
    /**
     * Get the handler for @see IModelHubGlobalEvent related methods.
     */
    GlobalEvents() {
        return new GlobalEvents_1.GlobalEventHandler(this._handler);
    }
    /**
     * Get the handler for @see IModelHubStatistics related methods.
     */
    UserStatistics() {
        return new UserStatistics_1.UserStatisticsHandler(this._handler);
    }
    /**
     * Get the @see CustomRequestOptions object for controlling future request options.
     */
    CustomRequestOptions() {
        return this._handler.getCustomRequestOptions();
    }
}
exports.IModelClient = IModelClient;


/***/ }),
/* 115 */
/***/ (function(module, exports) {

// empty (null-loader)

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/**
 * A Range3d that is aligned with the axes of a coordinate space.
 */
class AxisAlignedBox3d extends geometry_core_1.Range3d {
    constructor(low, high) {
        if (low === undefined || high === undefined)
            super(); // defines an empty box
        else
            super(low.x, low.y, low.z, high.x, high.y, high.z);
    }
    clone() { return new AxisAlignedBox3d(this.low, this.high); }
    /** Construct a new AxisAlignedBox3d from a LowAndHighXY */
    static fromRange2d(r) { const v = new AxisAlignedBox3d(); v.low.x = r.low.x; v.low.y = r.low.y; v.high.x = r.high.x; v.high.y = r.high.y; return v; }
    /** Get the center point of this AxisAlignedBox3d */
    getCenter() { return this.low.interpolate(.5, this.high); }
    /** Ensure that the length of each dimension of this AxisAlignedBox3d is at least a minimum size. If not, expand to minimum about the center.
     * @param min The minimum length for each dimension.
     */
    ensureMinLengths(min = .001) {
        let size = (min - this.xLength()) / 2.0;
        if (size > 0) {
            this.low.x -= size;
            this.high.x += size;
        }
        size = (min - this.yLength()) / 2.0;
        if (size > 0) {
            this.low.y -= size;
            this.high.y += size;
        }
        size = (min - this.zLength()) / 2.0;
        if (size > 0) {
            this.low.z -= size;
            this.high.z += size;
        }
    }
    /** @hidden */
    static fromJSON(json) {
        const val = new AxisAlignedBox3d();
        val.setFromJSON(json);
        return val;
    }
}
exports.AxisAlignedBox3d = AxisAlignedBox3d;
/** A bounding box aligned to the orientation of a 3d Element */
class ElementAlignedBox3d extends geometry_core_1.Range3d {
    static createFromPoints(low, high) { return new ElementAlignedBox3d(low.x, low.y, low.z, high.x, high.y, high.z); }
    get left() { return this.low.x; }
    get bottom() { return this.low.y; }
    get front() { return this.low.z; }
    get right() { return this.high.x; }
    get top() { return this.high.y; }
    get back() { return this.high.z; }
    get width() { return this.xLength(); }
    get depth() { return this.yLength(); }
    get height() { return this.zLength(); }
    isValid() {
        const max = geometry_core_1.Constant.circumferenceOfEarth;
        const lo = this.low;
        const hi = this.high;
        return !this.isNull() && lo.x > -max && lo.y > -max && lo.z > -max && hi.x < max && hi.y < max && hi.z < max;
    }
    static fromJSON(json) {
        const val = new ElementAlignedBox3d();
        if (json)
            val.setFromJSON(json);
        return val;
    }
}
exports.ElementAlignedBox3d = ElementAlignedBox3d;
/** A bounding box aligned to the orientation of a 2d Element */
class ElementAlignedBox2d extends geometry_core_1.Range2d {
    static createFromPoints(low, high) { return new ElementAlignedBox2d(low.x, low.y, high.x, high.y); }
    get left() { return this.low.x; }
    get bottom() { return this.low.y; }
    get right() { return this.high.x; }
    get top() { return this.high.y; }
    get width() { return this.xLength(); }
    get height() { return this.yLength(); }
    static fromJSON(json) {
        const val = new ElementAlignedBox2d();
        if (json)
            val.setFromJSON(json);
        return val;
    }
    isValid() {
        const max = geometry_core_1.Constant.circumferenceOfEarth;
        const lo = this.low;
        const hi = this.high;
        return !this.isNull() && lo.x > -max && lo.y > -max && hi.x < max && hi.y < max;
    }
}
exports.ElementAlignedBox2d = ElementAlignedBox2d;
/**
 * The placement of a GeometricElement3d. This includes the origin, orientation, and size (bounding box) of the element.
 * All geometry of a GeometricElement are relative to its placement.
 */
class Placement3d {
    constructor(origin, angles, bbox) {
        this.origin = origin;
        this.angles = angles;
        this.bbox = bbox;
    }
    getTransform() { return geometry_core_1.Transform.createOriginAndMatrix(this.origin, this.angles.toRotMatrix()); }
    static fromJSON(json) {
        json = json ? json : {};
        return new Placement3d(geometry_core_1.Point3d.fromJSON(json.origin), geometry_core_1.YawPitchRollAngles.fromJSON(json.angles), ElementAlignedBox3d.fromJSON(json.bbox));
    }
    setFrom(other) {
        this.origin.setFrom(other.origin);
        this.angles.setFrom(other.angles);
        this.bbox.setFrom(other.bbox);
    }
    /** Determine whether this Placement3d is valid. */
    isValid() { return this.bbox.isValid() && this.origin.maxAbs() < geometry_core_1.Constant.circumferenceOfEarth; }
    calculateRange() {
        const range = new AxisAlignedBox3d();
        if (!this.isValid())
            return range;
        this.getTransform().multiplyRange(this.bbox, range);
        // low and high are not allowed to be equal
        range.ensureMinLengths();
        return range;
    }
}
exports.Placement3d = Placement3d;
/** The placement of a GeometricElement2d. This includes the origin, rotation, and size (bounding box) of the element. */
class Placement2d {
    constructor(origin, angle, bbox) {
        this.origin = origin;
        this.angle = angle;
        this.bbox = bbox;
    }
    getTransform() { return geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createFrom(this.origin), geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), this.angle)); }
    static fromJSON(json) {
        json = json ? json : {};
        return new Placement2d(geometry_core_1.Point2d.fromJSON(json.origin), geometry_core_1.Angle.fromJSON(json.angle), ElementAlignedBox2d.fromJSON(json.bbox));
    }
    /** Determine whether this Placement2d is valid. */
    isValid() { return this.bbox.isValid() && this.origin.maxAbs() < geometry_core_1.Constant.circumferenceOfEarth; }
    setFrom(other) {
        this.origin.setFrom(other.origin);
        this.angle.setFrom(other.angle);
        this.bbox.setFrom(other.bbox);
    }
    calculateRange() {
        const range = new AxisAlignedBox3d();
        if (!this.isValid())
            return range;
        this.getTransform().multiplyRange(geometry_core_1.Range3d.createRange2d(this.bbox, 0), range);
        // low and high are not allowed to be equal
        range.ensureMinLengths();
        range.low.z = -1.0; // is the 2dFrustumDepth, which === 1 meter
        range.high.z = 1.0;
        return range;
    }
}
exports.Placement2d = Placement2d;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelError_1 = __webpack_require__(16);
const bentleyjs_core_1 = __webpack_require__(0);
const RpcOperation_1 = __webpack_require__(71);
const RpcRegistry_1 = __webpack_require__(33);
const RpcRequest_1 = __webpack_require__(42);
const RpcProtocol_1 = __webpack_require__(28);
const RpcConfiguration_1 = __webpack_require__(52);
const RpcMarshaling_1 = __webpack_require__(118);
const RpcControl_1 = __webpack_require__(59);
/** An RPC operation invocation in response to a request. */
class RpcInvocation {
    /** Constructs an invocation. */
    constructor(protocol, request) {
        this._threw = false;
        this._pending = false;
        this._notFound = false;
        this._timeIn = 0;
        this._timeOut = 0;
        /** The operation of the request. */
        this.operation = undefined;
        this._timeIn = new Date().getTime();
        this.protocol = protocol;
        this.request = request;
        try {
            try {
                this.operation = RpcOperation_1.RpcOperation.lookup(this.request.operation.interfaceDefinition, this.request.operation.operationName);
            }
            catch (error) {
                if (this.handleUnknownOperation(error)) {
                    this.operation = RpcOperation_1.RpcOperation.lookup(this.request.operation.interfaceDefinition, this.request.operation.operationName);
                }
                else {
                    throw error;
                }
            }
            this.operation.policy.invocationCallback(this);
            protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.RequestReceived, this);
            this.result = this.resolve();
        }
        catch (error) {
            this.result = this.reject(error);
        }
        this.fulfillment = this.result.then((value) => this.fulfillResolved(value), (reason) => this.fulfillRejected(reason));
    }
    /** The status for this request. */
    get status() {
        if (this._threw) {
            return RpcRequest_1.RpcRequestStatus.Rejected;
        }
        else {
            if (this._pending)
                return RpcRequest_1.RpcRequestStatus.Pending;
            else if (this._notFound)
                return RpcRequest_1.RpcRequestStatus.NotFound;
            else
                return RpcRequest_1.RpcRequestStatus.Resolved;
        }
    }
    /** The elapsed time for this invocation. */
    get elapsed() {
        return this._timeOut - this._timeIn;
    }
    /**
     * The invocation for the current RPC operation.
     * @note The return value of this function is only reliable in an RPC interface class member function where program control was received from the RpcInvocation constructor function.
     */
    static current(context) {
        return context[RpcRegistry_1.CURRENT_INVOCATION];
    }
    handleUnknownOperation(error) {
        return this.protocol.configuration.controlChannel.handleUnknownOperation(this, error);
    }
    resolve() {
        const parameters = RpcMarshaling_1.RpcMarshaling.deserialize(this.operation, this.protocol, this.request.parameters);
        const impl = RpcRegistry_1.RpcRegistry.instance.getImplForInterface(this.operation.interfaceDefinition);
        const op = this.lookupOperationFunction(impl);
        impl[RpcRegistry_1.CURRENT_INVOCATION] = this;
        return Promise.resolve(op.call(impl, ...parameters));
    }
    reject(error) {
        this._threw = true;
        this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendErrorOccurred, this);
        return Promise.reject(error);
    }
    fulfillResolved(value) {
        this._timeOut = new Date().getTime();
        this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendResponseCreated, this);
        const result = RpcMarshaling_1.RpcMarshaling.serialize(this.operation, this.protocol, value);
        return this.fulfill(result);
    }
    fulfillRejected(reason) {
        this._timeOut = new Date().getTime();
        if (!RpcConfiguration_1.RpcConfiguration.developmentMode)
            reason.stack = undefined;
        let result = RpcMarshaling_1.RpcMarshaling.serialize(this.operation, this.protocol, reason);
        if (reason instanceof RpcControl_1.RpcPendingResponse) {
            this._pending = true;
            result = reason.message;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendReportedPending, this);
        }
        else if (reason instanceof RpcControl_1.RpcNotFoundResponse) {
            this._notFound = true;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendReportedNotFound, this);
        }
        else {
            this._threw = true;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.BackendErrorOccurred, this);
        }
        return this.fulfill(result);
    }
    fulfill(result) {
        const fulfillment = {
            result,
            status: this.protocol.getCode(this.status),
            id: this.request.id,
            interfaceName: this.operation.interfaceDefinition.name,
        };
        return fulfillment;
    }
    lookupOperationFunction(implementation) {
        const func = implementation[this.operation.operationName];
        if (!func || typeof (func) !== "function") {
            throw new IModelError_1.IModelError(32768 /* ERROR */, `RPC interface class "${implementation.constructor.name}" does not implement operation "${this.operation.operationName}".`, bentleyjs_core_1.Logger.logError, "imodeljs-backend.RpcInterface");
        }
        return func;
    }
}
exports.RpcInvocation = RpcInvocation;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-string-literal
const RpcRegistry_1 = __webpack_require__(33);
const RpcConfiguration_1 = __webpack_require__(52);
let marshalingScope = "";
/** RPC interface type marshaling directives. */
var RpcMarshalingDirective;
(function (RpcMarshalingDirective) {
    RpcMarshalingDirective["Name"] = "__name__";
    RpcMarshalingDirective["JSON"] = "__JSON__";
    RpcMarshalingDirective["Undefined"] = "__undefined__";
    RpcMarshalingDirective["Map"] = "__map__";
    RpcMarshalingDirective["Set"] = "__set__";
    RpcMarshalingDirective["Unregistered"] = "__unregistered__";
    RpcMarshalingDirective["Error"] = "__error__";
    RpcMarshalingDirective["ErrorName"] = "__error_name__";
    RpcMarshalingDirective["ErrorMessage"] = "__error_message__";
    RpcMarshalingDirective["ErrorStack"] = "__error_stack__";
})(RpcMarshalingDirective = exports.RpcMarshalingDirective || (exports.RpcMarshalingDirective = {}));
/** @hidden @internal */
class RpcMarshaling {
    constructor() { }
    /** Serializes a value. */
    static serialize(operation, _protocol, value) {
        if (typeof (value) === "undefined") {
            return "";
        }
        marshalingScope = operation.interfaceDefinition.name;
        return JSON.stringify(value, RpcMarshaling.marshal);
    }
    /** Deserializes a value. */
    static deserialize(_operation, _protocol, value) {
        if (value === "") {
            return undefined;
        }
        return JSON.parse(value, RpcMarshaling.unmarshal);
    }
    /** JSON.stringify replacer callback that marshals JavaScript class instances. */
    static marshal(key, value) {
        if (key === RpcMarshalingDirective.Name || key === RpcMarshalingDirective.Undefined || key === RpcMarshalingDirective.Unregistered) {
            delete this[key];
        }
        let originalValue = value;
        let custom = false;
        if (this[key] !== value && (typeof (value) !== "object" || value === null || Array.isArray(value))) {
            custom = true;
            originalValue = this[key];
        }
        if (typeof (originalValue) === "object" && originalValue !== null && !Array.isArray(originalValue) && originalValue.constructor !== Object) {
            const name = `${marshalingScope}_${originalValue.constructor.name}`;
            const unregistered = !RpcRegistry_1.RpcRegistry.instance.types.has(name);
            if (custom) {
                return {
                    [RpcMarshalingDirective.Name]: name,
                    [RpcMarshalingDirective.JSON]: value,
                    [RpcMarshalingDirective.Unregistered]: unregistered,
                };
            }
            else {
                if (value instanceof Map) {
                    const elements = Array.from(value);
                    return {
                        [RpcMarshalingDirective.Name]: name,
                        [RpcMarshalingDirective.Map]: elements,
                        [RpcMarshalingDirective.Unregistered]: unregistered,
                    };
                }
                else if (value instanceof Set) {
                    const elements = Array.from(value);
                    return {
                        [RpcMarshalingDirective.Name]: name,
                        [RpcMarshalingDirective.Set]: elements,
                        [RpcMarshalingDirective.Unregistered]: unregistered,
                    };
                }
                else {
                    value[RpcMarshalingDirective.Name] = name;
                    value[RpcMarshalingDirective.Unregistered] = unregistered;
                    if (value instanceof Error) {
                        value[RpcMarshalingDirective.Error] = true;
                        const errorName = value.name;
                        value.name = "";
                        const errorMessage = value.message;
                        value.message = "[Backend to Frontend Transition]";
                        let stack = value.stack;
                        if (typeof (stack) === "undefined")
                            stack = "[Backend to Frontend Transition]\n[Backend Implementation]";
                        value[RpcMarshalingDirective.ErrorStack] = stack;
                        value.message = errorMessage;
                        value[RpcMarshalingDirective.ErrorMessage] = value.message;
                        value.name = errorName;
                        value[RpcMarshalingDirective.ErrorName] = value.name;
                    }
                    const undefineds = [];
                    for (const prop in value) {
                        if (value.hasOwnProperty(prop) && value[prop] === undefined)
                            undefineds.push(prop);
                    }
                    if (undefineds.length)
                        value[RpcMarshalingDirective.Undefined] = undefineds;
                }
            }
        }
        return value;
    }
    /** JSON.parse reviver callback that unmarshals JavaScript class instances. */
    static unmarshal(_key, value) {
        if (typeof (value) === "object" && value !== null && value[RpcMarshalingDirective.Name]) {
            const name = value[RpcMarshalingDirective.Name];
            delete value[RpcMarshalingDirective.Name];
            if (RpcConfiguration_1.RpcConfiguration.strictMode && value[RpcMarshalingDirective.Unregistered]) {
                const [className, typeName] = name.split("_", 2);
                throw new Error(`Cannot unmarshal type "${typeName} for this RPC interface. Ensure this type is listed in ${className}.types or suppress using RpcConfiguration.strictMode.`);
            }
            delete value[RpcMarshalingDirective.Unregistered];
            const type = RpcRegistry_1.RpcRegistry.instance.types.get(name);
            const customJSON = value[RpcMarshalingDirective.JSON];
            if (customJSON) {
                if (type) {
                    const typeFromJSON = type.fromJSON;
                    if (typeFromJSON)
                        return typeFromJSON(customJSON);
                    else
                        return new type(customJSON);
                }
                else {
                    return customJSON;
                }
            }
            else {
                const mapInit = value[RpcMarshalingDirective.Map];
                const setInit = value[RpcMarshalingDirective.Set];
                if (mapInit) {
                    return new Map(mapInit);
                }
                else if (setInit) {
                    return new Set(setInit);
                }
                else {
                    const undefineds = value[RpcMarshalingDirective.Undefined];
                    if (undefineds)
                        delete value[RpcMarshalingDirective.Undefined];
                    const isError = value[RpcMarshalingDirective.Error];
                    delete value[RpcMarshalingDirective.Error];
                    const errorName = value[RpcMarshalingDirective.ErrorName];
                    delete value[RpcMarshalingDirective.ErrorName];
                    const errorMessage = value[RpcMarshalingDirective.ErrorMessage];
                    delete value[RpcMarshalingDirective.ErrorMessage];
                    const errorStack = value[RpcMarshalingDirective.ErrorStack];
                    delete value[RpcMarshalingDirective.ErrorStack];
                    const descriptors = {};
                    const props = Object.keys(value);
                    for (const prop of props)
                        descriptors[prop] = Object.getOwnPropertyDescriptor(value, prop);
                    if (isError) {
                        if (!descriptors.hasOwnProperty("name")) {
                            descriptors["name"] = { configurable: true, enumerable: true, writable: true, value: errorName };
                        }
                        if (!descriptors.hasOwnProperty("message")) {
                            descriptors["message"] = { configurable: true, enumerable: true, writable: true, value: errorMessage };
                        }
                        if (!descriptors.hasOwnProperty("stack")) {
                            descriptors["stack"] = { configurable: true, enumerable: true, writable: true, value: errorStack };
                        }
                    }
                    if (undefineds) {
                        for (const prop of undefineds)
                            descriptors[prop] = { configurable: true, enumerable: true, writable: true, value: undefined };
                    }
                    return Object.create(type ? type.prototype : Object.prototype, descriptors);
                }
            }
        }
        return value;
    }
}
exports.RpcMarshaling = RpcMarshaling;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ColorDef_1 = __webpack_require__(58);
const IModel_1 = __webpack_require__(34);
const geometry_core_1 = __webpack_require__(1);
const Image_1 = __webpack_require__(195);
var FillFlags;
(function (FillFlags) {
    FillFlags[FillFlags["None"] = 0] = "None";
    FillFlags[FillFlags["ByView"] = 1] = "ByView";
    FillFlags[FillFlags["Always"] = 2] = "Always";
    FillFlags[FillFlags["Behind"] = 4] = "Behind";
    FillFlags[FillFlags["Blanking"] = 6] = "Blanking";
    FillFlags[FillFlags["Background"] = 8] = "Background";
})(FillFlags = exports.FillFlags || (exports.FillFlags = {}));
var PolylineTypeFlags;
(function (PolylineTypeFlags) {
    PolylineTypeFlags[PolylineTypeFlags["Normal"] = 0] = "Normal";
    PolylineTypeFlags[PolylineTypeFlags["Edge"] = 1] = "Edge";
    PolylineTypeFlags[PolylineTypeFlags["Outline"] = 2] = "Outline";
})(PolylineTypeFlags = exports.PolylineTypeFlags || (exports.PolylineTypeFlags = {}));
/** Flags describing a polyline. A polyline may represent a continuous line string, or a set of discrete points. */
class PolylineFlags {
    constructor(is2d = false, isPlanar = false, isDisjoint = false, type = PolylineTypeFlags.Normal) {
        this.isDisjoint = isDisjoint;
        this.isPlanar = isPlanar;
        this.is2d = is2d;
        this.type = type;
    }
    /** Create a PolylineFlags from a serialized numeric representation. */
    static unpack(value) {
        const isDisjoint = 0 !== (value & 1);
        const isPlanar = 0 !== (value & 2);
        const is2d = 0 !== (value & 4);
        const type = (value >> 3);
        bentleyjs_core_1.assert(type === PolylineTypeFlags.Normal || type === PolylineTypeFlags.Edge || type === PolylineTypeFlags.Outline);
        return new PolylineFlags(is2d, isPlanar, isDisjoint, type);
    }
    initDefaults() {
        this.isDisjoint = this.isPlanar = this.is2d = false;
        this.type = PolylineTypeFlags.Normal;
    }
    get isOutlineEdge() { return PolylineTypeFlags.Outline === this.type; }
    get isNormalEdge() { return PolylineTypeFlags.Edge === this.type; }
    get isAnyEdge() { return PolylineTypeFlags.Normal !== this.type; }
    setIsNormalEdge() { this.type = PolylineTypeFlags.Edge; }
    setIsOutlineEdge() { this.type = PolylineTypeFlags.Outline; }
    /** Convert these flags to a numeric representation for serialization. */
    pack() {
        let val = 0;
        if (this.isDisjoint)
            val += 1;
        if (this.isPlanar)
            val += 1 << 1;
        if (this.is2d)
            val += 1 << 2;
        val += this.type << 3;
        return val;
    }
    equals(other) {
        return this.type === other.type && this.is2d === other.is2d && this.isPlanar === other.isPlanar && this.isDisjoint === other.isDisjoint;
    }
}
exports.PolylineFlags = PolylineFlags;
/* An individual polyline which indexes into a shared set of vertices */
class PolylineData {
    constructor(vertIndices = [], numIndices = 0, startDistance = 0) {
        this.vertIndices = vertIndices;
        this.numIndices = numIndices;
        this.startDistance = startDistance;
    }
    isValid() { return 0 < this.numIndices; }
    reset() { this.numIndices = 0; this.vertIndices = []; this.startDistance = 0; }
    init(polyline) {
        this.numIndices = polyline.indices.length;
        this.vertIndices = 0 < this.numIndices ? polyline.indices : [];
        this.startDistance = polyline.startDistance;
        return this.isValid();
    }
}
exports.PolylineData = PolylineData;
class MeshPolyline {
    constructor(startDistance = 0, indices = []) {
        this.indices = indices.slice();
        this.startDistance = startDistance;
    }
    addIndex(index) {
        const { indices } = this;
        if (indices.length === 0 || indices[indices.length - 1] !== index)
            indices.push(index);
    }
    clear() { this.indices.length = 0; }
}
exports.MeshPolyline = MeshPolyline;
class MeshPolylineList extends Array {
    constructor(...args) { super(...args); }
}
exports.MeshPolylineList = MeshPolylineList;
class MeshEdge {
    constructor(index0, index1) {
        this.indices = [0, 0];
        if (undefined === index0 || undefined === index1) {
            return;
        }
        if (index0 < index1) {
            this.indices[0] = index0;
            this.indices[1] = index1;
        }
        else {
            this.indices[0] = index1;
            this.indices[1] = index0;
        }
    }
}
exports.MeshEdge = MeshEdge;
class MeshEdges {
    constructor() {
        this.visible = [];
        this.silhouette = [];
        this.polylines = new MeshPolylineList();
        this.silhouetteNormals = [];
    }
}
exports.MeshEdges = MeshEdges;
class EdgeArgs {
    init(meshEdges) {
        this.clear();
        if (undefined !== meshEdges && 0 < meshEdges.visible.length)
            this.edges = meshEdges.visible;
        return this.isValid;
    }
    clear() { this.edges = undefined; }
    get isValid() { return 0 < this.numEdges; }
    get numEdges() { return undefined !== this.edges ? this.edges.length : 0; }
}
exports.EdgeArgs = EdgeArgs;
class SilhouetteEdgeArgs extends EdgeArgs {
    init(meshEdges) {
        this.clear();
        if (undefined !== meshEdges && 0 < meshEdges.silhouette.length) {
            this.edges = meshEdges.silhouette;
            this.normals = meshEdges.silhouetteNormals;
        }
        return this.isValid;
    }
    clear() { this.normals = undefined; super.clear(); }
}
exports.SilhouetteEdgeArgs = SilhouetteEdgeArgs;
class PolylineEdgeArgs {
    constructor(lines) { this.init(lines); }
    init(lines) {
        this.lines = undefined !== lines && 0 < lines.length ? lines : undefined;
        return this.isValid;
    }
    get numLines() { return undefined !== this.lines ? this.lines.length : 0; }
    get isValid() { return this.numLines > 0; }
    clear() { this.lines = undefined; }
}
exports.PolylineEdgeArgs = PolylineEdgeArgs;
/** A Texture for rendering */
class RenderTexture {
    get isTileSection() { return 2 /* TileSection */ === this.type; }
    get isGlyph() { return 1 /* Glyph */ === this.type; }
    get isSkyBox() { return 3 /* SkyBox */ === this.type; }
    constructor(params) {
        this.key = params.key;
        this.type = params.type;
    }
}
exports.RenderTexture = RenderTexture;
(function (RenderTexture) {
    class Params {
        constructor(key, type = 0 /* Normal */) {
            this.type = 0 /* Normal */;
            this.key = key;
            this.type = type;
        }
        get isTileSection() { return 2 /* TileSection */ === this.type; }
        get isGlyph() { return 1 /* Glyph */ === this.type; }
        get isSkyBox() { return 3 /* SkyBox */ === this.type; }
    }
    /** Obtain a RenderTexture params object with default values. */
    Params.defaults = new Params();
    RenderTexture.Params = Params;
})(RenderTexture = exports.RenderTexture || (exports.RenderTexture = {}));
/** A Material for rendering */
class RenderMaterial {
    constructor(params) {
        this.key = params.key;
        this.textureMapping = params.textureMapping;
    }
    get hasTexture() { return this.textureMapping !== undefined && this.textureMapping.texture !== undefined; }
}
exports.RenderMaterial = RenderMaterial;
(function (RenderMaterial) {
    class Params {
        constructor(key) {
            this.diffuse = 0.6;
            this.specular = .4;
            this.specularExponent = 13.5;
            this.reflect = 0.0;
            this.transparency = 0.0;
            this.refract = 1.0;
            this.ambient = .3;
            this.shadows = true;
            this.key = key;
        }
        /** Create a RenderMaterial params object using specified key and ColorDef values, as well as an optional texture mapping. */
        static fromColors(key, diffuseColor, specularColor, emissiveColor, reflectColor, textureMap) {
            const materialParams = new Params();
            materialParams.key = key;
            materialParams.diffuseColor = diffuseColor;
            materialParams.specularColor = specularColor;
            materialParams.emissiveColor = emissiveColor;
            materialParams.reflectColor = reflectColor;
            materialParams.textureMapping = textureMap;
            return materialParams;
        }
    }
    /** Create a RenderMaterial params object with QVision default values. */
    Params.defaults = new Params();
    RenderMaterial.Params = Params;
})(RenderMaterial = exports.RenderMaterial || (exports.RenderMaterial = {}));
Object.freeze(RenderMaterial.Params.defaults);
var ImageLight;
(function (ImageLight) {
    class Solar {
        constructor(direction = new geometry_core_1.Vector3d(), color = ColorDef_1.ColorDef.white, intensity = 0) {
            this.direction = direction;
            this.color = color;
            this.intensity = intensity;
        }
    }
    ImageLight.Solar = Solar;
})(ImageLight = exports.ImageLight || (exports.ImageLight = {}));
/**
 * The "cooked" material and symbology for a RenderGraphic. This determines the appearance
 * (e.g. texture, color, width, linestyle, etc.) used to draw Geometry.
 */
class GraphicParams {
    constructor() {
        this.fillFlags = FillFlags.None;
        this.linePixels = 0 /* Solid */;
        this.rasterWidth = 1;
        this.lineColor = new ColorDef_1.ColorDef();
        this.fillColor = new ColorDef_1.ColorDef();
        this.trueWidthStart = 0;
        this.trueWidthEnd = 0;
    }
    // void Cook(GeometryParamsCR, ViewContextR);
    // void Init() {* this = GraphicParams(); }
    // Compare two GraphicParams.
    // DGNPLATFORM_EXPORT bool operator == (GraphicParamsCR rhs) const ;
    // copy operator
    // DGNPLATFORM_EXPORT GraphicParamsR operator = (GraphicParamsCR rhs);
    /** set the line color
     *  @param lineColor the new line color for this GraphicParams.
     */
    setLineColor(lineColor) { this.lineColor.setFrom(lineColor); }
    setLineTransparency(transparency) { this.lineColor.setAlpha(transparency); }
    /**
     * Set the current fill color for this GraphicParams.
     * @param fillColor the new fill color for this GraphicParams.
     */
    setFillColor(fillColor) { this.fillColor.setFrom(fillColor); }
    setFillTransparency(transparency) { this.fillColor.setAlpha(transparency); }
    /** Set the linear pixel pattern for this GraphicParams. This is only valid for overlay decorators in pixel mode. */
    setLinePixels(code) { this.linePixels = code; this.lineTexture = undefined; }
    static fromSymbology(lineColor, fillColor, lineWidth, linePixels = 0 /* Solid */) {
        const graphicParams = new GraphicParams();
        graphicParams.setLineColor(lineColor);
        graphicParams.setFillColor(fillColor);
        graphicParams.rasterWidth = lineWidth;
        graphicParams.setLinePixels(linePixels);
        return graphicParams;
    }
    static fromBlankingFill(fillColor) {
        const graphicParams = new GraphicParams();
        graphicParams.setFillColor(fillColor);
        graphicParams.fillFlags = FillFlags.Blanking;
        return graphicParams;
    }
}
exports.GraphicParams = GraphicParams;
/**
 * The current position (eyepoint), lens angle, and focus distance of a camera.
 */
class Camera {
    static isValidLensAngle(val) { return val.radians > (Math.PI / 8.0) && val.radians < Math.PI; }
    static validateLensAngle(val) { if (!this.isValidLensAngle(val))
        val.setRadians(Math.PI / 2.0); }
    invalidateFocus() { this.focusDist = 0.0; }
    isFocusValid() { return this.focusDist > 0.0 && this.focusDist < 1.0e14; }
    getFocusDistance() { return this.focusDist; }
    setFocusDistance(dist) { this.focusDist = dist; }
    isLensValid() { return Camera.isValidLensAngle(this.lens); }
    validateLens() { Camera.validateLensAngle(this.lens); }
    getLensAngle() { return this.lens; }
    setLensAngle(angle) { this.lens.setFrom(angle); }
    getEyePoint() { return this.eye; }
    setEyePoint(pt) { this.eye.setFrom(pt); }
    isValid() { return this.isLensValid() && this.isFocusValid(); }
    equals(other) { return this.lens === other.lens && this.focusDist === other.focusDist && this.eye.isExactEqual(other.eye); }
    clone() { return new Camera(this); }
    copyFrom(rhs) {
        this.lens.setFrom(rhs.lens);
        this.focusDist = rhs.focusDist;
        this.eye.setFrom(rhs.eye);
    }
    constructor(json) {
        this.lens = geometry_core_1.Angle.fromJSON(json.lens);
        this.focusDist = bentleyjs_core_1.JsonUtils.asDouble(json.focusDist);
        this.eye = geometry_core_1.Point3d.fromJSON(json.eye);
    }
}
exports.Camera = Camera;
/** Flags for view display style */
class ViewFlags {
    constructor() {
        this.renderMode = 0 /* Wireframe */;
        this.dimensions = true; // Shows or hides dimensions.
        this.patterns = true; // Shows or hides pattern geometry.
        this.weights = true; // Controls whether non-zero line weights are used or display using weight 0.
        this.styles = true; // Controls whether custom line styles are used (e.g. control whether elements with custom line styles draw normally, or as solid lines).
        this.transparency = true; // Controls whether element transparency is used (e.g. control whether elements with transparency draw normally, or as opaque).
        this.continuousRendering = false; // Controls whether continuous rendering is used.
        this.fill = true; // Controls whether the fills on filled elements are displayed.
        this.textures = true; // Controls whether to display texture maps for material assignments. When off only material color is used for display.
        this.materials = true; // Controls whether materials are used (e.g. control whether geometry with materials draw normally, or as if it has no material).
        this.acsTriad = false; // Shows or hides the ACS triad.
        this.grid = false; // Shows or hides the grid. The grid settings are a design file setting.
        this.visibleEdges = false; // Shows or hides visible edges in the shaded render mode.
        this.hiddenEdges = false; // Shows or hides hidden edges in the shaded render mode.
        this.sourceLights = false; // Controls whether the source lights in spatial models are used
        this.cameraLights = false; // Controls whether camera (ambient, portrait, flashbulb) lights are used.
        this.solarLight = false; // Controls whether sunlight used
        this.shadows = false; // Shows or hides shadows.
        this.noClipVolume = false; // Controls whether the clip volume is applied.
        this.constructions = false; // Shows or hides construction class geometry.
        this.monochrome = false; // draw all graphics in a single color
        this.noGeometryMap = false; // ignore geometry maps
        this.hLineMaterialColors = false; // use material colors for hidden lines
        this.edgeMask = 0; // 0=none, 1=generate mask, 2=use mask
    }
    clone(out) { return ViewFlags.createFrom(this, out); }
    static createFrom(other, out) {
        const val = undefined !== out ? out : new ViewFlags();
        if (other) {
            val.renderMode = other.renderMode;
            val.dimensions = other.dimensions;
            val.patterns = other.patterns;
            val.weights = other.weights;
            val.styles = other.styles;
            val.transparency = other.transparency;
            val.continuousRendering = other.continuousRendering;
            val.fill = other.fill;
            val.textures = other.textures;
            val.materials = other.materials;
            val.acsTriad = other.acsTriad;
            val.grid = other.grid;
            val.visibleEdges = other.visibleEdges;
            val.hiddenEdges = other.hiddenEdges;
            val.sourceLights = other.sourceLights;
            val.cameraLights = other.cameraLights;
            val.solarLight = other.solarLight;
            val.shadows = other.shadows;
            val.noClipVolume = other.noClipVolume;
            val.constructions = other.constructions;
            val.monochrome = other.monochrome;
            val.noGeometryMap = other.noGeometryMap;
            val.hLineMaterialColors = other.hLineMaterialColors;
            val.edgeMask = other.edgeMask;
        }
        return val;
    }
    hiddenEdgesVisible() {
        switch (this.renderMode) {
            case 4 /* SolidFill */:
            case 3 /* HiddenLine */:
                return this.hiddenEdges;
            case 6 /* SmoothShade */:
                return this.visibleEdges && this.hiddenEdges;
        }
        return true;
    }
    toJSON() {
        const out = {};
        if (!this.constructions)
            out.noConstruct = true;
        if (!this.dimensions)
            out.noDim = true;
        if (!this.patterns)
            out.noPattern = true;
        if (!this.weights)
            out.noWeight = true;
        if (!this.styles)
            out.noStyle = true;
        if (!this.transparency)
            out.noTransp = true;
        if (this.continuousRendering)
            out.contRend = true;
        if (!this.fill)
            out.noFill = true;
        if (this.grid)
            out.grid = true;
        if (this.acsTriad)
            out.acs = true;
        if (!this.textures)
            out.noTexture = true;
        if (!this.materials)
            out.noMaterial = true;
        if (!this.cameraLights)
            out.noCameraLights = true;
        if (!this.sourceLights)
            out.noSourceLights = true;
        if (!this.solarLight)
            out.noSolarLight = true;
        if (this.visibleEdges)
            out.visEdges = true;
        if (this.hiddenEdges)
            out.hidEdges = true;
        if (this.shadows)
            out.shadows = true;
        if (!this.noClipVolume)
            out.clipVol = true;
        if (this.hLineMaterialColors)
            out.hlMatColors = true;
        if (this.monochrome)
            out.monochrome = true;
        if (this.edgeMask !== 0)
            out.edgeMask = this.edgeMask;
        out.renderMode = this.renderMode;
        return out;
    }
    static fromJSON(json) {
        const val = new ViewFlags();
        if (!json)
            return val;
        val.constructions = !bentleyjs_core_1.JsonUtils.asBool(json.noConstruct);
        val.dimensions = !bentleyjs_core_1.JsonUtils.asBool(json.noDim);
        val.patterns = !bentleyjs_core_1.JsonUtils.asBool(json.noPattern);
        val.weights = !bentleyjs_core_1.JsonUtils.asBool(json.noWeight);
        val.styles = !bentleyjs_core_1.JsonUtils.asBool(json.noStyle);
        val.transparency = !bentleyjs_core_1.JsonUtils.asBool(json.noTransp);
        val.continuousRendering = bentleyjs_core_1.JsonUtils.asBool(json.contRend);
        val.fill = !bentleyjs_core_1.JsonUtils.asBool(json.noFill);
        val.grid = bentleyjs_core_1.JsonUtils.asBool(json.grid);
        val.acsTriad = bentleyjs_core_1.JsonUtils.asBool(json.acs);
        val.textures = !bentleyjs_core_1.JsonUtils.asBool(json.noTexture);
        val.materials = !bentleyjs_core_1.JsonUtils.asBool(json.noMaterial);
        val.cameraLights = !bentleyjs_core_1.JsonUtils.asBool(json.noCameraLights);
        val.sourceLights = !bentleyjs_core_1.JsonUtils.asBool(json.noSourceLights);
        val.solarLight = !bentleyjs_core_1.JsonUtils.asBool(json.noSolarLight);
        val.visibleEdges = bentleyjs_core_1.JsonUtils.asBool(json.visEdges);
        val.hiddenEdges = bentleyjs_core_1.JsonUtils.asBool(json.hidEdges);
        val.shadows = bentleyjs_core_1.JsonUtils.asBool(json.shadows);
        val.noClipVolume = !bentleyjs_core_1.JsonUtils.asBool(json.clipVol);
        val.monochrome = bentleyjs_core_1.JsonUtils.asBool(json.monochrome);
        val.edgeMask = bentleyjs_core_1.JsonUtils.asInt(json.edgeMask);
        val.hLineMaterialColors = bentleyjs_core_1.JsonUtils.asBool(json.hlMatColors);
        const renderModeValue = bentleyjs_core_1.JsonUtils.asInt(json.renderMode);
        if (renderModeValue < 3 /* HiddenLine */)
            val.renderMode = 0 /* Wireframe */;
        else if (renderModeValue > 4 /* SolidFill */)
            val.renderMode = 6 /* SmoothShade */;
        else
            val.renderMode = renderModeValue;
        return val;
    }
    isEqualTo(other) {
        return this.renderMode === other.renderMode
            && this.dimensions === other.dimensions
            && this.patterns === other.patterns
            && this.weights === other.weights
            && this.styles === other.styles
            && this.transparency === other.transparency
            && this.continuousRendering === other.continuousRendering
            && this.fill === other.fill
            && this.textures === other.textures
            && this.materials === other.materials
            && this.acsTriad === other.acsTriad
            && this.grid === other.grid
            && this.visibleEdges === other.visibleEdges
            && this.hiddenEdges === other.hiddenEdges
            && this.sourceLights === other.sourceLights
            && this.cameraLights === other.cameraLights
            && this.solarLight === other.solarLight
            && this.shadows === other.shadows
            && this.noClipVolume === other.noClipVolume
            && this.constructions === other.constructions
            && this.monochrome === other.monochrome
            && this.noGeometryMap === other.noGeometryMap
            && this.hLineMaterialColors === other.hLineMaterialColors
            && this.edgeMask === other.edgeMask;
    }
    showDimensions() { return this.dimensions; }
    ignoreGeometryMap() { return this.noGeometryMap; }
    isMonochrome() { return this.monochrome; }
    showAcsTriad() { return this.acsTriad; }
    showCameraLights() { return this.cameraLights; }
    showClipVolume() { return this.noClipVolume; }
    showConstructions() { return this.constructions; }
    showFill() { return this.fill; }
    showGrid() { return this.grid; }
    showHiddenEdges() { return this.hiddenEdges; }
    showMaterials() { return this.materials; }
    showPatterns() { return this.patterns; }
    showShadows() { return this.shadows; }
    showSolarLight() { return this.solarLight; }
    showSourceLights() { return this.sourceLights; }
    showStyles() { return this.styles; }
    showTextures() { return this.textures; }
    showTransparency() { return this.transparency; }
    showVisibleEdges() { return this.visibleEdges; }
    showWeights() { return this.weights; }
    useHlineMaterialColors() { return this.hLineMaterialColors; }
    getEdgeMask() { return this.edgeMask; }
    setEdgeMask(val) { this.edgeMask = val; }
    setIgnoreGeometryMap(val) { this.noGeometryMap = val; }
    setMonochrome(val) { this.monochrome = val; }
    setShowAcsTriad(val) { this.acsTriad = val; }
    setShowCameraLights(val) { this.cameraLights = val; }
    setShowClipVolume(val) { this.noClipVolume = !val; }
    setShowConstructions(val) { this.constructions = val; }
    setShowDimensions(val) { this.dimensions = val; }
    setShowFill(val) { this.fill = val; }
    setShowGrid(val) { this.grid = val; }
    setShowHiddenEdges(val) { this.hiddenEdges = val; }
    setShowMaterials(val) { this.materials = val; }
    setShowPatterns(val) { this.patterns = val; }
    setShowShadows(val) { this.shadows = val; }
    setShowSolarLight(val) { this.solarLight = val; }
    setShowSourceLights(val) { this.sourceLights = val; }
    setShowStyles(val) { this.styles = val; }
    setShowTextures(val) { this.textures = val; }
    setShowTransparency(val) { this.transparency = val; }
    setShowVisibleEdges(val) { this.visibleEdges = val; }
    setShowWeights(val) { this.weights = val; }
    setUseHlineMaterialColors(val) { this.hLineMaterialColors = val; }
    getRenderMode() { return this.renderMode; }
    setRenderMode(value) { this.renderMode = value; }
}
exports.ViewFlags = ViewFlags;
var ViewFlag;
(function (ViewFlag) {
    /**
     * Overrides a subset of ViewFlags.
     */
    class Overrides {
        /** Construct a ViewFlagsOverrides which overrides all flags to match the specified ViewFlags, or overrides nothing if no ViewFlags are supplied. */
        constructor(flags) {
            this.present = 0;
            this.values = new ViewFlags();
            if (undefined !== flags)
                this.overrideAll(flags);
        }
        setPresent(flag) { this.present |= (1 << flag); }
        isPresent(flag) { return 0 !== (this.present & (1 << flag)); }
        overrideAll(flags) {
            ViewFlags.createFrom(flags, this.values);
            this.present = 0xffffffff;
        }
        clone(out) {
            const result = undefined !== out ? out : new Overrides();
            result.copyFrom(this);
            return result;
        }
        copyFrom(other) {
            this.values.clone(other.values);
            this.present = other.present;
        }
        setShowDimensions(val) { this.values.setShowDimensions(val); this.setPresent(2 /* kDimensions */); }
        setShowPatterns(val) { this.values.setShowPatterns(val); this.setPresent(3 /* kPatterns */); }
        setShowWeights(val) { this.values.setShowWeights(val); this.setPresent(4 /* kWeights */); }
        setShowStyles(val) { this.values.setShowStyles(val); this.setPresent(5 /* kStyles */); }
        setShowTransparency(val) { this.values.setShowTransparency(val); this.setPresent(6 /* kTransparency */); }
        setShowFill(val) { this.values.setShowFill(val); this.setPresent(8 /* kFill */); }
        setShowTextures(val) { this.values.setShowTextures(val); this.setPresent(9 /* kTextures */); }
        setShowMaterials(val) { this.values.setShowMaterials(val); this.setPresent(10 /* kMaterials */); }
        setShowSourceLights(val) { this.values.setShowSourceLights(val); this.setPresent(13 /* kSourceLights */); }
        setShowCameraLights(val) { this.values.setShowCameraLights(val); this.setPresent(14 /* kCameraLights */); }
        setShowSolarLight(val) { this.values.setShowSolarLight(val); this.setPresent(15 /* kSolarLight */); }
        setShowVisibleEdges(val) { this.values.setShowVisibleEdges(val); this.setPresent(11 /* kVisibleEdges */); }
        setShowHiddenEdges(val) { this.values.setShowHiddenEdges(val); this.setPresent(12 /* kHiddenEdges */); }
        setShowShadows(val) { this.values.setShowShadows(val); this.setPresent(16 /* kShadows */); }
        setShowClipVolume(val) { this.values.setShowClipVolume(val); this.setPresent(17 /* kClipVolume */); }
        setShowConstructions(val) { this.values.setShowConstructions(val); this.setPresent(18 /* kConstructions */); }
        setMonochrome(val) { this.values.setMonochrome(val); this.setPresent(19 /* kMonochrome */); }
        setIgnoreGeometryMap(val) { this.values.setIgnoreGeometryMap(val); this.setPresent(20 /* kGeometryMap */); }
        setUseHlineMaterialColors(val) { this.values.setUseHlineMaterialColors(val); this.setPresent(21 /* kHlineMaterialColors */); }
        setEdgeMask(val) { this.values.setEdgeMask(val); this.setPresent(22 /* kEdgeMask */); }
        setRenderMode(val) { this.values.renderMode = val; this.setPresent(0 /* kRenderMode */); }
        anyOverridden() { return 0 !== this.present; }
        clear() { this.present = 0; }
        /** Apply these overrides to the supplied ViewFlags */
        apply(base) {
            if (!this.anyOverridden())
                return base;
            if (this.isPresent(2 /* kDimensions */))
                base.setShowDimensions(this.values.showDimensions());
            if (this.isPresent(3 /* kPatterns */))
                base.setShowPatterns(this.values.showPatterns());
            if (this.isPresent(4 /* kWeights */))
                base.setShowWeights(this.values.showWeights());
            if (this.isPresent(5 /* kStyles */))
                base.setShowStyles(this.values.showStyles());
            if (this.isPresent(6 /* kTransparency */))
                base.setShowTransparency(this.values.showTransparency());
            if (this.isPresent(8 /* kFill */))
                base.setShowFill(this.values.showFill());
            if (this.isPresent(9 /* kTextures */))
                base.setShowTextures(this.values.showTextures());
            if (this.isPresent(10 /* kMaterials */))
                base.setShowMaterials(this.values.showMaterials());
            if (this.isPresent(15 /* kSolarLight */))
                base.setShowSolarLight(this.values.showSolarLight());
            if (this.isPresent(14 /* kCameraLights */))
                base.setShowCameraLights(this.values.showCameraLights());
            if (this.isPresent(13 /* kSourceLights */))
                base.setShowSourceLights(this.values.showSourceLights());
            if (this.isPresent(11 /* kVisibleEdges */))
                base.setShowVisibleEdges(this.values.showVisibleEdges());
            if (this.isPresent(12 /* kHiddenEdges */))
                base.setShowHiddenEdges(this.values.showHiddenEdges());
            if (this.isPresent(16 /* kShadows */))
                base.setShowShadows(this.values.showShadows());
            if (this.isPresent(17 /* kClipVolume */))
                base.setShowClipVolume(this.values.showClipVolume());
            if (this.isPresent(18 /* kConstructions */))
                base.setShowConstructions(this.values.showConstructions());
            if (this.isPresent(19 /* kMonochrome */))
                base.setMonochrome(this.values.isMonochrome());
            if (this.isPresent(20 /* kGeometryMap */))
                base.setIgnoreGeometryMap(this.values.ignoreGeometryMap());
            if (this.isPresent(21 /* kHlineMaterialColors */))
                base.setUseHlineMaterialColors(this.values.useHlineMaterialColors());
            if (this.isPresent(22 /* kEdgeMask */))
                base.setEdgeMask(this.values.getEdgeMask());
            if (this.isPresent(0 /* kRenderMode */))
                base.setRenderMode(this.values.getRenderMode());
            return base;
        }
    }
    ViewFlag.Overrides = Overrides;
})(ViewFlag = exports.ViewFlag || (exports.ViewFlag = {}));
/** Represents a frustum as 6 planes and provides containment and intersection testing */
class FrustumPlanes {
    constructor(frustum) {
        if (undefined !== frustum) {
            this.init(frustum);
        }
    }
    get isValid() { return undefined !== this._planes; }
    init(frustum) {
        if (undefined === this._planes) {
            this._planes = [];
        }
        else {
            this._planes.length = 0;
        }
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 1, 3, 5); // right
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 0, 4, 2); // left
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 2, 6, 3); // top
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 0, 1, 4); // bottom
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 0, 2, 1); // back
        FrustumPlanes.addPlaneFromPoints(this._planes, frustum.points, 4, 5, 6); // front
    }
    computeFrustumContainment(box) { return this.computeContainment(box.points); }
    intersectsFrustum(box) { return 0 /* Outside */ !== this.computeFrustumContainment(box); }
    containsPoint(point, tolerance = 1.0e-8) { return 0 /* Outside */ !== this.computeContainment([point], tolerance); }
    computeContainment(points, tolerance = 1.0e-8) {
        bentleyjs_core_1.assert(this.isValid);
        if (undefined === this._planes) {
            return 0 /* Outside */;
        }
        let allInside = true;
        for (const plane of this._planes) {
            let nOutside = 0;
            for (const point of points) {
                if (plane.evaluatePoint(point) + tolerance < 0.0) {
                    ++nOutside;
                    allInside = false;
                }
            }
            if (nOutside === points.length) {
                return 0 /* Outside */;
            }
        }
        return allInside ? 2 /* Inside */ : 1 /* Partial */;
    }
    intersectsRay(origin, direction) {
        bentleyjs_core_1.assert(this.isValid);
        if (undefined === this._planes) {
            return false;
        }
        let tFar = 1e37;
        let tNear = -tFar;
        for (const plane of this._planes) {
            const vD = plane.dotProductVector(direction);
            const vN = plane.evaluatePoint(origin);
            if (0.0 === vD) {
                // ray is parallel... no need to continue testing if outside halfspace.
                if (vN < 0.0) {
                    return false;
                }
            }
            else {
                const rayDistance = -vN / vD;
                if (vD < 0.0) {
                    tFar = Math.min(rayDistance, tFar);
                }
                else {
                    tNear = Math.max(rayDistance, tNear);
                }
            }
        }
        return tNear <= tFar;
    }
}
exports.FrustumPlanes = FrustumPlanes;
(function (FrustumPlanes) {
    function addPlaneFromPoints(planes, points, i0, i1, i2, expandPlaneDistance = 1.0e-6) {
        const normal = geometry_core_1.Vector3d.createCrossProductToPoints(points[i2], points[i1], points[i0]);
        normal.normalizeInPlace();
        const plane = geometry_core_1.ClipPlane.createNormalAndDistance(normal, normal.dotProduct(points[i0]) - expandPlaneDistance);
        if (undefined !== plane) {
            planes.push(plane);
        }
    }
    FrustumPlanes.addPlaneFromPoints = addPlaneFromPoints;
})(FrustumPlanes = exports.FrustumPlanes || (exports.FrustumPlanes = {}));
/** parameters for displaying hidden lines */
var HiddenLine;
(function (HiddenLine) {
    class Style {
        constructor(json) {
            if (undefined !== json) {
                this.ovrColor = bentleyjs_core_1.JsonUtils.asBool(json.ovrColor);
                this.color = ColorDef_1.ColorDef.fromJSON(json.color);
                this.pattern = bentleyjs_core_1.JsonUtils.asInt(json.pattern, 0 /* Solid */);
                this.width = bentleyjs_core_1.JsonUtils.asInt(json.width);
            }
            else {
                this.ovrColor = false;
                this.color = new ColorDef_1.ColorDef(ColorDef_1.ColorByName.white);
                this.pattern = 0 /* Solid */;
                this.width = 0;
            }
        }
        equals(other) {
            return this.ovrColor === other.ovrColor && this.color === other.color && this.pattern === other.pattern && this.width === other.width;
        }
        clone(out) {
            const result = undefined !== out ? out : new Style({});
            result.copyFrom(this);
            return result;
        }
        copyFrom(other) {
            this.ovrColor = other.ovrColor;
            this.color.setFrom(other.color);
            this.pattern = other.pattern;
            this.width = other.width;
        }
    }
    HiddenLine.Style = Style;
    class Params {
        constructor(json) {
            this.transparencyThreshold = 1.0;
            this.visible = new HiddenLine.Style(undefined !== json && undefined !== json.visible ? json.visible : { ovrColor: false, color: new ColorDef_1.ColorDef(), width: 1, pattern: 0 /* Solid */ });
            this.hidden = new HiddenLine.Style(undefined !== json && undefined !== json.hidden ? json.hidden : { ovrColor: false, color: new ColorDef_1.ColorDef(), width: 1, pattern: 3435973836 /* HiddenLine */ });
            this.transparencyThreshold = undefined !== json ? bentleyjs_core_1.JsonUtils.asDouble(json.transThreshold, 1.0) : 1.0;
        }
        equals(other) { return this.visible === other.visible && this.hidden === other.hidden && this.transparencyThreshold === other.transparencyThreshold; }
    }
    HiddenLine.Params = Params;
})(HiddenLine = exports.HiddenLine || (exports.HiddenLine = {}));
var Gradient;
(function (Gradient) {
    /** @hidden Gradient settings specific to thematic mesh display */
    class ThematicProps {
        constructor() {
            this.mode = 0 /* Smooth */;
            this.stepCount = 10;
            this.margin = .05;
            this.marginColor = ColorDef_1.ColorDef.from(0x3f, 0x3f, 0x3f);
            this.colorScheme = 0 /* BlueRed */;
            this.rangeLow = Number.MAX_VALUE;
            this.rangeHigh = Number.MIN_VALUE;
        }
    }
    ThematicProps.defaults = new ThematicProps();
    Gradient.ThematicProps = ThematicProps;
    class KeyColor {
        constructor(json) {
            this.value = json.value;
            this.color = new ColorDef_1.ColorDef(json.color);
        }
    }
    Gradient.KeyColor = KeyColor;
    class Symb {
        constructor() {
            this.mode = 0 /* None */;
            this.flags = 0 /* None */;
            this.shift = 0;
            this.keys = [];
        }
        /** create a GradientSymb from a json object. */
        static fromJSON(json) {
            const result = new Symb();
            if (!json)
                return result;
            result.mode = json.mode;
            result.flags = (json.flags === undefined) ? 0 /* None */ : json.flags;
            result.angle = json.angle ? geometry_core_1.Angle.fromJSON(json.angle) : undefined;
            result.tint = json.tint;
            result.shift = json.shift ? json.shift : 0;
            json.keys.forEach((key) => result.keys.push(new KeyColor(key)));
            return result;
        }
        clone() {
            return Symb.fromJSON(this);
        }
        /** Returns true if this symbology is equal to another, false otherwise. */
        isEqualTo(other) {
            return Symb.compareSymb(this, other) === 0;
        }
        /** Compares two gradient symbologies. */
        static compareSymb(lhs, rhs) {
            if (lhs === rhs)
                return 0; // Same pointer
            if (lhs.mode !== rhs.mode)
                return lhs.mode - rhs.mode;
            if (lhs.flags !== rhs.flags)
                if (lhs.flags === undefined)
                    return -1;
                else if (rhs.flags === undefined)
                    return 1;
                else
                    return lhs.flags - rhs.flags;
            if (lhs.tint !== rhs.tint)
                if (lhs.tint === undefined)
                    return -1;
                else if (rhs.tint === undefined)
                    return 1;
                else
                    return lhs.tint - rhs.tint;
            if (lhs.shift !== rhs.shift)
                if (lhs.shift === undefined)
                    return -1;
                else if (rhs.shift === undefined)
                    return 1;
                else
                    return lhs.shift - rhs.shift;
            if ((lhs.angle === undefined) !== (rhs.angle === undefined))
                if (lhs.angle === undefined)
                    return -1;
                else
                    return 1;
            if (lhs.angle && !lhs.angle.isAlmostEqualNoPeriodShift(rhs.angle))
                return lhs.angle.radians - rhs.angle.radians;
            if (lhs.keys.length !== rhs.keys.length)
                return lhs.keys.length - rhs.keys.length;
            for (let i = 0; i < lhs.keys.length; i++) {
                if (lhs.keys[i].value !== rhs.keys[i].value)
                    return lhs.keys[i].value - rhs.keys[i].value;
                if (!lhs.keys[i].color.equals(rhs.keys[i].color))
                    return lhs.keys[i].color.tbgr - rhs.keys[i].color.tbgr;
            }
            return 0;
        }
        /** Compare this symbology to another. */
        compare(other) {
            return Gradient.Symb.compareSymb(this, other);
        }
        /**
         * Ensure the value given is within the range of 0 to 255,
         * and truncate the value to only the 8 least significant bits.
         */
        roundToByte(num) {
            return Math.min(num + .5, 255.0) & 0xFF;
        }
        /** Maps a value to an RGBA value adjusted from a color present in this symbology's array. */
        mapColor(value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            if ((this.flags & 1 /* Invert */) !== 0)
                value = 1 - value;
            let idx = 0;
            let d;
            let w0;
            let w1;
            if (this.keys.length <= 2) {
                w0 = 1.0 - value;
                w1 = value;
            }
            else {
                while (idx < (this.keys.length - 2) && value > this.keys[idx + 1].value)
                    idx++;
                d = this.keys[idx + 1].value - this.keys[idx].value;
                w1 = d < 0.0001 ? 0.0 : (value - this.keys[idx].value) / d;
                w0 = 1.0 - w1;
            }
            const color0 = this.keys[idx].color;
            const color1 = this.keys[idx + 1].color;
            const colors0 = color0.colors;
            const colors1 = color1.colors;
            const red = w0 * colors0.r + w1 * colors1.r;
            const green = w0 * colors0.g + w1 * colors1.g;
            const blue = w0 * colors0.b + w1 * colors1.b;
            const transparency = w0 * colors0.t + w1 * colors1.t;
            return ColorDef_1.ColorDef.from(this.roundToByte(red), this.roundToByte(green), this.roundToByte(blue), this.roundToByte(transparency));
        }
        get hasTranslucency() {
            for (const key of this.keys) {
                if (!key.color.isOpaque)
                    return true;
            }
            return false;
        }
        get isOutlined() { return 0 !== (this.flags & 2 /* Outline */); }
        /** Writes the image in 'reverse'. */
        getImage(width, height) {
            if (this.mode === 6 /* Thematic */) {
                width = 1;
                height = 8192; // Thematic image height
            }
            const hasAlpha = this.hasTranslucency;
            const thisAngle = (this.angle === undefined) ? 0 : this.angle.radians;
            const cosA = Math.cos(thisAngle);
            const sinA = Math.sin(thisAngle);
            const image = new Uint8Array(width * height * (hasAlpha ? 4 : 3));
            let currentIdx = image.length - 1;
            const shift = Math.min(1.0, Math.abs(this.shift));
            switch (this.mode) {
                case 1 /* Linear */:
                case 3 /* Cylindrical */: {
                    const xs = 0.5 - 0.25 * shift * cosA;
                    const ys = 0.5 - 0.25 * shift * sinA;
                    let dMax;
                    let dMin = dMax = 0.0;
                    let d;
                    for (let j = 0; j < 2; j++) {
                        for (let i = 0; i < 2; i++) {
                            d = (i - xs) * cosA + (j - ys) * sinA;
                            if (d < dMin)
                                dMin = d;
                            if (d > dMax)
                                dMax = d;
                        }
                    }
                    for (let j = 0; j < height; j++) {
                        const y = j / height - ys;
                        for (let i = 0; i < width; i++) {
                            const x = i / width - xs;
                            d = x * cosA + y * sinA;
                            let f;
                            if (this.mode === 1 /* Linear */) {
                                if (d > 0)
                                    f = 0.5 + 0.5 * d / dMax;
                                else
                                    f = 0.5 - 0.5 * d / dMin;
                            }
                            else {
                                if (d > 0)
                                    f = Math.sin(Math.PI / 2 * (1.0 - d / dMax));
                                else
                                    f = Math.sin(Math.PI / 2 * (1.0 - d / dMin));
                            }
                            const color = this.mapColor(f);
                            if (hasAlpha)
                                image[currentIdx--] = color.getAlpha();
                            image[currentIdx--] = color.colors.b;
                            image[currentIdx--] = color.colors.g;
                            image[currentIdx--] = color.colors.r;
                        }
                    }
                    break;
                }
                case 2 /* Curved */: {
                    const xs = 0.5 + 0.5 * sinA - 0.25 * shift * cosA;
                    const ys = 0.5 - 0.5 * cosA - 0.25 * shift * sinA;
                    for (let j = 0; j < height; j++) {
                        const y = j / height - ys;
                        for (let i = 0; i < width; i++) {
                            const x = i / width - xs;
                            const xr = 0.8 * (x * cosA + y * sinA);
                            const yr = y * cosA - x * sinA;
                            const f = Math.sin(Math.PI / 2 * (1 - Math.sqrt(xr * xr + yr * yr)));
                            const color = this.mapColor(f);
                            if (hasAlpha)
                                image[currentIdx--] = color.getAlpha();
                            image[currentIdx--] = color.colors.b;
                            image[currentIdx--] = color.colors.g;
                            image[currentIdx--] = color.colors.r;
                        }
                    }
                    break;
                }
                case 4 /* Spherical */: {
                    const r = 0.5 + 0.125 * Math.sin(2.0 * thisAngle);
                    const xs = 0.5 * shift * (cosA + sinA) * r;
                    const ys = 0.5 * shift * (sinA - cosA) * r;
                    for (let j = 0; j < height; j++) {
                        const y = ys + j / height - 0.5;
                        for (let i = 0; i < width; i++) {
                            const x = xs + i / width - 0.5;
                            const f = Math.sin(Math.PI / 2 * (1.0 - Math.sqrt(x * x + y * y) / r));
                            const color = this.mapColor(f);
                            if (hasAlpha)
                                image[currentIdx--] = color.getAlpha();
                            image[currentIdx--] = color.colors.b;
                            image[currentIdx--] = color.colors.g;
                            image[currentIdx--] = color.colors.r;
                        }
                    }
                    break;
                }
                case 5 /* Hemispherical */: {
                    const xs = 0.5 + 0.5 * sinA - 0.5 * shift * cosA;
                    const ys = 0.5 - 0.5 * cosA - 0.5 * shift * sinA;
                    for (let j = 0; j < height; j++) {
                        const y = j / height - ys;
                        for (let i = 0; i < width; i++) {
                            const x = i / width - xs;
                            const f = Math.sin(Math.PI / 2 * (1.0 - Math.sqrt(x * x + y * y)));
                            const color = this.mapColor(f);
                            if (hasAlpha)
                                image[currentIdx--] = color.getAlpha();
                            image[currentIdx--] = color.colors.b;
                            image[currentIdx--] = color.colors.g;
                            image[currentIdx--] = color.colors.r;
                        }
                    }
                    break;
                }
                case 6 /* Thematic */: {
                    let settings = this.thematicSettings;
                    if (settings === undefined) {
                        settings = ThematicProps.defaults;
                    }
                    // TBD - Stepped and isolines...
                    for (let j = 0; j < height; j++) {
                        let f = 1 - j / height;
                        let color;
                        if (f < settings.margin || f > 1.0 - settings.margin) {
                            color = settings.marginColor;
                        }
                        else {
                            f = (f - settings.margin) / (1 - 2 * settings.margin);
                            switch (settings.mode) {
                                case 2 /* SteppedWithDelimiter */:
                                case 1 /* Stepped */: {
                                    if (settings.stepCount !== 0) {
                                        const fStep = Math.floor(f * settings.stepCount + .99999) / settings.stepCount;
                                        const delimitFraction = 1 / 1024;
                                        if (settings.mode === 2 /* SteppedWithDelimiter */ && Math.abs(fStep - f) < delimitFraction)
                                            color = new ColorDef_1.ColorDef(0xff000000);
                                        else
                                            color = this.mapColor(fStep);
                                    }
                                    break;
                                }
                                case 0 /* Smooth */:
                                    color = this.mapColor(f);
                                    break;
                            }
                        }
                        for (let i = 0; i < width; i++) {
                            if (hasAlpha)
                                image[currentIdx--] = color.getAlpha();
                            image[currentIdx--] = color.colors.b;
                            image[currentIdx--] = color.colors.g;
                            image[currentIdx--] = color.colors.r;
                        }
                    }
                }
            }
            bentleyjs_core_1.assert(-1 === currentIdx);
            const imageBuffer = Image_1.ImageBuffer.create(image, hasAlpha ? 0 /* Rgba */ : 2 /* Rgb */, width);
            bentleyjs_core_1.assert(undefined !== imageBuffer);
            return imageBuffer;
        }
    }
    Gradient.Symb = Symb;
})(Gradient = exports.Gradient || (exports.Gradient = {}));
/** A list of Lights, plus the f-stop setting for the camera */
class SceneLights {
    constructor(imageBased, fstop = 0) {
        this.imageBased = imageBased;
        this.fstop = fstop;
        this._list = [];
    }
    get isEmpty() { return this._list.length === 0; }
    addLight(light) { if (light.isValid())
        this._list.push(light); }
}
exports.SceneLights = SceneLights;
/**
 * Geometry display properties used to override or augment the SubCategory Appearance.
 */
class GeometryParams {
    constructor(categoryId, subCategoryId = new bentleyjs_core_1.Id64()) {
        this.categoryId = categoryId;
        this.subCategoryId = subCategoryId;
        if (!subCategoryId.isValid())
            this.subCategoryId = IModel_1.IModel.getDefaultSubCategoryId(categoryId);
    }
    clone() {
        const retVal = new GeometryParams(this.categoryId, this.subCategoryId);
        retVal.materialId = this.materialId;
        retVal.elmPriority = this.elmPriority;
        retVal.weight = this.weight;
        retVal.lineColor = this.lineColor ? this.lineColor.clone() : undefined;
        retVal.fillColor = this.fillColor ? this.fillColor.clone() : undefined;
        retVal.backgroundFill = this.backgroundFill;
        retVal.fillDisplay = this.fillDisplay;
        retVal.elmTransparency = this.elmTransparency;
        retVal.fillTransparency = this.fillTransparency;
        retVal.geometryClass = this.geometryClass;
        retVal.styleInfo = this.styleInfo ? this.styleInfo.clone() : undefined;
        retVal.gradient = this.gradient ? this.gradient.clone() : undefined;
        retVal.pattern = this.pattern ? this.pattern.clone() : undefined;
        return retVal;
    }
    /**
     *  Clears appearance overrides while preserving category and sub-category.
     */
    resetAppearance() {
        this.materialId = undefined;
        this.elmPriority = undefined;
        this.weight = undefined;
        this.lineColor = undefined;
        this.fillColor = undefined;
        this.backgroundFill = undefined;
        this.fillDisplay = undefined;
        this.elmTransparency = undefined;
        this.fillTransparency = undefined;
        this.geometryClass = undefined;
        this.styleInfo = undefined;
        this.gradient = undefined;
        this.pattern = undefined;
    }
    /**
     *  Compare two GeometryParams for equivalence, i.e. both values are from sub-category appearance or have the same override.
     */
    isEquivalent(other) {
        if (this === other)
            return true; // Same pointer
        if (!this.categoryId.equals(other.categoryId))
            return false;
        if (!this.subCategoryId.equals(other.subCategoryId))
            return false;
        if (this.geometryClass !== other.geometryClass)
            return false;
        if (this.elmPriority !== other.elmPriority)
            return false;
        if (this.elmTransparency !== other.elmTransparency)
            return false;
        if (this.fillTransparency !== other.fillTransparency)
            return false;
        if ((this.lineColor === undefined) !== (other.lineColor === undefined))
            return false;
        if (this.lineColor && !this.lineColor.equals(other.lineColor))
            return false;
        if (this.weight !== other.weight)
            return false;
        if ((this.materialId === undefined) !== (other.materialId === undefined))
            return false;
        if (this.materialId && !this.materialId.equals(other.materialId))
            return false;
        if ((this.styleInfo === undefined) !== (other.styleInfo === undefined))
            return false;
        if (this.styleInfo && !this.styleInfo.isEqualTo(other.styleInfo))
            return false;
        if (this.fillDisplay !== other.fillDisplay)
            return false;
        if (this.fillDisplay !== undefined && this.fillDisplay !== 0 /* Never */) {
            if ((this.gradient === undefined) !== (other.gradient === undefined))
                return false;
            if (this.gradient && !this.gradient.isEqualTo(other.gradient))
                return false;
            if (this.backgroundFill !== other.backgroundFill)
                return false;
            if (this.backgroundFill === undefined || this.backgroundFill === 0 /* None */) {
                if ((this.fillColor === undefined) !== (other.fillColor === undefined))
                    return false;
                if (this.fillColor && !this.fillColor.equals(other.fillColor))
                    return false;
            }
        }
        if ((this.pattern === undefined) !== (other.pattern === undefined))
            return false;
        if (this.pattern && !this.pattern.isEqualTo(other.pattern))
            return false;
        return true;
    }
    /** Setting the Category Id also sets the SubCategory to the default. */
    setCategoryId(categoryId, clearAppearanceOverrides = true) {
        this.categoryId = categoryId;
        this.subCategoryId = IModel_1.IModel.getDefaultSubCategoryId(categoryId);
        if (clearAppearanceOverrides)
            this.resetAppearance();
    }
    setSubCategoryId(subCategoryId, clearAppearanceOverrides = true) {
        this.subCategoryId = subCategoryId;
        if (clearAppearanceOverrides)
            this.resetAppearance();
    }
    /**  Get whether this GeometryParams contains information that needs to be transformed (ex. to apply local to world). */
    isTransformable() { return this.pattern || this.styleInfo; }
    /**  Transform GeometryParams data like PatternParams and LineStyleInfo. */
    applyTransform(transform) {
        if (this.pattern)
            this.pattern.applyTransform(transform);
        if (this.styleInfo && this.styleInfo.styleMod)
            this.styleInfo.styleMod.applyTransform(transform);
    }
}
exports.GeometryParams = GeometryParams;
var Hilite;
(function (Hilite) {
    const defaultColor = ColorDef_1.ColorDef.from(0x23, 0xbb, 0xfc);
    const defaultVisibleRatio = 0.25;
    const defaultHiddenRatio = 0.0;
    const defaultWidth = 1 /* Thin */;
    /**
     * Describes the effect applied to hilited elements within a view.
     */
    class Settings {
        constructor(color = defaultColor.clone(), visibleRatio = defaultVisibleRatio, hiddenRatio = defaultHiddenRatio, silhouette = defaultWidth) {
            this.color = color;
            this.visibleRatio = visibleRatio;
            this.hiddenRatio = hiddenRatio;
            this.silhouette = silhouette;
            this.visibleRatio = Settings.clamp(this.visibleRatio);
            this.hiddenRatio = Settings.clamp(this.hiddenRatio);
        }
        static clamp(value) { return Math.min(1.0, Math.max(0.0, value)); }
        /** Change the color, preserving all other settings */
        setColor(color) { this.color.setFrom(color); }
        clone(out) {
            if (undefined !== out) {
                out.copyFrom(this);
                return out;
            }
            else {
                return new Settings(this.color, this.visibleRatio, this.hiddenRatio, this.silhouette);
            }
        }
        copyFrom(other) {
            this.color.setFrom(other.color);
            this.visibleRatio = other.visibleRatio;
            this.hiddenRatio = other.hiddenRatio;
            this.silhouette = other.silhouette;
        }
    }
    Hilite.Settings = Settings;
})(Hilite = exports.Hilite || (exports.Hilite = {}));
/**
 * Describes a "feature" within a batched RenderGraphic. A batched RenderGraphic can
 * contain multiple features. Each feature is associated with a unique combination of
 * attributes (element ID, subcategory, geometry class). This allows geometry to be
 * more efficiently batched on the GPU, while enabling features to be re-symbolized
 * individually.
 *
 * As a simple example, a single mesh primitive may contain geometry for 3 elements,
 * all belonging to the same subcategory and geometry class. The mesh would therefore
 * contain 3 Features. Each vertex within the mesh would be associated with the
 * index of the Feature to which it belongs, where the index is determined by the
 * FeatureTable associated with the primitive.
 */
class Feature {
    constructor(elementId = bentleyjs_core_1.Id64.invalidId, subCategoryId = bentleyjs_core_1.Id64.invalidId, geometryClass = 0 /* Primary */) {
        this.elementId = elementId;
        this.subCategoryId = subCategoryId;
        this.geometryClass = geometryClass;
    }
    get isDefined() { return this.elementId.isValid() || this.subCategoryId.isValid() || this.geometryClass !== 0 /* Primary */; }
    get isUndefined() { return !this.isDefined; }
    equals(other) { return 0 === this.compare(other); }
    compare(rhs) {
        if (this === rhs)
            return 0;
        let cmp = bentleyjs_core_1.compareNumbers(this.geometryClass, rhs.geometryClass);
        if (0 === cmp) {
            cmp = bentleyjs_core_1.compareStrings(this.elementId.value, rhs.elementId.value);
            if (0 === cmp) {
                cmp = bentleyjs_core_1.compareStrings(this.subCategoryId.value, rhs.subCategoryId.value);
            }
        }
        return cmp;
    }
}
exports.Feature = Feature;
/**
 * Defines a look-up table for Features within a batched RenderGraphic. Consecutive 32-bit
 * indices are assigned to each unique Feature. Primitives within the RenderGraphic can
 * use per-vertex indices to specify the distribution of Features within the primitive.
 * A FeatureTable can be shared amongst multiple primitives within a single RenderGraphic, and
 * amongst multiple sub-Graphics of a RenderGraphic.
 */
class FeatureTable extends bentleyjs_core_1.IndexMap {
    constructor(maxFeatures, modelId = bentleyjs_core_1.Id64.invalidId) {
        super(bentleyjs_core_1.compare, maxFeatures);
        this.modelId = modelId;
    }
    get maxFeatures() { return this.maximumSize; }
    get anyDefined() { return this.length > 1 || (1 === this.length && this.array[0].value.isDefined); }
    get isUniform() { return 1 === this.length; }
    get uniform() { return 1 === this.length ? this.array[0].value : undefined; }
    /** Returns the Feature corresponding to the specified index, or undefined if the index is not present. */
    findFeature(index) {
        for (const entry of this.array)
            if (entry.index === index)
                return entry.value;
        return undefined;
    }
    /** @hidden */
    insertWithIndex(feature, index) {
        const bound = this.lowerBound(feature);
        bentleyjs_core_1.assert(!bound.equal);
        bentleyjs_core_1.assert(!this.isFull);
        const entry = new bentleyjs_core_1.IndexedValue(feature, index);
        this.array.splice(bound.index, 0, entry);
    }
    /** @hidden */
    getArray() { return this.array; }
}
exports.FeatureTable = FeatureTable;
class TextureMapping {
    constructor(tx, params) {
        this.texture = tx;
        this.params = params;
    }
    computeUVParams(visitor, transformToImodel) {
        return this.params.computeUVParams(visitor, transformToImodel);
    }
}
exports.TextureMapping = TextureMapping;
(function (TextureMapping) {
    class Trans2x3 {
        constructor(t00 = 1, t01 = 0, t02 = 0, t10 = 0, t11 = 1, t12 = 0) {
            this._vals = new Array(2);
            const vals = this._vals;
            vals[0] = [t00, t01, t02];
            vals[1] = [t10, t11, t12];
        }
        setTransform() {
            const transform = geometry_core_1.Transform.createIdentity(), vals = this._vals, matrix = transform.matrix;
            for (let i = 0, len = 2; i < 2; ++i)
                for (let j = 0; j < len; ++j)
                    matrix.setAt(i, j, vals[i][j]);
            transform.origin.x = vals[0][2];
            transform.origin.y = vals[1][2];
            this._transform = transform;
        }
        get transform() { if (undefined === this._transform)
            this.setTransform(); return this._transform; }
    }
    TextureMapping.Trans2x3 = Trans2x3;
    class Params {
        constructor(props = {}) {
            const { textureMat2x3 = new Trans2x3(), textureWeight = 1.0, mapMode = 0 /* Parametric */, worldMapping = false } = props;
            this.textureMatrix = textureMat2x3;
            this.weight = textureWeight;
            this.mode = mapMode;
            this.worldMapping = worldMapping;
        }
        /**
         * Generates UV parameters for textured surfaces. Returns undefined on failure.
         */
        computeUVParams(visitor, transformToImodel) {
            switch (this.mode) {
                default: // Fall through to parametric in default case
                case 0 /* Parametric */: {
                    return this.computeParametricUVParams(visitor, this.textureMatrix.transform, !this.worldMapping);
                }
                case 2 /* Planar */: {
                    const normalIndices = visitor.normalIndex;
                    if (!normalIndices)
                        return undefined;
                    // Ignore planar mode unless master or sub units for scaleMode and facet is planar
                    if (!this.worldMapping || (visitor.normalIndex !== undefined && (normalIndices[0] !== normalIndices[1] || normalIndices[0] !== normalIndices[2]))) {
                        return this.computeParametricUVParams(visitor, this.textureMatrix.transform, !this.worldMapping);
                    }
                    else {
                        return this.computePlanarUVParams(visitor, this.textureMatrix.transform);
                    }
                }
                case 1 /* ElevationDrape */: {
                    return this.computeElevationDrapeUVParams(visitor, this.textureMatrix.transform, transformToImodel);
                }
            }
        }
        /** Computes UV parameters given a texture mapping mode of parametric. */
        computeParametricUVParams(visitor, uvTransform, isRelativeUnits) {
            const params = [];
            for (let i = 0; i < visitor.numEdgesThisFacet; i++) {
                let param = geometry_core_1.Point2d.create();
                if (isRelativeUnits || !visitor.tryGetDistanceParameter(i, param)) {
                    if (!visitor.tryGetNormalizedParameter(i, param)) {
                        // If mesh does not have facetFaceData, we still want to use the texture coordinates if they are present
                        param = visitor.getParam(i);
                    }
                }
                params.push(uvTransform.multiplyPoint2d(param));
            }
            return params;
        }
        /** Computes UV parameters given a texture mapping mode of planar. The result is stored in the Point2d array given. */
        computePlanarUVParams(visitor, uvTransform) {
            const params = [];
            const points = visitor.point;
            let normal;
            if (visitor.normal === undefined)
                normal = points.getPoint3dAt(0).crossProductToPoints(points.getPoint3dAt(1), points.getPoint3dAt(2));
            else
                normal = visitor.normal[0];
            if (!normal.normalize(normal))
                return undefined;
            // adjust U texture coordinate to be a continuous length starting at the
            // origin. V coordinate stays the same. This mode assumes Z is up vector
            // Flipping normal puts us in a planar coordinate system consistent with MicroStation's display system
            normal.scale(-1.0, normal);
            // pick the first vertex normal
            const sideVector = geometry_core_1.Vector3d.create(normal.y, -normal.x, 0.0);
            // if the magnitude of the normal is near zero, the real normal points
            // almost straighten up.. In this case, use Y as the up vector in order to
            // match QV
            const magnitude = sideVector.magnitude();
            sideVector.normalize(sideVector); // won't remain undefined if failed due to following check..
            if (magnitude < 1e-3) {
                normal.set(0, 0, -1);
                sideVector.set(1, 0, 0);
            }
            const upVector = sideVector.crossProduct(normal).normalize();
            if (!upVector)
                return undefined;
            const numEdges = visitor.numEdgesThisFacet;
            for (let i = 0; i < numEdges; i++) {
                const vector = geometry_core_1.Vector3d.createFrom(points.getPoint3dAt(i));
                params.push(geometry_core_1.Point2d.create(vector.dotProduct(sideVector), vector.dotProduct(upVector)));
                uvTransform.multiplyPoint2d(params[i], params[i]);
            }
            return params;
        }
        /** Computes UV parameters given a texture mapping mode of elevation drape. The result is stored in the Point2d array given. */
        computeElevationDrapeUVParams(visitor, uvTransform, transformToIModel) {
            const params = [];
            const numEdges = visitor.numEdgesThisFacet;
            for (let i = 0; i < numEdges; i++) {
                const point = visitor.point.getPoint3dAt(i);
                if (transformToIModel !== undefined)
                    transformToIModel.multiplyPoint3d(point, point);
                params.push(geometry_core_1.Point2d.createFrom(point));
                uvTransform.multiplyPoint2d(params[i], params[i]);
            }
            return params;
        }
    }
    TextureMapping.Params = Params;
})(TextureMapping = exports.TextureMapping || (exports.TextureMapping = {}));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module IModelConnection */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const IModelUnitTestRpcInterface_1 = __webpack_require__(334); // not part of the "barrel"
const SelectionSet_1 = __webpack_require__(206);
const ViewState_1 = __webpack_require__(121);
const CategorySelectorState_1 = __webpack_require__(210);
const DisplayStyleState_1 = __webpack_require__(211);
const ModelSelectorState_1 = __webpack_require__(212);
const ModelState_1 = __webpack_require__(76);
const IModelApp_1 = __webpack_require__(5);
const loggingCategory = "imodeljs-frontend.IModelConnection";
/** A connection to an iModel database hosted on the backend. */
class IModelConnection extends imodeljs_common_1.IModel {
    constructor(iModel, openMode, accessToken) {
        super(iModel.iModelToken);
        /** Generator for unique Ids of transient graphics for this IModelConnection. */
        this.transientIds = new bentleyjs_core_1.TransientIdSequence();
        /** A unique Id of this IModelConnection. */
        this.connectionId = bentleyjs_core_1.Guid.createValue();
        this.reopenConnectionHandler = async (request, response, resubmit, reject) => {
            if (!(response instanceof imodeljs_common_1.IModelNotFoundResponse))
                return;
            const iModelToken = request.parameters[0];
            if (this.token.key !== iModelToken.key)
                return; // The handler is called for a different connection than this
            try {
                bentleyjs_core_1.Logger.logTrace(loggingCategory, "Attempting to reopen connection", () => ({ iModelId: iModelToken.iModelId, changeSetId: iModelToken.changeSetId, key: iModelToken.key }));
                const openResponse = await IModelConnection.callOpen(this.openAccessToken, iModelToken, this.openMode);
                this.token = openResponse.iModelToken;
            }
            catch (error) {
                reject(error.message);
            }
            bentleyjs_core_1.Logger.logTrace(loggingCategory, "Resubmitting original request after reopening connection", () => ({ iModelId: iModelToken.iModelId, changeSetId: iModelToken.changeSetId, key: iModelToken.key }));
            request.parameters[0] = this.token; // Modify the token of the original request before resubmitting it.
            resubmit();
        };
        this._snapPending = false;
        super.initialize(iModel.name, iModel);
        this.openMode = openMode;
        this.models = new IModelConnection.Models(this);
        this.elements = new IModelConnection.Elements(this);
        this.codeSpecs = new IModelConnection.CodeSpecs(this);
        this.views = new IModelConnection.Views(this);
        this.hilited = new SelectionSet_1.HilitedSet(this);
        this.selectionSet = new SelectionSet_1.SelectionSet(this);
        this.tiles = new IModelConnection.Tiles(this);
        this.openAccessToken = accessToken;
    }
    /** Check the [[openMode]] of this IModelConnection to see if it was opened read-only. */
    isReadonly() { return this.openMode === 1 /* Readonly */; }
    /**
     * Load the FontMap for this IModelConnection.
     * @returns Returns a Promise<FontMap> that is fulfilled when the FontMap member of this IModelConnection is valid.
     */
    async loadFontMap() {
        return this.fontMap || (this.fontMap = new imodeljs_common_1.FontMap(JSON.parse(await imodeljs_common_1.IModelReadRpcInterface.getClient().readFontJson(this.iModelToken))));
    }
    /** Open an IModelConnection to an iModel */
    static async open(accessToken, contextId, iModelId, openMode = 1 /* Readonly */, version = imodeljs_common_1.IModelVersion.latest()) {
        if (!IModelApp_1.IModelApp.initialized)
            throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Call IModelApp.startup() before calling open");
        let changeSetId = await version.evaluateChangeSet(accessToken, iModelId, IModelApp_1.IModelApp.iModelClient);
        if (!changeSetId)
            changeSetId = "0"; // The first version is arbitrarily setup to have changeSetId = "0" since it is required by the RPC interface API.
        const iModelToken = new imodeljs_common_1.IModelToken(undefined, contextId, iModelId, changeSetId);
        const openResponse = await IModelConnection.callOpen(accessToken, iModelToken, openMode);
        const connection = new IModelConnection(openResponse, openMode, accessToken);
        imodeljs_common_1.RpcRequest.notFoundHandlers.addListener(connection.reopenConnectionHandler);
        return connection;
    }
    static async callOpen(accessToken, iModelToken, openMode) {
        // Try opening the iModel repeatedly accommodating any pending responses from the backend
        // After the first attempt wait for 500 ms.On subsequent attempts, double the wait time the
        // timeout period has reached
        let connectionRetryTime = 500; // milliseconds
        connectionRetryTime = Math.min(connectionRetryTime, IModelConnection.connectionTimeout);
        let openForReadOperation;
        let openForWriteOperation;
        if (openMode === 1 /* Readonly */) {
            openForReadOperation = imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelReadRpcInterface, "openForRead");
            if (!openForReadOperation)
                throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "IModelReadRpcInterface.openForRead() is not available");
            openForReadOperation.policy.retryInterval = () => connectionRetryTime;
        }
        else {
            openForWriteOperation = imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelWriteRpcInterface, "openForWrite");
            if (!openForWriteOperation)
                throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "IModelWriteRpcInterface.openForWrite() is not available");
            openForWriteOperation.policy.retryInterval = () => connectionRetryTime;
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Received open request in IModelConnection.open`, () => (Object.assign({}, iModelToken, { openMode })));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Setting open connection retry interval to ${connectionRetryTime} milliseconds in IModelConnection.open`, () => (Object.assign({}, iModelToken, { openMode })));
        const startTime = Date.now();
        const removeListener = imodeljs_common_1.RpcRequest.events.addListener((type, request) => {
            if (type !== imodeljs_common_1.RpcRequestEvent.PendingUpdateReceived)
                return;
            if (!(openForReadOperation && request.operation === openForReadOperation) && !(openForWriteOperation && request.operation === openForWriteOperation))
                return;
            bentleyjs_core_1.Logger.logTrace(loggingCategory, "Received pending open notification in IModelConnection.open", () => (Object.assign({}, iModelToken, { openMode })));
            if (Date.now() - startTime > IModelConnection.connectionTimeout) {
                bentleyjs_core_1.Logger.logTrace(loggingCategory, `Timed out opening connection in IModelConnection.open (took longer than ${IModelConnection.connectionTimeout} milliseconds)`, () => (Object.assign({}, iModelToken, { openMode })));
                throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Opening a connection was timed out"); // NEEDS_WORK: More specific error status
            }
            connectionRetryTime = connectionRetryTime * 2;
            request.retryInterval = connectionRetryTime;
            bentleyjs_core_1.Logger.logTrace(loggingCategory, `Adjusted open connection retry interval to ${request.retryInterval} milliseconds in IModelConnection.open`, () => (Object.assign({}, iModelToken, { openMode })));
        });
        let openResponse;
        try {
            if (openMode === 2 /* ReadWrite */)
                openResponse = await imodeljs_common_1.IModelWriteRpcInterface.getClient().openForWrite(accessToken, iModelToken);
            else
                openResponse = await imodeljs_common_1.IModelReadRpcInterface.getClient().openForRead(accessToken, iModelToken);
        }
        finally {
            removeListener();
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, "Completed open request in IModelConnection.open", () => (Object.assign({}, iModelToken, { openMode })));
        return openResponse;
    }
    /** Close this IModelConnection */
    async close(accessToken) {
        if (!this.iModelToken)
            return;
        imodeljs_common_1.RpcRequest.notFoundHandlers.removeListener(this.reopenConnectionHandler);
        IModelConnection.onClose.raiseEvent(this);
        this.models.onIModelConnectionClose(); // free WebGL resources if rendering
        try {
            await imodeljs_common_1.IModelReadRpcInterface.getClient().close(accessToken, this.iModelToken);
        }
        finally {
            this.token = undefined; // prevent closed connection from being reused
        }
    }
    /**
     * Open an IModelConnection to a standalone iModel (not managed by iModelHub) from a file name that is resolved by the backend.
     * This method is intended for desktop or mobile applications and should not be used for web applications.
     */
    static async openStandalone(fileName, openMode = 1 /* Readonly */) {
        const openResponse = await imodeljs_common_1.StandaloneIModelRpcInterface.getClient().openStandalone(fileName, openMode);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, "IModelConnection.openStandalone", () => ({ fileName, openMode }));
        return new IModelConnection(openResponse, openMode);
    }
    /** Close this standalone IModelConnection */
    async closeStandalone() {
        if (!this.iModelToken)
            return;
        IModelConnection.onClose.raiseEvent(this);
        this.models.onIModelConnectionClose(); // free WebGL resources if rendering
        try {
            await imodeljs_common_1.StandaloneIModelRpcInterface.getClient().closeStandalone(this.iModelToken);
        }
        finally {
            this.token = undefined; // prevent closed connection from being reused
        }
    }
    /** Load a file from the native asset directory of the backend.
     * @param assetName Name of the asset file, with path relative to the *Assets* directory
     */
    async loadNativeAsset(assetName) {
        const val = await imodeljs_common_1.IModelReadRpcInterface.getClient().loadNativeAsset(this.iModelToken, assetName);
        return new Uint8Array(atob(val).split("").map((c) => c.charCodeAt(0)));
    }
    /**
     * Execute an ECSQL query against the iModel.
     * The result of the query is returned as an array of JavaScript objects where every array element represents an
     * [ECSQL row]($docs/learning/ECSQLRowFormat).
     *
     * See also:
     * - [ECSQL Overview]($docs/learning/frontend/ExecutingECSQL)
     * - [Code Examples]($docs/learning/frontend/ECSQLCodeExamples)
     *
     * @param ecsql The ECSQL to execute
     * @param bindings The values to bind to the parameters (if the ECSQL has any).
     * The section "[iModelJs Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)" describes the
     * iModelJs types to be used for the different ECSQL parameter types.
     * Pass an *array* of values if the parameters are *positional*.
     * Pass an *object of the values keyed on the parameter name* for *named parameters*.
     * The values in either the array or object must match the respective types of the parameters.
     * @returns Returns the query result as an array of the resulting rows or an empty array if the query has returned no rows
     * @throws [IModelError]($common) if the ECSQL is invalid
     */
    async executeQuery(ecsql, bindings) {
        bentleyjs_core_1.Logger.logTrace(loggingCategory, "IModelConnection.executeQuery", () => ({ iModelId: this.iModelToken.iModelId, ecsql, bindings }));
        return await imodeljs_common_1.IModelReadRpcInterface.getClient().executeQuery(this.iModelToken, ecsql, bindings);
    }
    /** Query for a set of element ids that satisfy the supplied query params  */
    async queryEntityIds(params) { return imodeljs_common_1.IModelReadRpcInterface.getClient().queryEntityIds(this.iModelToken, params); }
    /**
     * Update the project extents of this iModel.
     * @param newExtents The new project extents as an AxisAlignedBox3d
     * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem updating the extents.
     */
    async updateProjectExtents(newExtents) {
        bentleyjs_core_1.Logger.logTrace(loggingCategory, "IModelConnection.updateProjectExtents", () => ({ iModelId: this.iModelToken.iModelId, newExtents }));
        if (2 /* ReadWrite */ !== this.openMode)
            return Promise.reject(new imodeljs_common_1.IModelError(65582 /* ReadOnly */));
        await imodeljs_common_1.IModelWriteRpcInterface.getClient().updateProjectExtents(this.iModelToken, newExtents);
    }
    /**
     * Commit pending changes to this iModel
     * @param description Optional description of the changes
     * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem saving changes.
     */
    async saveChanges(description) {
        bentleyjs_core_1.Logger.logTrace(loggingCategory, "IModelConnection.saveChanges", () => ({ iModelId: this.iModelToken.iModelId, description }));
        if (2 /* ReadWrite */ !== this.openMode)
            return Promise.reject(new imodeljs_common_1.IModelError(65582 /* ReadOnly */));
        return await imodeljs_common_1.IModelWriteRpcInterface.getClient().saveChanges(this.iModelToken, description);
    }
    /**
     * Determines whether the *Change Cache file* is attached to this iModel or not.
     *
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     * @returns Returns true if the *Change Cache file* is attached to the iModel. false otherwise
     */
    async isChangeCacheAttached() { return await imodeljs_common_1.IModelReadRpcInterface.getClient().isChangeCacheAttached(this.iModelToken); }
    /**
     * Attaches the *Change Cache file* to this iModel if it hasn't been attached yet.
     *
     * A new *Change Cache file* will be created for the iModel if it hasn't existed before.
     *
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     * @throws [IModelError]($common) if a Change Cache file has already been attached before.
     */
    async attachChangeCache() { await imodeljs_common_1.IModelReadRpcInterface.getClient().attachChangeCache(this.iModelToken); }
    /**
     * Detaches the *Change Cache file* to this iModel if it had been attached before.
     * > You do not have to check whether a Change Cache file had been attached before. The
     * > method does not do anything, if no Change Cache is attached.
     *
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     */
    async detachChangeCache() { await imodeljs_common_1.IModelReadRpcInterface.getClient().detachChangeCache(this.iModelToken); }
    /**
     * Execute a test by name
     * @param testName The name of the test to execute
     * @param params A JSON string containing all parameters the test requires
     * @hidden
     */
    async executeTest(testName, params) { return IModelUnitTestRpcInterface_1.IModelUnitTestRpcInterface.getClient().executeTest(this.iModelToken, testName, params); }
    async requestSnap(props) {
        this._snapPending = true; // save flag indicating we're in the process of generating a snap
        const response = imodeljs_common_1.IModelReadRpcInterface.getClient().requestSnap(this.iModelToken, this.connectionId, props);
        await response; // after snap completes, turn off flag
        this._snapPending = false;
        return response; // return fulfilled promise
    }
    async cancelSnap() {
        if (this._snapPending) {
            this._snapPending = false;
            return imodeljs_common_1.IModelReadRpcInterface.getClient().cancelSnap(this.iModelToken, this.connectionId); // this will throw an exception in previous stack.
        }
    }
}
/** The maximum time (in milliseconds) to wait before timing out the request to open a connection to a new iModel */
IModelConnection.connectionTimeout = 5 * 60 * 1000;
/**
 * Event called immediately before an IModelConnection is closed.
 * @note Be careful not to perform any asynchronous operations on the IModelConnection because it will close before they are processed.
 */
IModelConnection.onClose = new bentleyjs_core_1.BeEvent();
exports.IModelConnection = IModelConnection;
(function (IModelConnection) {
    /** The collection of loaded ModelState objects for an [[IModelConnection]]. */
    class Models {
        /** @hidden */
        constructor(_iModel) {
            this._iModel = _iModel;
            /** The set of loaded models for this IModelConnection, indexed by Id. */
            this.loaded = new Map();
        }
        /** Register a class by classFullName */
        static registerClass(className, classType) { this._registry.set(className, classType); }
        static findClass(className) { return this._registry.get(className); }
        /** The Id of the [RepositoryModel]($backend). */
        get repositoryModelId() { return new bentleyjs_core_1.Id64("0x1"); }
        /** Get a batch of [[ModelProps]] given a list of Model ids. */
        async getProps(modelIds) {
            return await imodeljs_common_1.IModelReadRpcInterface.getClient().getModelProps(this._iModel.iModelToken, bentleyjs_core_1.Id64.toIdSet(modelIds));
        }
        getLoaded(id) { return this.loaded.get(id); }
        /** Find the first base class of the given class that is registered. Then, register that ModelState as the handler of the given class so we won't need this method again for that class. */
        async findRegisteredBaseClass(className) {
            let ctor = ModelState_1.ModelState; // worst case, we don't find any registered base classes
            // wait until we get the full list of base classes from backend
            const baseClasses = await imodeljs_common_1.IModelReadRpcInterface.getClient().getClassHierarchy(this._iModel.iModelToken, className);
            // walk through the list until we find a registered base class
            baseClasses.some((baseClass) => {
                const test = Models.findClass(baseClass);
                if (test === undefined)
                    return false; // nope, not registered
                ctor = test; // found it, save it
                Models.registerClass(className, ctor); // and register the fact that our starting class is handled by this ModelState subclass.
                return true; // stop
            });
            return ctor; // either the baseClass handler or ModelState if we didn't find a registered baseClass
        }
        /** load a set of models by Ids. After calling this method, you may get the ModelState objects by calling getLoadedModel. */
        async load(modelIds) {
            const notLoaded = new Set();
            bentleyjs_core_1.Id64.toIdSet(modelIds).forEach((id) => {
                const loaded = this.getLoaded(id);
                if (!loaded)
                    notLoaded.add(id);
            });
            if (notLoaded.size === 0)
                return; // all requested models are already loaded
            try {
                (await this.getProps(notLoaded)).forEach(async (props) => {
                    let ctor = Models.findClass(props.classFullName);
                    if (undefined === ctor)
                        ctor = await this.findRegisteredBaseClass(props.classFullName); // must wait for this
                    const modelState = new ctor(props, this._iModel); // create a new instance of the appropriate ModelState subclass
                    this.loaded.set(modelState.id.value, modelState); // save it in loaded set
                });
            }
            catch (err) { } // ignore error, we had nothing to do.
        }
        /** Query for a set of ModelProps of the specified ModelQueryParams. */
        async queryProps(queryParams) {
            const params = Object.assign({}, queryParams); // make a copy
            params.from = queryParams.from || ModelState_1.ModelState.sqlName; // use "BisCore.Model" as default class name
            params.where = queryParams.where || "";
            if (!queryParams.wantPrivate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsPrivate=FALSE ";
            }
            if (!queryParams.wantTemplate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsTemplate=FALSE ";
            }
            return await imodeljs_common_1.IModelReadRpcInterface.getClient().queryModelProps(this._iModel.iModelToken, params);
        }
        /** Code to run when the IModelConnection has closed. */
        onIModelConnectionClose() {
            this.loaded.forEach((value) => {
                value.onIModelConnectionClose();
            });
        }
    }
    /** Registry of className to ModelState class */
    Models._registry = new Map();
    IModelConnection.Models = Models;
    /** The collection of Elements for an [[IModelConnection]]. */
    class Elements {
        /** @hidden */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /** The Id of the [root subject element]($docs/bis/intro/glossary.md#subject-root) for this iModel. */
        get rootSubjectId() { return new bentleyjs_core_1.Id64("0x1"); }
        /** Get a set of element ids that satisfy a query */
        async queryIds(params) { return this._iModel.queryEntityIds(params); }
        /** Get an array of [[ElementProps]] given one or more element ids. */
        async getProps(arg) {
            return await imodeljs_common_1.IModelReadRpcInterface.getClient().getElementProps(this._iModel.iModelToken, bentleyjs_core_1.Id64.toIdSet(arg));
        }
        /** Get an array  of [[ElementProps]] that satisfy a query */
        async queryProps(params) {
            return await imodeljs_common_1.IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken, params);
        }
        /** Ask the backend to format (for presentation) the specified list of element ids. */
        async formatElements(elementIds) {
            return await imodeljs_common_1.IModelReadRpcInterface.getClient().formatElements(this._iModel.iModelToken, bentleyjs_core_1.Id64.toIdSet(elementIds));
        }
    }
    IModelConnection.Elements = Elements;
    /** The collection of [[CodeSpec]] entities for an [[IModelConnection]]. */
    class CodeSpecs {
        /** @hidden */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /** Loads all CodeSpec from the remote IModelDb. */
        async _loadAllCodeSpecs() {
            if (this._loaded)
                return;
            this._loaded = [];
            const codeSpecArray = await imodeljs_common_1.IModelReadRpcInterface.getClient().getAllCodeSpecs(this._iModel.iModelToken);
            for (const codeSpec of codeSpecArray) {
                this._loaded.push(new imodeljs_common_1.CodeSpec(this._iModel, new bentleyjs_core_1.Id64(codeSpec.id), codeSpec.name, codeSpec.jsonProperties));
            }
        }
        /** Look up a CodeSpec by Id.
         * @param codeSpecId The Id of the CodeSpec to load
         * @returns The CodeSpec with the specified Id
         * @throws [[IModelError]] if the Id is invalid or if no CodeSpec with that Id could be found.
         */
        async getById(codeSpecId) {
            if (!codeSpecId.isValid())
                return Promise.reject(new imodeljs_common_1.IModelError(65559 /* InvalidId */, "Invalid codeSpecId", bentleyjs_core_1.Logger.logWarning, loggingCategory, () => ({ codeSpecId })));
            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded
            const found = this._loaded.find((codeSpec) => codeSpec.id.equals(codeSpecId));
            if (!found)
                return Promise.reject(new imodeljs_common_1.IModelError(65574 /* NotFound */, "CodeSpec not found", bentleyjs_core_1.Logger.logWarning, loggingCategory));
            return found;
        }
        /** Look up a CodeSpec by name.
         * @param name The name of the CodeSpec to load
         * @returns The CodeSpec with the specified name
         * @throws [[IModelError]] if no CodeSpec with the specified name could be found.
         */
        async getByName(name) {
            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded
            const found = this._loaded.find((codeSpec) => codeSpec.name === name);
            if (!found)
                return Promise.reject(new imodeljs_common_1.IModelError(65574 /* NotFound */, "CodeSpec not found", bentleyjs_core_1.Logger.logWarning, loggingCategory));
            return found;
        }
    }
    IModelConnection.CodeSpecs = CodeSpecs;
    /** The collection of views for an [[IModelConnection]]. */
    class Views {
        /** @hidden */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /**
         * Query for an array of ViewDefinitionProps
         * @param queryParams Query parameters specifying the views to return
         */
        async queryProps(queryParams) {
            const params = Object.assign({}, queryParams); // make a copy
            params.from = queryParams.from || ViewState_1.ViewState.sqlName; // use "BisCore.ViewDefinition" as default class name
            params.where = queryParams.where || "";
            if (!queryParams.wantPrivate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsPrivate=FALSE ";
            }
            const viewProps = await imodeljs_common_1.IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken, params);
            bentleyjs_core_1.assert((viewProps.length === 0) || ("categorySelectorId" in viewProps[0]), "invalid view definition"); // spot check that the first returned element is-a ViewDefinitionProps
            return viewProps;
        }
        /**
         * Get an array of the ViewSpecs for all views in this IModel that satisfy a ViewQueryParams.
         *
         * This is typically used to create a list for UI.
         *
         * For example:
         * ```ts
         * [[include:IModelConnection.Views.getViewList]]
         * ```
         * @param queryParams The parameters for the views to find.
         */
        async getViewList(queryParams) {
            const views = [];
            const viewProps = await this.queryProps(queryParams);
            viewProps.forEach((viewProp) => { views.push({ id: viewProp.id, name: viewProp.code.value, class: viewProp.classFullName }); });
            return views;
        }
        /** Load a [[ViewState]] object from the specified [[ViewDefinition]] id. */
        async load(viewDefinitionId) {
            const viewStateData = await imodeljs_common_1.IModelReadRpcInterface.getClient().getViewStateData(this._iModel.iModelToken, typeof viewDefinitionId === "string" ? viewDefinitionId : viewDefinitionId.value);
            const categorySelectorState = new CategorySelectorState_1.CategorySelectorState(viewStateData.categorySelectorProps, this._iModel);
            let viewState;
            switch (viewStateData.viewDefinitionProps.classFullName) {
                case ViewState_1.SpatialViewState.getClassFullName(): {
                    const displayStyleState = new DisplayStyleState_1.DisplayStyle3dState(viewStateData.displayStyleProps, this._iModel);
                    const modelSelectorState = new ModelSelectorState_1.ModelSelectorState(viewStateData.modelSelectorProps, this._iModel);
                    viewState = new ViewState_1.SpatialViewState(viewStateData.viewDefinitionProps, this._iModel, categorySelectorState, displayStyleState, modelSelectorState);
                    break;
                }
                case ViewState_1.OrthographicViewState.getClassFullName(): {
                    const displayStyleState = new DisplayStyleState_1.DisplayStyle3dState(viewStateData.displayStyleProps, this._iModel);
                    const modelSelectorState = new ModelSelectorState_1.ModelSelectorState(viewStateData.modelSelectorProps, this._iModel);
                    viewState = new ViewState_1.OrthographicViewState(viewStateData.viewDefinitionProps, this._iModel, categorySelectorState, displayStyleState, modelSelectorState);
                    break;
                }
                case ViewState_1.ViewState2d.getClassFullName(): {
                    const displayStyleState = new DisplayStyleState_1.DisplayStyle2dState(viewStateData.displayStyleProps, this._iModel);
                    viewState = new ViewState_1.ViewState2d(viewStateData.viewDefinitionProps, this._iModel, categorySelectorState, displayStyleState);
                    break;
                }
                case ViewState_1.DrawingViewState.getClassFullName(): {
                    const displayStyleState = new DisplayStyleState_1.DisplayStyle2dState(viewStateData.displayStyleProps, this._iModel);
                    viewState = new ViewState_1.DrawingViewState(viewStateData.viewDefinitionProps, this._iModel, categorySelectorState, displayStyleState);
                    break;
                }
                case ViewState_1.SheetViewState.getClassFullName(): {
                    const displayStyleState = new DisplayStyleState_1.DisplayStyle2dState(viewStateData.displayStyleProps, this._iModel);
                    viewState = new ViewState_1.SheetViewState(viewStateData.viewDefinitionProps, this._iModel, categorySelectorState, displayStyleState);
                    break;
                }
                default:
                    return Promise.reject(new imodeljs_common_1.IModelError(65595 /* WrongClass */, "Invalid ViewState class", bentleyjs_core_1.Logger.logError, loggingCategory, () => viewStateData));
            }
            await viewState.load(); // loads models for ModelSelector
            return viewState;
        }
    }
    IModelConnection.Views = Views;
    /** @hidden */
    // NB: Very WIP.
    class Tiles {
        /** @hidden */
        constructor(iModel) {
            this._iModel = iModel;
        }
        async getTileTreeProps(ids) {
            return imodeljs_common_1.IModelTileRpcInterface.getClient().getTileTreeProps(this._iModel.iModelToken, ids);
        }
        async getTileProps(ids) {
            return imodeljs_common_1.IModelTileRpcInterface.getClient().getTileProps(this._iModel.iModelToken, ids);
        }
    }
    IModelConnection.Tiles = Tiles;
})(IModelConnection = exports.IModelConnection || (exports.IModelConnection = {}));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const AuxCoordSys_1 = __webpack_require__(207);
const EntityState_1 = __webpack_require__(53);
const bentleyjs_core_2 = __webpack_require__(0);
const MeshPrimitives_1 = __webpack_require__(43);
const IModelApp_1 = __webpack_require__(5);
const Viewport_1 = __webpack_require__(44);
const AnalyticGeometry_1 = __webpack_require__(11);
const ModelState_1 = __webpack_require__(76);
const Sheet_1 = __webpack_require__(340);
const TileTree_1 = __webpack_require__(62);
/** @hidden */
// tslint:disable-next-line:variable-name
exports.StandardView = {
    Top: geometry_core_1.RotMatrix.identity,
    Bottom: geometry_core_1.RotMatrix.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1),
    Left: geometry_core_1.RotMatrix.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0),
    Right: geometry_core_1.RotMatrix.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0),
    Front: geometry_core_1.RotMatrix.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0),
    Back: geometry_core_1.RotMatrix.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0),
    Iso: geometry_core_1.RotMatrix.createRowValues(0.707106781186548, -0.70710678118654757, 0.00000000000000000, 0.408248290463863, 0.40824829046386302, 0.81649658092772603, -0.577350269189626, -0.57735026918962573, 0.57735026918962573),
    RightIso: geometry_core_1.RotMatrix.createRowValues(0.707106781186548, 0.70710678118654757, 0.00000000000000000, -0.408248290463863, 0.40824829046386302, 0.81649658092772603, 0.577350269189626, -0.57735026918962573, 0.57735026918962573),
};
Object.freeze(exports.StandardView);
const standardViewMatrices = [
    exports.StandardView.Top, exports.StandardView.Bottom, exports.StandardView.Left, exports.StandardView.Right,
    exports.StandardView.Front, exports.StandardView.Back, exports.StandardView.Iso, exports.StandardView.RightIso,
];
standardViewMatrices.forEach((view) => Object.freeze(view));
Object.freeze(standardViewMatrices);
/**
 * Margins for white space to be left around view volumes for ViewDefinition.lookAtVolume.
 * Values mean "percent of view" and must be between 0 and .25.
 */
class MarginPercent {
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        const limitMargin = (val) => (val < 0.0) ? 0.0 : (val > .25) ? .25 : val;
        this.left = limitMargin(left);
        this.top = limitMargin(top);
        this.right = limitMargin(right);
        this.bottom = limitMargin(bottom);
    }
}
exports.MarginPercent = MarginPercent;
/**
 * Stores information about sub-categories specific to a ViewState. Functions as a lazily-populated cache.
 */
class ViewSubCategories {
    constructor() {
        this._byCategoryId = new Map();
        this._appearances = new Map();
    }
    /** Get the Ids of all subcategories belonging to the category with the specified Id, or undefined if no such information is present. */
    getSubCategories(categoryId) { return this._byCategoryId.get(categoryId); }
    /** Get the base appearance of the subcategory with the specified Id, or undefined if no such information is present. */
    getSubCategoryAppearance(subCategoryId) { return this._appearances.get(subCategoryId); }
    /** Asynchronously populates this cache with information about subcategories belonging to the specified set of categories. */
    async load(categoryIds, iModel) {
        const where = [...categoryIds].join(",");
        if (0 === where.length)
            return Promise.resolve();
        const ecsql = "SELECT ECInstanceId as id, Parent.Id as parentId, Properties as appearance FROM BisCore.SubCategory WHERE Parent.Id IN (" + where + ")";
        return iModel.executeQuery(ecsql).then((rows) => this.loadFromRows(rows));
    }
    /**
     * If information for subcategories belonging to the specified categories is not present, enqueues an asynchronous request to load it.
     * When the request completes, the ViewState's feature overrides will be marked dirty to indicate they must be updated.
     */
    update(addedCategoryIds, view) {
        let missing;
        for (const catId of addedCategoryIds) {
            if (undefined === this._byCategoryId.get(catId)) {
                if (undefined === missing)
                    missing = new Set();
                missing.add(catId);
            }
        }
        if (undefined !== missing)
            this.load(missing, view.iModel).then(() => view.setFeatureOverridesDirty());
    }
    loadFromRows(rows) {
        for (const row of rows)
            this.add(row.parentId, row.id, new imodeljs_common_1.SubCategoryAppearance(JSON.parse(row.appearance)));
    }
    add(categoryId, subCategoryId, appearance) {
        let set = this._byCategoryId.get(categoryId);
        if (undefined === set)
            this._byCategoryId.set(categoryId, set = new Set());
        set.add(subCategoryId);
        this._appearances.set(subCategoryId, appearance);
    }
}
exports.ViewSubCategories = ViewSubCategories;
/**
 * The state of a ViewDefinition element. ViewDefinitions specify the area/volume that is viewed, and points to a DisplayStyle and a CategorySelector.
 * Subclasses of ViewDefinition determine which model(s) are viewed.
 * * @see [Views]($docs/learning/frontend/Views.md)
 */
class ViewState extends EntityState_1.ElementState {
    constructor(props, iModel, categorySelector, displayStyle) {
        super(props, iModel);
        this.categorySelector = categorySelector;
        this.displayStyle = displayStyle;
        this._featureOverridesDirty = true;
        this._selectionSetDirty = true;
        this.subCategories = new ViewSubCategories();
        this._alwaysDrawnExclusive = false;
        this.description = props.description;
        this.isPrivate = props.isPrivate;
        if (categorySelector instanceof ViewState) {
            this.categorySelector = categorySelector.categorySelector.clone();
            this.displayStyle = categorySelector.displayStyle.clone();
            this.subCategories = categorySelector.subCategories; // NB: This is a cache. No reason to deep-copy.
        }
    }
    static get className() { return "ViewDefinition"; }
    /** get the ViewFlags from the displayStyle of this ViewState. */
    get viewFlags() { return this.displayStyle.viewFlags; }
    /** Set the ViewFlags and mark them as dirty if they have changed. */
    set viewFlags(newFlags) {
        if (!this.viewFlags.isEqualTo(newFlags)) {
            this.setFeatureOverridesDirty();
            this.displayStyle.viewFlags = newFlags;
        }
    }
    /** determine whether this ViewState exactly matches another */
    equals(other) { return super.equals(other) && this.categorySelector.equals(other.categorySelector) && this.displayStyle.equals(other.displayStyle); }
    /** determine whether this ViewState matches another for the purpose of visually matching another view state (not exact equality) */
    equalState(other) {
        if (this.isPrivate !== other.isPrivate)
            return false;
        if (!this.categorySelector.id.equals(other.categorySelector.id))
            return false;
        if (!this.displayStyle.id.equals(other.displayStyle.id))
            return false;
        if (!this.categorySelector.equalState(other.categorySelector))
            return false;
        if (!this.displayStyle.equalState(other.displayStyle))
            return false;
        return JSON.stringify(this.getDetails()) === (JSON.stringify(other.getDetails()));
    }
    toJSON() {
        const json = super.toJSON();
        json.categorySelectorId = this.categorySelector.id;
        json.displayStyleId = this.displayStyle.id;
        json.isPrivate = this.isPrivate;
        json.description = this.description;
        return json;
    }
    /** Asynchronously load any required data for this ViewState from the backend.
     * @note callers should await the Promise returned by this method before using this ViewState.
     * @see [Views]($docs/learning/frontend/Views.md)
     */
    async load() {
        this._auxCoordSystem = undefined;
        const acsId = this.getAuxiliaryCoordinateSystemId();
        if (acsId.isValid()) {
            const props = await this.iModel.elements.getProps(acsId);
            this._auxCoordSystem = AuxCoordSys_1.AuxCoordSystemState.fromProps(props[0], this.iModel);
        }
        return this.subCategories.load(this.categorySelector.categories, this.iModel);
    }
    /** Get the name of the ViewDefinition of this ViewState */
    get name() { return this.code.getValue(); }
    /** Get the background color */
    get backgroundColor() { return this.displayStyle.backgroundColor; }
    get neverDrawn() { return this._neverDrawn; }
    get alwaysDrawn() { return this._alwaysDrawn; }
    clearAlwaysDrawn() {
        if (undefined !== this.alwaysDrawn && 0 < this.alwaysDrawn.size) {
            this.alwaysDrawn.clear();
            this._alwaysDrawnExclusive = false;
            this.setFeatureOverridesDirty();
        }
    }
    clearNeverDrawn() {
        if (undefined !== this.neverDrawn && 0 < this.neverDrawn.size) {
            this.neverDrawn.clear();
            this.setFeatureOverridesDirty();
        }
    }
    setNeverDrawn(ids) {
        this._neverDrawn = ids;
        this.setFeatureOverridesDirty();
    }
    setAlwaysDrawn(ids, exclusive = false) {
        this._alwaysDrawn = ids;
        this._alwaysDrawnExclusive = exclusive;
        this.setFeatureOverridesDirty();
    }
    dropSubCategoryOverride(id) {
        this.displayStyle.dropSubCategoryOverride(id);
        this.setFeatureOverridesDirty();
    }
    overrideSubCategory(id, ovr) {
        this.displayStyle.overrideSubCategory(id, ovr);
        this.setFeatureOverridesDirty();
    }
    getSubCategoryOverride(id) { return this.displayStyle.getSubCategoryOverride(id); }
    /** Returns the appearance of the subcategory with the specified ID within this view, possibly as overridden by the display style. */
    getSubCategoryAppearance(id) {
        const app = this.subCategories.getSubCategoryAppearance(id.value);
        if (undefined === app)
            return imodeljs_common_1.SubCategoryAppearance.defaults;
        const ovr = this.getSubCategoryOverride(id);
        return undefined !== ovr ? ovr.override(app) : app;
    }
    isSubCategoryVisible(id) {
        const app = this.subCategories.getSubCategoryAppearance(id.toString());
        if (undefined === app || app.invisible)
            return false;
        const ovr = this.getSubCategoryOverride(id);
        return undefined === ovr || !ovr.invisible;
    }
    /** Returns true if the set of elements returned by GetAlwaysDrawn() are the *only* elements rendered by this view controller */
    get isAlwaysDrawnExclusive() { return this._alwaysDrawnExclusive; }
    changeCategoryDisplay(arg, add) {
        if (add) {
            this.categorySelector.addCategories(arg);
            this.subCategories.update(bentleyjs_core_1.Id64.toIdSet(arg), this);
        }
        else {
            this.categorySelector.dropCategories(arg);
        }
        this.setFeatureOverridesDirty();
    }
    /** Returns true if the set of elements returned by GetAlwaysDrawn() are the *only* elements rendered by this view */
    get areFeatureOverridesDirty() { return this._featureOverridesDirty; }
    get isSelectionSetDirty() { return this._selectionSetDirty; }
    setFeatureOverridesDirty(dirty = true) { this._featureOverridesDirty = dirty; }
    setSelectionSetDirty(dirty = true) { this._selectionSetDirty = dirty; }
    is3d() { return this instanceof ViewState3d; }
    isSpatialView() { return this instanceof SpatialViewState; }
    createScene(context) { this.forEachModel((model) => this.addModelToScene(model, context)); }
    static getStandardViewMatrix(id) { if (id < 0 /* Top */ || id > 7 /* RightIso */)
        id = 0 /* Top */; return standardViewMatrices[id]; }
    setStandardRotation(id) { this.setRotation(ViewState.getStandardViewMatrix(id)); }
    /**  Get the target point of the view. If there is no camera, center is returned. */
    getTargetPoint(result) { return this.getCenter(result); }
    /**  Get the point at the geometric center of the view. */
    getCenter(result) {
        const delta = this.getRotation().transpose().multiplyVector(this.getExtents());
        return this.getOrigin().plusScaled(delta, 0.5, result);
    }
    drawGrid(context) {
        const vp = context.viewport;
        if (!vp.isGridOn)
            return;
        const orientation = this.getGridOrientation();
        if (4 /* AuxCoord */ === orientation) {
            this.auxiliaryCoordinateSystem.drawGrid(context);
            return;
        }
        else if (5 /* GeoCoord */ === orientation) {
            // NEEDSWORK...
        }
        const isoGrid = false;
        const gridsPerRef = this.getGridsPerRef();
        const spacing = geometry_core_1.Point2d.createFrom(this.getGridSpacing());
        const origin = geometry_core_1.Point3d.create();
        const matrix = geometry_core_1.RotMatrix.createIdentity();
        const fixedRepsAuto = geometry_core_1.Point2d.create();
        this.getGridSettings(vp, origin, matrix, orientation);
        context.drawStandardGrid(origin, matrix, spacing, gridsPerRef, isoGrid, orientation !== 0 /* View */ ? fixedRepsAuto : undefined);
    }
    computeRootToNpc() {
        const viewRot = this.getRotation();
        const delta = this.getExtents();
        const inOrigin = this.getOrigin();
        const xVector = viewRot.rowX();
        const yVector = viewRot.rowY();
        const zVector = viewRot.rowZ();
        let frustFraction = 1.0;
        let xExtent;
        let yExtent;
        let zExtent;
        let origin;
        // Compute root vectors along edges of view frustum.
        if (this.is3d() && this.isCameraOn()) {
            const camera = this.camera;
            const eyeToOrigin = geometry_core_1.Vector3d.createStartEnd(camera.eye, inOrigin); // vector from origin on backplane to eye
            viewRot.multiplyVectorInPlace(eyeToOrigin); // align with view coordinates.
            const focusDistance = camera.focusDist;
            let zDelta = delta.z;
            let zBack = eyeToOrigin.z; // Distance from eye to backplane.
            let zFront = zBack + zDelta; // Distance from eye to frontplane.
            if (zFront / zBack < Viewport_1.Viewport.nearScale24) {
                const maximumBackClip = 10000 * geometry_core_1.Constant.oneKilometer;
                if (-zBack > maximumBackClip) {
                    zBack = -maximumBackClip;
                    eyeToOrigin.z = zBack;
                }
                zFront = zBack * Viewport_1.Viewport.nearScale24;
                zDelta = zFront - eyeToOrigin.z;
            }
            // z out back of eye ====> origin z coordinates are negative.  (Back plane more negative than front plane)
            const backFraction = -zBack / focusDistance; // Perspective fraction at back clip plane.
            const frontFraction = -zFront / focusDistance; // Perspective fraction at front clip plane.
            frustFraction = frontFraction / backFraction;
            // delta.x,delta.y are view rectangle sizes at focus distance.  Scale to back plane:
            xExtent = xVector.scale(delta.x * backFraction); // xExtent at back == delta.x * backFraction.
            yExtent = yVector.scale(delta.y * backFraction); // yExtent at back == delta.y * backFraction.
            // Calculate the zExtent in the View coordinate system.
            zExtent = new geometry_core_1.Vector3d(eyeToOrigin.x * (frontFraction - backFraction), // eyeToOrigin.x * frontFraction - eyeToOrigin.x * backFraction
            eyeToOrigin.y * (frontFraction - backFraction), // eyeToOrigin.y * frontFraction - eyeToOrigin.y * backFraction
            zDelta);
            viewRot.multiplyVectorInPlace(zExtent); // rotate back to root coordinates.
            origin = new geometry_core_1.Point3d(eyeToOrigin.x * backFraction, // Calculate origin in eye coordinates
            eyeToOrigin.y * backFraction, eyeToOrigin.z);
            viewRot.multiplyTransposeVectorInPlace(origin); // Rotate back to root coordinates
            origin.plus(camera.eye, origin); // Add the eye point.
        }
        else {
            origin = inOrigin;
            xExtent = xVector.scale(delta.x);
            yExtent = yVector.scale(delta.y);
            zExtent = zVector.scale(delta.z);
        }
        // calculate the root-to-npc mapping (using expanded frustum)
        return geometry_core_1.Map4d.createVectorFrustum(origin, xExtent, yExtent, zExtent, frustFraction);
    }
    /**
     * Calculate the world coordinate Frustum from the parameters of this ViewState.
     * @param result Optional Frustum to hold result. If undefined a new Frustum is created.
     * @returns The 8-point Frustum with the corners of this ViewState, or undefined if the parameters are invalid.
     */
    calculateFrustum(result) {
        const rootToNpc = this.computeRootToNpc();
        if (undefined === rootToNpc)
            return undefined;
        const box = result ? result.initNpc() : new imodeljs_common_1.Frustum();
        rootToNpc.transform1.multiplyPoint3dArrayQuietNormalize(box.points);
        return box;
    }
    /**
     * Initialize the origin, extents, and rotation from an existing Frustum
     * @param frustum the input Frustum.
     */
    setupFromFrustum(inFrustum) {
        const frustum = inFrustum.clone(); // make sure we don't modify input frustum
        frustum.fixPointOrder();
        const frustPts = frustum.points;
        const viewOrg = frustPts[0 /* LeftBottomRear */];
        // frustumX, frustumY, frustumZ are vectors along edges of the frustum. They are NOT unit vectors.
        // X and Y should be perpendicular, and Z should be right handed.
        const frustumX = geometry_core_1.Vector3d.createFrom(frustPts[1 /* RightBottomRear */].minus(viewOrg));
        const frustumY = geometry_core_1.Vector3d.createFrom(frustPts[2 /* LeftTopRear */].minus(viewOrg));
        const frustumZ = geometry_core_1.Vector3d.createFrom(frustPts[4 /* LeftBottomFront */].minus(viewOrg));
        const frustMatrix = geometry_core_1.RotMatrix.createRigidFromColumns(frustumX, frustumY, 0 /* XYZ */);
        if (!frustMatrix)
            return 7 /* InvalidWindow */;
        // if we're close to one of the standard views, adjust to it to remove any "fuzz"
        standardViewMatrices.some((test) => { if (test.maxDiff(frustMatrix) > 1.0e-7)
            return false; frustMatrix.setFrom(test); return true; });
        const xDir = frustMatrix.getColumn(0);
        const yDir = frustMatrix.getColumn(1);
        const zDir = frustMatrix.getColumn(2);
        // set up view Rotation matrix as rows of frustum matrix.
        const viewRot = frustMatrix.inverse();
        if (!viewRot)
            return 7 /* InvalidWindow */;
        // Left handed frustum?
        const zSize = zDir.dotProduct(frustumZ);
        if (zSize < 0.0)
            return 7 /* InvalidWindow */;
        const viewDiagRoot = new geometry_core_1.Vector3d();
        viewDiagRoot.plus2Scaled(xDir, xDir.dotProduct(frustumX), yDir, yDir.dotProduct(frustumY), viewDiagRoot); // vectors on the back plane
        viewDiagRoot.plusScaled(zDir, zSize, viewDiagRoot); // add in z vector perpendicular to x,y
        // use center of frustum and view diagonal for origin. Original frustum may not have been orthogonal
        frustum.getCenter().plusScaled(viewDiagRoot, -0.5, viewOrg);
        // delta is in view coordinates
        const viewDelta = viewRot.multiplyVector(viewDiagRoot);
        const validSize = this.validateViewDelta(viewDelta, false);
        if (validSize !== 0 /* Success */)
            return validSize;
        this.setOrigin(viewOrg);
        this.setExtents(viewDelta);
        this.setRotation(viewRot);
        return 0 /* Success */;
    }
    /** get the largest and smallest values allowed for the extents for this ViewState
     * @returns an object with members {min, max}
     */
    getExtentLimits() { return { min: geometry_core_1.Constant.oneMillimeter, max: 2.0 * geometry_core_1.Constant.diameterOfEarth }; }
    setDisplayStyle(style) { this.displayStyle = style; }
    getDetails() { if (!this.jsonProperties.viewDetails)
        this.jsonProperties.viewDetails = new Object(); return this.jsonProperties.viewDetails; }
    adjustAspectRatio(windowAspect) {
        const extents = this.getExtents();
        const viewAspect = extents.x / extents.y;
        windowAspect *= this.getAspectRatioSkew();
        if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)
            return;
        const oldDelta = extents.clone();
        if (viewAspect > windowAspect)
            extents.y = extents.x / windowAspect;
        else
            extents.x = extents.y * windowAspect;
        let origin = this.getOrigin();
        const trans = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createZero(), this.getRotation());
        const newOrigin = trans.multiplyPoint3d(origin);
        newOrigin.x += ((oldDelta.x - extents.x) / 2.0);
        newOrigin.y += ((oldDelta.y - extents.y) / 2.0);
        origin = trans.inverse().multiplyPoint3d(newOrigin);
        this.setOrigin(origin);
        this.setExtents(extents);
    }
    validateViewDelta(delta, messageNeeded) {
        const limit = this.getExtentLimits();
        let error = 0 /* Success */;
        const limitWindowSize = (v, ignoreError) => {
            if (v < limit.min) {
                v = limit.min;
                if (!ignoreError)
                    error = 8 /* MinWindow */;
            }
            else if (v > limit.max) {
                v = limit.max;
                if (!ignoreError)
                    error = 9 /* MaxWindow */;
            }
            return v;
        };
        delta.x = limitWindowSize(delta.x, false);
        delta.y = limitWindowSize(delta.y, false);
        delta.z = limitWindowSize(delta.z, true); // We ignore z error messages for the sake of 2D views
        if (messageNeeded && error !== 0 /* Success */) {
            //      Viewport::OutputFrustumErrorMessage(error);
        }
        return error;
    }
    /** Peek to see if a detail is defined. May return undefined. */
    peekDetail(name) { return this.getDetails()[name]; }
    /** Get the current value of a view detail. If not present, return empty object. */
    getDetail(name) { const v = this.getDetails()[name]; return v ? v : {}; }
    /** Change the value of a view detail. */
    setDetail(name, value) { this.getDetails()[name] = value; }
    /** Remove a view detail. */
    removeDetail(name) { delete this.getDetails()[name]; }
    /** Set the CategorySelector for this view. */
    setCategorySelector(categories) { this.categorySelector = categories; }
    /** get the auxiliary coordinate system state object for this ViewState, if present */
    get auxiliaryCoordinateSystem() {
        if (!this._auxCoordSystem)
            this._auxCoordSystem = this.createAuxCoordSystem("");
        return this._auxCoordSystem;
    }
    /** Get the AuxiliaryCoordinateSystem for this ViewDefinition */
    getAuxiliaryCoordinateSystemId() { return bentleyjs_core_1.Id64.fromJSON(this.getDetail("acs")); }
    /** Set or clear the AuxiliaryCoordinateSystem for this view.
     * @param acs the new AuxiliaryCoordinateSystem for this view. If undefined, no AuxiliaryCoordinateSystem will be used.
     */
    setAuxiliaryCoordinateSystem(acs) {
        this._auxCoordSystem = acs;
        if (acs)
            this.setDetail("acs", acs.id.value);
        else
            this.removeDetail("acs");
    }
    /** Determine whether the specified Category is displayed in this view */
    viewsCategory(id) { return this.categorySelector.isCategoryViewed(id); }
    /**  Get the aspect ratio (width/height) of this view */
    getAspectRatio() { const extents = this.getExtents(); return extents.x / extents.y; }
    /** Get the aspect ratio skew (x/y, usually 1.0) that is used to exaggerate one axis of the view. */
    getAspectRatioSkew() { return bentleyjs_core_1.JsonUtils.asDouble(this.getDetail("aspectSkew"), 1.0); }
    /** Set the aspect ratio skew (x/y) for this view. To remove aspect ratio skew, pass 1.0 for val. */
    setAspectRatioSkew(val) {
        if (!val || val === 1.0) {
            this.removeDetail("aspectSkew");
        }
        else {
            this.setDetail("aspectSkew", val);
        }
    }
    /** Get the unit vector that points in the view X (left-to-right) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getXVector(result) { return this.getRotation().getRow(0, result); }
    /** Get the unit vector that points in the view Y (bottom-to-top) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getYVector(result) { return this.getRotation().getRow(1, result); }
    /** Get the unit vector that points in the view Z (front-to-back) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getZVector(result) { return this.getRotation().getRow(2, result); }
    /** Set or clear the clipping volume for this view.
     * @param clip the new clipping volume. If undefined, clipping is removed from view.
     */
    setViewClip(clip) {
        if (clip && clip.isValid())
            this.setDetail("clip", clip.toJSON());
        else
            this.removeDetail("clip");
    }
    /** Get the clipping volume for this view, if defined */
    getViewClip() {
        const clip = this.peekDetail("clip");
        if (clip === undefined)
            return undefined;
        const clipVector = geometry_core_1.ClipVector.fromJSON(clip);
        return clipVector.isValid() ? clipVector : undefined;
    }
    /** Set the grid settings for this view */
    setGridSettings(orientation, spacing, gridsPerRef) {
        switch (orientation) {
            case 2 /* WorldYZ */:
            case 3 /* WorldXZ */:
                if (!this.is3d())
                    return;
                break;
            case 5 /* GeoCoord */:
                if (!this.isSpatialView())
                    return;
                break;
        }
        const details = this.getDetails();
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridOrient", orientation, 1 /* WorldXY */);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridPerRef", gridsPerRef, 10);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridSpaceX", spacing.x, 1.0);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridSpaceY", spacing.y, spacing.x);
    }
    /** Populate the given origin and rotation with information from the grid settings from the grid orientation. */
    getGridSettings(vp, origin, rMatrix, orientation) {
        // start with global origin (for spatial views) and identity matrix
        rMatrix.setIdentity();
        origin.setFrom(vp.view.isSpatialView() ? vp.view.iModel.globalOrigin : geometry_core_1.Point3d.create());
        switch (orientation) {
            case 0 /* View */: {
                const centerWorld = geometry_core_1.Point3d.create(0.5, 0.5, 0.5);
                vp.npcToWorld(centerWorld, centerWorld);
                rMatrix.setFrom(vp.rotMatrix);
                rMatrix.multiplyXYZtoXYZ(origin, origin);
                origin.z = centerWorld.z;
                rMatrix.multiplyTransposeVectorInPlace(origin);
                break;
            }
            case 1 /* WorldXY */:
                break;
            case 2 /* WorldYZ */: {
                const rowX = rMatrix.getRow(0);
                const rowY = rMatrix.getRow(1);
                const rowZ = rMatrix.getRow(2);
                rMatrix.setRow(0, rowY);
                rMatrix.setRow(1, rowZ);
                rMatrix.setRow(2, rowX);
                break;
            }
            case 3 /* WorldXZ */: {
                const rowX = rMatrix.getRow(0);
                const rowY = rMatrix.getRow(1);
                const rowZ = rMatrix.getRow(2);
                rMatrix.setRow(0, rowX);
                rMatrix.setRow(1, rowZ);
                rMatrix.setRow(2, rowY);
                break;
            }
        }
    }
    /** Get the grid settings for this view */
    getGridOrientation() { return bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridOrient"), 1 /* WorldXY */); }
    getGridsPerRef() { return bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridPerRef"), 10); }
    getGridSpacing() {
        const x = bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridSpaceX"), 1.0);
        return { x, y: bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridSpaceY"), x) };
    }
    /**
     * Change the volume that this view displays, keeping its current rotation.
     * @param worldVolume The new volume, in world-coordinates, for the view. The resulting view will show all of worldVolume, by fitting a
     * view-axis-aligned bounding box around it. For views that are not aligned with the world coordinate system, this will sometimes
     * result in a much larger volume than worldVolume.
     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not
     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.
     * @param margin The amount of "white space" to leave around the view volume (which essentially increases the volume
     * of space shown in the view.) If undefined, no additional white space is added.
     * @note for 2d views, only the X and Y values of volume are used.
     */
    lookAtVolume(volume, aspect, margin) {
        const rangeBox = volume.corners();
        this.getRotation().multiplyVectorArrayInPlace(rangeBox);
        return this.lookAtViewAlignedVolume(geometry_core_1.Range3d.createArray(rangeBox), aspect, margin);
    }
    /**
     * look at a volume of space defined by a range in view local coordinates, keeping its current rotation.
     * @param volume The new volume, in view-coordinates, for the view. The resulting view will show all of volume.
     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not
     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.
     * @param margin The amount of "white space" to leave around the view volume (which essentially increases the volume
     * of space shown in the view.) If undefined, no additional white space is added.
     * @see lookAtVolume
     */
    lookAtViewAlignedVolume(volume, aspect, margin) {
        if (volume.isNull())
            return;
        const viewRot = this.getRotation();
        const newOrigin = volume.low.clone();
        let newDelta = geometry_core_1.Vector3d.createStartEnd(volume.low, volume.high);
        const minimumDepth = geometry_core_1.Constant.oneMillimeter;
        if (newDelta.z < minimumDepth) {
            newOrigin.z -= (minimumDepth - newDelta.z) / 2.0;
            newDelta.z = minimumDepth;
        }
        let origNewDelta = newDelta.clone();
        const isCameraOn = this.is3d() && this.isCameraOn();
        if (isCameraOn) {
            // If the camera is on, the only way to guarantee we can see the entire volume is to set delta at the front plane, not focus plane.
            // That generally causes the view to be too large (objects in it are too small), since we can't tell whether the objects are at
            // the front or back of the view. For this reason, don't attempt to add any "margin" to camera views.
        }
        else if (margin) {
            // compute how much space we'll need for both of X and Y margins in root coordinates
            const wPercent = margin.left + margin.right;
            const hPercent = margin.top + margin.bottom;
            const marginHorizontal = wPercent / (1 - wPercent) * newDelta.x;
            const marginVert = hPercent / (1 - hPercent) * newDelta.y;
            // compute left and bottom margins in root coordinates
            const marginLeft = margin.left / (1 - wPercent) * newDelta.x;
            const marginBottom = margin.bottom / (1 - hPercent) * newDelta.y;
            // add the margins to the range
            newOrigin.x -= marginLeft;
            newOrigin.y -= marginBottom;
            newDelta.x += marginHorizontal;
            newDelta.y += marginVert;
            // don't fix the origin due to changes in delta here
            origNewDelta = newDelta.clone();
        }
        else {
            newDelta.scale(1.04, newDelta); // default "dilation"
        }
        if (isCameraOn) {
            // make sure that the zDelta is large enough so that entire model will be visible from any rotation
            const diag = newDelta.magnitudeXY();
            if (diag > newDelta.z)
                newDelta.z = diag;
        }
        this.validateViewDelta(newDelta, true);
        this.setExtents(newDelta);
        if (aspect)
            this.adjustAspectRatio(aspect);
        newDelta = this.getExtents();
        newOrigin.x -= (newDelta.x - origNewDelta.x) / 2.0;
        newOrigin.y -= (newDelta.y - origNewDelta.y) / 2.0;
        newOrigin.z -= (newDelta.z - origNewDelta.z) / 2.0;
        viewRot.multiplyTransposeVectorInPlace(newOrigin);
        this.setOrigin(newOrigin);
        if (!this.is3d())
            return;
        const cameraDef = this.camera;
        cameraDef.validateLens();
        // move the camera back so the entire x,y range is visible at front plane
        const frontDist = Math.max(newDelta.x, newDelta.y) / (2.0 * Math.tan(cameraDef.getLensAngle().radians / 2.0));
        const backDist = frontDist + newDelta.z;
        cameraDef.setFocusDistance(frontDist); // do this even if the camera isn't currently on.
        this.centerEyePoint(backDist); // do this even if the camera isn't currently on.
        this.verifyFocusPlane(); // changes delta/origin
    }
    addModelToScene(model, context) {
        model.loadTileTree();
        if (undefined !== model.tileTree)
            model.tileTree.drawScene(context);
    }
    /**
     * Set the rotation of this ViewState to the supplied rotation, by rotating it about a point.
     * @param rotation The new rotation matrix for this ViewState.
     * @param point The point to rotate about. If undefined, use the [[getTargetPoint]].
     */
    setRotationAboutPoint(rotation, point) {
        if (undefined === point)
            point = this.getTargetPoint();
        const inverse = rotation.clone().inverse();
        if (undefined === inverse)
            return;
        const targetMatrix = inverse.multiplyMatrixMatrix(this.getRotation());
        const worldTransform = geometry_core_1.Transform.createFixedPointAndMatrix(point, targetMatrix);
        const frustum = this.calculateFrustum();
        if (undefined !== frustum) {
            frustum.multiply(worldTransform);
            this.setupFromFrustum(frustum);
        }
    }
}
exports.ViewState = ViewState;
/** Defines the state of a view of 3d models.
 * @see [ViewState Parameters]($docs/learning/frontend/views#viewstate-parameters)
 */
class ViewState3d extends ViewState {
    constructor(props, iModel, categories, displayStyle) {
        super(props, iModel, categories, displayStyle);
        /** Minimum distance for front plane */
        this.forceMinFrontDist = 0.0;
        this.cameraOn = bentleyjs_core_1.JsonUtils.asBool(props.cameraOn);
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.extents = geometry_core_1.Vector3d.fromJSON(props.extents);
        this.rotation = geometry_core_1.YawPitchRollAngles.fromJSON(props.angles).toRotMatrix();
        bentleyjs_core_2.assert(this.rotation.isRigid());
        this.camera = new imodeljs_common_1.Camera(props.camera);
    }
    /** @hidden */
    static get className() { return "ViewDefinition3d"; }
    onRenderFrame(_viewport) { }
    allow3dManipulations() { return true; }
    toJSON() {
        const val = super.toJSON();
        val.cameraOn = this.cameraOn;
        val.origin = this.origin;
        val.extents = this.extents;
        val.angles = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(this.rotation).toJSON();
        bentleyjs_core_2.assert(undefined !== val.angles, "rotMatrix is illegal");
        val.camera = this.camera;
        return val;
    }
    equalState(other) {
        if (!this.origin.isAlmostEqual(other.origin) || !this.extents.isAlmostEqual(other.extents) || !this.rotation.isAlmostEqual(other.rotation))
            return false;
        if (this.isCameraOn() !== other.isCameraOn())
            return false;
        if (this.isCameraOn() && this.camera.equals(other.camera))
            return false;
        return super.equalState(other);
    }
    isCameraOn() { return this.cameraOn; }
    setupFromFrustum(frustum) {
        const stat = super.setupFromFrustum(frustum);
        if (0 /* Success */ !== stat)
            return stat;
        this.turnCameraOff();
        const frustPts = frustum.points;
        // use comparison of back, front plane X sizes to indicate camera or flat view ...
        const xBack = frustPts[0 /* LeftBottomRear */].distance(frustPts[1 /* RightBottomRear */]);
        const xFront = frustPts[4 /* LeftBottomFront */].distance(frustPts[5 /* RightBottomFront */]);
        const flatViewFractionTolerance = 1.0e-6;
        if (xFront > xBack * (1.0 + flatViewFractionTolerance))
            return 7 /* InvalidWindow */;
        // see if the frustum is tapered, and if so, set up camera eyepoint and adjust viewOrg and delta.
        const compression = xFront / xBack;
        if (compression >= (1.0 - flatViewFractionTolerance))
            return 0 /* Success */;
        // the frustum has perspective, turn camera on
        let viewOrg = frustPts[0 /* LeftBottomRear */];
        const viewDelta = this.getExtents().clone();
        const zDir = this.getZVector();
        const frustumZ = viewOrg.vectorTo(frustPts[4 /* LeftBottomFront */]);
        const frustOrgToEye = frustumZ.scale(1.0 / (1.0 - compression));
        const eyePoint = viewOrg.plus(frustOrgToEye);
        const backDistance = frustOrgToEye.dotProduct(zDir); // distance from eye to back plane of frustum
        const focusDistance = backDistance - (viewDelta.z / 2.0);
        const focalFraction = focusDistance / backDistance; // ratio of focus plane distance to back plane distance
        viewOrg = eyePoint.plus2Scaled(frustOrgToEye, -focalFraction, zDir, focusDistance - backDistance); // now project that point onto back plane
        viewDelta.x *= focalFraction; // adjust view delta for x and y so they are also at focus plane
        viewDelta.y *= focalFraction;
        this.setEyePoint(eyePoint);
        this.setFocusDistance(focusDistance);
        this.setOrigin(viewOrg);
        this.setExtents(viewDelta);
        this.setLensAngle(this.calcLensAngle());
        this.enableCamera();
        return 0 /* Success */;
    }
    static calculateMaxDepth(delta, zVec) {
        const depthRatioLimit = 1.0E8; // Limit for depth Ratio.
        const maxTransformRowRatio = 1.0E5;
        const minXYComponent = Math.min(Math.abs(zVec.x), Math.abs(zVec.y));
        const maxDepthRatio = (0.0 === minXYComponent) ? depthRatioLimit : Math.min((maxTransformRowRatio / minXYComponent), depthRatioLimit);
        return Math.max(delta.x, delta.y) * maxDepthRatio;
    }
    getOrigin() { return this.origin; }
    getExtents() { return this.extents; }
    getRotation() { return this.rotation; }
    setOrigin(origin) { this.origin.setFrom(origin); }
    setExtents(extents) { this.extents.setFrom(extents); }
    setRotation(rot) { this.rotation.setFrom(rot); }
    /** @hidden */
    enableCamera() { if (this.supportsCamera())
        this.cameraOn = true; }
    supportsCamera() { return true; }
    minimumFrontDistance() { return Math.max(15.2 * geometry_core_1.Constant.oneCentimeter, this.forceMinFrontDist); }
    isEyePointAbove(elevation) { return !this.cameraOn ? (this.getZVector().z > 0) : (this.getEyePoint().z > elevation); }
    getDisplayStyle3d() { return this.displayStyle; }
    /**
     * Turn the camera off for this view. After this call, the camera parameters in this view definition are ignored and views that use it will
     * display with an orthographic (infinite focal length) projection of the view volume from the view direction.
     * @note To turn the camera back on, call #lookAt
     */
    turnCameraOff() { this.cameraOn = false; }
    /** Determine whether the camera is valid for this view */
    isCameraValid() { return this.camera.isValid(); }
    /** Calculate the lens angle formed by the current delta and focus distance */
    calcLensAngle() {
        const maxDelta = Math.max(this.extents.x, this.extents.y);
        return geometry_core_1.Angle.createRadians(2.0 * Math.atan2(maxDelta * 0.5, this.camera.getFocusDistance()));
    }
    /** Get the target point of the view. If there is no camera, view center is returned. */
    getTargetPoint(result) {
        if (!this.cameraOn)
            return super.getTargetPoint(result);
        const viewZ = this.getRotation().getRow(2);
        return this.getEyePoint().plusScaled(viewZ, -1.0 * this.getFocusDistance(), result);
    }
    /**
     * Position the camera for this view and point it at a new target point.
     * @param eyePoint The new location of the camera.
     * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.
     * @param upVector A vector that orients the camera's "up" (view y). This vector must not be parallel to the vector from eye to target.
     * @param newExtents  The new size (width and height) of the view rectangle. The view rectangle is on the focus plane centered on the targetPoint.
     * If newExtents is undefined, the existing size is unchanged.
     * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.
     * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.
     * @returns A [[ViewStatus]] indicating whether the camera was successfully positioned.
     * @note If the aspect ratio of viewDelta does not match the aspect ratio of a Viewport into which this view is displayed, it will be
     * adjusted when the [[Viewport]] is synchronized from this view.
     */
    lookAt(eyePoint, targetPoint, upVector, newExtents, frontDistance, backDistance) {
        const eye = new geometry_core_1.Point3d(eyePoint.x, eyePoint.y, eyePoint.z);
        const yVec = upVector.normalize();
        if (!yVec)
            return 12 /* InvalidUpVector */;
        const zVec = geometry_core_1.Vector3d.createStartEnd(targetPoint, eye); // z defined by direction from eye to target
        const focusDist = zVec.normalizeWithLength(zVec).mag; // set focus at target point
        const minFrontDist = this.minimumFrontDistance();
        if (focusDist <= minFrontDist)
            return 13 /* InvalidTargetPoint */;
        const xVec = new geometry_core_1.Vector3d();
        if (yVec.crossProduct(zVec).normalizeWithLength(xVec).mag < geometry_core_1.Geometry.smallMetricDistance)
            return 12 /* InvalidUpVector */; // up is parallel to z
        if (zVec.crossProduct(xVec).normalizeWithLength(yVec).mag < geometry_core_1.Geometry.smallMetricDistance)
            return 12 /* InvalidUpVector */;
        // we now have rows of the rotation matrix
        const rotation = geometry_core_1.RotMatrix.createRows(xVec, yVec, zVec);
        backDistance = backDistance ? backDistance : this.getBackDistance();
        frontDistance = frontDistance ? frontDistance : this.getFrontDistance();
        const delta = newExtents ? new geometry_core_1.Vector3d(Math.abs(newExtents.x), Math.abs(newExtents.y), this.extents.z) : this.extents.clone();
        frontDistance = Math.max(frontDistance, (.5 * geometry_core_1.Constant.oneMeter));
        backDistance = Math.max(backDistance, focusDist + (.5 * geometry_core_1.Constant.oneMeter));
        if (backDistance < focusDist)
            backDistance = focusDist + geometry_core_1.Constant.oneMillimeter;
        if (frontDistance > focusDist)
            frontDistance = focusDist - minFrontDist;
        if (frontDistance < minFrontDist)
            frontDistance = minFrontDist;
        delta.z = (backDistance - frontDistance);
        const frontDelta = delta.scale(frontDistance / focusDist);
        const stat = this.validateViewDelta(frontDelta, false); // validate window size on front (smallest) plane
        if (0 /* Success */ !== stat)
            return stat;
        if (delta.z > ViewState3d.calculateMaxDepth(delta, zVec))
            return 11 /* MaxDisplayDepth */;
        // The origin is defined as the lower left of the view rectangle on the focus plane, projected to the back plane.
        // Start at eye point, and move to center of back plane, then move left half of width. and down half of height
        const origin = eye.plus3Scaled(zVec, -backDistance, xVec, -0.5 * delta.x, yVec, -0.5 * delta.y);
        this.setEyePoint(eyePoint);
        this.setRotation(rotation);
        this.setFocusDistance(focusDist);
        this.setOrigin(origin);
        this.setExtents(delta);
        this.setLensAngle(this.calcLensAngle());
        this.enableCamera();
        return 0 /* Success */;
    }
    /**
     * Position the camera for this view and point it at a new target point, using a specified lens angle.
     * @param eyePoint The new location of the camera.
     * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.
     * @param upVector A vector that orients the camera's "up" (view y). This vector must not be parallel to the vector from eye to target.
     * @param fov The angle, in radians, that defines the field-of-view for the camera. Must be between .0001 and pi.
     * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.
     * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     * @note The aspect ratio of the view remains unchanged.
     */
    lookAtUsingLensAngle(eyePoint, targetPoint, upVector, fov, frontDistance, backDistance) {
        const focusDist = eyePoint.vectorTo(targetPoint).magnitude(); // Set focus at target point
        if (focusDist <= geometry_core_1.Constant.oneMillimeter)
            return 13 /* InvalidTargetPoint */;
        if (fov.radians < .0001 || fov.radians > Math.PI)
            return 14 /* InvalidLens */;
        const extent = 2.0 * Math.tan(fov.radians / 2.0) * focusDist;
        const delta = geometry_core_1.Vector2d.create(this.extents.x, this.extents.y);
        const longAxis = Math.max(delta.x, delta.y);
        delta.scale(extent / longAxis, delta);
        return this.lookAt(eyePoint, targetPoint, upVector, delta, frontDistance, backDistance);
    }
    /**
     * Move the camera relative to its current location by a distance in camera coordinates.
     * @param distance to move camera. Length is in world units, direction relative to current camera orientation.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    moveCameraLocal(distance) {
        const distWorld = this.getRotation().multiplyTransposeVector(distance);
        return this.moveCameraWorld(distWorld);
    }
    /**
     * Move the camera relative to its current location by a distance in world coordinates.
     * @param distance in world units.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    moveCameraWorld(distance) {
        if (!this.cameraOn) {
            this.origin.plus(distance, this.origin);
            return 0 /* Success */;
        }
        const newTarget = this.getTargetPoint().plus(distance);
        const newEyePt = this.getEyePoint().plus(distance);
        return this.lookAt(newEyePt, newTarget, this.getYVector());
    }
    /**
     * Rotate the camera from its current location about an axis relative to its current orientation.
     * @param angle The angle to rotate the camera.
     * @param axis The axis about which to rotate the camera. The axis is a direction relative to the current camera orientation.
     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place
     *  (i.e. about the current eyePoint).
     * @note Even though the axis is relative to the current camera orientation, the aboutPt is in world coordinates, \b not relative to the camera.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    rotateCameraLocal(angle, axis, aboutPt) {
        const axisWorld = this.getRotation().multiplyTransposeVector(axis);
        return this.rotateCameraWorld(angle, axisWorld, aboutPt);
    }
    /**
     * Rotate the camera from its current location about an axis in world coordinates.
     * @param angle The angle to rotate the camera.
     * @param axis The world-based axis (direction) about which to rotate the camera.
     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place
     *  (i.e. about the current eyePoint).
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    rotateCameraWorld(angle, axis, aboutPt) {
        const about = aboutPt ? aboutPt : this.getEyePoint();
        const rotation = geometry_core_1.RotMatrix.createRotationAroundVector(axis, angle);
        if (!rotation)
            return 12 /* InvalidUpVector */; // Invalid axis given
        const trans = geometry_core_1.Transform.createFixedPointAndMatrix(about, rotation);
        const newTarget = trans.multiplyPoint3d(this.getTargetPoint());
        const upVec = rotation.multiplyVector(this.getYVector());
        return this.lookAt(this.getEyePoint(), newTarget, upVec);
    }
    /** Get the distance from the eyePoint to the front plane for this view. */
    getFrontDistance() { return this.getBackDistance() - this.extents.z; }
    /** Get the distance from the eyePoint to the back plane for this view. */
    getBackDistance() {
        // backDist is the z component of the vector from the origin to the eyePoint .
        const eyeOrg = this.origin.vectorTo(this.getEyePoint());
        this.getRotation().multiplyVector(eyeOrg, eyeOrg);
        return eyeOrg.z;
    }
    /**
     * Place the eyepoint of the camera so it is aligned with the center of the view. This removes any 1-point perspective skewing that may be
     * present in the current view.
     * @param backDistance If defined, the new the distance from the eyepoint to the back plane. Otherwise the distance from the
     * current eyepoint is used.
     */
    centerEyePoint(backDistance) {
        const eyePoint = this.getExtents().scale(0.5);
        eyePoint.z = backDistance ? backDistance : this.getBackDistance();
        const eye = this.getRotation().multiplyTransposeXYZ(eyePoint.x, eyePoint.y, eyePoint.z);
        this.camera.setEyePoint(this.getOrigin().plus(eye));
    }
    /** Center the focus distance of the camera halfway between the front plane and the back plane, keeping the eyepoint,
     * lens angle, rotation, back distance, and front distance unchanged.
     * @note The focus distance, origin, and delta values are modified, but the view encloses the same volume and appears visually unchanged.
     */
    centerFocusDistance() {
        const backDist = this.getBackDistance();
        const frontDist = this.getFrontDistance();
        const eye = this.getEyePoint();
        const target = eye.plusScaled(this.getZVector(), frontDist - backDist);
        this.lookAtUsingLensAngle(eye, target, this.getYVector(), this.getLensAngle(), frontDist, backDist);
    }
    /** Ensure the focus plane lies between the front and back planes. If not, center it. */
    verifyFocusPlane() {
        if (!this.cameraOn)
            return;
        let backDist = this.getBackDistance();
        const frontDist = backDist - this.extents.z;
        const camera = this.camera;
        const extents = this.extents;
        const rot = this.rotation;
        if (backDist <= 0.0 || frontDist <= 0.0) {
            // the camera location is invalid. Set it based on the view range.
            const tanAngle = Math.tan(camera.lens.radians / 2.0);
            backDist = extents.z / tanAngle;
            camera.setFocusDistance(backDist / 2);
            this.centerEyePoint(backDist);
            return;
        }
        const focusDist = camera.focusDist;
        if (focusDist > frontDist && focusDist < backDist)
            return;
        // put it halfway between front and back planes
        camera.setFocusDistance((extents.z / 2.0) + frontDist);
        // moving the focus plane means we have to adjust the origin and delta too (they're on the focus plane, see diagram above)
        const ratio = camera.focusDist / focusDist;
        extents.x *= ratio;
        extents.y *= ratio;
        camera.eye.plus3Scaled(rot.rowZ(), -backDist, rot.rowX(), -0.5 * extents.x, rot.rowY(), -0.5 * extents.y, this.origin); // this centers the camera too
    }
    /** Get the current location of the eyePoint for camera in this view. */
    getEyePoint() { return this.camera.eye; }
    /** Get the lens angle for this view. */
    getLensAngle() { return this.camera.lens; }
    /** Set the lens angle for this view.
     *  @param angle The new lens angle in radians. Must be greater than 0 and less than pi.
     *  @note This does not change the view's current field-of-view. Instead, it changes the lens that will be used if the view
     *  is subsequently modified and the lens angle is used to position the eyepoint.
     *  @note To change the field-of-view (i.e. "zoom") of a view, pass a new viewDelta to #lookAt
     */
    setLensAngle(angle) { this.camera.setLensAngle(angle); }
    /** Change the location of the eyePoint for the camera in this view.
     * @param pt The new eyepoint.
     * @note This method is generally for internal use only. Moving the eyePoint arbitrarily can result in skewed or illegal perspectives.
     * The most common method for user-level camera positioning is #lookAt.
     */
    setEyePoint(pt) { this.camera.setEyePoint(pt); }
    /** Set the focus distance for this view.
     *  @note Changing the focus distance changes the plane on which the delta.x and delta.y values lie. So, changing focus distance
     *  without making corresponding changes to delta.x and delta.y essentially changes the lens angle, causing a "zoom" effect
     */
    setFocusDistance(dist) { this.camera.setFocusDistance(dist); }
    /**  Get the distance from the eyePoint to the focus plane for this view. */
    getFocusDistance() { return this.camera.focusDist; }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystem3dState.createNew(acsName, this.iModel); }
    // ###TODO: Move this back to SpatialViewState...for some reason we always get OrthographicViewState, which we should rarely if ever encounter...
    decorate(context) {
        const useOldSkyBox = true;
        if (useOldSkyBox)
            this.drawSkyBox(context);
        else
            this.drawRealSkyBox(context);
        this.drawGroundPlane(context);
    }
    /** Attempt to extract the eyepoint if the camera is on. Otherwise, compute the eye point from the given frustum. */
    computeEyePoint(frustum) {
        if (this.cameraOn)
            return this.camera.eye;
        const delta = geometry_core_1.Vector3d.createStartEnd(frustum.getCorner(0 /* LeftBottomRear */), frustum.getCorner(4 /* LeftBottomFront */));
        const pseudoCameraHalfAngle = 22.5;
        const diagonal = frustum.getCorner(0 /* LeftBottomRear */).distance(frustum.getCorner(3 /* RightTopRear */));
        const focalLength = diagonal / (2 * Math.atan(pseudoCameraHalfAngle * geometry_core_1.Constant.radiansPerDegree));
        return geometry_core_1.Point3d.add3Scaled(frustum.getCorner(0 /* LeftBottomRear */), .5, frustum.getCorner(3 /* RightTopRear */), .5, delta, focalLength / delta.magnitude());
    }
    /** Calculate a UV coordinate from a vector direction, its rotation, and offset along the z axis. */
    static getUVForDirection(direction, rotation, zOffset) {
        const radius = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
        const zValue = direction.z - radius * zOffset;
        const azimuth = (Math.atan2(direction.y, direction.x) + rotation) / (Math.PI * 2);
        const altitude = Math.atan2(zValue, radius);
        return geometry_core_1.Point2d.create(0.5 - altitude / (Math.PI * 2), 0.25 - azimuth);
    }
    /** Given a graphic builder, construct a mesh grid with corresponding UV coordinates, using data contained within the viewport. */
    drawBackgroundMesh(builder, viewport, rotation, zOffset) {
        /// ### TODO: Until we have more support in geometry package for tracking UV coordinates of higher level geometry
        // we will use a PolyfaceBuilder here to add simple quads in the grid with manually calculated UV params, claim the polyface when finished,
        // and then send that over to the GraphicBuilder
        const strokeOptions = new geometry_core_1.StrokeOptions();
        strokeOptions.needParams = true;
        strokeOptions.needNormals = true;
        strokeOptions.shouldTriangulate = false;
        const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create(strokeOptions);
        polyfaceBuilder.toggleReversedFacetFlag();
        const meshDimension = 10;
        const delta = 1 / (meshDimension - 1);
        const frustum = viewport.getFrustum();
        const cameraPos = this.computeEyePoint(frustum);
        const points = [geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create()];
        const params = [geometry_core_1.Point2d.create(), geometry_core_1.Point2d.create(), geometry_core_1.Point2d.create(), geometry_core_1.Point2d.create()];
        for (let row = 1; row < meshDimension; ++row) {
            for (let col = 1; col < meshDimension; ++col) {
                const low = geometry_core_1.Point2d.create((row - 1) * delta, (col - 1) * delta);
                const high = geometry_core_1.Point2d.create(row * delta, col * delta);
                const npcZ = .5;
                geometry_core_1.Point3d.create(low.x, low.y, npcZ, points[0]);
                geometry_core_1.Point3d.create(high.x, low.y, npcZ, points[1]);
                geometry_core_1.Point3d.create(high.x, high.y, npcZ, points[2]);
                geometry_core_1.Point3d.create(low.x, high.y, npcZ, points[3]);
                viewport.npcToWorldArray(points);
                for (let i = 0; i < 4; i++) {
                    const direction = geometry_core_1.Vector3d.createStartEnd(cameraPos, points[i]);
                    params[i].setFrom(ViewState3d.getUVForDirection(direction, rotation, zOffset));
                }
                // Avoid seam discontinuities by eliminating cycles
                const paramRange = geometry_core_1.Range2d.createArray(params);
                if ((paramRange.high.x - paramRange.low.x) > .5) {
                    for (let i = 0; i < 4; i++)
                        while (params[i].x < .5)
                            params[i].x += 1;
                }
                if ((paramRange.high.y - paramRange.low.y) > .5) {
                    for (let i = 0; i < 4; i++)
                        while (params[i].y < .5)
                            params[i].y += 1;
                }
                viewport.worldToViewArray(points);
                polyfaceBuilder.addQuadFacet(points, params, undefined);
            }
        }
        const polyface = polyfaceBuilder.claimPolyface(false);
        builder.addPolyface(polyface, true);
    }
    /** @hidden */
    drawRealSkyBox(context) {
        const style3d = this.getDisplayStyle3d();
        if (!style3d.getEnvironment().sky.display)
            return;
        const vp = context.viewport;
        style3d.loadSkyBoxParams(vp.target.renderSystem);
        if (undefined !== style3d.skyBoxParams) {
            const skyBoxGraphic = IModelApp_1.IModelApp.renderSystem.createSkyBox(style3d.skyBoxParams);
            context.setSkyBox(skyBoxGraphic);
        }
        else {
            // ###TODO: Skybox textures failed to load. Resort to drawing 'fake' version
        }
    }
    /** @hidden */
    drawSkyBox(context) {
        const style3d = this.getDisplayStyle3d();
        if (!style3d.getEnvironment().sky.display)
            return;
        const vp = context.viewport;
        style3d.loadSkyBoxMaterial(vp.target.renderSystem);
        if (style3d.skyboxMaterial !== undefined) {
            // Create a graphic for the skybox, and assign it the sky material
            const skyGraphic = context.createViewBackground();
            const params = new imodeljs_common_1.GraphicParams();
            params.material = style3d.skyboxMaterial;
            skyGraphic.activateGraphicParams(params);
            // create a 10x10 mesh on the backplane with the sky material mapped to its UV coordinates
            this.drawBackgroundMesh(skyGraphic, vp, 0.0, this.iModel.globalOrigin.z);
            context.setViewBackground(skyGraphic.finish());
        }
        else {
            // Skybox material failed to load. Resort to drawing 'fake' version
            const rect = context.viewport.viewRect;
            const points = [new geometry_core_1.Point3d(0, 0, 0), new geometry_core_1.Point3d(rect.width, 0, 0), new geometry_core_1.Point3d(rect.width, rect.height), new geometry_core_1.Point3d(0, rect.height)];
            const args = new MeshPrimitives_1.MeshArgs();
            args.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createArray(points)));
            for (const point of points)
                args.points.add(point);
            args.vertIndices = [3, 2, 0, 2, 1, 0];
            const colors = new Uint32Array([imodeljs_common_1.ColorByName.red, imodeljs_common_1.ColorByName.yellow, imodeljs_common_1.ColorByName.cyan, imodeljs_common_1.ColorByName.blue]);
            args.colors.initNonUniform(colors, new Uint16Array([0, 1, 2, 3]), false);
            const gf = IModelApp_1.IModelApp.renderSystem.createTriMesh(args);
            if (undefined !== gf)
                context.setViewBackground(gf);
        }
    }
    /** Returns the ground elevation taken from the environment added with the global z position of this imodel. */
    getGroundElevation() {
        const env = this.getDisplayStyle3d().getEnvironment();
        return env.ground.elevation + this.iModel.globalOrigin.z;
    }
    /** Return the ground extents, which will originate either from the viewport frustum or the extents of the imodel. */
    getGroundExtents(vp) {
        const displayStyle = this.getDisplayStyle3d();
        const extents = new imodeljs_common_1.AxisAlignedBox3d();
        if (undefined !== vp && !displayStyle.getEnvironment().ground.display)
            return extents; // Ground plane is not enabled
        const elevation = this.getGroundElevation();
        if (undefined !== vp) {
            const viewRay = AnalyticGeometry_1.Ray3d.create(geometry_core_1.Point3d.create(), vp.rotMatrix.rowZ());
            const xyPlane = AnalyticGeometry_1.Plane3dByOriginAndUnitNormal.create(geometry_core_1.Point3d.create(0, 0, elevation), geometry_core_1.Vector3d.create(0, 0, 1));
            // first determine whether the ground plane is displayed in the view
            const worldFrust = vp.getFrustum();
            for (const point of worldFrust.points) {
                viewRay.origin = point; // We never modify the reference
                const xyzPoint = geometry_core_1.Point3d.create();
                const param = viewRay.intersectionWithPlane(xyPlane, xyzPoint);
                if (param === undefined)
                    return extents; // View does not show ground plane
            }
        }
        extents.setFrom(this.iModel.projectExtents);
        extents.low.z = extents.high.z = elevation;
        const center = extents.low.interpolate(.5, extents.high);
        const radius = extents.low.distance(extents.high);
        extents.setNull();
        extents.extendPoint(center); // Extents now contains single point
        extents.low.addScaledInPlace(geometry_core_1.Vector3d.create(-1, -1, -1), radius);
        extents.high.addScaledInPlace(geometry_core_1.Vector3d.create(1, 1, 1), radius);
        extents.low.z = extents.high.z = elevation;
        return extents;
    }
    /** @hidden */
    drawGroundPlane(context) {
        const extents = this.getGroundExtents(context.viewport);
        if (extents.isNull()) {
            return;
        }
        const ground = this.getDisplayStyle3d().getEnvironment().ground;
        if (!ground.display)
            return;
        const points = [extents.low.clone(), extents.low.clone(), extents.high.clone(), extents.high.clone()];
        points[1].x = extents.high.x;
        points[3].x = extents.low.x;
        const aboveGround = this.isEyePointAbove(extents.low.z);
        const colors = [];
        const gradient = ground.getGroundPlaneTextureSymb(aboveGround, colors);
        const texture = context.viewport.target.renderSystem.getGradientTexture(gradient, this.iModel);
        if (!texture)
            return;
        const matParams = new imodeljs_common_1.RenderMaterial.Params();
        matParams.diffuseColor = imodeljs_common_1.ColorDef.white;
        matParams.shadows = false;
        matParams.ambient = 1;
        matParams.diffuse = 0;
        const mapParams = new imodeljs_common_1.TextureMapping.Params();
        const transform = new imodeljs_common_1.TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0);
        mapParams.textureMatrix = transform;
        mapParams.textureMatrix.setTransform();
        matParams.textureMapping = new imodeljs_common_1.TextureMapping(texture, mapParams);
        const material = context.viewport.target.renderSystem.createMaterial(matParams, this.iModel);
        if (!material)
            return;
        const params = new imodeljs_common_1.GraphicParams();
        params.setLineColor(colors[0]);
        params.setFillColor(imodeljs_common_1.ColorDef.white); // Fill should be set to opaque white for gradient texture...
        params.material = material;
        const builder = context.createWorldDecoration();
        builder.activateGraphicParams(params);
        /// ### TODO: Until we have more support in geometry package for tracking UV coordinates of higher level geometry
        // we will use a PolyfaceBuilder here to add the ground plane as a quad, claim the polyface, and then send that to the GraphicBuilder
        const strokeOptions = new geometry_core_1.StrokeOptions();
        strokeOptions.needParams = true;
        const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create(strokeOptions);
        polyfaceBuilder.toggleReversedFacetFlag();
        const uvParams = [geometry_core_1.Point2d.create(0, 0), geometry_core_1.Point2d.create(1, 0), geometry_core_1.Point2d.create(1, 1), geometry_core_1.Point2d.create(0, 1)];
        polyfaceBuilder.addQuadFacet(points, uvParams);
        const polyface = polyfaceBuilder.claimPolyface(false);
        builder.addPolyface(polyface, true);
        context.addWorldDecoration(builder.finish());
    }
}
exports.ViewState3d = ViewState3d;
/** Defines a view of one or more SpatialModels.
 * The list of viewed models is stored by the ModelSelector.
 */
class SpatialViewState extends ViewState3d {
    constructor(props, iModel, arg3, displayStyle, modelSelector) {
        super(props, iModel, arg3, displayStyle);
        this.modelSelector = modelSelector;
        if (arg3 instanceof SpatialViewState) {
            this.modelSelector = arg3.modelSelector.clone();
        }
    }
    equals(other) { return super.equals(other) && this.modelSelector.equals(other.modelSelector); }
    equalState(other) {
        if (!super.equalState(other))
            return false;
        if (!this.modelSelector.id.equals(other.modelSelector.id))
            return false;
        return this.modelSelector.equalState(other.modelSelector);
    }
    static get className() { return "SpatialViewDefinition"; }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystemSpatialState.createNew(acsName, this.iModel); }
    computeFitRange() {
        // Loop over the current models in the model selector with loaded tile trees and union their ranges
        const range = new imodeljs_common_1.AxisAlignedBox3d();
        this.forEachModel((model) => {
            if (model.tileTree !== undefined && model.tileTree.rootTile !== undefined) {
                range.extendRange(model.tileTree.rootTile.computeWorldContentRange());
            }
        });
        if (range.isNull())
            range.setFrom(this.getViewedExtents());
        range.ensureMinLengths(1.0);
        return range;
    }
    getViewedExtents() {
        const extents = imodeljs_common_1.AxisAlignedBox3d.fromJSON(this.iModel.projectExtents);
        extents.scaleAboutCenterInPlace(1.0001); // projectExtents. lying smack up against the extents is not excluded by frustum...
        extents.extendRange(this.getGroundExtents());
        return extents;
    }
    toJSON() {
        const val = super.toJSON();
        val.modelSelectorId = this.modelSelector.id;
        return val;
    }
    async load() { await super.load(); return this.modelSelector.load(); }
    viewsModel(modelId) { return this.modelSelector.containsModel(modelId); }
    clearViewedModels() { this.modelSelector.models.clear(); }
    addViewedModel(id) { this.modelSelector.addModels(id); }
    removeViewedModel(id) { this.modelSelector.dropModels(id); }
    forEachModel(func) {
        for (const modelId of this.modelSelector.models) {
            const model = this.iModel.models.getLoaded(modelId);
            if (undefined !== model && model.isGeometricModel)
                func(model);
        }
    }
}
exports.SpatialViewState = SpatialViewState;
/** Defines a spatial view that displays geometry on the image plane using a parallel orthographic projection. */
class OrthographicViewState extends SpatialViewState {
    static get className() { return "OrthographicViewDefinition"; }
    constructor(props, iModel, categories, displayStyle, modelSelector) { super(props, iModel, categories, displayStyle, modelSelector); }
    supportsCamera() { return false; }
}
exports.OrthographicViewState = OrthographicViewState;
/** Defines the state of a view of a single 2d model. */
class ViewState2d extends ViewState {
    static get className() { return "ViewDefinition2d"; }
    constructor(props, iModel, categories, displayStyle) {
        super(props, iModel, categories, displayStyle);
        this.origin = geometry_core_1.Point2d.fromJSON(props.origin);
        this.delta = geometry_core_1.Point2d.fromJSON(props.delta);
        this.angle = geometry_core_1.Angle.fromJSON(props.angle);
        this.baseModelId = bentleyjs_core_1.Id64.fromJSON(props.baseModelId);
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.delta = this.delta;
        val.angle = this.angle;
        val.baseModelId = this.baseModelId;
        return val;
    }
    /** Return the model for this 2d view. */
    getViewedModel() {
        const model = this.iModel.models.getLoaded(this.baseModelId.value);
        if (model && !(model instanceof ModelState_1.GeometricModel2dState))
            return undefined;
        return model;
    }
    /** Create the scene for this view from a set of pre-initialized DrawArgs. */
    createSceneFromDrawArgs(args) {
        // ###TODO: Check for a context RenderPlan wait time in the draw arguments given
        args.root.draw(args);
    }
    /**
     * This should be overridden by more specific leaf classes of ViewState2d
     * @hidden
     */
    decorate(_context) { }
    equalState(other) {
        if (!this.baseModelId.equals(other.baseModelId))
            return false;
        if (!this.origin.isAlmostEqual(other.origin))
            return false;
        if (!this.delta.isAlmostEqual(other.delta))
            return false;
        if (!this.angle.isAlmostEqualNoPeriodShift(other.angle))
            return false;
        return super.equalState(other);
    }
    computeFitRange() { return this.getViewedExtents(); }
    getViewedExtents() {
        if (undefined === this._viewedExtents) {
            const model = this.iModel.models.getLoaded(this.baseModelId.value);
            if (undefined !== model && model.isGeometricModel) {
                const tree = model.getOrLoadTileTree();
                if (undefined !== tree) {
                    this._viewedExtents = new imodeljs_common_1.AxisAlignedBox3d(tree.range.low, tree.range.high);
                    tree.location.multiplyRange(this._viewedExtents, this._viewedExtents);
                }
            }
        }
        return undefined !== this._viewedExtents ? this._viewedExtents : new imodeljs_common_1.AxisAlignedBox3d();
    }
    onRenderFrame(_viewport) { }
    async load() {
        await super.load();
        return this.iModel.models.load(this.baseModelId);
    }
    allow3dManipulations() { return false; }
    getOrigin() { return new geometry_core_1.Point3d(this.origin.x, this.origin.y); }
    getExtents() { return new geometry_core_1.Vector3d(this.delta.x, this.delta.y); }
    getRotation() { return geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), this.angle); }
    setExtents(delta) { this.delta.set(delta.x, delta.y); }
    setOrigin(origin) { this.origin.set(origin.x, origin.y); }
    setRotation(rot) { const xColumn = rot.getColumn(0); this.angle.setRadians(Math.atan2(xColumn.y, xColumn.x)); }
    viewsModel(modelId) { return this.baseModelId.equals(modelId); }
    forEachModel(func) {
        const model = this.iModel.models.getLoaded(this.baseModelId.value);
        if (undefined !== model && model.isGeometricModel)
            func(model);
    }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystem2dState.createNew(acsName, this.iModel); }
}
exports.ViewState2d = ViewState2d;
/** A view of a DrawingModel */
class DrawingViewState extends ViewState2d {
    static get className() { return "DrawingViewDefinition"; }
}
exports.DrawingViewState = DrawingViewState;
/** A view of a SheetModel */
class SheetViewState extends ViewState2d {
    constructor(props, iModel, categories, displayStyle) {
        super(props, iModel, categories, displayStyle);
        this._size = geometry_core_1.Point2d.create();
        this._attachments = new Sheet_1.Sheet.Attachments();
    }
    static get className() { return "SheetViewDefinition"; }
    /** If the view has been loaded, returns a valid sheet size in the form (width, height). */
    get sheetSize() { return this._size; }
    /** If the view has been loaded, returns valid extents of the sheet. */
    get sheetExtents() { return new imodeljs_common_1.AxisAlignedBox3d(geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create(this._size.x, this._size.y, 0)); }
    /** If the view has been loaded, returns the attachments of this sheet. */
    get attachments() { return this._attachments; }
    /**
     * Given the base model of this view, obtain, set, and return the size of the entire sheet by performing an asynchronous
     * request for the modeled element.
     */
    async getSheetSize(model) {
        const sheetElement = (await this.iModel.elements.getProps(model.modeledElement.id))[0];
        bentleyjs_core_2.assert(sheetElement !== undefined, "Sheet modeled element is undefined");
        this._size.set(sheetElement.width, sheetElement.height);
    }
    /** Load the size and attachment for this sheet, as well as any other 2d view state characteristics. */
    async load() {
        await super.load();
        // Set the size of the sheet
        const model = this.getViewedModel();
        if (model === undefined)
            return;
        this.getSheetSize(model);
        // Query the attachment ids
        this._attachments.clear();
        const queryResult = (await this.iModel.executeQuery("SELECT ECInstanceId FROM BisCore.ViewAttachment WHERE Model.Id=" + model.id));
        const attachmentIds = [];
        for (const row of queryResult)
            attachmentIds.push(row.id);
        // Query the attachments using the id list, and grab all of their corresponding view ids
        const attachments = await this.iModel.elements.getProps(attachmentIds);
        const attachmentViewIds = [];
        for (const attachment of attachments)
            attachmentViewIds.push(attachment.view.id);
        // Load each view state corresponding to each attachment in the attachments array
        // ###TODO: It would be nice to not have to make these asynchronous requests in a loop......
        const attachmentViews = [];
        for (const viewId of attachmentViewIds)
            attachmentViews.push(await this.iModel.views.load(viewId));
        // Create the attachment objects and store them on this SheetViewState
        for (let i = 0; i < attachments.length; i++) {
            if (attachmentViews[i].is3d())
                continue; // this._attachments.add(new Sheet.Attachment3d(attachments[i], attachmentViews[i]));
            else
                this._attachments.add(new Sheet_1.Sheet.Attachment2d(attachments[i], attachmentViews[i]));
        }
    }
    /** If the tiles for this view's attachments are not finished loading, invalidates the scene. */
    onRenderFrame(_viewport) {
        if (!this._attachments.allLoaded)
            _viewport.sync.invalidateScene();
    }
    /** Adds the Sheet view to the scene, along with any of this sheet's attachments. */
    createScene(context) {
        super.createScene(context);
        if (!this._attachments.allLoaded) {
            // ###TODO: Do this incrementally (honor the timeout, if any, on the context's UpdatePlan)
            let i = 0;
            while (i < this._attachments.length) {
                const attachStatus = this._attachments.load(i);
                // If load fails, attachment gets dropped from the list
                if (attachStatus !== TileTree_1.TileTree.LoadStatus.NotFound && attachStatus !== TileTree_1.TileTree.LoadStatus.NotLoaded)
                    i++;
            }
        }
        // DEBUG ONLY
        /*
        for (const attachment of this._attachments.list)
          attachment.drawDebugBorder();
        */
        // Draw all attachments that have a status of loaded
        for (const attachment of this._attachments.list)
            if (attachment.getLoadStatus() === TileTree_1.TileTree.LoadStatus.Loaded) {
                bentleyjs_core_2.assert(attachment.tree !== undefined);
                attachment.tree.drawScene(context);
            }
    }
    /** Create a sheet border decoration graphic. */
    createBorder(width, height, viewContext) {
        const border = Sheet_1.Sheet.Border.create(width, height, viewContext);
        const builder = viewContext.createViewBackground();
        border.addToBuilder(builder);
        return builder.finish();
    }
    decorate(context) {
        if (this._size !== undefined) {
            const border = this.createBorder(this._size.x, this._size.y, context);
            context.setViewBackground(border);
        }
    }
    /** Serialize this SheetViewState into a JSON object. */
    toJSON() {
        const json = super.toJSON();
        return json;
    }
    // override - copy references to view attachments and sheet size
    clone() {
        const viewStateClone = super.clone();
        viewStateClone._size = this._size;
        viewStateClone._attachments = this._attachments;
        return viewStateClone;
    }
}
exports.SheetViewState = SheetViewState;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
class Iterable {
    constructor(list) {
        this.list = list;
    }
    [Symbol.iterator]() {
        let key = 0;
        return { next: () => { const result = key < this.list.length ? { value: this.list[key], done: false } : { value: this.list[key - 1], done: true }; key++; return result; } };
    }
}
exports.Iterable = Iterable;
const identityTransform = geometry_core_1.Transform.createIdentity();
Object.freeze(identityTransform);
/** Parameters used to construct a GraphicBuilder. */
class GraphicBuilderCreateParams {
    get placement() { return this._placement; }
    set placement(tf) { this._placement.setFrom(tf); }
    get isViewCoordinates() { return this.type === 0 /* ViewBackground */ || this.type === 4 /* ViewOverlay */; }
    get isWorldCoordinates() { return !this.isViewCoordinates; }
    get isSceneGraphic() { return this.type === 1 /* Scene */; }
    get isViewBackground() { return this.type === 0 /* ViewBackground */; }
    get isOverlay() { return this.type === 4 /* ViewOverlay */ || this.type === 3 /* WorldOverlay */; }
    get iModel() { return this.viewport.iModel; }
    constructor(placement = identityTransform, type, viewport) {
        this._placement = placement;
        this.type = type;
        this.viewport = viewport;
    }
    /**
     * consolidates viewport and imodel parameters, as we would always want to use the imodel of the viewport if the viewport was passed
     */
    static create(type, vp, placement) {
        return new GraphicBuilderCreateParams(placement, type, vp);
    }
    /**
     * Create params for a graphic in world coordinates, not necessarily associated with any viewport.
     * When an iModel parameter is given, this function is chiefly used for tile generation code as the tolerance for faceting the graphic's geometry is independent of any viewport.
     * When an iModel parameter is not given, this function is chiefly used for code which produces 'normal' decorations and dynamics.
     * If this function is used outside of tile generation context, a default coarse tolerance will be used.
     * To get a tolerance appropriate to a viewport, use the overload accepting a Viewport.
     */
    static scene(vp, placement) {
        return new GraphicBuilderCreateParams(placement, 1 /* Scene */, vp);
    }
    /**
     * Create params for a subgraphic
     */
    subGraphic(placement) {
        return new GraphicBuilderCreateParams(placement, this.type, this.viewport);
    }
    /**
     * Create params for a WorldDecoration-type RenderGraphic
     * The faceting tolerance will be computed from the finished graphic's range and the viewport.
     */
    static worldDecoration(vp, placement) {
        return new GraphicBuilderCreateParams(placement, 2 /* WorldDecoration */, vp);
    }
    /**
     * Create params for a WorldOverlay-type RenderGraphic
     * The faceting tolerance will be computed from the finished graphic's range and the viewport.
     */
    static worldOverlay(vp, placement) {
        return new GraphicBuilderCreateParams(placement, 3 /* WorldOverlay */, vp);
    }
    /**
     * Create params for a ViewOverlay-type RenderGraphic
     */
    static viewOverlay(vp, placement) {
        return new GraphicBuilderCreateParams(placement, 4 /* ViewOverlay */, vp);
    }
}
exports.GraphicBuilderCreateParams = GraphicBuilderCreateParams;
/** Exposes methods for constructing a RenderGraphic from geometric primitives. */
class GraphicBuilder {
    constructor(createParams) {
        this.createParams = createParams;
    }
    /**
     * Get/Set the current GeometryStreamEntryId, which identifies the graphics that are currently being drawn.
     * Separated from _streamId to allow child classes to override the logic involved in setting the streamId
     */
    get iModel() { return this.createParams.iModel; }
    get localToWorldTransform() { return this.createParams.placement; }
    get viewport() { return this.createParams.viewport; }
    get isWorldCoordinates() { return this.createParams.isWorldCoordinates; }
    get isViewCoordinates() { return this.createParams.isViewCoordinates; }
    /** IFacetOptions => StrokeOptions */
    wantStrokeLineStyle(_symb, _facetOptions) { return true; }
    wantStrokePattern(_pattern) { return true; }
    finish() { return this._finish(); }
    /** Helper for adding a series of line strings */
    addLineStrings(...lines) { this.convertToLineStringParams(...lines).forEach((l) => this.addLineString(l.points)); }
    /** Helper for converting an array of string param data each of which are stored as array into an array of line string params */
    convertToLineStringParams(...lines) { return lines.map((l) => ({ numPoints: l[0], points: l[1] })); }
    /** Add DRange3d edges */
    addRangeBox(range) {
        const p = [];
        for (let i = 0; i < 8; ++i)
            p[i] = new geometry_core_1.Point3d();
        p[0].x = p[3].x = p[4].x = p[5].x = range.low.x;
        p[1].x = p[2].x = p[6].x = p[7].x = range.high.x;
        p[0].y = p[1].y = p[4].y = p[7].y = range.low.y;
        p[2].y = p[3].y = p[5].y = p[6].y = range.high.y;
        p[0].z = p[1].z = p[2].z = p[3].z = range.low.z;
        p[4].z = p[5].z = p[6].z = p[7].z = range.high.z;
        const tmpPts = [];
        tmpPts[0] = p[0];
        tmpPts[1] = p[1];
        tmpPts[2] = p[2];
        tmpPts[3] = p[3];
        tmpPts[4] = p[5];
        tmpPts[5] = p[6];
        tmpPts[6] = p[7];
        tmpPts[7] = p[4];
        tmpPts[8] = p[0];
        this.addLineStrings([9, tmpPts], [2, [p[0], p[3]]], [2, [p[4], p[5]]], [2, [p[1], p[7]]], [2, [p[2], p[6]]]);
    }
    /**
     * Set symbology for decorations that are only used for display purposes. Pickable decorations require a category, must initialize
     * a GeometryParams and cook it into a GraphicParams to have a locatable decoration.
     */
    setSymbology(lineColor, fillColor, lineWidth, linePixels = 0 /* Solid */) {
        this.activateGraphicParams(imodeljs_common_1.GraphicParams.fromSymbology(lineColor, fillColor, lineWidth, linePixels));
    }
    /**
     * Set blanking fill symbology for decorations that are only used for display purposes. Pickable decorations require a category, must initialize
     * a GeometryParams and cook it into a GraphicParams to have a locatable decoration.
     */
    setBlankingFill(fillColor) { this.activateGraphicParams(imodeljs_common_1.GraphicParams.fromBlankingFill(fillColor)); }
}
exports.GraphicBuilder = GraphicBuilder;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const IModelApp_1 = __webpack_require__(5);
const bentleyjs_core_1 = __webpack_require__(0);
class NotifyMessageDetails {
    /** Constructor
     *  @param priority        The priority this message should be accorded by the NotificationManager.
     *  @param briefMsg        A short message that conveys the simplest explanation of the issue.
     *  @param detailedMsg     A comprehensive message that explains the issue in detail and potentially offers a solution.
     *  @param msgType         The type of message.
     *  @param openAlert       Whether an alert box should be displayed or not, and if so what kind.
     */
    constructor(priority, briefMessage, detailedMessage, msgType = 0 /* Toast */, openAlert = 0 /* None */) {
        this.priority = priority;
        this.briefMessage = briefMessage;
        this.detailedMessage = detailedMessage;
        this.msgType = msgType;
        this.openAlert = openAlert;
        this.displayTime = bentleyjs_core_1.BeDuration.fromSeconds(3.5);
        this.relativePosition = 5 /* TopRight */;
    }
    /** Set OutputMessageType.Pointer message details.
     * @param viewport            Viewport over which to display the Pointer type message.
     * @param displayPoint        Point at which to display the Pointer type message.
     * @param relativePosition    Position relative to displayPoint at which to display the Pointer type message.
     */
    setPointerTypeDetails(viewport, displayPoint, relativePosition = 5 /* TopRight */) {
        this.viewport = viewport;
        this.displayPoint = geometry_core_1.Point2d.fromJSON(displayPoint);
        this.relativePosition = relativePosition;
    }
}
exports.NotifyMessageDetails = NotifyMessageDetails;
/**
 * Specifies the details of an activity message to be displayed to the user.
 */
class ActivityMessageDetails {
    /**
     * @param showProgressBar         Indicates whether to show the progress bar in the activity message dialog.
     * @param showPercentInMessage    Indicates whether to show the percentage complete in the activity message text.
     * @param supportsCancellation    Indicates whether to show the Cancel button, giving the user the ability to cancel the operation.
     */
    constructor(showProgressBar, showPercentInMessage, supportsCancellation) {
        this.showProgressBar = showProgressBar;
        this.showPercentInMessage = showPercentInMessage;
        this.supportsCancellation = supportsCancellation;
        this.wasCancelled = false;
    }
    /** Called from NotificationAdmin when the user cancels the activity. */
    onActivityCancelled() { this.wasCancelled = true; }
    /** Called from NotificationAdmin when the activity completes successfully. */
    onActivityCompleted() { this.wasCancelled = false; }
}
exports.ActivityMessageDetails = ActivityMessageDetails;
/**
 * The NotificationManager controls the interaction with the user for prompts, error messages, and alert dialogs.
 * Implementations of the NotificationManager may present the information in different ways. For example, in
 * non-interactive sessions, these messages may be saved to a log file or simply discarded.
 */
class NotificationManager {
    /** Output a prompt, given an i18n key. */
    outputPromptByKey(key) { this.outputPrompt(IModelApp_1.IModelApp.i18n.translate(key)); }
    /** Output a localized prompt to the user. A 'prompt' indicates an action the user should take to proceed.
     * @param _prompt The localized string with the prompt message.
     */
    outputPrompt(_prompt) { }
    /** Output a message and/or alert to the user. */
    outputMessage(_message) { }
    /** Output a MessageBox and wait for response from the user.
     * @param _mbType       The MessageBox type.
     * @param _message      The message to display.
     * @param _icon         The MessageBox icon type.
     * @return the response from the user.
     */
    openMessageBox(_mbType, _message, _icon) { return Promise.resolve(3 /* Ok */); }
    /**
     * Set up for activity messages.
     * @param _details  The activity message details.
     * @return true if the message was displayed, false if an invalid priority is specified.
     */
    setupActivityMessage(_details) { return true; }
    /**
     * Output an activity message to the user.
     * @param _messageText The message text.
     * @param _percentComplete The percentage of completion.
     * @return true if the message was displayed, false if the message could not be displayed.
     */
    outputActivityMessage(_messageText, _percentComplete) { return true; }
    /**
     * End an activity message.
     * @param _reason The reason for the end of the Activity Message.
     * @return true if the message was ended successfully, false if the activityMessage could not be ended.
     */
    endActivityMessage(_reason) { return true; }
    /** Return true if the ToolTip is current open. */
    isToolTipOpen() { return false; }
    /** Clear the ToolTip if it is current open. If not open, does nothing. */
    clearToolTip() { }
    /** Show a ToolTip window.
     * @param _htmlElement The HTMLElement that that anchors the toolTip.
     * @param _message The message to display inside the ToolTip
     * @param _location An optional location, relative to the origin of _htmlElement, for the ToolTip. If undefined, determined by _options.
     * @param _options Options that supply additional information about how the ToolTip should function.
     */
    showToolTip(_htmlElement, _message, _pt, _options) { }
}
exports.NotificationManager = NotificationManager;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
class RenderBuffer {
    getHandle() { return this._glBuffer; }
    static create(width, height, format = GL_1.GL.RenderBuffer.Format.DepthComponent16) {
        const gl = System_1.System.instance.context;
        const glBuffer = gl.createRenderbuffer();
        if (null === glBuffer) {
            return undefined;
        }
        bentleyjs_core_1.assert(0 < width && 0 < height);
        RenderBuffer.bindBuffer(glBuffer);
        gl.renderbufferStorage(GL_1.GL.RenderBuffer.TARGET, format, width, height);
        RenderBuffer.unbind();
        return new RenderBuffer(glBuffer);
    }
    get isDisposed() { return this._glBuffer === undefined || this._glBuffer === null; }
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteRenderbuffer(this._glBuffer);
            this._glBuffer = undefined;
        }
    }
    bind() {
        bentleyjs_core_1.assert(undefined !== this._glBuffer);
        if (undefined !== this._glBuffer) {
            RenderBuffer.bindBuffer(this._glBuffer);
        }
    }
    constructor(glBuffer) { this._glBuffer = glBuffer; }
    static bindBuffer(glBuffer) { System_1.System.instance.context.bindRenderbuffer(GL_1.GL.RenderBuffer.TARGET, glBuffer); }
    static unbind() { this.bindBuffer(null); }
}
exports.RenderBuffer = RenderBuffer;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const Handle_1 = __webpack_require__(36);
const DrawCommand_1 = __webpack_require__(56);
const GL_1 = __webpack_require__(8);
const TechniqueFlags_1 = __webpack_require__(126);
const System_1 = __webpack_require__(7);
/** Describes the location of a uniform variable within a shader program. */
class Uniform {
    constructor(name) { this._name = name; }
    compile(prog) {
        bentleyjs_core_1.assert(!this.isValid);
        if (undefined !== prog.glProgram) {
            this._handle = Handle_1.UniformHandle.create(prog.glProgram, this._name, true);
        }
        return this.isValid;
    }
    get isValid() { return undefined !== this._handle; }
}
exports.Uniform = Uniform;
/**
 * Describes the location of a uniform variable within a shader program, the value of which does not change while the program is active.
 * The supplied binding function will be invoked once each time the shader becomes active to set the value of the uniform.
 */
class ProgramUniform extends Uniform {
    constructor(name, bind) {
        super(name);
        this._bind = bind;
    }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.ProgramUniform = ProgramUniform;
/**
 * Describes the location of a uniform variable within a shader program, the value of which is dependent upon the graphic primitive
 * currently being rendered by the program. The supplied binding function will be invoked once for each graphic primitive submitted
 * to the program to set the value of the uniform.
 */
class GraphicUniform extends Uniform {
    constructor(name, bind) {
        super(name);
        this._bind = bind;
    }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.GraphicUniform = GraphicUniform;
/** Describes the location of an attribute within a shader program along with a function for binding the attribute's data */
class Attribute {
    constructor(name, bind) {
        this._name = name;
        this._bind = bind;
    }
    compile(prog) {
        bentleyjs_core_1.assert(!this.isValid);
        if (undefined !== prog.glProgram) {
            this._handle = Handle_1.AttributeHandle.create(prog.glProgram, this._name, true);
        }
        return this.isValid;
    }
    get isValid() { return undefined !== this._handle; }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.Attribute = Attribute;
class ShaderProgram {
    constructor(gl, vertSource, fragSource, description) {
        this._inUse = false;
        this._status = 2 /* Uncompiled */;
        this._programUniforms = new Array();
        this._graphicUniforms = new Array();
        this._attributes = new Array();
        this._description = description;
        this.vertSource = vertSource;
        this.fragSource = fragSource;
        const glProgram = gl.createProgram();
        this._glProgram = (null === glProgram) ? undefined : glProgram;
        // ###TODO: Silencing 'unused variable' warnings temporarily...
        bentleyjs_core_1.assert(undefined !== this._description);
    }
    get isDisposed() { return this._glProgram === undefined; }
    dispose() {
        if (!this.isDisposed) {
            bentleyjs_core_1.assert(!this._inUse);
            System_1.System.instance.context.deleteProgram(this._glProgram);
            this._glProgram = undefined;
            this._status = 2 /* Uncompiled */;
        }
    }
    get glProgram() { return this._glProgram; }
    get isUncompiled() { return 2 /* Uncompiled */ === this._status; }
    compileShader(type) {
        const gl = System_1.System.instance.context;
        const shader = gl.createShader(type);
        if (null === shader) {
            return undefined;
        }
        const src = GL_1.GL.ShaderType.Vertex === type ? this.vertSource : this.fragSource;
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        const succeeded = gl.getShaderParameter(shader, GL_1.GL.ShaderParameter.CompileStatus);
        const compileLog = succeeded ? "" : (GL_1.GL.ShaderType.Vertex === type ? "Vertex" : "Fragment") + " compilation errors: " + gl.getShaderInfoLog(shader) + "\n" + src;
        bentleyjs_core_1.assert(succeeded, compileLog);
        return succeeded ? shader : undefined;
    }
    linkProgram(vert, frag) {
        bentleyjs_core_1.assert(undefined !== this.glProgram);
        if (undefined === this._glProgram || null === this._glProgram) {
            return false;
        }
        const gl = System_1.System.instance.context;
        gl.attachShader(this._glProgram, vert);
        gl.attachShader(this._glProgram, frag);
        gl.linkProgram(this._glProgram);
        return gl.getProgramParameter(this._glProgram, GL_1.GL.ProgramParameter.LinkStatus);
    }
    compile() {
        switch (this._status) {
            case 1 /* Failure */: return false;
            case 0 /* Success */: return true;
            default: {
                if (this.isDisposed) {
                    this._status = 1 /* Failure */;
                    return false;
                }
                break;
            }
        }
        const vert = this.compileShader(GL_1.GL.ShaderType.Vertex);
        const frag = this.compileShader(GL_1.GL.ShaderType.Fragment);
        if (undefined !== vert && undefined !== frag) {
            if (this.linkProgram(vert, frag) && this.compileUniforms(this._programUniforms) && this.compileUniforms(this._graphicUniforms) && this.compileAttributes()) {
                this._status = 0 /* Success */;
                return true;
            }
        }
        this._status = 1 /* Failure */;
        return false;
    }
    use(params) {
        if (!this.compile()) {
            return false;
        }
        bentleyjs_core_1.assert(undefined !== this._glProgram);
        if (null === this._glProgram || undefined === this._glProgram) {
            return false;
        }
        bentleyjs_core_1.assert(!this._inUse);
        this._inUse = true;
        params.context.useProgram(this._glProgram);
        for (const uniform of this._programUniforms) {
            uniform.bind(params);
        }
        return true;
    }
    endUse() {
        bentleyjs_core_1.assert(this._inUse);
        this._inUse = false;
        System_1.System.instance.context.useProgram(null);
    }
    draw(params) {
        bentleyjs_core_1.assert(this._inUse);
        for (const uniform of this._graphicUniforms) {
            uniform.bind(params);
        }
        for (const attribute of this._attributes) {
            attribute.bind(params);
        }
        params.geometry.draw();
    }
    addProgramUniform(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._programUniforms.push(new ProgramUniform(name, binding));
    }
    addGraphicUniform(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._graphicUniforms.push(new GraphicUniform(name, binding));
    }
    addAttribute(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._attributes.push(new Attribute(name, binding));
    }
    compileUniforms(uniforms) {
        for (const uniform of uniforms) {
            if (!uniform.compile(this))
                return false;
        }
        return true;
    }
    compileAttributes() {
        for (const attribute of this._attributes) {
            if (!attribute.compile(this))
                return false;
        }
        return true;
    }
}
exports.ShaderProgram = ShaderProgram;
// Context in which ShaderPrograms are executed. Avoids switching shaders unnecessarily.
// Ensures shader programs are compiled before use and un-bound when scope is disposed.
// This class must *only* be used inside a using() function!
class ShaderProgramExecutor {
    constructor(target, pass, program) {
        this._params = new DrawCommand_1.ShaderProgramParams(target, pass);
        this.changeProgram(program);
    }
    /** Clears the current program to be executed. This does not free WebGL resources, since those are owned by Techniques. */
    dispose() { this.changeProgram(undefined); }
    setProgram(program) { return this.changeProgram(program); }
    get isValid() { return undefined !== this._program; }
    get target() { return this._params.target; }
    get renderPass() { return this._params.renderPass; }
    draw(params) {
        bentleyjs_core_1.assert(this.isValid);
        if (undefined !== this._program) {
            this._program.draw(params);
        }
    }
    drawInterrupt(params) {
        bentleyjs_core_1.assert(params.target === this._params.target);
        const tech = params.target.techniques.getTechnique(params.geometry.getTechniqueId(params.target));
        const program = tech.getShader(TechniqueFlags_1.TechniqueFlags.defaults);
        if (this.setProgram(program)) {
            this.draw(params);
        }
    }
    pushBranch(branch) { this.target.pushBranch(this, branch); }
    popBranch() { this.target.popBranch(); }
    changeProgram(program) {
        if (this._program === program) {
            return true;
        }
        else if (undefined !== this._program) {
            this._program.endUse();
        }
        this._program = program;
        if (undefined !== program && !program.use(this._params)) {
            this._program = undefined;
            return false;
        }
        return true;
    }
}
exports.ShaderProgramExecutor = ShaderProgramExecutor;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/** Flags used to control which shader program is used by a rendering Technique. */
class TechniqueFlags {
    constructor(translucent = false) {
        this.isTranslucent = translucent;
        this.hasClipVolume = this._isHilite = false;
        this.featureMode = 0 /* None */;
    }
    init(target, pass) {
        const hasClip = target.hasClipVolume || target.hasClipMask;
        if (6 /* Hilite */ === pass) {
            this.initForHilite(hasClip ? 1 /* Yes */ : 0 /* No */);
        }
        else {
            this._isHilite = false;
            this.hasClipVolume = hasClip;
            this.isTranslucent = 4 /* Translucent */ === pass;
            if (undefined !== target.currentOverrides) {
                this.featureMode = 2 /* Overrides */;
            }
            else if (undefined !== target.currentPickTable) {
                this.featureMode = 1 /* Pick */;
            }
            else {
                this.featureMode = 0 /* None */;
            }
        }
    }
    reset(mode, clip, isTranslucent = false) {
        this._isHilite = false;
        this.featureMode = mode;
        this.hasClipVolume = 1 /* Yes */ === clip;
        this.isTranslucent = isTranslucent;
    }
    get hasFeatures() { return 0 /* None */ !== this.featureMode; }
    get isHilite() { return this._isHilite; }
    initForHilite(withClip) {
        this.featureMode = 2 /* Overrides */;
        this._isHilite = true;
        this.hasClipVolume = 1 /* Yes */ === withClip;
        this.isTranslucent = false;
    }
    buildDescription() {
        const parts = [this.isTranslucent ? "Translucent" : "Opaque"];
        if (this.isHilite)
            parts.push("hilite");
        if (this.hasClipVolume)
            parts.push("clip");
        if (this.hasFeatures)
            parts.push(1 /* Pick */ === this.featureMode ? "pick" : "overrides");
        return parts.join("; ");
    }
}
TechniqueFlags.defaults = new TechniqueFlags();
exports.TechniqueFlags = TechniqueFlags;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const Mesh_1 = __webpack_require__(102);
const VertexLUT_1 = __webpack_require__(88);
const System_1 = __webpack_require__(7);
const Handle_1 = __webpack_require__(36);
const GL_1 = __webpack_require__(8);
const ColorInfo_1 = __webpack_require__(101);
const FloatRGBA_1 = __webpack_require__(35);
function wantMaterials(vf) { return vf.showMaterials() && 6 /* SmoothShade */ === vf.renderMode; }
function wantLighting(vf) {
    return 6 /* SmoothShade */ === vf.renderMode && (vf.showSourceLights() || vf.showCameraLights() || vf.showSolarLight());
}
class SurfaceGeometry extends Mesh_1.MeshGeometry {
    static create(mesh, indices) {
        const indexBytes = VertexLUT_1.VertexLUT.convertIndicesToTriplets(indices);
        const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(indexBytes);
        return undefined !== indexBuffer ? new SurfaceGeometry(indexBuffer, indices.length, mesh) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._indices);
    }
    get isLit() { return 1 /* Lit */ === this.surfaceType || 3 /* TexturedLit */ === this.surfaceType; }
    get isTextured() { return 2 /* Textured */ === this.surfaceType || 3 /* TexturedLit */ === this.surfaceType; }
    get isGlyph() { return undefined !== this.texture && this.texture.isGlyph; }
    get isTileSection() { return undefined !== this.texture && this.texture.isTileSection; }
    bindVertexArray(attr) {
        attr.enableArray(this._indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    draw() {
        const gl = System_1.System.instance.context;
        const offset = 1 /* BlankingRegion */ === this.renderOrder;
        if (offset) {
            gl.enable(GL_1.GL.POLYGON_OFFSET_FILL);
            gl.polygonOffset(1.0, 1.0);
        }
        this._indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this.numIndices);
        if (offset) {
            gl.disable(GL_1.GL.POLYGON_OFFSET_FILL);
        }
    }
    getTechniqueId(_target) { return 0 /* Surface */; }
    get isLitSurface() { return this.isLit; }
    get renderOrder() {
        if (imodeljs_common_1.FillFlags.Behind === (this.fillFlags & imodeljs_common_1.FillFlags.Behind))
            return 1 /* BlankingRegion */;
        else
            return this.isPlanar ? 10 /* PlanarSurface */ : 2 /* Surface */;
    }
    getColor(target) {
        if (imodeljs_common_1.FillFlags.Background === (this.fillFlags & imodeljs_common_1.FillFlags.Background))
            return new ColorInfo_1.ColorInfo(FloatRGBA_1.FloatPreMulRgba.fromColorDef(target.bgColor));
        else
            return this.colorInfo;
    }
    getRenderPass(target) {
        const mat = this.isLit ? this.mesh.material : undefined;
        const tex = this.texture;
        const opaquePass = this.isPlanar ? 2 /* OpaquePlanar */ : 3 /* OpaqueGeneral */;
        const fillFlags = this.fillFlags;
        const vf = target.currentViewFlags;
        if (0 /* Wireframe */ === vf.renderMode) {
            const showFill = imodeljs_common_1.FillFlags.Always === (fillFlags & imodeljs_common_1.FillFlags.Always) || (vf.showFill() && imodeljs_common_1.FillFlags.ByView === (fillFlags & imodeljs_common_1.FillFlags.ByView));
            if (!showFill) {
                return 255 /* None */;
            }
        }
        if (!this.isGlyph) {
            if (!vf.showTransparency() || 4 /* SolidFill */ === vf.renderMode || 3 /* HiddenLine */ === vf.renderMode) {
                return opaquePass;
            }
        }
        if (undefined !== tex && this.wantTextures(target)) {
            if (tex.hasTranslucency)
                return 4 /* Translucent */;
            // material may have texture weight < 1 - if so must account for material or element alpha below
            if (undefined === mat || (mat.textureMapping !== undefined && mat.textureMapping.params.weight >= 1))
                return opaquePass;
        }
        const hasAlpha = (undefined !== mat && wantMaterials(vf) && mat.hasTranslucency) || this.getColor(target).hasTranslucency;
        return hasAlpha ? 4 /* Translucent */ : opaquePass;
    }
    _wantWoWReversal(target) {
        const fillFlags = this.fillFlags;
        if (imodeljs_common_1.FillFlags.None !== (fillFlags & imodeljs_common_1.FillFlags.Background))
            return false; // fill color explicitly from background
        if (imodeljs_common_1.FillFlags.None !== (fillFlags & imodeljs_common_1.FillFlags.Always))
            return true; // fill displayed even in wireframe
        const vf = target.currentViewFlags;
        if (0 /* Wireframe */ === vf.renderMode || vf.showVisibleEdges())
            return false; // never invert surfaces when edges are displayed
        if (this.isLit && wantLighting(vf))
            return false;
        // Don't invert white pixels of textures...
        return !this.isTextured || !this.wantTextures(target);
    }
    get material() { return this.mesh.material; }
    computeSurfaceFlags(params) {
        const target = params.target;
        const vf = target.currentViewFlags;
        let flags = wantMaterials(vf) ? 0 /* None */ : 8 /* IgnoreMaterial */;
        if (this.isLit) {
            flags |= 4 /* HasNormals */;
            if (wantLighting(vf)) {
                flags |= 2 /* ApplyLighting */;
                if (undefined !== target.environmentMap) {
                    flags |= 128 /* EnvironmentMap */;
                }
            }
            // Textured meshes store normal in place of color index.
            // Untextured lit meshes store normal where textured meshes would store UV coords.
            // Tell shader where to find normal.
            if (!this.isTextured) {
                flags |= 64 /* HasColorAndNormal */;
            }
        }
        if (this.isTextured && this.wantTextures(target)) {
            flags |= 1 /* HasTexture */;
        }
        switch (params.renderPass) {
            // NB: We need this for opaque pass due to SolidFill (must compute transparency, discard below threshold, render opaque at or above threshold)
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
            case 3 /* OpaqueGeneral */:
            case 4 /* Translucent */: {
                const mode = vf.renderMode;
                if (!this.isGlyph && (3 /* HiddenLine */ === mode || 4 /* SolidFill */ === mode)) {
                    flags |= 16 /* TransparencyThreshold */;
                    if (3 /* HiddenLine */ === mode && imodeljs_common_1.FillFlags.Always !== (this.fillFlags & imodeljs_common_1.FillFlags.Always)) {
                        // fill flags test for text - doesn't render with bg fill in hidden line mode.
                        flags |= 32 /* BackgroundFill */;
                    }
                    break;
                }
            }
        }
        return flags;
    }
    constructor(indices, numIndices, mesh) {
        super(mesh, numIndices);
        this._indices = indices;
    }
    wantTextures(target) {
        if (this.isGlyph) {
            return true;
        }
        const fill = this.fillFlags;
        const flags = target.currentViewFlags;
        // ###TODO need to distinguish between gradient fill and actual textures...
        switch (flags.renderMode) {
            case 6 /* SmoothShade */: return flags.showTextures();
            case 0 /* Wireframe */: return imodeljs_common_1.FillFlags.Always === (fill & imodeljs_common_1.FillFlags.Always) || (flags.showFill() && imodeljs_common_1.FillFlags.ByView === (fill & imodeljs_common_1.FillFlags.ByView));
            default: return imodeljs_common_1.FillFlags.Always === (fill & imodeljs_common_1.FillFlags.Always);
        }
    }
}
exports.SurfaceGeometry = SurfaceGeometry;
class SurfacePrimitive extends Mesh_1.MeshPrimitive {
    static create(args, mesh) {
        if (undefined === args.vertIndices) {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
        const geom = SurfaceGeometry.create(mesh.meshData, args.vertIndices);
        return undefined !== geom ? new SurfacePrimitive(geom, mesh) : undefined;
    }
    constructor(cachedGeom, mesh) {
        super(cachedGeom, mesh);
    }
    get renderOrder() {
        if (imodeljs_common_1.FillFlags.Behind === (this.meshData.fillFlags & imodeljs_common_1.FillFlags.Behind))
            return 1 /* BlankingRegion */;
        else
            return this.meshData.isPlanar ? 10 /* PlanarSurface */ : 2 /* Surface */;
    }
}
exports.SurfacePrimitive = SurfacePrimitive;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const Primitive_1 = __webpack_require__(65);
const Graphic_1 = __webpack_require__(64);
const CachedGeometry_1 = __webpack_require__(29);
const Handle_1 = __webpack_require__(36);
const FeaturesInfo_1 = __webpack_require__(87);
const EdgeOverrides_1 = __webpack_require__(55);
const VertexLUT_1 = __webpack_require__(88);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
const bentleyjs_core_1 = __webpack_require__(0);
class PolylineInfo {
    constructor(args) {
        this.vertexParams = args.pointParams;
        this.features = FeaturesInfo_1.FeaturesInfo.create(args.features);
        this.lineWeight = args.width;
        this.lineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(args.linePixels);
        this.flags = args.flags;
    }
    get isPlanar() { return this.flags.isPlanar; }
    get isAnyEdge() { return this.flags.isAnyEdge; }
    get isNormalEdge() { return this.flags.isNormalEdge; }
    get isOutlineEdge() { return this.flags.isOutlineEdge; }
    get renderOrder() {
        if (this.isAnyEdge)
            return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */;
        else
            return this.isPlanar ? 11 /* PlanarLinear */ : 3 /* Linear */;
    }
}
exports.PolylineInfo = PolylineInfo;
class TesselatedPolyline {
    constructor(vertIndex, prevIndex, nextIndexAndParam, distance) {
        this.vertIndex = vertIndex;
        this.prevIndex = prevIndex;
        this.nextIndexAndParam = nextIndexAndParam;
        this.distance = distance;
    }
    get numIndices() { return this.distance.length; }
}
exports.TesselatedPolyline = TesselatedPolyline;
class PolylineTesselatorVertex {
    constructor(isSegmentStart, isPolylineStartOrEnd, vertexIndex, prevIndex, nextIndex, distance) {
        this.isSegmentStart = isSegmentStart;
        this.isPolylineStartOrEnd = isPolylineStartOrEnd;
        this.vertexIndex = vertexIndex;
        this.prevIndex = prevIndex;
        this.nextIndex = nextIndex;
        this.distance = distance;
        this.prevIndex = prevIndex;
        this.prevIndex = prevIndex;
    }
    computeParam(negatePerp, adjacentToJoint = false, joint = false, noDisplacement = false) {
        if (joint)
            return 12 /* kJointBase */;
        let param = 0 /* kNone */;
        if (noDisplacement)
            param = 96 /* kNoneAdjWt */; // prevent getting tossed before width adjustment
        else if (adjacentToJoint)
            param = 9 /* kMiterInsideOnly */;
        else
            param = this.isPolylineStartOrEnd ? 3 /* kSquare */ : 6 /* kMiter */;
        let adjust = 0;
        if (negatePerp)
            adjust = 24 /* kNegatePerp */;
        if (!this.isSegmentStart)
            adjust += 48 /* kNegateAlong */;
        return param + adjust;
    }
}
class PolylineTesselator {
    constructor(polylines, points, doJointTriangles) {
        this.numIndices = 0;
        this.vertIndex = [];
        this.prevIndex = [];
        this.nextIndex = [];
        this.nextParam = [];
        this.distance = [];
        this.position = [];
        this.polylines = polylines;
        this.points = points;
        this.doJoints = doJointTriangles;
    }
    static fromPolyline(args) {
        return new PolylineTesselator(args.polylines, args.points, Graphic_1.wantJointTriangles(args.width, args.flags.is2d));
    }
    static fromMesh(args) {
        if (undefined !== args.edges.polylines.lines && undefined !== args.points)
            return new PolylineTesselator(args.edges.polylines.lines, args.points, Graphic_1.wantJointTriangles(args.edges.width, args.is2d));
        return undefined;
    }
    tesselate() {
        for (const p of this.points.list)
            this.position.push(p.unquantize(this.points.params));
        this._tesselate();
        const vertIndex = VertexLUT_1.VertexLUT.convertIndicesToTriplets(this.vertIndex);
        const prevIndex = VertexLUT_1.VertexLUT.convertIndicesToTriplets(this.prevIndex);
        const nextIndexAndParam = new Uint8Array(this.numIndices * 4);
        for (let i = 0; i < this.numIndices; i++) {
            const index = this.nextIndex[i];
            const j = i * 4;
            nextIndexAndParam[j + 0] = index & 0x000000ff;
            nextIndexAndParam[j + 1] = (index & 0x0000ff00) >> 8;
            nextIndexAndParam[j + 2] = (index & 0x00ff0000) >> 16;
            nextIndexAndParam[j + 3] = this.nextParam[i] & 0x000000ff;
        }
        const distance = new Float32Array(this.numIndices);
        for (let i = 0; i < this.numIndices; ++i)
            distance[i] = this.distance[i];
        return new TesselatedPolyline(vertIndex, prevIndex, nextIndexAndParam, distance);
    }
    _tesselate() {
        for (const line of this.polylines) {
            if (line.numIndices < 2)
                continue;
            let cumulativeDist = line.startDistance;
            const last = line.numIndices - 1;
            const isClosed = line.vertIndices[0] === line.vertIndices[last];
            for (let i = 0; i < last; ++i) {
                const idx0 = line.vertIndices[i];
                const idx1 = line.vertIndices[i + 1];
                const pos0 = this.position[idx0];
                const pos1 = this.position[idx1];
                const dist = pos0.distance(pos1);
                const isStart = (0 === i);
                const isEnd = (last - 1 === i);
                const prevIdx0 = isStart ? (isClosed ? line.vertIndices[last - 1] : idx0) : line.vertIndices[i - 1];
                const nextIdx1 = isEnd ? (isClosed ? line.vertIndices[1] : idx1) : line.vertIndices[i + 2];
                const v0 = new PolylineTesselatorVertex(true, isStart && !isClosed, idx0, prevIdx0, idx1, cumulativeDist);
                const v1 = new PolylineTesselatorVertex(false, isEnd && !isClosed, idx1, nextIdx1, idx0, cumulativeDist += dist);
                const maxJointDot = -0.7;
                const jointAt0 = this.doJoints && (isClosed || !isStart) && this._dotProduct(v0) > maxJointDot;
                const jointAt1 = this.doJoints && (isClosed || !isEnd) && this._dotProduct(v1) > maxJointDot;
                if (jointAt0 || jointAt1) {
                    this._addVertex(v0, v0.computeParam(true, jointAt0, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v1, v1.computeParam(true, jointAt1, false, false));
                }
                else {
                    this._addVertex(v0, v0.computeParam(true));
                    this._addVertex(v1, v1.computeParam(false));
                    this._addVertex(v0, v0.computeParam(false));
                    this._addVertex(v0, v0.computeParam(false));
                    this._addVertex(v1, v1.computeParam(false));
                    this._addVertex(v1, v1.computeParam(true));
                }
            }
        }
    }
    _dotProduct(v) {
        const pos = this.position[v.vertexIndex];
        const prevDir = geometry_core_1.Vector3d.createStartEnd(this.position[v.prevIndex], pos);
        const nextDir = geometry_core_1.Vector3d.createStartEnd(this.position[v.nextIndex], pos);
        return prevDir.dotProduct(nextDir);
    }
    _addVertex(vertex, param) {
        this.vertIndex[this.numIndices] = vertex.vertexIndex;
        this.prevIndex[this.numIndices] = vertex.prevIndex;
        this.nextIndex[this.numIndices] = vertex.nextIndex;
        this.nextParam[this.numIndices] = param;
        this.distance[this.numIndices] = vertex.distance;
        this.numIndices++;
    }
}
exports.PolylineTesselator = PolylineTesselator;
class PolylineGeometry extends CachedGeometry_1.LUTGeometry {
    constructor(buffers, numIndices, lut, info) {
        super();
        this.polyline = info;
        this.lut = lut;
        this.numIndices = numIndices;
        this.buffers = buffers;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        bentleyjs_core_1.dispose(this.buffers);
    }
    _wantWoWReversal(_target) { return true; }
    get polylineBuffers() { return this.buffers; }
    _computeEdgePass(target, colorInfo) {
        const vf = target.currentViewFlags;
        if (6 /* SmoothShade */ === vf.renderMode && !vf.showVisibleEdges())
            return 255 /* None */;
        // Only want to return Translucent for edges if rendering in Wireframe mode TODO: what about overrides?
        const isTranslucent = 0 /* Wireframe */ === vf.renderMode && vf.showTransparency() && colorInfo.hasTranslucency;
        return isTranslucent ? 4 /* Translucent */ : 1 /* OpaqueLinear */;
    }
    getRenderPass(target) {
        const vf = target.currentViewFlags;
        if (this.isEdge) {
            let pass = this._computeEdgePass(target, this.lut.colorInfo);
            // Only display the outline in wireframe if Fill is off...
            if (255 /* None */ !== pass && this.polyline.isOutlineEdge && 0 /* Wireframe */ === vf.renderMode && vf.showFill())
                pass = 255 /* None */;
            return pass;
        }
        const isTranslucent = vf.showTransparency() && this.lut.colorInfo.hasTranslucency;
        return isTranslucent ? 4 /* Translucent */ : 1 /* OpaqueLinear */;
    }
    getTechniqueId(_target) { return 1 /* Polyline */; }
    get renderOrder() { return this.polyline.renderOrder; }
    get isPlanar() { return this.polyline.isPlanar; }
    get isEdge() { return this.polyline.isAnyEdge; }
    get qOrigin() { return this.lut.qOrigin; }
    get qScale() { return this.lut.qScale; }
    get numRgbaPerVertex() { return this.lut.numRgbaPerVertex; }
    get featuresInfo() { return this.polyline.features; }
    _getLineWeight(params) {
        return this.isEdge ? params.target.getEdgeWeight(params, this.polyline.lineWeight) : this.polyline.lineWeight;
    }
    _getLineCode(params) {
        return this.isEdge ? params.target.getEdgeLineCode(params, this.polyline.lineCode) : this.polyline.lineCode;
    }
    getColor(target) { return this.isEdge && target.isEdgeColorOverridden ? target.edgeColor : this.lut.colorInfo; }
    bindVertexArray(attr) {
        attr.enableArray(this.buffers.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    draw() {
        const gl = System_1.System.instance.context;
        this.buffers.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this.numIndices);
    }
    static create(args) {
        const lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.SimpleBuilder(args), args.colors);
        const info = new PolylineInfo(args);
        const lut = lutParams.toData(info.vertexParams);
        if (undefined !== lut) {
            const tess = PolylineTesselator.fromPolyline(args);
            const tp = tess.tesselate();
            const vBuff = Handle_1.BufferHandle.createArrayBuffer(tp.vertIndex);
            const pBuff = Handle_1.BufferHandle.createArrayBuffer(tp.prevIndex);
            const npBuff = Handle_1.BufferHandle.createArrayBuffer(tp.nextIndexAndParam);
            const dBuff = Handle_1.BufferHandle.createArrayBuffer(tp.distance);
            if (undefined !== vBuff && undefined !== pBuff && undefined !== npBuff && undefined !== dBuff) {
                const pb = new CachedGeometry_1.PolylineBuffers(vBuff, pBuff, npBuff, dBuff);
                return new PolylineGeometry(pb, tp.distance.length, lut, info);
            }
        }
        return undefined;
    }
}
exports.PolylineGeometry = PolylineGeometry;
class PolylinePrimitive extends Primitive_1.Primitive {
    constructor(cachedGeom) { super(cachedGeom); }
    static create(args) {
        const geom = PolylineGeometry.create(args);
        return undefined !== geom ? new PolylinePrimitive(geom) : undefined;
    }
    get renderOrder() { return this.cachedGeometry.renderOrder; }
    get isPlanar() { return this.cachedGeometry.isPlanar; }
    get isEdge() { return this.cachedGeometry.isEdge; }
}
exports.PolylinePrimitive = PolylinePrimitive;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Adds a uniform holding the current render pass and a set of kRenderPass_* constants
 * uniform float u_renderPass
 */
function addRenderPass(builder) {
    builder.addUniform("u_renderPass", 3 /* Float */, (prog) => {
        prog.addProgramUniform("u_renderPass", (uniform, params) => {
            let renderPass = params.renderPass;
            if (5 /* HiddenEdge */ === renderPass) {
                renderPass = 3 /* OpaqueGeneral */; // no distinction from shader POV...
            }
            uniform.setUniform1f(renderPass);
        });
    });
    builder.addGlobal("kRenderPass_Background", 3 /* Float */, "0.0", true);
    builder.addGlobal("kRenderPass_OpaqueLinear", 3 /* Float */, "1.0", true);
    builder.addGlobal("kRenderPass_OpaquePlanar", 3 /* Float */, "2.0", true);
    builder.addGlobal("kRenderPass_OpaqueGeneral", 3 /* Float */, "3.0", true);
    builder.addGlobal("kRenderPass_Translucent", 3 /* Float */, "4.0", true);
    builder.addGlobal("kRenderPass_HiddenEdge", 3 /* Float */, "5.0", true);
    builder.addGlobal("kRenderPass_Hilite", 3 /* Float */, "6.0", true);
    builder.addGlobal("kRenderPass_WorldOverlay", 3 /* Float */, "7.0", true);
    builder.addGlobal("kRenderPass_ViewOverlay", 3 /* Float */, "8.0", true);
}
exports.addRenderPass = addRenderPass;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
class Material extends imodeljs_common_1.RenderMaterial {
    constructor(materialParams) {
        super(materialParams);
        this.diffuseUniform = new Float32Array(4); // [red, green, blue, overridden]
        this.alphaUniform = new Float32Array(2); // [alpha, overridden]
        this.specular = new Float32Array(4); // [red, green, blue, exponent]
        this.weights = new Float32Array(3); // [diffuse weight, specular weight, reflect]
        this.diffuseUniform[3] = undefined !== materialParams.diffuseColor ? 1.0 : 0.0;
        if (undefined !== materialParams.diffuseColor) {
            const diffRgb = materialParams.diffuseColor.colors;
            this.diffuseUniform[0] = diffRgb.r / 255;
            this.diffuseUniform[1] = diffRgb.g / 255;
            this.diffuseUniform[2] = diffRgb.b / 255;
        }
        else {
            this.diffuseUniform[0] = this.diffuseUniform[1] = this.diffuseUniform[2] = 1.0;
        }
        this.specular[3] = materialParams.specularExponent;
        if (materialParams.specularColor) {
            const specRgb = materialParams.specularColor.colors;
            this.specular[0] = specRgb.r / 255;
            this.specular[1] = specRgb.g / 255;
            this.specular[2] = specRgb.b / 255;
        }
        else {
            this.specular[0] = this.specular[1] = this.specular[2] = 1.0;
        }
        if (materialParams.reflectColor)
            this.reflectColor = materialParams.reflectColor.clone();
        this.weights[0] = materialParams.diffuse;
        this.weights[1] = materialParams.specular;
        this.weights[2] = materialParams.reflect;
        if (0.0 !== materialParams.transparency) {
            this.alphaUniform[0] = 1.0 - materialParams.transparency;
            this.alphaUniform[1] = 1.0;
        }
        else {
            this.alphaUniform[0] = 1.0;
            this.alphaUniform[1] = 0.0;
        }
    }
    get textureWeight() { return undefined !== this.textureMapping ? this.textureMapping.params.weight : 1.0; }
    get overridesRgb() { return 1.0 === this.diffuseUniform[3]; }
    get overridesAlpha() { return 1.0 === this.alphaUniform[1]; }
    get hasTranslucency() { return this.overridesAlpha && this.alphaUniform[0] < 1.0; }
}
Material.default = new Material(imodeljs_common_1.RenderMaterial.Params.defaults);
exports.Material = Material;
Object.freeze(Material.default);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
// show status in the output HTML
function showStatus(string1, string2) {
    let outString = string1;
    if (string2)
        outString = outString.concat(" ", string2);
    document.getElementById("showstatus").innerHTML = outString;
}
exports.showStatus = showStatus;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const AccuDraw_1 = __webpack_require__(105);
const AccuSnap_1 = __webpack_require__(79);
const Tool_1 = __webpack_require__(15);
const LegacyMath_1 = __webpack_require__(75);
const geometry_core_1 = __webpack_require__(1);
const HitDetail_1 = __webpack_require__(63);
const IModelApp_1 = __webpack_require__(5);
/**
 * A shortcut may require no user input  (immediate) or it may install a viewing tool.Tool implementors should not use
 * this class to setup AccuDraw, instead use AccuDraw.setContext to provide hints.
 */
class AccuDrawShortcuts {
    static rotateAxesByPoint(isSnapped, aboutCurrentZ) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return false;
        const vp = accudraw.currentView;
        if (!vp)
            return false;
        const point = accudraw.point;
        if (!vp.view.is3d())
            point.z = 0.0;
        if (aboutCurrentZ)
            accudraw.hardConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);
        else
            accudraw.softConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);
        // Snap point and compass origin coincide...
        const xVec = new geometry_core_1.Vector3d();
        if (LegacyMath_1.LegacyMath.normalizedDifference(point, accudraw.planePt, xVec) < geometry_core_1.Geometry.smallAngleRadians)
            return false;
        accudraw.axes.x.setFrom(xVec);
        if (6 /* Context */ !== accudraw.rotationMode)
            accudraw.setRotationMode(6 /* Context */);
        accudraw.flags.contextRotMode = 1 /* XAxis */;
        accudraw.flags.lockedRotation = false;
        accudraw.updateRotation();
        accudraw.refreshDecorationsAndDynamics();
        // Always want index line to display for x-Axis...changing rotation clears this...so it flashes...
        accudraw.indexed |= 1 /* X_BM */;
        return true;
    }
    static updateACSByPoints(acs, vp, points, isDynamics) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return false;
        let accept = false;
        const vec = [new geometry_core_1.Vector3d(), new geometry_core_1.Vector3d(), new geometry_core_1.Vector3d()];
        acs.setOrigin(points[0]);
        switch (points.length) {
            case 1:
                acs.setRotation(vp.rotMatrix);
                if (!isDynamics) {
                    accudraw.published.origin.setFrom(points[0]);
                    accudraw.published.flags = 4 /* SetOrigin */;
                    accudraw.flags.fixedOrg = true;
                }
                break;
            case 2:
                if (LegacyMath_1.LegacyMath.normalizedDifference(points[1], points[0], vec[0]) < 0.00001) {
                    accept = true;
                    break;
                }
                if (vp.view.is3d()) {
                    if (LegacyMath_1.LegacyMath.normalizedCrossProduct(accudraw.axes.y, vec[0], vec[1]) < 0.00001) {
                        vec[2].set(0.0, 0.0, 1.0);
                        if (LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[2], vec[0], vec[1]) < 0.00001) {
                            vec[2].set(0.0, 1.0, 0.0);
                            LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[2], vec[0], vec[1]);
                        }
                    }
                    LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[0], vec[1], vec[2]);
                    acs.setRotation(geometry_core_1.RotMatrix.createRows(vec[0], vec[1], vec[2]));
                    if (!isDynamics) {
                        accudraw.published.origin.setFrom(points[0]);
                        accudraw.published.flags = 4 /* SetOrigin */ | 64 /* SetNormal */;
                        accudraw.published.vector.setFrom(vec[0]);
                    }
                    break;
                }
                vec[2].set(0.0, 0.0, 1.0);
                LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[2], vec[0], vec[1]);
                acs.setRotation(geometry_core_1.RotMatrix.createRows(vec[0], vec[1], vec[2]));
                accept = true;
                break;
            case 3: {
                if (LegacyMath_1.LegacyMath.normalizedDifference(points[1], points[0], vec[0]) < 0.00001 ||
                    LegacyMath_1.LegacyMath.normalizedDifference(points[2], points[0], vec[1]) < 0.00001 ||
                    LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[0], vec[1], vec[2]) < 0.00001) {
                    accept = true;
                    break;
                }
                LegacyMath_1.LegacyMath.normalizedCrossProduct(vec[2], vec[0], vec[1]);
                acs.setRotation(geometry_core_1.RotMatrix.createRows(vec[0], vec[1], vec[2]));
                accept = true;
                break;
            }
        }
        return accept;
    }
    counterRotate(angle) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const rMatrix = accudraw.getRotation();
        rMatrix.multiplyVectorInPlace(accudraw.vector);
        const angleMatrix = geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_1.Angle.createRadians(-angle));
        rMatrix.multiplyMatrixMatrix(angleMatrix, rMatrix); // NEEDS_WORK - verify order
        accudraw.axes.fromRotMatrix(rMatrix);
        accudraw.flags.lockedRotation = true;
    }
    static processPendingHints() { IModelApp_1.IModelApp.accuDraw.processHints(); }
    static saveToolState(restore, ignoreFlags, stateBuffer) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (restore) {
            if (!stateBuffer)
                stateBuffer = accudraw.savedState;
            if (0 !== (ignoreFlags & 4 /* SetOrigin */)) {
                stateBuffer.origin.setFrom(accudraw.origin);
            }
            if (0 !== (ignoreFlags & 16 /* SetRMatrix */)) {
                stateBuffer.axes.setFrom(accudraw.axes);
                stateBuffer.auxRotationPlane = accudraw.flags.auxRotationPlane;
                stateBuffer.contextRotMode = accudraw.flags.contextRotMode;
                stateBuffer.rotationMode = accudraw.rotationMode;
            }
        }
        if (stateBuffer && stateBuffer !== accudraw.savedState)
            accudraw.saveState(restore, stateBuffer);
    }
    static synchSavedStateWithCurrent(stateBuffer) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        // Restore will leave current state active...used for shortcuts like RE that also enable AccuDraw...
        if (stateBuffer && stateBuffer !== accudraw.savedState)
            stateBuffer.state = accudraw.currentState;
        else
            accudraw.savedState.state = accudraw.currentState;
    }
    static requestInputFocus() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        accudraw.grabInputFocus();
        accudraw.refreshDecorationsAndDynamics();
    }
    //   //! Helper methods for GUI implementation...
    static itemFieldNavigate(index, str, forward) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (accudraw.getFieldLock(index))
            accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));
        if (!accudraw.isActive() && AccuDraw_1.KeyinStatus.Partial === accudraw.getKeyinStatus(index)) {
            accudraw.processFieldInput(index, str, true);
        }
        else {
            accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Dynamic);
            accudraw.onFieldValueChange(index);
        }
        const vp = accudraw.currentView;
        const is3d = vp ? vp.view.is3d() : false;
        const isPolar = (0 /* Polar */ === accudraw.getCompassMode());
        switch (index) {
            case 0 /* DIST_Item */:
                index = ((is3d && !forward) ? 4 /* Z_Item */ : 1 /* ANGLE_Item */);
                break;
            case 1 /* ANGLE_Item */:
                index = ((is3d && forward) ? 4 /* Z_Item */ : 0 /* DIST_Item */);
                break;
            case 2 /* X_Item */:
                index = ((is3d && !forward) ? 4 /* Z_Item */ : 3 /* Y_Item */);
                break;
            case 3 /* Y_Item */:
                index = ((is3d && forward) ? 4 /* Z_Item */ : 2 /* X_Item */);
                break;
            case 4 /* Z_Item */:
                index = (forward ? (isPolar ? 0 /* DIST_Item */ : 2 /* X_Item */) : (isPolar ? 1 /* ANGLE_Item */ : 3 /* Y_Item */));
                break;
        }
        accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Partial);
        accudraw.setFocusItem(index);
        accudraw.dontMoveFocus = true;
    }
    static itemFieldNewInput(index) { IModelApp_1.IModelApp.accuDraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Partial); }
    static itemFieldAcceptInput(index, str) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        accudraw.processFieldInput(index, str, true);
        accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Dynamic);
        if (accudraw.getFieldLock(index))
            accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));
        const vp = accudraw.currentView;
        if (accudraw.isActive()) {
            if (!vp)
                return;
            if (0 /* Polar */ === accudraw.getCompassMode())
                accudraw.fixPointPolar(vp);
            else
                accudraw.fixPointRectangular(vp);
            accudraw.flags.dialogNeedsUpdate = true;
            return;
        }
        const is3d = vp ? vp.view.is3d() : false;
        const isPolar = (0 /* Polar */ === accudraw.getCompassMode());
        switch (index) {
            case 0 /* DIST_Item */:
                index = 1 /* ANGLE_Item */;
                break;
            case 1 /* ANGLE_Item */:
                index = (is3d ? 4 /* Z_Item */ : 0 /* DIST_Item */);
                break;
            case 2 /* X_Item */:
                index = 3 /* Y_Item */;
                break;
            case 3 /* Y_Item */:
                index = (is3d ? 4 /* Z_Item */ : 2 /* X_Item */);
                break;
            case 4 /* Z_Item */:
                index = (isPolar ? 0 /* DIST_Item */ : 2 /* X_Item */);
                break;
        }
        accudraw.setFocusItem(index);
    }
    static itemFieldLockToggle(index) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (accudraw.getFieldLock(index)) {
            switch (index) {
                case 0 /* DIST_Item */:
                    accudraw.distanceLock(true, false);
                    break;
                case 1 /* ANGLE_Item */:
                    accudraw.angleLock();
                    break;
                case 2 /* X_Item */:
                    accudraw.clearTentative();
                    accudraw.locked |= 1 /* X_BM */;
                    break;
                case 3 /* Y_Item */:
                    accudraw.clearTentative();
                    accudraw.locked |= 2 /* Y_BM */;
                    break;
                case 4 /* Z_Item */:
                    accudraw.clearTentative();
                    break;
            }
            return;
        }
        switch (index) {
            case 0 /* DIST_Item */:
                accudraw.locked &= ~8 /* DIST_BM */;
                break;
            case 1 /* ANGLE_Item */:
                accudraw.locked &= ~7 /* ANGLE_BM */;
                break;
            case 2 /* X_Item */:
                accudraw.locked &= ~1 /* X_BM */;
                break;
            case 3 /* Y_Item */:
                accudraw.locked &= ~2 /* Y_BM */;
                break;
            case 4 /* Z_Item */:
                break;
        }
        accudraw.dontMoveFocus = false;
        accudraw.clearTentative();
    }
    static itemRotationModeChange(rotation) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (6 /* Context */ === rotation) {
            if (15 /* None */ !== accudraw.savedState.contextRotMode) {
                accudraw.setRotationMode(7 /* Restore */);
                accudraw.updateRotation(true);
            }
            else {
                this.rotateAxes(true);
            }
            return;
        }
        const vp = accudraw.currentView;
        const is3d = vp ? vp.view.is3d() : true;
        if (!is3d && (2 /* Front */ === rotation || 3 /* Side */ === rotation))
            accudraw.setRotationMode(1 /* Top */);
        accudraw.flags.baseRotation = rotation;
        accudraw.updateRotation(true);
    }
    //   //! Shortcut implementations for GUI entry points...
    setOrigin(explicitOrigin) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (explicitOrigin) {
            accudraw.published.origin.setFrom(explicitOrigin);
            accudraw.flags.haveValidOrigin = true;
        }
        else if (accudraw.isInactive() || accudraw.isDeactivated()) {
            // If AccuSnap is active use adjusted snap point, otherwise use last data point...
            if (IModelApp_1.IModelApp.accuSnap.isHot()) {
                accudraw.published.origin.setFrom(AccuSnap_1.TentativeOrAccuSnap.getCurrentPoint());
                accudraw.flags.haveValidOrigin = true;
            }
            else {
                const ev = new Tool_1.BeButtonEvent();
                IModelApp_1.IModelApp.toolAdmin.fillEventFromLastDataButton(ev);
                if (ev.viewport) {
                    accudraw.published.origin.setFrom(ev.point);
                    accudraw.flags.haveValidOrigin = true;
                }
                else {
                    // NOTE: If current point isn't valid _SetDefaultOrigin will be called...
                    accudraw.published.origin.setFrom(accudraw.point);
                }
            }
        }
        else {
            accudraw.published.origin.setFrom(accudraw.point);
            accudraw.flags.haveValidOrigin = true;
            accudraw.setLastPoint(accudraw.published.origin);
        }
        accudraw.clearTentative();
        const vp = accudraw.currentView;
        // NOTE: _AdjustPoint should have been called to have setup currentView...
        if (vp && !vp.view.is3d())
            accudraw.published.origin.z = 0.0;
        accudraw.origin.setFrom(accudraw.published.origin);
        accudraw.point.setFrom(accudraw.published.origin);
        accudraw.planePt.setFrom(accudraw.published.origin);
        accudraw.published.flags |= 4 /* SetOrigin */;
        accudraw.activate();
        accudraw.refreshDecorationsAndDynamics();
    }
    changeCompassMode() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        let axisLockStatus = accudraw.locked & 3 /* XY_BM */;
        if (axisLockStatus) {
            if (1 /* Rectangular */ === accudraw.getCompassMode()) {
                if (axisLockStatus & 1 /* X_BM */ && accudraw.delta.x !== 0.0)
                    axisLockStatus &= ~1 /* X_BM */;
                if (axisLockStatus & 2 /* Y_BM */ && accudraw.delta.y !== 0.0)
                    axisLockStatus &= ~2 /* Y_BM */;
            }
        }
        accudraw.changeCompassMode(true);
        if (axisLockStatus) {
            if (1 /* Rectangular */ === accudraw.getCompassMode()) {
                accudraw.delta.x = accudraw.delta.y = 0.0;
                if (axisLockStatus & 1 /* X_BM */)
                    accudraw.setFieldLock(2 /* X_Item */, true);
                else if (axisLockStatus & 2 /* Y_BM */)
                    accudraw.setFieldLock(3 /* Y_Item */, true);
            }
            else {
                accudraw.setFieldLock(1 /* ANGLE_Item */, true);
            }
            accudraw.locked = axisLockStatus;
        }
        accudraw.flags.baseMode = accudraw.getCompassMode();
        accudraw.refreshDecorationsAndDynamics();
    }
    lockSmart() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        // Don't want AccuSnap to influence axis or Z...
        if (accuSnap.isHot()) {
            accuSnap.clear();
            const vp = accudraw.currentView;
            if (vp) {
                if (0 /* Polar */ === accudraw.getCompassMode())
                    accudraw.fixPointPolar(vp);
                else
                    accudraw.fixPointRectangular(vp);
            }
        }
        if (0 /* Polar */ === accudraw.getCompassMode()) {
            const isSnapped = accudraw.clearTentative();
            if (accudraw.locked & 7 /* ANGLE_BM */) {
                accudraw.setFieldLock(1 /* ANGLE_Item */, false);
                accudraw.locked &= ~7 /* ANGLE_BM */;
            }
            else if (accudraw.getFieldLock(0 /* DIST_Item */)) {
                accudraw.setFieldLock(0 /* DIST_Item */, false);
                accudraw.locked &= ~8 /* DIST_BM */;
            }
            else if (isSnapped) {
                accudraw.doLockAngle(isSnapped);
            }
            else if (accudraw.indexed & 7 /* ANGLE_BM */) {
                accudraw.angleLock();
            }
            else {
                if (Math.abs(accudraw.vector.dotProduct(accudraw.axes.x)) > Math.abs(accudraw.vector.dotProduct(accudraw.axes.y)))
                    accudraw.indexed |= 2 /* Y_BM */;
                else
                    accudraw.indexed |= 1 /* X_BM */;
                accudraw.angleLock();
            }
            return;
        }
        if (accudraw.locked) {
            accudraw.clearTentative();
            accudraw.locked &= ~3 /* XY_BM */;
            accudraw.setFieldLock(2 /* X_Item */, false);
            accudraw.setFieldLock(3 /* Y_Item */, false);
            if (accudraw.getFieldLock(4 /* Z_Item */) && accudraw.delta.z === 0.0 && !accudraw.stickyZLock)
                accudraw.setFieldLock(4 /* Z_Item */, false);
        }
        else if (!accudraw.indexed && accudraw.getFieldLock(4 /* Z_Item */) && !accudraw.stickyZLock) {
            accudraw.clearTentative();
            accudraw.setFieldLock(4 /* Z_Item */, false);
        }
        else {
            if (accudraw.clearTentative()) {
                if (Math.abs(accudraw.delta.x) >= geometry_core_1.Geometry.smallAngleRadians && Math.abs(accudraw.delta.y) >= geometry_core_1.Geometry.smallAngleRadians) {
                    accudraw.doLockAngle(false);
                    return;
                }
            }
            const vp = accudraw.currentView;
            if (Math.abs(accudraw.delta.x) > Math.abs(accudraw.delta.y)) {
                accudraw.delta.y = 0.0;
                accudraw.onFieldValueChange(3 /* Y_Item */);
                accudraw.locked |= 2 /* Y_BM */;
                accudraw.locked &= ~1 /* X_BM */;
                accudraw.setFieldLock(2 /* X_Item */, false);
                accudraw.setFieldLock(3 /* Y_Item */, true);
                accudraw.setFieldLock(4 /* Z_Item */, vp ? vp.view.is3d() : false);
            }
            else {
                accudraw.delta.x = 0.0;
                accudraw.onFieldValueChange(2 /* X_Item */);
                accudraw.locked |= 1 /* X_BM */;
                accudraw.locked &= ~2 /* Y_BM */;
                accudraw.setFieldLock(3 /* Y_Item */, false);
                accudraw.setFieldLock(2 /* X_Item */, true);
                accudraw.setFieldLock(4 /* Z_Item */, vp ? vp.view.is3d() : false);
            }
            if (!accudraw.flags.lockedRotation) {
                accudraw.flags.lockedRotation = true;
                accudraw.flags.contextRotMode = 0 /* Locked */;
                accudraw.setRotationMode(6 /* Context */);
            }
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    lockX() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        accudraw.clearTentative();
        if (1 /* Rectangular */ !== accudraw.getCompassMode()) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.fixPointRectangular(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(2 /* X_Item */)) {
            accudraw.setFieldLock(2 /* X_Item */, false);
            accudraw.locked = accudraw.locked & ~1 /* X_BM */;
        }
        else {
            accudraw.saveCoordinate(2 /* X_Item */, accudraw.delta.x);
            accudraw.setFieldLock(2 /* X_Item */, true);
            accudraw.locked = accudraw.locked | 1 /* X_BM */;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    lockY() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        accudraw.clearTentative();
        if (1 /* Rectangular */ !== accudraw.getCompassMode()) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.fixPointRectangular(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(3 /* Y_Item */)) {
            accudraw.setFieldLock(3 /* Y_Item */, false);
            accudraw.locked = accudraw.locked & ~2 /* Y_BM */;
        }
        else {
            accudraw.saveCoordinate(3 /* Y_Item */, accudraw.delta.y);
            accudraw.setFieldLock(3 /* Y_Item */, true);
            accudraw.locked = accudraw.locked | 2 /* Y_BM */;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    lockZ() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const vp = accudraw.currentView;
        if (!vp || !vp.view.is3d())
            return;
        const isSnapped = accudraw.clearTentative();
        if (accudraw.getFieldLock(4 /* Z_Item */)) {
            accudraw.setFieldLock(4 /* Z_Item */, false);
        }
        else {
            // Move focus to Z field...
            if (!isSnapped && accudraw.autoFocusFields) {
                accudraw.setFocusItem(4 /* Z_Item */);
                accudraw.dontMoveFocus = true;
            }
            accudraw.setFieldLock(4 /* Z_Item */, true);
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    lockDistance() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const isSnapped = accudraw.clearTentative();
        if (0 /* Polar */ !== accudraw.getCompassMode()) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.locked = 0;
            accudraw.fixPointPolar(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(0 /* DIST_Item */)) {
            accudraw.setFieldLock(0 /* DIST_Item */, false);
            accudraw.locked &= ~8 /* DIST_BM */;
            accudraw.setKeyinStatus(0 /* DIST_Item */, AccuDraw_1.KeyinStatus.Dynamic); // Need to clear partial status if locked by entering distance since focus stays in distance field...
        }
        else {
            // Move focus to distance field...
            if (!isSnapped && accudraw.autoFocusFields)
                accudraw.setFocusItem(0 /* DIST_Item */);
            accudraw.distanceLock(true, true);
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    lockAngle() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        accudraw.doLockAngle(accudraw.clearTentative());
        accudraw.refreshDecorationsAndDynamics();
    }
    lockIndex() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (accudraw.flags.indexLocked) {
            if (accudraw.locked)
                this.lockSmart();
            accudraw.flags.indexLocked = false;
        }
        else {
            if (0 /* Polar */ === accudraw.getCompassMode()) {
                if (accudraw.indexed & 3 /* XY_BM */) {
                    accudraw.setFieldLock(1 /* ANGLE_Item */, true);
                    accudraw.angleLock();
                }
                if (accudraw.indexed & 8 /* DIST_BM */)
                    this.lockDistance();
            }
            else {
                if (accudraw.indexed & 1 /* X_BM */) {
                    this.lockX();
                    if (accudraw.indexed & 8 /* DIST_BM */)
                        this.lockY();
                }
                if (accudraw.indexed & 2 /* Y_BM */) {
                    this.lockY();
                    if (accudraw.indexed & 8 /* DIST_BM */)
                        this.lockX();
                }
                if (accudraw.indexed & 8 /* DIST_BM */ && !(accudraw.indexed & 3 /* XY_BM */)) {
                    if (accudraw.locked & 1 /* X_BM */)
                        this.lockY();
                    else
                        this.lockX();
                }
            }
            accudraw.flags.indexLocked = true;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static setStandardRotation(rotation, restoreContext = false) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (accudraw.rotationMode === rotation && 15 /* None */ !== accudraw.savedState.contextRotMode && restoreContext) {
            accudraw.setRotationMode(7 /* Restore */);
        }
        else if (6 /* Context */ === rotation) {
            const axes = accudraw.baseAxes.clone();
            accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);
            accudraw.setContextRotation(axes.toRotMatrix(), false, true);
            accudraw.refreshDecorationsAndDynamics();
            return;
        }
        else {
            accudraw.flags.baseRotation = rotation;
            accudraw.setRotationMode(rotation);
        }
        accudraw.updateRotation(true);
        accudraw.refreshDecorationsAndDynamics();
    }
    static alignView() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const vp = accudraw.currentView;
        if (!vp)
            return;
        const newMatrix = accudraw.getRotation();
        const oldMatrix = vp.rotMatrix.clone();
        if (newMatrix.isExactEqual(oldMatrix)) {
            // Compass currently aligned to view, rotate to saved axes if they are valid and different, otherwise use top or iso...
            if (!accudraw.savedState.axes.equals(accudraw.axes) &&
                0.0 !== accudraw.savedState.axes.x.magnitude() &&
                0.0 !== accudraw.savedState.axes.y.magnitude() &&
                0.0 !== accudraw.savedState.axes.z.magnitude())
                accudraw.savedState.axes.toRotMatrix(newMatrix);
            else
                AccuDraw_1.AccuDraw.getStandardRotation(vp.view.is3d() ? 6 /* Iso */ : 0 /* Top */, vp, false, newMatrix);
            if (newMatrix.isExactEqual(oldMatrix))
                return;
        }
        // Save old view rotation in saved axes so RV can toggle between old/new rotations...
        accudraw.savedState.axes.setFrom(AccuDraw_1.ThreeAxes.createFromRotMatrix(oldMatrix));
        // NEEDS_WORK: Frustum morph doesn't keep fixed origin during transitional frames...
        //            Compare to behavior using mdlView_rotateToRMatrixAboutPoint which looked better...
        // Frustum startFrustum = vp -> GetFrustum();
        // Frustum frustum = startFrustum;
        // Transform   fromTrans, toTrans;
        // const origin = accudraw.origin;
        // fromTrans.InitFromMatrixAndFixedPoint(vp -> GetRotMatrix(), origin);
        // frustum.Multiply(fromTrans);
        // toTrans.InitFromMatrixAndFixedPoint(newMatrix, origin);
        // toTrans.InverseOf(toTrans);
        // frustum.Multiply(toTrans);
        // ViewportAnimatorPtr animator = ViewportAnimator:: Create(ViewportAnimator:: Params(* vp, true, BeDuration:: Seconds(1), 1), startFrustum, frustum);
        // animator -> SetTerminationHandler([](bool) { AccuDraw:: GetInstance().UpdateRotation(true); });
        // vp -> SetAnimator(* animator);
        accudraw.refreshDecorationsAndDynamics();
    }
    static rotateToBase(restoreContext) { this.setStandardRotation(IModelApp_1.IModelApp.accuDraw.flags.baseRotation, restoreContext); }
    static rotateToACS(restoreContext) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        // NOTE: Match current ACS orientation..reset auxRotationPlane to top!
        accudraw.flags.auxRotationPlane = 1 /* Top */;
        this.setStandardRotation(5 /* ACS */, restoreContext);
    }
    static rotateToPoint(ptIn, animate) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const vp = accudraw.currentView;
        if (!vp)
            return;
        const point = ptIn.clone();
        if (!vp.view.is3d())
            point.z = 0.0;
        if (AccuSnap_1.TentativeOrAccuSnap.isHot())
            accudraw.hardConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, true);
        else
            accudraw.softConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, true);
        // Snap point and compass origin coincide...
        const xVec = new geometry_core_1.Vector3d();
        if (LegacyMath_1.LegacyMath.normalizedDifference(point, accudraw.planePt, xVec) < geometry_core_1.Geometry.smallAngleRadians)
            return;
        accudraw.axes.x.setFrom(xVec);
        if (6 /* Context */ !== accudraw.rotationMode)
            accudraw.setRotationMode(6 /* Context */);
        accudraw.flags.contextRotMode = 1 /* XAxis */;
        accudraw.flags.lockedRotation = false;
        accudraw.updateRotation(animate);
        accudraw.refreshDecorationsAndDynamics();
    }
    static rotateCycle(updateCurrentACS) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const vp = accudraw.currentView;
        if (!vp || !vp.view.is3d())
            return;
        let rotation;
        switch (accudraw.rotationMode) {
            case 4 /* View */:
            case 3 /* Side */:
                rotation = 1 /* Top */;
                break;
            case 1 /* Top */:
                rotation = 2 /* Front */;
                break;
            case 2 /* Front */:
                rotation = 3 /* Side */;
                break;
            case 6 /* Context */:
                if (!updateCurrentACS) {
                    rotation = 6 /* Context */;
                    if (rotation !== accudraw.flags.baseRotation) {
                        accudraw.baseAxes.setFrom(accudraw.axes);
                        accudraw.flags.auxRotationPlane = 1 /* Top */;
                        accudraw.flags.baseRotation = rotation;
                    }
                    else {
                        const axes = accudraw.baseAxes.clone();
                        accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);
                        if (!accudraw.axes.equals(axes))
                            accudraw.changeBaseRotationMode(rotation);
                    }
                    switch (accudraw.flags.auxRotationPlane) {
                        case 2 /* Front */:
                            accudraw.flags.auxRotationPlane = 3 /* Side */;
                            break;
                        case 3 /* Side */:
                            accudraw.flags.auxRotationPlane = 1 /* Top */;
                            break;
                        case 1 /* Top */:
                            accudraw.flags.auxRotationPlane = 2 /* Front */;
                            break;
                    }
                    break;
                }
                // copy it to an ACS
                accudraw.updateRotation();
                accudraw.flags.auxRotationPlane = 1 /* Top */;
            // AuxCoordSystemPtr acsPtr = AuxCoordSystem:: CreateFrom(vp -> GetViewController().GetAuxCoordinateSystem());
            // RotMatrix auxRMatrix;
            // accudraw.GetRotation(auxRMatrix);
            // acsPtr -> SetRotation(auxRMatrix);
            // AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
            // then fall thru
            /* falls through */
            case 5 /* ACS */:
                rotation = 5 /* ACS */;
                switch (accudraw.flags.auxRotationPlane) {
                    case 2 /* Front */:
                        accudraw.flags.auxRotationPlane = 3 /* Side */;
                        break;
                    case 3 /* Side */:
                        accudraw.flags.auxRotationPlane = 1 /* Top */;
                        break;
                    case 1 /* Top */:
                        accudraw.flags.auxRotationPlane = 2 /* Front */;
                        break;
                }
                break;
            default:
                return;
        }
        this.setStandardRotation(rotation, false);
    }
    static rotate90(axis) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        const newRotation = new AccuDraw_1.ThreeAxes();
        accudraw.locked = accudraw.indexed = 0;
        accudraw.unlockAllFields();
        switch (axis) {
            case 0:
                newRotation.x.setFrom(accudraw.axes.x);
                newRotation.z.setFrom(accudraw.axes.y);
                newRotation.z.crossProduct(newRotation.x, newRotation.y);
                break;
            case 1:
                newRotation.x.setFrom(accudraw.axes.z);
                newRotation.y.setFrom(accudraw.axes.y);
                newRotation.x.crossProduct(newRotation.y, newRotation.z);
                break;
            case 2:
                newRotation.x.setFrom(accudraw.axes.y);
                newRotation.z.setFrom(accudraw.axes.z);
                newRotation.z.crossProduct(newRotation.x, newRotation.y);
                break;
        }
        accudraw.setContextRotation(newRotation.toRotMatrix(), true, true);
        accudraw.refreshDecorationsAndDynamics();
    }
    static rotateAxes(aboutCurrentZ) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return;
        if (accudraw.clearTentative() || IModelApp_1.IModelApp.accuSnap.isHot() ||
            (0 /* Polar */ === accudraw.getCompassMode() && accudraw.getFieldLock(1 /* ANGLE_Item */)) ||
            (0 /* Polar */ !== accudraw.getCompassMode() && accudraw.getFieldLock(2 /* X_Item */) && accudraw.getFieldLock(3 /* Y_Item */))) {
            if (AccuDrawShortcuts.rotateAxesByPoint(true, aboutCurrentZ)) {
                AccuDrawShortcuts.itemFieldUnlockAll();
                return;
            }
        }
        AccuDrawTool.installTool(new RotateAxesTool(aboutCurrentZ));
    }
    static rotateToElement(updateCurrentACS) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isEnabled())
            AccuDrawTool.installTool(new RotateElementTool(updateCurrentACS, false));
    }
    static defineACSByElement() {
        AccuDrawTool.installTool(new RotateElementTool(true, true));
    }
    static defineACSByPoints() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isEnabled())
            AccuDrawTool.installTool(new DefineACSByPointsTool());
    }
    static getACS(acsName, useOrigin, useRotation) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return 32768 /* ERROR */;
        const vp = accudraw.currentView;
        if (!vp)
            return 32768 /* ERROR */;
        let currRotation = 0, currBaseRotation = 0;
        const axes = new AccuDraw_1.ThreeAxes();
        if (!useRotation) {
            // Save current rotation, uStn event listener on ACS change will orient AccuDraw to ACS...
            currRotation = accudraw.rotationMode;
            currBaseRotation = accudraw.flags.baseRotation;
            axes.setFrom(accudraw.axes);
        }
        if (acsName && "" !== acsName) {
            //   // See if this ACS already exists...
            //   DgnCode acsCode = AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), acsName);
            //   DgnElementId acsId = vp -> GetViewController().GetDgnDb().Elements().QueryElementIdByCode(acsCode);
            //   if (!acsId.IsValid())
            //     return ERROR;
            //   AuxCoordSystemCPtr auxElm = vp -> GetViewController().GetDgnDb().Elements().Get<AuxCoordSystem>(acsId);
            //   if (!auxElm.IsValid())
            //     return ERROR;
            //   AuxCoordSystemPtr acsPtr = auxElm -> MakeCopy<AuxCoordSystem>();
            //   if (!acsPtr.IsValid())
            //     return ERROR;
            //   AuxCoordSystemCR oldACS = vp -> GetViewController().GetAuxCoordinateSystem();
            //   if (!useOrigin)
            //     acsPtr -> SetOrigin(oldACS.GetOrigin());
            //   if (!useRotation)
            //     acsPtr -> SetRotation(oldACS.GetRotation());
            //   AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
        }
        const currentACS = vp.view.auxiliaryCoordinateSystem;
        if (useOrigin) {
            accudraw.origin.setFrom(currentACS.getOrigin());
            accudraw.point.setFrom(accudraw.origin);
            accudraw.planePt.setFrom(accudraw.origin);
        }
        if (useRotation) {
            accudraw.flags.auxRotationPlane = 1 /* Top */;
            this.setStandardRotation(5 /* ACS */);
        }
        else {
            this.itemFieldUnlockAll();
            accudraw.setRotationMode(currRotation);
            accudraw.flags.baseRotation = currBaseRotation;
            accudraw.axes.setFrom(axes);
            if (5 /* ACS */ === accudraw.flags.baseRotation) {
                const acs = currentACS.clone();
                const rMatrix = accudraw.getRotation();
                acs.setRotation(rMatrix);
                AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(acs, vp);
            }
            accudraw.published.flags &= ~131072 /* OrientACS */;
        }
        return 0 /* SUCCESS */;
    }
    writeACS(_acsName) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled())
            return 32768 /* ERROR */;
        const vp = accudraw.currentView;
        if (!vp)
            return 32768 /* ERROR */;
        // const origin = accudraw.origin;
        // const rMatrix = accudraw.getRotation();
        // AuxCoordSystemPtr acsPtr = AuxCoordSystem:: CreateFrom(vp -> GetViewController().GetAuxCoordinateSystem());
        // acsPtr -> SetOrigin(origin);
        // acsPtr -> SetRotation(rMatrix);
        // acsPtr -> SetType(CompassMode.Polar == accudraw.getCompassMode() ? ACSType :: Cylindrical : ACSType:: Rectangular);
        // acsPtr -> SetCode(AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), nullptr != acsName ? acsName : ""));
        // acsPtr -> SetDescription("");
        // if (acsName && '\0' != acsName[0]) {
        //   DgnDbStatus status;
        //   acsPtr -> Insert(& status);
        //   if (DgnDbStatus:: Success != status)
        //   return BentleyStatus.ERROR;
        // }
        // AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
        // accudraw.flags.baseRotation = RotationMode.ACS;
        // accudraw.SetRotationMode(RotationMode.ACS);
        return 0 /* SUCCESS */;
    }
    static itemFieldUnlockAll() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isEnabled())
            accudraw.unlockAllFields();
    }
}
exports.AccuDrawShortcuts = AccuDrawShortcuts;
class AccuDrawShortcutsTool extends Tool_1.InputCollector {
    constructor(shortcut) { super(); this.shortcut = shortcut; this.cancel = true; }
    onPostInstall() { super.onPostInstall(); this.shortcut.doManipulationStart(); }
    pnCleanup() { this.shortcut.doManipulationStop(this.cancel); }
    onDataButtonDown(ev) { if (this.shortcut.doManipulation(ev, false)) {
        this.cancel = false;
        this.exitTool();
    } return false; }
    onModelMotion(ev) { this.shortcut.doManipulation(ev, true); }
    decorate(context) { this.shortcut.onDecorate(context); }
    exitTool() { super.exitTool(); AccuDrawShortcuts.requestInputFocus(); } // re-grab focus when auto-focus tool setting set...
}
AccuDrawShortcutsTool.toolId = "View.AccuDraw";
class AccuDrawTool {
    constructor() {
        this.stateBuffer = new AccuDraw_1.SavedState(); // Need separate state buffer since we aren't a ViewTool...
    }
    doManipulationStart() {
        AccuDrawShortcuts.saveToolState(false, 0, this.stateBuffer);
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        // NOTE: Unlike starting a viewing tool, an input collector inherits the suspended primitive's state and must set everything...
        toolAdmin.setLocateCursor(false);
        toolAdmin.toolState.coordLockOvr = 0 /* None */;
        if (this.activateAccuDrawOnStart())
            IModelApp_1.IModelApp.accuDraw.activate();
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        accuSnap.enableLocate(false);
        accuSnap.enableSnap(true);
        this.doManipulation(undefined, true);
    }
    doManipulationStop(cancel) {
        if (!cancel)
            this.stateBuffer.ignoreDataButton = true; // Want to ignore data point event when terminating shortcut...
        AccuDrawShortcuts.saveToolState(true, cancel ? 0 : this.onManipulationComplete(), this.stateBuffer);
    }
    activateAccuDrawOnStart() { return true; }
    onManipulationComplete() { return 0; }
    onDecorate(_context) { }
    static installTool(shortcut) { return new AccuDrawShortcutsTool(shortcut).run(); }
    static outputPrompt(messageKey) { IModelApp_1.IModelApp.notifications.outputPromptByKey("AccuDraw.Prompt." + messageKey); }
}
exports.AccuDrawTool = AccuDrawTool;
class RotateAxesTool extends AccuDrawTool {
    constructor(aboutCurrentZ) {
        super();
        this.aboutCurrentZ = aboutCurrentZ;
    }
    onManipulationComplete() { return 16 /* SetRMatrix */; }
    doManipulationStart() {
        super.doManipulationStart();
        AccuDrawTool.outputPrompt("DefineXAxis");
    }
    doManipulation(ev, isMotion) {
        const vp = ev ? ev.viewport : IModelApp_1.IModelApp.accuDraw.currentView;
        if (!vp)
            return true;
        AccuDrawShortcuts.rotateAxesByPoint(AccuSnap_1.TentativeOrAccuSnap.isHot(), this.aboutCurrentZ);
        vp.invalidateDecorations();
        if (!isMotion)
            AccuDrawShortcuts.itemFieldUnlockAll();
        return true;
    }
}
class RotateElementTool extends AccuDrawTool {
    // RotateToElemToolHelper  rotateElmHelper;
    constructor(updateCurrentACS, updateDynamicACS) {
        super();
        this.updateCurrentACS = updateCurrentACS;
        this.updateDynamicACS = updateDynamicACS;
        this.moveOrigin = true;
    }
    onManipulationComplete() { return 4 /* SetOrigin */ | 16 /* SetRMatrix */; }
    activateAccuDrawOnStart() {
        this.moveOrigin = !IModelApp_1.IModelApp.accuDraw.isActive(); // Leave current origin is AccuDraw is already enabled...
        return !this.updateDynamicACS;
    }
    doManipulationStart() {
        //   this.rotateElmHelper.enableGeometryCache(); // Keep geometry cache...
        super.doManipulationStart();
        AccuDrawTool.outputPrompt("DefineElem");
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        // If user doesn't want AccuSnap, tool will work fine with with just auto-locate (which the user can no longer disable).
        if (!accuSnap.userWantsSnaps()) {
            IModelApp_1.IModelApp.toolAdmin.setLocateCursor(true);
            accuSnap.enableLocate(true);
        }
    }
    doManipulationStop(restore) {
        super.doManipulationStop(restore);
        //  rotateElmHelper.ClearGeometryCache(); // Free cached geometry...
    }
    updateOrientation(tmpSnapDetail, ev) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isActive() && 0 /* NONE_LOCKED */ !== accudraw.locked) {
            // Make sure adjusted point is used instead of close point on element...
            tmpSnapDetail.setSnapPoint(ev.point, 2 /* InRange */);
            tmpSnapDetail.testPoint.setFrom(ev.point);
        }
        else {
            // Test point needs to reflect cursor position when tentative is active...
            tmpSnapDetail.testPoint.setFrom(ev.rawPoint);
        }
        // if (!rotateElmHelper.GetOrientation(tmpSnapDetail, origin, rMatrix))
        //   return false;
        // if (!moveOrigin)
        //   accudraw.GetOrigin(origin); // Don't want data to move origin...
        // accudraw.SetContext((AccuDrawFlags)(ACCUDRAW_AlwaysSetOrigin | ACCUDRAW_SetRMatrix), & origin, (DVec3dCP) & rMatrix);
        return true;
    }
    doManipulation(ev, isMotion) {
        if (!ev || !ev.viewport)
            return true;
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        // NOTE: User could start tool with AccuSnap user enabled and then turn it off...detect this and enable auto-locate.
        //       If AccuSnap is enabled after the tool is started you can end up with both auto-locate and AccuSnap enabled,
        //       this is a little visually messy (locate cursor and AccuSnap)...but it doesn't cause major problems.
        if (!accuSnap.isActive())
            accuSnap.enableLocate(true);
        const snapDetail = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
        if (snapDetail) {
            const tmpSnapDetail = snapDetail.clone();
            if (!this.updateOrientation(tmpSnapDetail, ev))
                return true;
        }
        else {
            const hitDetail = accuSnap.currHit;
            if (hitDetail) {
                const tmpSnapDetail = new HitDetail_1.SnapDetail(hitDetail);
                if (!this.updateOrientation(tmpSnapDetail, ev))
                    return true;
            }
        }
        if (this.updateDynamicACS)
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        if (isMotion)
            return true;
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (this.updateCurrentACS) {
            AccuDrawShortcuts.processPendingHints();
            // const origin = accudraw.origin;
            // const rMatrix = accudraw.getRotation();
            // AuxCoordSystemPtr acsPtr = AuxCoordSystem:: CreateFrom(vp -> GetViewController().GetAuxCoordinateSystem());
            // acsPtr -> SetOrigin(origin);
            // acsPtr -> SetRotation(rMatrix);
            // AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
        }
        else {
            accudraw.changeBaseRotationMode(6 /* Context */); // Hold temporary rotation for tool duration when not updating ACS...
        }
        // RE enables Accudraw, so leave active regardless of state for suspended tool...
        AccuDrawShortcuts.synchSavedStateWithCurrent(this.stateBuffer);
        return true;
    }
    onDecorate(context) {
        if (!this.updateDynamicACS)
            return;
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        const origin = accudraw.origin;
        const rMatrix = accudraw.getRotation();
        const acs = context.viewport.view.auxiliaryCoordinateSystem.clone();
        acs.setOrigin(origin);
        acs.setRotation(rMatrix);
        // acsPtr -> Display(context, ACSDisplayOptions:: Active | ACSDisplayOptions:: Dynamics);
    }
}
class DefineACSByPointsTool extends AccuDrawTool {
    constructor() {
        super(...arguments);
        this.points = [];
    }
    onManipulationComplete() { return 16 /* SetRMatrix */; }
    dDoManipulationStart() {
        super.doManipulationStart();
        const tentativePoint = IModelApp_1.IModelApp.tentativePoint;
        if (!tentativePoint.isActive) {
            AccuDrawTool.outputPrompt("DefineOrigin");
            return;
        }
        const origin = tentativePoint.getPoint().clone();
        AccuDrawTool.outputPrompt("DefineXAxis");
        IModelApp_1.IModelApp.accuDraw.setContext(4 /* SetOrigin */ | 8 /* FixedOrigin */, origin);
        this.points.push(origin);
        tentativePoint.clear(true);
    }
    doManipulation(ev, isMotion) {
        if (!ev || !ev.viewport)
            return true;
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        if (isMotion)
            return false;
        this.points.push(ev.point.clone());
        const vp = ev.viewport;
        if (!this.acs)
            this.acs = vp.view.auxiliaryCoordinateSystem.clone();
        if (AccuDrawShortcuts.updateACSByPoints(this.acs, vp, this.points, false)) {
            AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(this.acs, vp);
            AccuDrawShortcuts.rotateToACS(false);
            return true;
        }
        AccuDrawTool.outputPrompt(1 === this.points.length ? "DefineXAxis" : "DefineYDir");
        return false;
    }
    onDecorate(context) {
        const tmpPoints = [];
        this.points.forEach((pt) => tmpPoints.push(pt));
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        tmpPoints.push(ev.point);
        const vp = context.viewport;
        if (!this.acs)
            this.acs = vp.view.auxiliaryCoordinateSystem.clone();
        AccuDrawShortcuts.updateACSByPoints(this.acs, vp, tmpPoints, true);
        // this.acs -> Display(context, ACSDisplayOptions:: Active | ACSDisplayOptions:: Dynamics);
    }
}


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * abstract base class for access to XYZ data with indexed reference.
 * * This allows algorithms to work with Point3d[] or GrowableXYZ.
 * ** GrowableXYZArray implements these for its data.
 * ** Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.
 * * In addition to "point by point" accessors, there abstract members compute commonly useful vector data "between points".
 * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.
*/
class IndexedXYZCollection {
}
exports.IndexedXYZCollection = IndexedXYZCollection;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const PointVector_1 = __webpack_require__(4);
const Range_1 = __webpack_require__(21);
const Range_2 = __webpack_require__(21);
const Transform_1 = __webpack_require__(6);
const Geometry4d_1 = __webpack_require__(46);
const AnalyticGeometry_1 = __webpack_require__(11);
const Geometry_1 = __webpack_require__(3);
const PointHelpers_1 = __webpack_require__(22);
const GrowableArray_1 = __webpack_require__(37);
const Polynomials_1 = __webpack_require__(66);
const ClipUtils_1 = __webpack_require__(135);
/** A ClipPlane is a single plane represented as
 * * An inward unit normal (u,v,w)
 * * A signedDistance
 *
 * Hence
 * * The halfspace function evaluation for "point" [x,y,z,] is: ([x,y,z] DOT (u,v,w)l - signedDistance)
 * * POSITIVE values of the halfspace function are "inside"
 * * ZERO value of the halfspace function is "on"
 * * NEGATIVE value of the halfspace function is "outside"
 * * A representative point on the plane is (signedDistance*u, signedDistance * v, signedDistance *w)
 */
class ClipPlane {
    constructor(normal, distance, invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
        this._inwardNormal = normal;
        this._distanceFromOrigin = distance;
    }
    /**
     * @returns Return true if all members are almostEqual to corresponding members of other.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)
            && this._inwardNormal.isAlmostEqual(other._inwardNormal)
            && this._interior === other._interior
            && this._invisible === other._invisible;
    }
    /** @return a cloned plane */
    clone() {
        const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        return result;
    }
    /** @return Return a cloned plane with coordinate data negated. */
    cloneNegated() {
        const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        plane.negateInPlace();
        return plane;
    }
    /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */
    static createPlane(plane, invisible = false, interior = false, result) {
        const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());
        if (result) {
            result._invisible = invisible;
            result._interior = interior;
            result._inwardNormal = plane.getNormalRef().clone();
            result._distanceFromOrigin = distance;
            return result;
        }
        return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);
    }
    /**
     * * Create a ClipPlane with direct normal and signedDistance.
     * * The vector is normalized for storage.
     */
    static createNormalAndDistance(normal, distance, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" is the inward normal of the plane. (It is internally normalized)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPoint(normal, point, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            const distance = normalized.dotProduct(point);
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" is the inward normal of the plane. (It is internally normalized)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPointXYZXYZ(normalX, normalY, normalZ, originX, originY, originZ, invisible = false, interior = false) {
        const normal = PointVector_1.Vector3d.create(normalX, normalY, normalZ);
        const normalized = normal.normalizeInPlace();
        if (normalized) {
            const distance = normal.dotProductXYZ(originX, originY, originZ);
            return new ClipPlane(normal, distance, invisible, interior);
        }
        return undefined;
    }
    /**
     * return a json object of the form
     * `{"normal":[u,v,w],"dist":signedDistanceValue,"interior":true,"invisible":true}`
     */
    toJSON() {
        const val = {};
        val.normal = this.inwardNormalRef.toJSON();
        val.dist = this.distance;
        if (this.interior)
            val.interior = true;
        if (this.invisible)
            val.invisible = true;
        return val;
    }
    static fromJSON(json, result) {
        if (json && json.normal && Number.isFinite(json.dist)) {
            return ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);
        }
        return ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.unitZ(), 0, false, false, result);
    }
    setFlags(invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
    }
    // Getters
    get distance() { return this._distanceFromOrigin; }
    get inwardNormalRef() { return this._inwardNormal; }
    get interior() { return this._interior; }
    get invisible() { return this._invisible; }
    static createEdgeAndUpVector(point0, point1, upVector, tiltAngle, result) {
        const edgeVector = PointVector_1.Vector3d.createFrom(point1.minus(point0));
        let normal = (upVector.crossProduct(edgeVector)).normalize();
        if (normal) {
            if (!tiltAngle.isAlmostZero()) {
                const tiltNormal = PointVector_1.Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);
                if (tiltNormal) {
                    normal = tiltNormal.clone();
                }
            }
            normal.negate(normal);
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        }
        return undefined;
    }
    static createEdgeXY(point0, point1, result) {
        const normal = PointVector_1.Vector3d.create(point0.y - point1.y, point1.x - point0.x);
        if (normal.normalizeInPlace())
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        return undefined;
    }
    getPlane3d() {
        const d = this._distanceFromOrigin;
        // Normal should be normalized, will not return undefined
        return AnalyticGeometry_1.Plane3dByOriginAndUnitNormal.create(PointVector_1.Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal);
    }
    getPlane4d() {
        return Geometry4d_1.Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, -this._distanceFromOrigin);
    }
    setPlane4d(plane) {
        const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
        const r = a === 0.0 ? 1.0 : 1.0 / a;
        this._inwardNormal.x = r * plane.x;
        this._inwardNormal.y = r * plane.y;
        this._inwardNormal.z = r * plane.z;
        this._distanceFromOrigin = -r * plane.w;
    }
    evaluatePoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;
    }
    /** @returns return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).
     */
    dotProductVector(vector) {
        return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;
    }
    /** @returns return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT using the plane's distanceFromOrigin).
     */
    dotProductPlaneNormalPoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;
    }
    isPointOnOrInside(point, tolerance) {
        let value = this.evaluatePoint(point);
        if (tolerance) {
            value += tolerance;
        }
        return value >= 0.0;
    }
    isPointInside(point, tolerance) {
        let value = this.evaluatePoint(point);
        if (tolerance) {
            value += tolerance;
        }
        return value > 0.0;
    }
    isPointOn(point, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        return Math.abs(this.evaluatePoint(point)) <= tolerance;
    }
    appendIntersectionRadians(arc, intersectionRadians) {
        const arcVectors = arc.toVectors();
        const alpha = this.evaluatePoint(arc.center);
        const beta = this.dotProductVector(arcVectors.vector0);
        const gamma = this.dotProductVector(arcVectors.vector90);
        Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = ClipPlane.sClipArcFractionArray;
        breaks.clear();
        this.appendIntersectionRadians(arc, breaks);
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * * Compute intersection of (unbounded) segment with the plane.
     * * If the ends are on the same side of the plane, return undefined.
     * * If the intersection is an endpoint or interior to the segment return the fraction.
     * * If both ends are on, return undefined.
     */
    getBoundedSegmentSimpleIntersection(pointA, pointB) {
        const h0 = this.evaluatePoint(pointA);
        const h1 = this.evaluatePoint(pointB);
        if (h0 * h1 > 0.0)
            return undefined;
        if (h0 === 0.0 && h1 === 0.0) {
            return undefined;
        }
        return -h0 / (h1 - h0);
    }
    // Returns true if successful
    transformInPlace(transform) {
        const plane = this.getPlane3d();
        const matrix = transform.matrix;
        const newPoint = transform.multiplyPoint3d(plane.getOriginRef());
        // Normal transforms as the inverse transpose of the matrix part
        // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)
        const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());
        if (!newNormal)
            return false;
        plane.set(newPoint, newNormal);
        const normalized = (plane.getNormalRef()).normalize();
        if (!normalized)
            return false;
        this._inwardNormal = normalized;
        this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());
        return true;
    }
    setInvisible(invisible) {
        this._invisible = invisible;
    }
    /**  reverse the sign of all coefficients, so outside and inside reverse */
    negateInPlace() {
        this._inwardNormal = this._inwardNormal.negate();
        this._distanceFromOrigin = -this._distanceFromOrigin;
    }
    /**
     * Move the plane INWARD by given distance
     * @param offset distance of shift inwards
     */
    offsetDistance(offset) {
        this._distanceFromOrigin += offset;
    }
    convexPolygonClipInPlace(xyz, work) {
        work.length = 0;
        let numNegative = 0;
        ClipPlane.fractionTol = 1.0e-8;
        if (xyz.length > 2) {
            let xyz0 = xyz[xyz.length - 1];
            let a0 = this.evaluatePoint(xyz0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                if (a1 < 0)
                    numNegative++;
                if (a0 * a1 < 0.0) {
                    // simple crossing . . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - ClipPlane.fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                    }
                    else {
                        work.push(xyz0.interpolate(f, xyz1));
                    }
                }
                if (a1 >= 0.0)
                    work.push(xyz1);
                xyz0 = PointVector_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
        if (work.length <= 2) {
            xyz.length = 0;
        }
        else if (numNegative > 0) {
            xyz.length = 0;
            for (const xyzi of work) {
                xyz.push(xyzi);
            }
            work.length = 0;
        }
    }
    polygonCrossings(xyz, crossings) {
        crossings.length = 0;
        if (xyz.length >= 2) {
            let xyz0 = xyz[xyz.length - 1];
            let a0 = this.evaluatePoint(xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    crossings.push(xyz0.interpolate(f, xyz1));
                }
                if (a1 === 0.0) {
                    crossings.push(xyz1);
                }
                xyz0 = PointVector_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
    }
    convexPolygonSplitInsideOutside(xyz, xyzIn, xyzOut, altitudeRange) {
        xyzOut.length = 0;
        xyzIn.length = 0;
        // let numSplit = 0;
        ClipPlane.fractionTol = 1.0e-8;
        if (xyz.length > 2) {
            let xyz0 = xyz[xyz.length - 1];
            altitudeRange.setNull();
            let a0 = this.evaluatePoint(xyz0);
            altitudeRange.extendX(a0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (const xyz1 of xyz) {
                const a1 = this.evaluatePoint(xyz1);
                altitudeRange.extendX(a1);
                let nearZero = false;
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - ClipPlane.fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                        nearZero = true;
                    }
                    else {
                        const xyzA = xyz0.interpolate(f, xyz1);
                        xyzIn.push(xyzA);
                        xyzOut.push(xyzA);
                    }
                    // numSplit++;
                }
                if (a1 >= 0.0 || nearZero)
                    xyzIn.push(xyz1);
                if (a1 <= 0.0 || nearZero)
                    xyzOut.push(xyz1);
                xyz0 = PointVector_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
    }
    multiplyPlaneByMatrix(matrix) {
        const plane = this.getPlane4d();
        matrix.multiplyTransposePoint4d(plane, plane);
        this.setPlane4d(plane);
    }
    /** announce the interval (if any) where a line is within the clip plane half space. */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        if (f1 < f0)
            return false;
        const h0 = -this.evaluatePoint(pointA);
        const h1 = -this.evaluatePoint(pointB);
        const delta = h1 - h0;
        const f = Geometry_1.Geometry.conditionalDivideFraction(-h0, delta);
        if (f === undefined) {
            if (h0 <= 0.0) {
                if (announce)
                    announce(f0, f1);
                return true;
            }
            return false;
        }
        if (delta > 0) {
            if (f < f1)
                f1 = f;
        }
        else {
            // segment aims IN
            if (f > f0)
                f0 = f;
        }
        if (f1 < f0)
            return false;
        if (announce)
            announce(f0, f1);
        return true;
    }
}
// Static variable from original native c++ function ConvexPolygonClipInPlace
ClipPlane.fractionTol = 1.0e-8;
ClipPlane.sClipArcFractionArray = new GrowableArray_1.GrowableFloat64Array();
exports.ClipPlane = ClipPlane;
/**
 * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.
 */
class ConvexClipPlaneSet {
    // private _parity: number;   <--- Not yet used
    // public get parity() { return this._parity; }
    // public set parity(value: number) { this._parity = value; }
    constructor(planes) {
        // this._parity = 1;
        this._planes = planes ? planes : [];
    }
    toJSON() {
        const val = [];
        for (const plane of this._planes) {
            val.push(plane.toJSON());
        }
        return val;
    }
    static fromJSON(json, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            const plane = ClipPlane.fromJSON(thisJson);
            if (plane)
                result._planes.push(plane);
        }
        return result;
    }
    /**
     * @returns Return true if all members are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._planes.length !== other._planes.length)
            return false;
        for (let i = 0; i < this._planes.length; i++)
            if (!this._planes[i].isAlmostEqual(other._planes[i]))
                return false;
        return true;
    }
    static createPlanes(planes, result) {
        result = result ? result : new ConvexClipPlaneSet();
        for (const plane of planes)
            result._planes.push(plane);
        return result;
    }
    /**
     * Create new convex set using selected planes of a Range3d.
     * @param range range with coordinates
     * @param lowX true to clip at the low x plane
     * @param highX true to clip at the high x plane
     * @param lowY true to clip at the low y plane
     * @param highY true to clip at the high z plane
     * @param lowZ true to clip at the low z plane
     * @param highZ true to clip at the high z plane
     */
    static createRange3dPlanes(range, lowX = true, highX = true, lowY = true, highY = true, lowZ = true, highZ = true) {
        const result = ConvexClipPlaneSet.createEmpty();
        if (lowX)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0));
        if (highX)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0));
        if (lowY)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0));
        if (highY)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0));
        if (lowZ)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z));
        if (highZ)
            result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z));
        return result;
    }
    static createEmpty(result) {
        if (result) {
            result._planes.length = 0;
            return result;
        }
        return new ConvexClipPlaneSet();
    }
    /** negate all planes of the set. */
    negateAllPlanes() {
        for (const plane of this._planes)
            plane.negateInPlace();
    }
    static createXYBox(x0, y0, x1, y1, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        const clip0 = ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(-1, 0, 0), -x1, false, true);
        const clip1 = ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(1, 0, 0), x0, false, true);
        const clip2 = ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(0, -1, 0), -y1, false, true);
        const clip3 = ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(0, 1, 0), y0, false, true);
        if (clip0 && clip1 && clip2 && clip3) {
            result._planes.push(clip0, clip1, clip2, clip3);
        }
        return result;
    }
    static createXYPolyLine(points, interior, leftIsInside, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = PointVector_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            if (!leftIsInside)
                perp.negate();
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane.createNormalAndPoint(perp, points[i0], interior[i0], interior[i0]);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    /**
     * Create a convexClipPlaneSet with planes whose "inside" normal is to the left of each segment.
     * @param points array of points.
     */
    static createXYPolyLineInsideLeft(points, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = PointVector_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane.createNormalAndPoint(perp, points[i0], false, false);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    clone(result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (const plane of this._planes)
            result._planes.push(plane.clone());
        return result;
    }
    get planes() {
        return this._planes;
    }
    // tNear passed as Float64Array of size 1 to be used as reference
    static testRayIntersections(tNear, origin, direction, planes) {
        tNear[0] = -ConvexClipPlaneSet.hugeVal;
        let tFar = ConvexClipPlaneSet.hugeVal;
        for (const plane of planes._planes) {
            const vD = plane.dotProductVector(direction);
            const vN = plane.evaluatePoint(origin);
            if (vD === 0.0) {
                // Ray is parallel... No need to continue testing if outside halfspace.
                if (vN < 0.0)
                    return false;
            }
            else {
                const rayDistance = -vN / vD;
                if (vD < 0.0) {
                    if (rayDistance < tFar)
                        tFar = rayDistance;
                }
                else {
                    if (rayDistance > tNear[0])
                        tNear[0] = rayDistance;
                }
            }
        }
        return tNear[0] <= tFar;
    }
    multiplyPlanesByMatrix(matrix) {
        for (const plane of this._planes) {
            plane.multiplyPlaneByMatrix(matrix);
        }
    }
    isPointInside(point) {
        for (const plane of this._planes) {
            if (!plane.isPointInside(point))
                return false;
        }
        return true;
    }
    isPointOnOrInside(point, tolerance) {
        const interiorTolerance = Math.abs(tolerance); // Interior tolerance should always be positive. (TFS# 246598).
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))
                return false;
        }
        return true;
    }
    isSphereInside(point, radius) {
        // Note - The sphere logic differ from "PointOnOrInside" only in the handling of interior planes.
        // For a sphere we don't negate the tolerance on interior planes - we have to look for true containment (TFS# 439212).
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(point, radius)) {
                return false;
            }
        }
        return true;
    }
    /** Find the parts of the line segment  (if any) that is within the convex clip volume.
     * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.
     * * To clip to the usual bounded line segment, starts with fractions (0,1).
     * If the clip volume is unbounded, the line interval may also be unbounded.
     * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.
     * @param fraction0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)
     * @param fraction1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let fraction;
        if (f1 < f0)
            return false;
        for (const plane of this._planes) {
            const hA = -plane.evaluatePoint(pointA);
            const hB = -plane.evaluatePoint(pointB);
            fraction = Geometry_1.Geometry.safeDivideFraction(-hA, (hB - hA), 0.0);
            if (fraction === undefined) {
                // LIne parallel to the plane.  If positive, it is all OUT
                if (hA > 0.0)
                    return false;
            }
            else if (hB > hA) {
                if (fraction < f0)
                    return false;
                if (fraction < f1)
                    f1 = fraction;
            }
            else if (hA > hB) {
                if (fraction > f1)
                    return false;
                if (fraction > f0)
                    f0 = fraction;
            }
            else {
                // Strictly equal evaluations
                if (hA > 0.0)
                    return false;
            }
        }
        if (f1 >= f0) {
            if (announce)
                announce(f0, f1);
            return true;
        }
        return false;
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = ConvexClipPlaneSet.sClipArcFractionArray;
        breaks.clear();
        for (const clipPlane of this.planes) {
            clipPlane.appendIntersectionRadians(arc, breaks);
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /** Find the parts of the (unbounded) line segment  (if any) that is within the convex clip volume.
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    clipUnboundedSegment(pointA, pointB, announce) {
        return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);
    }
    transformInPlace(transform) {
        for (const plane of this._planes) {
            plane.transformInPlace(transform);
        }
    }
    /** Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.
     * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.
     * * The expected point set is for a polygon.
     * * Hence any clipping will eventually have to consider the lines between the points.
     * * This method looks for the special case of a single clip plane that has all the points outside.
     * * In this case the whole polygon must be outside.
     * * Note that this does not detect a polygon that is outside but "crosses a corner" -- it is mixed with respect to
     *     multiple planes.
     */
    classifyPointContainment(points, onIsOutside) {
        let allInside = true;
        const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;
        const interiorTolerance = 1.0e-8; // Interior tolerance should always be positive
        for (const plane of this._planes) {
            let nOutside = 0;
            for (const point of points) {
                if (plane.evaluatePoint(point) < (plane.interior ? interiorTolerance : onTolerance)) {
                    nOutside++;
                    allInside = false;
                }
            }
            if (nOutside === points.length)
                return 3 /* StronglyOutside */;
        }
        return allInside ? 1 /* StronglyInside */ : 2 /* Ambiguous */;
    }
    /**
     * * Create a convex clip set for a polygon swept with possible tilt angle.
     * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.
     * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in reverse order.
     * * If first and last points do not match, points are used in order given
     * @param points polygon points. (Closure point optional)
     * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector
     * @param tiltAngle angle to tilt sweep planes away from the sweep direction.
     */
    static createSweptPolyline(points, upVector, tiltAngle) {
        const result = ConvexClipPlaneSet.createEmpty();
        let reverse = false;
        if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {
            const polygonNormal = PointHelpers_1.PolygonOps.areaNormal(points);
            const normalDot = polygonNormal.dotProduct(upVector);
            if (normalDot > 0.0)
                reverse = true;
        }
        for (let i = 0; (i + 1) < points.length; i++) {
            if (reverse) {
                const toAdd = ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);
                if (toAdd) {
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
            else {
                const toAdd = ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);
                if (toAdd) {
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    addPlaneToConvexSet(plane) {
        if (plane)
            this._planes.push(plane);
    }
    clipPointsOnOrInside(points, inOrOn, out) {
        inOrOn.length = 0;
        out.length = 0;
        for (const xyz of points) {
            if (this.isPointOnOrInside(xyz, 0.0)) {
                inOrOn.push(xyz);
            }
            else {
                out.push(xyz);
            }
        }
    }
    polygonClip(input, output, work) {
        output.length = 0;
        // Copy input array
        for (const i of input)
            output.push(i);
        for (const plane of this._planes) {
            if (output.length === 0)
                break;
            plane.convexPolygonClipInPlace(output, work);
        }
    }
    /**
     * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.
     * * always create planes for the swept edges of the polygon
     * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.
     * @param points Points of a bounding polygon
     * @param sweepDirection direction to sweep.
     * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.
     */
    reloadSweptPolygon(points, sweepDirection, sideSelect) {
        this._planes.length = 0;
        const n = points.length;
        if (n <= 2)
            return 0;
        const planeNormal = PointHelpers_1.PolygonOps.areaNormal(points);
        const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;
        const delta = isCCW ? 1 : n - 1;
        for (let i = 0; i < n; i++) {
            const i1 = (i + delta) % n;
            const xyz0 = points[i];
            const xyz1 = points[i1];
            if (xyz0.isAlmostEqual(xyz1))
                continue;
            const edgeVector = PointVector_1.Vector3d.createStartEnd(xyz0, xyz1);
            const inwardNormal = PointVector_1.Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z, edgeVector.x, edgeVector.y, edgeVector.z);
            const inwardNormalNormalized = inwardNormal.normalize();
            let distance;
            if (inwardNormalNormalized) {
                distance = inwardNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // Clipplane creation could result in undefined
            }
        }
        if (sideSelect !== 0.0) {
            let planeNormalNormalized = planeNormal.normalize();
            if (planeNormalNormalized) {
                const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;
                if (a < 0.0)
                    planeNormalNormalized = planeNormalNormalized.negate();
                const xyz0 = points[0];
                const distance = planeNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // Clipplane creation could result in undefined
            }
        }
        return isCCW ? 1 : -1;
    }
    /**
     * Returns range if result does not cover a space of infinity, otherwise undefined.
     * Note: If given a range for output, overwrites it, rather than extending it.
     */
    getRangeOfAlignedPlanes(transform, result) {
        const idMatrix = Transform_1.RotMatrix.createIdentity();
        const bigRange = Range_2.Range3d.createXYZXYZ(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const range = bigRange.clone(result);
        for (const clipPlane of this._planes) {
            if (transform)
                clipPlane.transformInPlace(transform);
            // Array of 1-d ranges that will be pieced back together into a Range3d after making adjustments
            const rangePieces = [
                Range_1.Range1d.createXX(range.low.x, range.high.x),
                Range_1.Range1d.createXX(range.low.y, range.high.y),
                Range_1.Range1d.createXX(range.low.z, range.high.z)
            ];
            for (let i = 0; i < 3; i++) {
                // Set values of minP and maxP based on i (we are compensating for pointer arithmetic in native code)
                let minP;
                let maxP;
                minP = rangePieces[i].low;
                maxP = rangePieces[i].high;
                const direction = idMatrix.getColumn(i);
                if (clipPlane.inwardNormalRef.isParallelTo(direction, true)) {
                    if (clipPlane.inwardNormalRef.dotProduct(direction) > 0.0) {
                        if (clipPlane.distance > minP)
                            rangePieces[i].low = clipPlane.distance;
                    }
                    else {
                        if (-clipPlane.distance < maxP)
                            rangePieces[i].high = -clipPlane.distance;
                    }
                }
            }
            // Reassign to Range3d
            range.low.x = rangePieces[0].low;
            range.high.x = rangePieces[0].high;
            range.low.y = rangePieces[1].low;
            range.high.y = rangePieces[1].high;
            range.low.z = rangePieces[2].low;
            range.high.z = rangePieces[2].high;
        }
        if (range.isAlmostEqual(bigRange))
            return undefined;
        else
            return range;
    }
    setInvisible(invisible) {
        for (const plane of this._planes) {
            plane.setInvisible(invisible);
        }
    }
    addZClipPlanes(invisible, zLow, zHigh) {
        if (zLow !== undefined)
            this._planes.push(ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(0, 0, 1), zLow, invisible));
        if (zHigh !== undefined)
            this._planes.push(ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.create(0, 0, -1), -zHigh, invisible));
    }
}
ConvexClipPlaneSet.hugeVal = 1e37;
ConvexClipPlaneSet.sClipArcFractionArray = new GrowableArray_1.GrowableFloat64Array();
exports.ConvexClipPlaneSet = ConvexClipPlaneSet;
/**
 * A collection of ConvexClipPlaneSets.
 * * A point is "in" the clip plane set if it is "in" one or more of  the ConvexClipPlaneSet
 * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.
 */
class ClipPlaneSet {
    constructor() {
        this._convexSets = [];
    }
    get convexSets() { return this._convexSets; }
    toJSON() {
        const val = [];
        for (const convex of this._convexSets) {
            val.push(convex.toJSON());
        }
        return val;
    }
    static fromJSON(json, result) {
        result = result ? result : new ClipPlaneSet();
        result._convexSets.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            result._convexSets.push(ConvexClipPlaneSet.fromJSON(thisJson));
        }
        return result;
    }
    static createEmpty(result) {
        if (result) {
            result._convexSets.length = 0;
            return result;
        }
        return new ClipPlaneSet();
    }
    /**
     * @returns Return true if all member convex sets are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._convexSets.length !== other._convexSets.length)
            return false;
        for (let i = 0; i < this._convexSets.length; i++)
            if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))
                return false;
        return true;
    }
    static createConvexSets(convexSets, result) {
        result = result ? result : new ClipPlaneSet();
        for (const set of convexSets)
            result._convexSets.push(set);
        return result;
    }
    clone(result) {
        result = result ? result : new ClipPlaneSet();
        result._convexSets.length = 0;
        for (const convexSet of this._convexSets)
            result._convexSets.push(convexSet.clone());
        return result;
    }
    addConvexSet(toAdd) {
        this._convexSets.push(toAdd);
    }
    testRayIntersect(point, direction) {
        const tNear = new Float64Array(1);
        for (const planeSet of this._convexSets) {
            if (ConvexClipPlaneSet.testRayIntersections(tNear, point, direction, planeSet))
                return true;
        }
        return false;
    }
    getRayIntersection(point, direction) {
        let nearest = -ConvexClipPlaneSet.hugeVal;
        for (const planeSet of this._convexSets) {
            if (planeSet.isPointInside(point)) {
                return 0.0;
            }
            else {
                const tNear = new Float64Array(1);
                if (ConvexClipPlaneSet.testRayIntersections(tNear, point, direction, planeSet) && tNear[0] > nearest) {
                    nearest = tNear[0];
                }
            }
        }
        if (nearest > -ConvexClipPlaneSet.hugeVal)
            return nearest;
        else
            return undefined;
    }
    isPointInside(point) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointInside(point)) {
                return true;
            }
        }
        return false;
    }
    isPointOnOrInside(point, tolerance) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointOnOrInside(point, tolerance))
                return true;
        }
        return false;
    }
    isSphereInside(point, radius) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isSphereInside(point, radius))
                return true;
        }
        return false;
    }
    /** test if any part of a line segment is within the volume */
    isAnyPointInOrOnFromSegment(segment) {
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))
                return true;
        }
        return false;
    }
    // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,
    // and so splitting the intervals into segments aids in better organization
    /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces */
    appendIntervalsFromSegment(segment, intervals) {
        for (const convexSet of this._convexSets) {
            convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref, (fraction0, fraction1) => intervals.push(PointVector_1.Segment1d.create(fraction0, fraction1)));
        }
    }
    transformInPlace(transform) {
        for (const convexSet of this._convexSets) {
            convexSet.transformInPlace(transform);
        }
    }
    /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively */
    classifyPointContainment(points, onIsOutside) {
        for (const convexSet of this._convexSets) {
            const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);
            if (thisStatus !== 3 /* StronglyOutside */)
                return thisStatus;
        }
        return 3 /* StronglyOutside */;
    }
    /** Clip a polygon using this ClipPlaneSet, returning a new polygon boundary. */
    polygonClip(input, output) {
        output.length = 0;
        const convexClipOutput = [];
        for (const convexSet of this._convexSets) {
            convexSet.polygonClip(input, convexClipOutput, []);
            input = convexClipOutput.slice(); // input of next convex set is the output from the previous
            convexClipOutput.length = 0;
        }
        for (const point of input)
            output.push(point);
    }
    /**
     * * announce clipSegment() for each convexSet in this ClipPlaneSet.
     * * all clipPlaneSets are inspected
     * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.
     * @param f0 active interval start.
     * @param f1 active interval end
     * @param pointA line segment start
     * @param pointB line segment end
     * @param announce function to announce interval.
     * @returns Return true if any announcements are made.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let numAnnounce = 0;
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))
                numAnnounce++;
        }
        return numAnnounce > 0;
    }
    announceClippedArcIntervals(arc, announce) {
        const breaks = ClipPlaneSet.sClipArcFractionArray;
        breaks.clear();
        for (const convexSet of this._convexSets) {
            for (const clipPlane of convexSet.planes) {
                clipPlane.appendIntersectionRadians(arc, breaks);
            }
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * Returns range if result does not cover a space of infinity, otherwise undefined.
     * Note: If given a range for output, overwrites it, rather than extending it.
     */
    getRangeOfAlignedPlanes(transform, result) {
        const range = Range_2.Range3d.createNull(result);
        for (const convexSet of this._convexSets) {
            const thisRange = Range_2.Range3d.createNull();
            if (convexSet.getRangeOfAlignedPlanes(transform, thisRange))
                range.extendRange(thisRange);
        }
        if (range.isNull())
            return undefined;
        else
            return range;
    }
    multiplyPlanesByMatrix(matrix) {
        for (const convexSet of this._convexSets) {
            convexSet.multiplyPlanesByMatrix(matrix);
        }
    }
    setInvisible(invisible) {
        for (const convexSet of this._convexSets) {
            convexSet.setInvisible(invisible);
        }
    }
    addOutsideZClipSets(invisible, zLow, zHigh) {
        if (zLow) {
            const convexSet = ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, zLow);
            this._convexSets.push(convexSet);
        }
        if (zHigh) {
            const convexSet = ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, undefined, zHigh);
            this._convexSets.push(convexSet);
        }
    }
}
ClipPlaneSet.sClipArcFractionArray = new GrowableArray_1.GrowableFloat64Array();
exports.ClipPlaneSet = ClipPlaneSet;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const PointVector_1 = __webpack_require__(4);
/** Static class whose various methods are functions for clipping geometry. */
class ClipUtilities {
    static selectIntervals01(curve, unsortedFractions, clipper, announce) {
        unsortedFractions.push(0);
        unsortedFractions.push(1);
        unsortedFractions.sort();
        let f0 = unsortedFractions.at(0);
        let f1;
        let fMid;
        const testPoint = ClipUtilities.sSelectIntervals01TestPoint;
        const n = unsortedFractions.length;
        for (let i = 1; i < n; i++, f0 = f1) {
            f1 = unsortedFractions.at(i);
            fMid = 0.5 * (f0 + f1);
            if (f1 > f0 && (fMid >= 0.0 && fMid <= 1.0)) {
                curve.fractionToPoint(fMid, testPoint);
                if (clipper.isPointOnOrInside(testPoint)) {
                    if (announce)
                        announce(f0, f1, curve);
                    else
                        return true;
                }
            }
        }
        return false;
    }
    /**
     * Announce triples of (low, high, cp) for each entry in intervals
     * @param intervals source array
     * @param cp CurvePrimitive for announcement
     * @param announce funtion to receive data
     */
    static announceNNC(intervals, cp, announce) {
        if (announce) {
            for (const ab of intervals) {
                announce(ab.low, ab.high, cp);
            }
        }
        return intervals.length > 0;
    }
    static collectClippedCurves(curve, clipper) {
        const result = [];
        curve.announceClipIntervals(clipper, (fraction0, fraction1, curveA) => {
            if (fraction1 !== fraction0) {
                const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);
                if (partialCurve)
                    result.push(partialCurve);
            }
        });
        return result;
    }
    /**
     * Clip a polygon down to regions defined by each shape of a ClipVector.
     * @return An multidimensional array of points, where each array is the boundary of a clipped polygon.
     */
    static clipPolygonToClipVector(polygon, clipVec) {
        const output = [];
        for (const primitive of clipVec.clips) {
            const setOutput = [];
            primitive.fetchClipPlanesRef().polygonClip(polygon, setOutput);
            output.push(setOutput);
        }
        return output;
    }
    /** Given an array of points, return whether or not processing is required to clip to a ClipPlaneSet region. */
    static pointSetSingleClipStatus(points, planeSet, tolerance) {
        if (planeSet.convexSets.length === 0)
            return 2 /* TrivialAccept */;
        for (const convexSet of planeSet.convexSets) {
            let allOutsideSinglePlane = false, anyOutside = false;
            for (const plane of convexSet.planes) {
                let numInside = 0, numOutside = 0;
                const planeDistance = plane.distance - tolerance;
                const currPt = PointVector_1.Point3d.create();
                const currVec = PointVector_1.Vector3d.create();
                for (let i = 0; i < points.length; i++) {
                    points.getPoint3dAt(i, currPt);
                    currVec.setFrom(currPt);
                    currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;
                }
                anyOutside = (numOutside !== 0) ? true : anyOutside;
                if (numInside === 0) {
                    allOutsideSinglePlane = true;
                    break;
                }
            }
            if (!anyOutside)
                return 2 /* TrivialAccept */;
            if (!allOutsideSinglePlane)
                return 0 /* ClipRequired */;
        }
        return 1 /* TrivialReject */;
    }
}
ClipUtilities.sSelectIntervals01TestPoint = PointVector_1.Point3d.create();
exports.ClipUtilities = ClipUtilities;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPlane_1 = __webpack_require__(134);
const PointVector_1 = __webpack_require__(4);
const Range_1 = __webpack_require__(21);
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
const PointHelpers_1 = __webpack_require__(22);
/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */
class PolyEdge {
    constructor(origin, next, normal, z) {
        this.origin = PointVector_1.Point3d.create(origin.x, origin.y, z);
        this.next = PointVector_1.Point3d.create(next.x, next.y, z);
        this.normal = normal;
    }
}
/**
 * Cache structure that holds a ClipPlaneSet and various parameters for adding new ClipPlanes to the set. This structure
 * will typically be fed to an additive function that will append new ClipPlanes to the cache based on these parameters.
 */
class PlaneSetParamsCache {
    constructor(zLow, zHigh, localOrigin, isMask = false, isInvisible = false, focalLength = 0.0) {
        this.clipPlaneSet = ClipPlane_1.ClipPlaneSet.createEmpty();
        this.zLow = zLow;
        this.zHigh = zHigh;
        this.isMask = isMask;
        this.invisible = isInvisible;
        this.focalLength = focalLength;
        this.limitValue = 0;
        this.localOrigin = localOrigin ? localOrigin : PointVector_1.Point3d.create();
    }
}
exports.PlaneSetParamsCache = PlaneSetParamsCache;
/** Base class for clipping implementations that use
 *
 * * A ClipPlaneSet designated "clipPlanes"
 * * A ClipPlaneSet designated "maskPlanes"
 * * an "invisible" flag
 */
class ClipPrimitive {
    constructor(planeSet, isInvisible = false) {
        this._clipPlanes = planeSet;
        this._invisible = isInvisible;
    }
    transformInPlaceSuper(transform) {
        if (this._clipPlanes)
            this._clipPlanes.transformInPlace(transform);
        if (this._maskPlanes)
            this._maskPlanes.transformInPlace(transform);
        return true;
    }
    /** Sets both the clip plane set and the mask set visibility */
    setInvisible(invisible) {
        this._invisible = invisible;
        if (this._clipPlanes)
            this._clipPlanes.setInvisible(invisible);
        if (this._maskPlanes)
            this._maskPlanes.setInvisible(invisible);
    }
    containsZClip() {
        if (this.fetchClipPlanesRef() !== undefined)
            for (const convexSet of this._clipPlanes.convexSets)
                for (const plane of convexSet.planes)
                    if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)
                        return true;
        return false;
    }
    /**
     * Determines whether the given points fall inside or outside the set. If this set is defined by masking planes,
     * will check the mask planes only, provided that ignoreMasks is false. Otherwise, will check the clipplanes member.
     */
    classifyPointContainment(points, ignoreMasks) {
        if (this.fetchMaskPlanesRef() !== undefined) {
            if (ignoreMasks)
                return 1 /* StronglyInside */;
            switch (this._maskPlanes.classifyPointContainment(points, true)) {
                case 1 /* StronglyInside */:
                    return 3 /* StronglyOutside */;
                case 3 /* StronglyOutside */:
                    return 1 /* StronglyInside */;
                case 2 /* Ambiguous */:
                    return 2 /* Ambiguous */;
            }
        }
        return (this.fetchClipPlanesRef() === undefined) ? 1 /* StronglyInside */ : this._clipPlanes.classifyPointContainment(points, false);
    }
    static isLimitEdge(limitValue, point0, point1) {
        const tol = 1.0e-5 * limitValue;
        // High x-limit...
        if (Math.abs(point0.x - limitValue) < tol && Math.abs(point1.x - limitValue) < tol)
            return true;
        // Low x-limit...
        if (Math.abs(point0.x + limitValue) < tol && Math.abs(point1.x + limitValue) < tol)
            return true;
        // high y limit ...
        if (Math.abs(point0.y - limitValue) < tol && Math.abs(point1.y - limitValue) < tol)
            return true;
        // low y limit ...
        if (Math.abs(point0.y + limitValue) < tol && Math.abs(point1.y + limitValue) < tol)
            return true;
        return false;
    }
    /** Add an unbounded plane set (a) to the right of the line defined by two points, and (b) "ahead" of
     *  the start point (set is pushed to the set located within the PlaneSetParamsCache object given). This method can be used
     *  in the development of ClipShapes, by ClipShapes.
     */
    static addOutsideEdgeSetToParams(x0, y0, x1, y1, pParams, isInvisible = false) {
        const unit0 = PointVector_1.Vector3d.create();
        const vec0 = PointVector_1.Vector3d.create(x1 - x0, y1 - y0, 0.0);
        const point0 = PointVector_1.Point3d.create(x0 + pParams.localOrigin.x, y0 + pParams.localOrigin.y, 0.0);
        vec0.normalize(unit0);
        const unit1 = PointVector_1.Vector3d.create(unit0.y, -unit0.x, 0.0);
        const convexSet = ClipPlane_1.ConvexClipPlaneSet.createEmpty();
        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(unit1, point0, isInvisible));
        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(unit0, point0, isInvisible));
        convexSet.addZClipPlanes(isInvisible, pParams.zLow, pParams.zHigh);
        pParams.clipPlaneSet.convexSets.push(convexSet);
    }
    /**
     * Add a plane set representative of a 3d object based on the given array of 2d points and 3d parameters of the PlaneSetParamsCache,
     * where the returned value is stored in the params object given. The original points array given is not modified. This method
     * can be used in the development of ClipShapes, by ClipShapes.
     */
    static addShapeToParams(shape, pFlags, pParams) {
        const pPoints = shape.slice(0);
        // Add the closure point
        if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))
            pPoints.push(pPoints[0].clone());
        const area = PointHelpers_1.PolygonOps.areaXY(pPoints);
        const n = pPoints.length;
        const point0 = PointVector_1.Point3d.create();
        const point1 = PointVector_1.Point3d.create();
        const vector0 = PointVector_1.Vector3d.create();
        const vector1 = PointVector_1.Vector3d.create();
        const point0Local = PointVector_1.Point3d.create();
        let point1Local = PointVector_1.Point3d.create();
        const zVector = PointVector_1.Vector3d.create(0, 0, 1);
        let normal;
        let tangent;
        const convexSet = ClipPlane_1.ConvexClipPlaneSet.createEmpty();
        const reverse = area < 0.0;
        for (let i = 0; i < n; i++, point0.setFrom(point1), point0Local.setFrom(point1Local)) {
            point1Local = pPoints[i % n];
            point1Local.plus(pParams.localOrigin, point1);
            if (i && !point1.isAlmostEqual(point0, 1.0e-8)) {
                const bIsLimitPlane = ClipPrimitive.isLimitEdge(pParams.limitValue, point0Local, point1Local);
                const isInterior = (0 === (pFlags[i - 1] & 1)) || bIsLimitPlane;
                if (!pParams.focalLength) {
                    tangent = PointVector_1.Vector3d.createFrom(point1.minus(point0));
                    normal = zVector.crossProduct(tangent).normalize(); // Assumes that cross product is never zero vector
                    if (reverse)
                        normal.negate(normal);
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(normal, point0, pParams.invisible, isInterior));
                }
                else {
                    vector1.setFrom(point1);
                    vector0.setFrom(point0);
                    normal = vector1.crossProduct(vector0).normalize();
                    if (reverse)
                        normal.negate();
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(normal, 0.0, pParams.invisible, isInterior));
                }
            }
        }
        convexSet.addZClipPlanes(pParams.invisible, pParams.zLow, pParams.zHigh);
        if (convexSet.planes.length !== 0)
            pParams.clipPlaneSet.convexSets.push(convexSet);
    }
}
exports.ClipPrimitive = ClipPrimitive;
/**
 * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).
 * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters
 * for parsing clipplanes from the shape later.
 */
class ClipShape extends ClipPrimitive {
    constructor(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false) {
        super(undefined, invisible); // ClipPlaneSets will be set up later after storing points
        this._isMask = false;
        this._zLowValid = false;
        this._zHighValid = false;
        this._transformValid = false;
        this._polygon = polygon;
        this.initSecondaryProps(isMask, zLow, zHigh, transform);
    }
    /** Returns true if this ClipShape is marked as invisible. */
    get invisible() { return this._invisible; }
    /** Return this transformFromClip, which may be undefined. */
    get transformFromClip() { return this._transformFromClip; }
    /** Return this transformToClip, which may be undefined. */
    get transformToClip() { return this._transformToClip; }
    /** Returns true if this ClipShape's transforms are currently set. */
    get transformValid() { return this._transformValid; }
    /** Returns true if this ClipShape's lower z boundary is set. */
    get zLowValid() { return this._zLowValid; }
    /** Returns true if this ClipShape's upper z boundary is set. */
    get zHighValid() { return this._zHighValid; }
    /** Return this zLow, which may be undefined. */
    get zLow() { return this._zLow; }
    /** Return this zHigh, which may be undefined. */
    get zHigh() { return this._zHigh; }
    /** Returns a reference to this ClipShape's polygon array. */
    get polygon() { return this._polygon; }
    /** Return this bspline curve, which may be undefined. */
    get bCurve() { return this._bCurve; }
    /** Returns true if this ClipShape is a masking set. */
    get isMask() { return this._isMask; }
    /**
     * Returns true if this ClipShape has been parsed, and currently contains a ClipPlaneSet in its cache.
     * This does not take into account validity of the ClipPlanes, given that the polygon array might have changed.
     */
    arePlanesDefined() {
        if (this._isMask)
            return this._maskPlanes !== undefined;
        return this._clipPlanes !== undefined;
    }
    /** Sets the polygon points array of this ClipShape to the array given (by reference). */
    setPolygon(polygon) {
        // Add closure point
        if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))
            polygon.push(polygon[0].clone());
        this._polygon = polygon;
    }
    /**
     * If the clip plane set is already stored, return it. Otherwise, parse the clip planes out of the shape
     * defined by the set of polygon points.
     */
    fetchClipPlanesRef() {
        if (this._clipPlanes !== undefined)
            return this._clipPlanes;
        this._clipPlanes = ClipPlane_1.ClipPlaneSet.createEmpty();
        this.parseClipPlanes(this._clipPlanes);
        if (this._transformValid)
            this._clipPlanes.transformInPlace(this._transformFromClip);
        return this._clipPlanes;
    }
    /**
     * If the masking clip plane set is already stored, return it. Otherwise, parse the mask clip planes out of the shape
     * defined by the set of polygon points.
     */
    fetchMaskPlanesRef() {
        if (!this._isMask)
            return undefined;
        if (this._maskPlanes !== undefined)
            return this._maskPlanes;
        this._maskPlanes = ClipPlane_1.ClipPlaneSet.createEmpty();
        this.parseClipPlanes(this._maskPlanes);
        if (this._transformValid)
            this._maskPlanes.transformInPlace(this._transformFromClip);
        return this._maskPlanes;
    }
    /**
     * Initialize the members of the ClipShape class that may at times be undefined.
     * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform
     */
    initSecondaryProps(isMask, zLow, zHigh, transform) {
        this._isMask = isMask;
        this._zLowValid = (zLow !== undefined);
        if (false !== this._zLowValid)
            this._zLow = zLow;
        else
            this._zLow = -Number.MAX_VALUE;
        this._zHighValid = (zHigh !== undefined);
        if (false !== this._zHighValid)
            this._zHigh = zHigh;
        else
            this._zHigh = Number.MAX_VALUE;
        this._transformValid = (transform !== undefined);
        if (false !== this._transformValid) {
            this._transformFromClip = transform;
            this._transformToClip = transform.inverse(); // could be undefined
        }
        else {
            this._transformFromClip = Transform_1.Transform.createIdentity();
            this._transformToClip = Transform_1.Transform.createIdentity();
        }
    }
    toJSON() {
        const val = {};
        val.shape = {};
        val.shape.points = [];
        for (const pt of this._polygon)
            val.shape.points.push(pt.toJSON());
        if (this.invisible)
            val.shape.invisible = true;
        if (this._transformFromClip && !this._transformFromClip.isIdentity())
            val.shape.trans = this._transformFromClip.toJSON();
        if (this.isMask)
            val.shape.mask = true;
        if (typeof (this.zLow) !== "undefined" && this.zLow !== -Number.MAX_VALUE)
            val.shape.zlow = this.zLow;
        if (typeof (this.zHigh) !== "undefined" && this.zHigh !== Number.MAX_VALUE)
            val.shape.zhigh = this.zHigh;
        return val;
    }
    static fromJSON(json, result) {
        if (!json.shape)
            return undefined;
        const points = [];
        if (json.shape.points)
            for (const pt of json.shape.points)
                points.push(PointVector_1.Point3d.fromJSON(pt));
        let trans;
        if (json.shape.trans)
            trans = Transform_1.Transform.fromJSON(json.shape.trans);
        let zLow;
        if (json.shape.zlow)
            zLow = json.shape.zlow;
        let zHigh;
        if (json.shape.zhigh)
            zHigh = json.shape.zhigh;
        let isMask = false;
        if (json.shape.mask)
            isMask = json.shape.mask;
        let invisible = false;
        if (json.shape.invisible)
            invisible = true;
        return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);
    }
    /** Returns a new ClipShape that is a deep copy of the ClipShape given */
    static createFrom(other, result) {
        const retVal = ClipShape.createEmpty(false, false, undefined, result);
        retVal._invisible = other._invisible;
        for (const point of other._polygon) {
            retVal._polygon.push(point.clone());
        }
        retVal._isMask = other._isMask;
        retVal._zLow = other._zLow;
        retVal._zHigh = other._zHigh;
        retVal._zLowValid = other._zLowValid;
        retVal._zHighValid = other._zHighValid;
        retVal._transformValid = other._transformValid;
        retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;
        retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;
        retVal._bCurve = other._bCurve ? other._bCurve.clone() : undefined;
        // TODO: COPY _gpa AS WELL, ONCE IT IS IMPLEMENTED
        return retVal;
    }
    /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */
    static createShape(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false, result) {
        if (polygon.length < 3)
            return undefined;
        const pPoints = polygon.slice(0);
        // Add closure point
        if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))
            pPoints.push(pPoints[0]);
        if (result) {
            result._clipPlanes = undefined; // Start as undefined
            result._maskPlanes = undefined; // Start as undefined
            result._invisible = invisible;
            result._polygon = pPoints;
            result.initSecondaryProps(isMask, zLow, zHigh, transform);
            return result;
        }
        else {
            return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);
        }
    }
    /**
     * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to
     * also store this shape's zLow and zHigh members from the range through the use of a ClipMask.
     */
    static createBlock(extremities, clipMask, isMask = false, invisible = false, transform, result) {
        const low = extremities.low;
        const high = extremities.high;
        const blockPoints = [];
        for (let i = 0; i < 5; i++)
            blockPoints.push(PointVector_1.Point3d.create());
        blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;
        blockPoints[1].x = blockPoints[2].x = high.x;
        blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;
        blockPoints[2].y = blockPoints[3].y = high.y;
        return ClipShape.createShape(blockPoints, (0 /* None */ !== (clipMask & 16 /* ZLow */)) ? low.z : undefined, 0 /* None */ !== (clipMask & 32 /* ZHigh */) ? high.z : undefined, transform, isMask, invisible, result);
    }
    /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */
    static createEmpty(isMask = false, invisible = false, transform, result) {
        if (result) {
            result._clipPlanes = undefined;
            result._maskPlanes = undefined;
            result._invisible = invisible;
            result._bCurve = undefined;
            result._polygon.length = 0;
            result.initSecondaryProps(isMask, undefined, undefined, transform);
            return result;
        }
        return new ClipShape([], undefined, undefined, transform, isMask, invisible);
    }
    /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */
    isValidPolygon() {
        if (this._polygon.length < 3)
            return false;
        if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))
            return false;
        return true;
    }
    /** Returns a deep copy of this instance of ClipShape, storing in an optional result */
    clone(result) {
        return ClipShape.createFrom(this, result);
    }
    /** Given the current polygon data, parses clip planes that together form an object, storing the result in the set given, either clipplanes or maskplanes. */
    parseClipPlanes(set) {
        const points = this._polygon;
        if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {
            this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);
            return true;
        }
        const direction = PointHelpers_1.PolygonOps.testXYPolygonTurningDirections(points);
        if (0 !== direction) {
            this.parseConvexPolygonPlanes(set, direction);
            return true;
        }
        else {
            // TODO: HANDLE CONCAVE POLYGONS
            return false;
        }
    }
    parseLinearPlanes(set, start, end, cameraFocalLength) {
        // Handles the degenerate case of 2 distinct points (used by select by line).
        const normal = start.vectorTo(end);
        if (normal.magnitude() === 0.0)
            return false;
        normal.normalize(normal);
        const convexSet = ClipPlane_1.ConvexClipPlaneSet.createEmpty();
        if (cameraFocalLength === undefined) {
            const perpendicular = PointVector_1.Vector2d.create(-normal.y, normal.x);
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(normal.x, normal.y), PointVector_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(-normal.x, -normal.y), PointVector_1.Point3d.createFrom(end), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(perpendicular.x, perpendicular.y), PointVector_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(-perpendicular.x, -perpendicular.y), PointVector_1.Point3d.createFrom(start), this._invisible));
        }
        else {
            const start3d = PointVector_1.Point3d.create(start.x, start.y, -cameraFocalLength);
            const end3d = PointVector_1.Point3d.create(end.x, end.y, -cameraFocalLength);
            const vecEnd3d = PointVector_1.Vector3d.createFrom(end3d);
            const perpendicular = vecEnd3d.crossProduct(PointVector_1.Vector3d.createFrom(start3d)).normalize();
            let endNormal = PointVector_1.Vector3d.createFrom(start3d).crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
            perpendicular.negate();
            endNormal = vecEnd3d.crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
        }
        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
        set.addConvexSet(convexSet);
        return true;
    }
    parseConvexPolygonPlanes(set, direction, cameraFocalLength) {
        const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants
        const edges = [];
        const reverse = (direction < 0) !== this._isMask;
        const polygon = this._polygon;
        const numVerts = this._polygon.length;
        for (let i = 0; i < numVerts - 1; i++) {
            const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;
            const dir = PointVector_1.Vector2d.createFrom((polygon[i + 1].minus(polygon[i])));
            const magnitude = dir.magnitude();
            dir.normalize(dir);
            if (magnitude > samePointTolerance) {
                const normal = PointVector_1.Vector2d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);
                edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));
            }
        }
        if (edges.length < 3) {
            return false;
        }
        if (this._isMask) {
            const last = edges.length - 1;
            for (let i = 0; i <= last; i++) {
                const edge = edges[i];
                const prevEdge = edges[i ? (i - 1) : last];
                const nextEdge = edges[(i === last) ? 0 : (i + 1)];
                const convexSet = ClipPlane_1.ConvexClipPlaneSet.createEmpty();
                const prevNormal = edge.normal.minus(prevEdge.normal);
                const nextNormal = edge.normal.minus(nextEdge.normal);
                prevNormal.normalize(prevNormal);
                nextNormal.normalize(nextNormal);
                // Create three-sided fans from each edge.   Note we could define the correct region
                // with only two planes for edge, but cannot then designate the "interior" status of the edges accurately.
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(prevNormal.x, prevNormal.y), edge.origin, this._invisible, true));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin, this._invisible, false));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(nextNormal.x, nextNormal.y), nextEdge.origin, this._invisible, true));
                convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
                set.addConvexSet(convexSet);
            }
            set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);
        }
        else {
            const convexSet = ClipPlane_1.ConvexClipPlaneSet.createEmpty();
            if (cameraFocalLength === undefined) {
                for (const edge of edges)
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(PointVector_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin));
            }
            else {
                if (reverse)
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.createFrom(edge.origin).crossProduct(PointVector_1.Vector3d.createFrom(edge.next)).normalize(), 0.0));
                else
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(PointVector_1.Vector3d.createFrom(edge.next).crossProduct(PointVector_1.Vector3d.createFrom(edge.origin)).normalize(), 0.0));
            }
            convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
            set.addConvexSet(convexSet);
        }
        return true;
    }
    /** Get the 3-dimensional range that this combination of ClipPlanes bounds in space. Returns the range/result
     *  if successful, otherwise, returns undefined. Transform will only be used for transforming the polygon points if clipplanes/maskplanes
     *  have not yet been set. Otherwise, we return the range of the planes without an applied transform.
     */
    getRange(returnMaskRange = false, transform, result) {
        let zHigh = Number.MAX_VALUE;
        let zLow = -Number.MAX_VALUE;
        transform = (transform === undefined) ? Transform_1.Transform.createIdentity() : transform;
        if (this._transformToClip !== undefined)
            transform.setMultiplyTransformTransform(transform, this._transformFromClip);
        if ((!returnMaskRange && this._isMask) || this._polygon === undefined)
            return undefined;
        if (this._zLowValid)
            zLow = this._zLow;
        if (this._zHighValid)
            zHigh = this._zHigh;
        const range = Range_1.Range3d.createNull(result);
        for (const point of this._polygon) {
            const shapePts = [
                PointVector_1.Point3d.create(point.x, point.y, zLow),
                PointVector_1.Point3d.create(point.x, point.y, zHigh),
            ];
            transform.multiplyPoint3dArray(shapePts, shapePts);
            range.extend(shapePts[0], shapePts[1]);
        }
        if (range.isNull()) {
            return undefined;
        }
        return range;
    }
    /** Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise, return false. */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        if (this.fetchMaskPlanesRef() !== undefined)
            return !this._maskPlanes.isPointOnOrInside(point, onTolerance);
        return this.fetchClipPlanesRef().isPointOnOrInside(point, onTolerance);
    }
    transformInPlace(transform) {
        if (transform.isIdentity())
            return true;
        this.transformInPlaceSuper(transform);
        if (this._transformValid)
            transform.multiplyTransformTransform(this._transformFromClip, this._transformFromClip);
        else
            this._transformFromClip = transform;
        this._transformToClip = this._transformFromClip.inverse(); // could be undefined
        this._transformValid = true;
        return true;
    }
    multiplyPlanesTimesMatrix(matrix) {
        if (this._isMask)
            return false;
        this._clipPlanes = ClipPlane_1.ClipPlaneSet.createEmpty();
        this._maskPlanes = undefined;
        this.parseClipPlanes(this._clipPlanes);
        this._clipPlanes.multiplyPlanesByMatrix(matrix);
        return true;
    }
    isXYPolygon() {
        if (this._polygon.length === 0)
            return false;
        if (this._transformFromClip === undefined)
            return true;
        const testPoint = PointVector_1.Vector3d.create(0.0, 0.0, 1.0);
        this._transformFromClip.multiplyVectorXYZ(testPoint.x, testPoint.y, testPoint.z, testPoint);
        return testPoint.magnitudeXY() < 1.0e-8;
    }
    /** Transform the input point using this instance's transformToClip member */
    performTransformToClip(point) {
        if (this._transformToClip !== undefined)
            this._transformToClip.multiplyPoint3d(point);
    }
    /** Transform the input point using this instance's transformFromClip member */
    performTransformFromClip(point) {
        if (this._transformFromClip !== undefined)
            this._transformFromClip.multiplyPoint3d(point);
    }
}
exports.ClipShape = ClipShape;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(3);
const PascalCoefficients_1 = __webpack_require__(243);
const Polynomials_1 = __webpack_require__(66);
/* tslint:disable:variable-name*/
/**
 * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.
 * * The base class carries a Float64Array with coefficients.
 * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.
 * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.
 * * The general degree Bezier class also uses this as its base class.
 * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.
 */
class BezierCoffs {
    /**
     * * If `data` is a number, an array of that size is created with zeros.
     * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)
     * * If `data` is a number array, its values are copied.
     */
    constructor(data) {
        if (data instanceof Float64Array) {
            this.coffs = data.slice();
        }
        else if (Array.isArray(data)) {
            this.coffs = new Float64Array(data.length);
            let i = 0;
            for (const a of data)
                this.coffs[i++] = a;
        }
        else {
            this.coffs = new Float64Array(data);
        }
    }
    /**
     * create an object of same order with zero coefficients.
     * The base implementation makes a generic Bezier of the same order.
     */
    createPeer() {
        const peer = new Bezier(this.order);
        return peer;
    }
    /** The order (number of coefficients) as a readable property  */
    get order() { return this.coffs.length; }
    /** Copy coefficients from other Bezier. Note that the coefficient count (order) of "this" can change. */
    copyFrom(other) {
        if (this.order === other.order)
            for (let i = 0; i < this.coffs.length; i++) {
                this.coffs[i] = other.coffs[i];
            }
        else
            this.coffs = other.coffs.slice();
    }
    /**
     * Apply a scale factor to all coefficients.
     * @param scale scale factor to apply to all coefficients.
     */
    scaleInPlace(scale) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] *= scale;
    }
    /** add a constant to each coefficient.
     * @param a constant to add.
     */
    addInPlace(a) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] += a;
    }
    /** Compute parameter values where the bezier value matches _targetValue.
     * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)
     * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.
     */
    roots(targetValue, _restrictTo01) {
        const bezier = Bezier.create(this);
        bezier.addInPlace(-targetValue);
        return Bezier.deflateRoots01(bezier);
    }
    /** Given an array of numbers, optionally remove those not in the 0..1 interval.
     * @param roots candidate values
     * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.
     *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.
     */
    filter01(roots, restrictTo01 = false) {
        if (!roots || !restrictTo01)
            return roots;
        let anyFound = false;
        for (const r of roots) {
            if (Geometry_1.Geometry.isIn01(r)) {
                anyFound = true;
                break;
            }
        }
        if (anyFound) {
            const roots01 = [];
            for (const r of roots) {
                if (Geometry_1.Geometry.isIn01(r))
                    roots01.push(r);
            }
            return roots01;
        }
        return undefined;
    }
    zero() { for (let i = 0; i < this.coffs.length; i++) {
        this.coffs[i] = 0.0;
    } }
    /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */
    subdivide(u, left, right) {
        const order = this.order;
        if (left.order !== order && right.order !== order)
            return false;
        const v = 1.0 - u;
        right.copyFrom(this);
        // each left will be filled in directly, so there is no need to initialize it.
        let n1 = order - 1; // number of interpolations in inner loop.
        for (let i0 = 0; i0 < order; i0++) {
            left.coffs[i0] = right.coffs[0];
            for (let i = 0; i < n1; i++)
                right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];
            n1--;
        }
        return true;
    }
    static maxAbsDiff(dataA, dataB) {
        const order = dataA.order;
        if (dataB.order !== order)
            return undefined;
        let d = 0.0;
        let d1;
        for (let i = 0; i < order; i++) {
            d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);
            if (d1 > d)
                d = d1;
        }
        return d;
    }
}
exports.BezierCoffs = BezierCoffs;
/**
 * * The Bezier class is an one-dimensional bezier polynomial with no particular order.
 * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- should be used when a fixed order is known.
 * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)
 *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the
 *     curve order.   Hence those polynomials commonly reach degree 8 to 12.
 * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.
 * * Some machine-level constraints apply for curves of extrmely high order, e.g. 70.   For instance, at that level use of
 *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that
 *     large.
 */
class Bezier extends BezierCoffs {
    get order() { return this._order; }
    constructor(order) {
        super(order);
        this._order = order;
    }
    /** Return a copy, optionally with coffs array length reduced to actual order. */
    clone(compressToMinimalAllocation = false) {
        if (compressToMinimalAllocation) {
            const result1 = new Bezier(this.order);
            result1.coffs = this.coffs.slice(0, this.order);
            return result1;
        }
        const result = new Bezier(this.coffs.length);
        result._order = this._order;
        result.coffs = this.coffs.slice();
        return result;
    }
    /** Create a new bezier which is a copy of other.
     * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`
     * @param other coefficients to copy.
     */
    static create(other) {
        const result = new Bezier(other.order);
        result.coffs = other.coffs.slice();
        return result;
    }
    /**
     * copy coefficients into a new bezier.
     * @param coffs coefficients for bezier
     */
    static createCoffs(coffs) {
        const result = new Bezier(coffs.length);
        for (let i = 0; i < coffs.length; i++)
            result.coffs[i] = coffs[i];
        return result;
    }
    /**
     * Create a product of 2 bezier polynomials.
     * @param bezierA
     * @param bezierB
     */
    static createProduct(bezierA, bezierB) {
        const result = new Bezier(bezierA.order + bezierB.order - 1);
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order - 1);
        const pascalB = PascalCoefficients_1.PascalCoefficients.getRow(bezierB.order - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);
        for (let iA = 0; iA < bezierA.order; iA++) {
            const a = bezierA.coffs[iA] * pascalA[iA];
            for (let iB = 0; iB < bezierB.order; iB++) {
                const b = bezierB.coffs[iB] * pascalB[iB];
                const iC = iA + iB;
                const c = pascalC[iC];
                result.coffs[iC] += a * b / c;
            }
        }
        return result;
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        if (!result || result.length !== this.order)
            result = new Float64Array(this.order);
        let i = 0;
        for (const a of this._basisValues)
            result[i++] = a;
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        let sum = 0;
        for (let i = 0; i < this.order; i++)
            sum += this._basisValues[i] * this.coffs[i];
        return sum;
    }
    /**
     * Apply deflation from the left to a bezier.
     * * This assumes that the left coefficient is zero.
     */
    deflateLeft() {
        // coefficient 0 is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i + 1];
            this.coffs[i] = a * coff1[i + 1] / coff0[i];
        }
        this._order--;
    }
    /**
     * Apply deflation from the right to a frame.
     * * This assumes that the right coefficient is zero.
     * @param frame frame description
     */
    deflateRight() {
        // final coefficient is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a, b;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i];
            b = a * coff1[i] / coff0[i];
            this.coffs[i] = b;
        }
        this._order--;
    }
    /**
     * divide the polynomial by `(x-root)`.
     * * If `root` is truly a root.
     * @param root root to remove
     */
    deflateRoot(root) {
        const orderA = this.order;
        const orderC = orderA - 1; // the order of the deflated bezier.
        if (orderA === 1) {
            this._order = 0;
            return this.coffs[0];
        }
        if (orderA < 1) {
            this._order = 0;
            return 0.0;
        }
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        const b0 = -root;
        const b1 = 1.0 - root;
        let remainder = 0;
        if (root > 0.5) {
            let c0 = this.coffs[0] / b0;
            let c1;
            this.coffs[0] = c0;
            let a1 = this.coffs[1];
            for (let i = 1; i < orderC; i++) {
                a1 = this.coffs[i] * pascalA[i];
                c1 = (a1 - c0 * b1) / b0;
                this.coffs[i] = c1 / pascalC[i];
                c0 = c1;
            }
            remainder = this.coffs[orderA - 1] - c0 * b1;
        }
        else {
            // work backwards (to get division by larger of b0, b1)
            // replace coefficients of a starting wtih orderA -1 --
            // at end move them all forward.
            let c1 = this.coffs[orderA - 1] / b1;
            let c0;
            this.coffs[orderA - 1] = c1;
            let a1;
            for (let i = orderA - 2; i > 0; i--) {
                a1 = this.coffs[i] * pascalA[i];
                c0 = (a1 - c1 * b0) / b1;
                this.coffs[i] = c0 / pascalC[i - 1]; // pascalC index is from destination, which is not shifted.
                c1 = c0;
            }
            remainder = (this.coffs[0] - c1 * b0);
            for (let i = 0; i < orderC; i++)
                this.coffs[i] = this.coffs[i + 1];
        }
        this._order = orderC;
        // This should be zero !!!! (If not, `root` was not really a root!!)
        return remainder;
    }
    /**
     * Run a Newton iteration from startFraction.
     * @param startFraction [in] fraction for first iteration
     * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the
     * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass
     * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting
     * that the final iteration will clean it up to nearly machine precision.
     * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.
     */
    runNewton(startFraction, tolerance = 1.0e-11) {
        const derivativeFactor = this.order - 1;
        let numConverged = 0;
        let u = startFraction;
        let f, df;
        const bigStep = 10.0;
        const order = this.order;
        const coffs = this.coffs;
        const orderD = order - 1;
        for (let iterations = 0; iterations++ < 10;) {
            Bezier._basisBuffer = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(order, u, Bezier._basisBuffer);
            f = 0;
            for (let i = 0; i < order; i++)
                f += coffs[i] * Bezier._basisBuffer[i];
            Bezier._basisBuffer1 = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(orderD, u, Bezier._basisBuffer1);
            df = 0;
            for (let i = 0; i < orderD; i++)
                df += (coffs[i + 1] - coffs[i]) * Bezier._basisBuffer1[i];
            df *= derivativeFactor;
            if (Math.abs(f) > bigStep * Math.abs(df))
                return undefined;
            const du = f / df;
            if (Math.abs(du) < tolerance) {
                numConverged++;
                if (numConverged >= 2)
                    return u - du;
            }
            else {
                numConverged = 0;
            }
            u -= du;
        }
        return undefined;
    }
    // Deflation table.  b0, b1 are coefficients of term being divided out
    // Pascal coffs for b0,b1 are just 1.
    // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.
    // each ci is a coefficient of the (unknown) result, with its coefficient blended in.
    // note b0, b1 are both nonzero, so the divisions are safe.
    // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]
    // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]
    // |    |  b0    | b1      |   equivalence               | solve moving down
    // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0
    // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0
    // | c2 | c2* b0 | c2 * b1
    // Each internal ci = (ai - c[i-1] * b1) /b0
    // first c0*b0 = a0
    // last c[orderC-1]*b1 = a[orderA-1]
    static deflateRoots01(bezier) {
        const roots = [];
        const coffs = bezier.coffs;
        let a0, a1, segmentFraction, globalStartFraction, newtonFraction;
        while (bezier.order > 1) {
            const order = bezier.order;
            // Find any crossing
            if (coffs[0] === 0.0) {
                bezier.deflateLeft();
                roots.push(0.0);
                continue;
            }
            let numCrossing = 0;
            let numNewtonOK = 0;
            for (let i = 1; i < order; i++) {
                a0 = coffs[i - 1];
                a1 = coffs[i];
                if (a0 * a1 <= 0.0) {
                    numCrossing++;
                    segmentFraction = -a0 / (a1 - a0);
                    globalStartFraction = (i - 1 + segmentFraction) / (order - 1);
                    newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);
                    if (newtonFraction !== undefined) {
                        roots.push(newtonFraction);
                        bezier.deflateRoot(newtonFraction);
                        numNewtonOK++;
                        break;
                    }
                }
            }
            if (numNewtonOK)
                continue;
            // if any crossing was found and led to a good newton, the "continue" jumped past this.
            // if no crossings found, there are no roots to be had -- accept
            if (numCrossing === 0)
                return roots;
            // reach here if there were crossings but not roots.
            // is this just a local min?  or maybe a big problem?   Whatever, accept it
            return roots;
        }
        return roots;
    }
}
exports.Bezier = Bezier;
/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function) */
class Order2Bezier extends BezierCoffs {
    constructor(f0 = 0.0, f1 = 0.0) {
        super(2);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
    }
    /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */
    clone() {
        return new Order2Bezier(this.coffs[0], this.coffs[1]);
    }
    /** normally, return fractional coordinate where bezier (a0,a1) has a root.
     * but if the fraction would exceed Geometry.largeFractionResult, return undefined.
     */
    static solveCoffs(a0, a1) {
        return Geometry_1.Geometry.conditionalDivideFraction(-a0, (a1 - a0));
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u) {
        const result = new Float64Array(2);
        result[0] = 1.0 - u;
        result[1] = u;
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        return (1.0 - u) * this.coffs[0] + u * this.coffs[1];
    }
    // "just like" roots() but never creates an array.
    solve(rightHandSide) {
        const df = this.coffs[1] - this.coffs[0];
        return Geometry_1.Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);
    }
    /**
     * Concrete implementation of the abstract roots method
     * @param targetValue target function value.
     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.
     * @returns If no roots, return undefined.  If single root, return an array with the root.
     */
    roots(targetValue, restrictTo01) {
        const x = this.solve(targetValue);
        if (x === undefined)
            return undefined;
        if (!restrictTo01 || Geometry_1.Geometry.isIn01(x))
            return [x];
        return undefined;
    }
}
exports.Order2Bezier = Order2Bezier;
/** Bezier polynomial specialized to order 3 (3 coefficients, paraboloa  function) */
class Order3Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0) {
        super(3);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
    }
    clone() {
        return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u) {
        const v = 1.0 - u;
        const result = new Float64Array(3);
        result[0] = v * v;
        result[1] = 2.0 * u * v;
        result[2] = u * u;
        return result;
    }
    /**
     * Add the square of a linear bezier.
     * @param f0 linear factor value at u=0.
     * @param f1 linear factor value at u=1.
     * @param a  scale factor.
     */
    addSquareLinear(f0, f1, a) {
        this.coffs[0] += a * f0 * f0;
        this.coffs[1] += a * f0 * f1;
        this.coffs[2] += a * f1 * f1;
    }
    roots(targetValue, restrictTo01) {
        const a0 = this.coffs[0] - targetValue;
        const a1 = this.coffs[1] - targetValue;
        const a2 = this.coffs[2] - targetValue;
        const a01 = a1 - a0;
        const a12 = a2 - a1;
        const a012 = a12 - a01;
        const roots = Polynomials_1.Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);
        return super.filter01(roots, restrictTo01);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v = 1.0 - u;
        return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);
    }
}
exports.Order3Bezier = Order3Bezier;
/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function) */
class Order4Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0) {
        super(4);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
    }
    clone() {
        return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);
    }
    static createProductOrder3Order2(factorA, factorB) {
        return new Order4Bezier(factorA.coffs[0] * factorB.coffs[0], (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0, (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0, factorA.coffs[2] * factorB.coffs[1]);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u) {
        const v = 1.0 - u;
        const uu = u * u;
        const vv = v * v;
        const result = new Float64Array(4);
        result[0] = vv * v;
        result[1] = 3.0 * vv * u;
        result[2] = 3.0 * v * uu;
        result[3] = u * uu;
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        return this.coffs[0] * v3
            + u * (3.0 * this.coffs[1] * v2
                + u * (3.0 * this.coffs[2] * v1
                    + u * this.coffs[3]));
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree3PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d1 = source.evaluateDerivative(1.0);
        const f1 = source.evaluate(1.0);
        const a = 3.0;
        return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);
    }
    // Find solutions (u values) of the bezier-form cubic
    // y0 (1-u)^3 + 3 y1 u(1-u)^2 + 3 y2 u^2 (1-u) + y3 u^3= e
    // i.e. y0, y1, y2, y3 are coefficients of bezier-basis polynomial, e is y level whose crossings
    // are needed.
    //
    realRoots(e, restrictTo01, roots) {
        // Get direct solutions in standard basis
        roots.clear();
        const cc = new Float64Array(4);
        const y0 = this.coffs[0];
        const y1 = this.coffs[1];
        const y2 = this.coffs[2];
        const y3 = this.coffs[3];
        const yMax = Math.max(y0, y1, y2, y3);
        const yMin = Math.min(y0, y1, y2, y3);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(1.0 / 3.0);
            roots.push(2.0 / 3.0);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic
        }
        cc[0] = (y0 - e);
        cc[1] = 3.0 * (y1 - y0);
        cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = -y0 + 3.0 * y1 - 3.0 * y2 + y3;
        Polynomials_1.AnalyticRoots.appendCubicRoots(cc, roots); // can't have zero solutions after passing minmax conditions . . .
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order4Bezier = Order4Bezier;
/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function) */
class Order5Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0) {
        super(5);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
        this.coffs[4] = f4;
    }
    /**
     * @returns Return a clone of this bezier.
     */
    clone() {
        return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree4PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d4 = source.evaluateDerivative(1.0);
        const f4 = source.evaluate(1.0);
        const a = 0.25;
        const d0a = a * d0;
        const fa = f0 + d0a;
        const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;
        return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);
    }
    /** evaluate the basis fucntions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u) {
        const v = 1.0 - u;
        const uu = u * u;
        const uuu = uu * u;
        const vv = v * v;
        const vvv = vv * v;
        const result = new Float64Array(5);
        result[0] = vv * vv;
        result[1] = 4.0 * vvv * u;
        result[2] = 6.0 * vv * uu;
        result[3] = 4.0 * v * uuu;
        result[4] = uu * uu;
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        const v4 = v2 * v2;
        return this.coffs[0] * v4
            + u * (4.0 * this.coffs[1] * v3
                + u * (6.0 * this.coffs[2] * v2
                    + u * (4.0 * this.coffs[3] * v1
                        + u * this.coffs[4])));
    }
    addProduct(f, g, a) {
        this.coffs[0] += a * f.coffs[0] * g.coffs[0];
        this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;
        this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;
        this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;
        this.coffs[4] += a * f.coffs[2] * g.coffs[2];
    }
    addConstant(a) {
        for (let i = 0; i < 5; i++)
            this.coffs[i] += a;
    }
    // Find solutions (u values) of the bezier-form quartic
    // y0 (1-u)u^4 + etc = e
    //
    realRoots(e, restrictTo01, roots) {
        roots.clear();
        const y0 = this.coffs[0] - e;
        const y1 = this.coffs[1] - e;
        const y2 = this.coffs[2] - e;
        const y3 = this.coffs[3] - e;
        const y4 = this.coffs[4] - e;
        // Get direct solutions in standard basis
        const yMax = Math.max(y0, y1, y2, y3, y4);
        const yMin = Math.min(y0, y1, y2, y3, y4);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(0.25);
            roots.push(0.5);
            roots.push(0.75);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...
        }
        const cc = new Float64Array(5);
        cc[0] = (y0 - e);
        cc[1] = 4.0 * (-y0 + y1);
        cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);
        cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);
        Polynomials_1.AnalyticRoots.appendQuarticRoots(cc, roots);
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order5Bezier = Order5Bezier;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(3);
/** base class for Newton iterations in various dimensions.
 * Dimension-specific classes carry all dimension-related data and answer generalized queries
 * from this base class.
 */
class AbstractNewtonIterator {
    /**
     * @param stepSizeTarget tolerance to consider a single step converged.
     * This number should be "moderately" strict.   Because 2 successive convergences are required,
     * it is expected that a first "accept" for (say) 10 to 14 digit step will be followed by another
     * iteration.   A well behaved newton would then hypothetically double the number of digits to
     * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will
     * typically achieve full precision.
     * @param successiveConvergenceTarget number of successive convergences required for acceptance.
     * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.
     *     Allow 15 to 20 to catch difficult cases.
     */
    constructor(stepSizeTolerance = 1.0e-11, successiveConvergenceTarget = 2, maxIterations = 15) {
        this.numAccepted = 0;
        this.numIterations = 0;
        this.stepSizeTolerance = stepSizeTolerance;
        this.successiveConvergenceTarget = successiveConvergenceTarget;
        this.maxIterations = maxIterations;
    }
    testConvergence(delta) {
        if (Math.abs(delta) < this.stepSizeTolerance) {
            this.numAccepted++;
            return this.numAccepted >= this.successiveConvergenceTarget;
        }
        this.numAccepted = 0;
        return false;
    }
    runIterations() {
        this.numAccepted = 0;
        this.numIterations = 0;
        while (this.numIterations++ < this.maxIterations && this.computeStep()) {
            if (this.testConvergence(this.currentStepSize())
                && this.applyCurrentStep(true)) {
                return true;
            }
            this.applyCurrentStep(false);
        }
        return false;
    }
}
exports.AbstractNewtonIterator = AbstractNewtonIterator;
/** object to evaluate a newton function.  The object must retain most-recent function and derivative
 * values for immediate query.
 */
class NewtonEvaluatorRtoRD {
}
exports.NewtonEvaluatorRtoRD = NewtonEvaluatorRtoRD;
class Newton1dUnbounded extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this.func = func;
        this.setTarget(0);
    }
    setX(x) { this.currentX = x; return true; }
    getX() { return this.currentX; }
    setTarget(y) { this.target = y; }
    applyCurrentStep() { return this.setX(this.currentX - this.currentStep); }
    /** Univariate newton step : */
    computeStep() {
        if (this.func.evaluate(this.currentX)) {
            const dx = Geometry_1.Geometry.conditionalDivideFraction(this.func.currentF - this.target, this.func.currentdFdX);
            if (dx !== undefined) {
                this.currentStep = dx;
                return true;
            }
        }
        return false;
    }
    currentStepSize() {
        return Math.abs(this.currentStep / (1.0 + Math.abs(this.currentX)));
    }
}
exports.Newton1dUnbounded = Newton1dUnbounded;
/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.
 */
class NewtonEvaluatorRtoR {
}
exports.NewtonEvaluatorRtoR = NewtonEvaluatorRtoR;
class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this.func = func;
        this.derivativeH = 1.0e-8;
    }
    setX(x) { this.currentX = x; return true; }
    getX() { return this.currentX; }
    applyCurrentStep() { return this.setX(this.currentX - this.currentStep); }
    /** Univariate newton step : */
    computeStep() {
        if (this.func.evaluate(this.currentX)) {
            const fA = this.func.currentF;
            if (this.func.evaluate(this.currentX + this.derivativeH)) {
                const fB = this.func.currentF;
                const dx = Geometry_1.Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);
                if (dx !== undefined) {
                    this.currentStep = dx;
                    return true;
                }
            }
        }
        return false;
    }
    currentStepSize() {
        return Math.abs(this.currentStep / (1.0 + Math.abs(this.currentX)));
    }
}
exports.Newton1dUnboundedApproximateDerivative = Newton1dUnboundedApproximateDerivative;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const Geometry4d_1 = __webpack_require__(46);
class MomentData {
    constructor() {
        this.origin = PointVector_1.Point3d.createZero();
        this.sums = Geometry4d_1.Matrix4d.createZero();
        this.localToWorldMap = Transform_1.Transform.createIdentity();
        this.radiusOfGyration = PointVector_1.Vector3d.create();
    }
    static momentTensorFromInertiaProducts(products) {
        const rr = products.sumDiagonal();
        const result = Transform_1.RotMatrix.createScale(rr, rr, rr);
        result.addScaledInPlace(products, -1.0);
        return result;
    }
    static sortColumnsForIncreasingMoments(axes, moments) {
        const points = [
            axes.indexedColumnWithWeight(0, moments.x),
            axes.indexedColumnWithWeight(1, moments.y),
            axes.indexedColumnWithWeight(2, moments.z)
        ].sort((dataA, dataB) => {
            if (dataA.w < dataB.w)
                return -1;
            if (dataA.w > dataB.w)
                return 1;
            return 0;
        });
        axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);
        moments.set(points[0].w, points[1].w, points[2].w);
    }
    static pointsToPrincipalAxes(points) {
        const moments = new MomentData();
        if (points.length === 0)
            return moments;
        moments.clearSums(points[0]);
        moments.accumulatePointMomentsFromOrigin(points);
        if (moments.shiftSumsToCentroid()) {
            const products = moments.sums.matrixPart();
            const tensor = MomentData.momentTensorFromInertiaProducts(products);
            const moment2 = PointVector_1.Vector3d.create();
            const axisVectors = Transform_1.RotMatrix.createZero();
            tensor.fastSymmetricEigenvalues(axisVectors, moment2);
            MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);
            moments.localToWorldMap = Transform_1.Transform.createOriginAndMatrix(moments.origin, axisVectors);
            moments.radiusOfGyration.set(Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));
            moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));
        }
        return moments;
    }
    /**
     * Compute principal axes from inertial products
     * @param origin The origin used for the inertia products.
     * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]
     */
    static inertiaProductsToPrincipalAxes(origin, inertiaProducts) {
        const moments = new MomentData();
        moments.sums.setFrom(inertiaProducts);
        moments.origin.setFrom(origin);
        if (!moments.shiftSumsToCentroid())
            return undefined;
        const products = moments.sums.matrixPart();
        const tensor = MomentData.momentTensorFromInertiaProducts(products);
        const moment2 = PointVector_1.Vector3d.create();
        const axisVectors = Transform_1.RotMatrix.createZero();
        tensor.fastSymmetricEigenvalues(axisVectors, moment2);
        MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);
        moments.localToWorldMap = Transform_1.Transform.createOriginAndMatrix(moments.origin, axisVectors);
        moments.radiusOfGyration.set(Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));
        moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));
        return moments;
    }
    clearSums(origin) {
        this.sums.setZero();
        if (origin)
            this.origin.setFrom(origin);
        else
            this.origin.setZero();
    }
    accumulatePointMomentsFromOrigin(points) {
        for (const p of points) {
            this.sums.addMomentsInPlace(p.x - this.origin.x, p.y - this.origin.y, p.z - this.origin.z, 1.0);
        }
    }
    shiftSumsToCentroid() {
        const xyz = this.sums.columnW().realPoint();
        if (xyz) {
            this.origin.addInPlace(xyz);
            const translation = Geometry4d_1.Matrix4d.createTranslationXYZ(-xyz.x, -xyz.y, -xyz.z);
            const TA = translation.multiplyMatrixMatrix(this.sums);
            TA.multiplyMatrixMatrixTranspose(translation, this.sums);
            return true;
        }
        return false;
    }
}
exports.MomentData = MomentData;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryHandler_1 = __webpack_require__(90);
const LineSegment3d_1 = __webpack_require__(38);
const Arc3d_1 = __webpack_require__(47);
const PointVector_1 = __webpack_require__(4);
const LineString3d_1 = __webpack_require__(10);
/**
 * Context for constructing a curve that is interpolated between two other curves.
 * * The only callable method is the static `InterpolateBetween`.
 * * Other methods are called only by `dispatchToGeometryHandler`
 */
class ConstructCurveBetweenCurves extends GeometryHandler_1.NullGeometryHandler {
    constructor(_geometry0, _fraction, _geometry1) {
        super();
        // this.geometry0 = _geometry0;   <-- Never used
        this.geometry1 = _geometry1;
        this.fraction = _fraction;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied segment0.
     */
    handleLineSegment3d(segment0) {
        if (this.geometry1 instanceof LineSegment3d_1.LineSegment3d) {
            const segment1 = this.geometry1;
            return LineSegment3d_1.LineSegment3d.create(segment0.startPoint().interpolate(this.fraction, segment1.startPoint()), segment0.endPoint().interpolate(this.fraction, segment1.endPoint()));
        }
        return undefined;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied ls0.
     */
    handleLineString3d(ls0) {
        if (this.geometry1 instanceof LineString3d_1.LineString3d) {
            const ls1 = this.geometry1;
            if (ls0.numPoints() === ls1.numPoints()) {
                const ls = LineString3d_1.LineString3d.create();
                const workPoint = PointVector_1.Point3d.create();
                const workPoint0 = PointVector_1.Point3d.create();
                const workPoint1 = PointVector_1.Point3d.create();
                for (let i = 0; i < ls0.numPoints(); i++) {
                    ls0.pointAt(i, workPoint0);
                    ls1.pointAt(i, workPoint1);
                    workPoint0.interpolate(this.fraction, workPoint1, workPoint);
                    ls.addPoint(workPoint);
                }
                return ls;
            }
        }
        return undefined;
    }
    /**
     * * To be directly called only by double displatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpoalted curve between this.geomtry1 and the supplied arc0.
     */
    handleArc3d(arc0) {
        if (this.geometry1 instanceof Arc3d_1.Arc3d) {
            const arc1 = this.geometry1;
            return Arc3d_1.Arc3d.create(arc0.center.interpolate(this.fraction, arc1.center), arc0.vector0.interpolate(this.fraction, arc1.vector0), arc0.vector90.interpolate(this.fraction, arc1.vector90), arc0.sweep.interpolate(this.fraction, arc1.sweep));
        }
        return undefined;
    }
    /**
     * Construct a geometry item which is fractionally interpolated btween two others.
     * * The construction is only supported between certain types:
     * * * LineSegment3d+LineSegment3d -- endpoints are interpolated
     * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.
     * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.
     * @param geometry0 geometry "at fraction 0"
     * @param fraction  fractional positon
     * @param geometry1 geometry "at fraction 1"
     */
    static InterpolateBetween(geometry0, fraction, geometry1) {
        const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);
        return geometry0.dispatchToGeometryHandler(handler);
    }
}
exports.ConstructCurveBetweenCurves = ConstructCurveBetweenCurves;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Curve */
const CurvePrimitive_1 = __webpack_require__(12);
/* tslint:disable:variable-name no-empty*/
/** base class for detailed traversal of curve artifacts.  This recurses to children in the quickest way (no records of path)
 * Use the RecursiveCurveProcessorWithStack to record the path along the visit.
 */
class RecursiveCurveProcessor {
    constructor() {
    }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** annouce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
    }
    /** annouce beginning or end of a parity region */
    announceUnionRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const child of data.children) {
            child.announceToCurveProcessor(this, i++);
        }
    }
    announceBagOfCurves(data, _indexInParent = -1) {
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child);
            else
                child.announceToCurveProcessor(this);
        }
    }
}
exports.RecursiveCurveProcessor = RecursiveCurveProcessor;
/** base class for detailed traversal of curve artifacts, maintaining a stack that shows complete path to each artifact.
 * Use the QuickRecursiveCurveProcessor to visit without recording the path.
 */
class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {
    constructor() {
        super();
        this.stack = [];
    }
    enter(data) { this.stack.push(data); }
    leave() { return this.stack.pop(); }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, indexInParent = -1) {
        this.enter(data);
        super.announcePath(data, indexInParent);
        this.leave();
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, indexInParent = -1) {
        this.enter(data);
        super.announceLoop(data, indexInParent);
        this.leave();
    }
    /** annouce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
        this.leave();
    }
    /** annouce beginning or end of a parity region */
    announceUnionRegion(data, indexInParent = -1) {
        this.enter(data);
        super.announceUnionRegion(data, indexInParent);
        this.leave();
    }
    announceBagOfCurves(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child, i++);
            else
                child.announceToCurveProcessor(this);
        }
        this.leave();
    }
}
exports.RecursiveCurveProcessorWithStack = RecursiveCurveProcessorWithStack;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const PointHelpers_1 = __webpack_require__(22);
const CurvePrimitive_1 = __webpack_require__(12);
/* tslint:disable:variable-name no-empty*/
/**
 * A PointString3d is an array of points.
 * * PointString3D is first class (displayable) geometry derived from the GeometryQuery base class.
 * * The varous points in the PointString3d are NOT connected by line segments for display or other calculations.
 */
class PointString3d extends CurvePrimitive_1.GeometryQuery {
    isSameGeometryClass(other) { return other instanceof PointString3d; }
    /** return the points array (cloned). */
    get points() { return this._points; }
    constructor() {
        super();
        this._points = [];
    }
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    static flattenArray(arr) {
        return arr.reduce((flat, toFlatten) => {
            return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);
        }, []);
    }
    /** Create a PointString3d from points. */
    static create(...points) {
        const result = new PointString3d();
        result.addPoints(points);
        return result;
    }
    /** Add multiple points to the PointString3d */
    addPoints(...points) {
        const toAdd = PointString3d.flattenArray(points);
        for (const p of toAdd) {
            if (p instanceof PointVector_1.Point3d)
                this._points.push(p);
        }
    }
    /** Add a single point to the PoinstString3d */
    addPoint(point) {
        this._points.push(point);
    }
    /** Remove the last point added to the PointString3d */
    popPoint() {
        this._points.pop();
    }
    setFrom(other) {
        this._points = PointHelpers_1.Point3dArray.clonePoint3dArray(other._points);
    }
    /** Create from an array of Point3d */
    static createPoints(points) {
        const ps = new PointString3d();
        ps._points = PointHelpers_1.Point3dArray.clonePoint3dArray(points);
        return ps;
    }
    /** Create a PointString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ps = new PointString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ps._points.push(PointVector_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ps;
    }
    clone() {
        const retVal = new PointString3d();
        retVal.setFrom(this);
        return retVal;
    }
    setFromJSON(json) {
        this._points.length = 0;
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(PointVector_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an PointString3d to a JSON object.
     * @return {*} [[x,y,z],...[x,y,z]]
     */
    toJSON() {
        const value = [];
        for (const p of this._points)
            value.push(p.toJSON());
        return value;
    }
    static fromJSON(json) {
        const ps = new PointString3d();
        ps.setFromJSON(json);
        return ps;
    }
    /** Access a single point by index. */
    pointAt(i, result) {
        if (i >= 0 && i < this._points.length) {
            if (result) {
                result.setFrom(this._points[i]);
                return result;
            }
            return this._points[i].clone();
        }
        return undefined;
    }
    /** Return the number of points. */
    numPoints() { return this._points.length; }
    /** Reverse the point order */
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            while (i0 < i1) {
                const a = this._points[i0];
                this._points[i1] = this._points[i0];
                this._points[i0] = a;
                i0++;
                i1--;
            }
        }
    }
    /** Return the number of points. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3dArrayInPlace(this._points);
        return true;
    }
    /** Return the index and coordinates of the closest point to spacepoint. */
    closestPoint(spacePoint) {
        const result = { index: -1, xyz: PointVector_1.Point3d.create() };
        const index = PointHelpers_1.Point3dArray.closestPointIndex(this._points, spacePoint);
        if (index >= 0) {
            result.index = index;
            result.xyz.setFrom(this._points[index]);
        }
        return result;
    }
    /** Return true if all points are in the given plane. */
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this._points, plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** Extend a range to include the points in this PointString3d. */
    extendRange(rangeToExtend, transform) {
        rangeToExtend.extendArray(this._points, transform);
    }
    /** Return true if corresponding points are almost equal. */
    isAlmostEqual(other) {
        if (!(other instanceof PointString3d))
            return false;
        return PointHelpers_1.Point3dArray.isAlmostEqual(this._points, other._points);
    }
    /** Reduce to empty set of points. */
    clear() { this._points.length = 0; }
    /** Pass this PointString3d to the handler's `handlePointString` method. */
    dispatchToGeometryHandler(handler) {
        return handler.handlePointString3d(this);
    }
}
exports.PointString3d = PointString3d;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const Quadrature_1 = __webpack_require__(106);
const CurvePrimitive_1 = __webpack_require__(12);
const AnalyticGeometry_1 = __webpack_require__(11);
const LineString3d_1 = __webpack_require__(10);
// import {} from "./";
/** A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.
 * * The symmetry condition creates a relationship among the following 4 quantities:
 * ** curvature0 = curvature (i.e. 1/radius) at start
 * ** curvature1 = curvature (i.e. 1/radius) at end
 * ** sweepRadians = signed turning angle from start to end
 * ** arcLength = length of curve
 * * The relationship is the equation
 * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`
 * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.
 */
class TransitionConditionalProperties {
    /**
     * capture numeric or undefined values
     * @param radius0 start radius or undefined
     * @param radius1 end radius or undefined
     * @param bearing0 start bearing or undefined
     * @param bearing1 end bearing or undefined
     * @param arcLength arc length or undefined
     */
    constructor(radius0, radius1, bearing0, bearing1, arcLength) {
        this.radius0 = radius0;
        this.radius1 = radius1;
        this.bearing0 = bearing0;
        this.bearing1 = bearing1;
        this.curveLength = arcLength;
    }
    /** return the number of defined values among the 5 properties. */
    numDefinedProperties() {
        return Geometry_1.Geometry.defined01(this.radius0)
            + Geometry_1.Geometry.defined01(this.radius1)
            + Geometry_1.Geometry.defined01(this.bearing0)
            + Geometry_1.Geometry.defined01(this.bearing1)
            + Geometry_1.Geometry.defined01(this.curveLength);
    }
    /** clone with all properties (i.e. preserve undefined states) */
    clone() {
        return new TransitionConditionalProperties(this.radius0, this.radius1, this.bearing0 === undefined ? undefined : this.bearing0.clone(), this.bearing1 === undefined ? undefined : this.bearing1.clone(), this.curveLength);
    }
    /** Examine which properties are defined and compute the (single) undefined.
     * @returns Return true if the input state had precisely one undefined member.
     */
    tryResolveAnySingleUnknown() {
        if (this.bearing0 && this.bearing1) {
            const sweepRadians = this.bearing1.radians - this.bearing0.radians;
            if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {
                this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {
                this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {
                this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);
                return true;
            }
            return false;
        }
        // at least one bearing is undefined ...
        if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)
            return false;
        if (this.bearing0) {
            this.bearing1 = Geometry_1.Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        if (this.bearing1) {
            this.bearing0 = Geometry_1.Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        return false;
    }
    almostEqualCoordinate(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return Geometry_1.Geometry.isSameCoordinate(a, b);
        return false;
    }
    almostEqualBearing(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return a.isAlmostEqualNoPeriodShift(b);
        return false;
    }
    /**
     * Test if this and other have matching numeric and undefined members.
     */
    isAlmostEqual(other) {
        if (!this.almostEqualCoordinate(this.radius0, other.radius0))
            return false;
        if (!this.almostEqualCoordinate(this.radius1, other.radius1))
            return false;
        if (!this.almostEqualBearing(this.bearing0, other.bearing0))
            return false;
        if (!this.almostEqualBearing(this.bearing1, other.bearing1))
            return false;
        if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))
            return false;
        return true;
    }
}
exports.TransitionConditionalProperties = TransitionConditionalProperties;
class TransitionSpiral3d extends CurvePrimitive_1.CurvePrimitive {
    // constructor demands all bearing, radius, and length data -- caller determines usual dependency of "any 4 determine the 5th"
    constructor(spiralType, radius01, bearing01, activeFractionInterval, localToWorld, arcLength, properties) {
        super();
        this.spiralType = spiralType;
        this.localToWorld = localToWorld;
        this.radius01 = radius01;
        this.bearing01 = bearing01;
        this.localToWorld = localToWorld;
        this.activeFractionInterval = activeFractionInterval;
        this.arcLength01 = arcLength;
        this.strokes = LineString3d_1.LineString3d.create();
        // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...
        this.curvature01 = PointVector_1.Segment1d.create(0, 1);
        this.refreshComputedProperties();
        this.properties = properties;
    }
    // return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line)
    static radiusToCurvature(radius) { return (radius === 0.0) ? 0.0 : 1.0 / radius; }
    // return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0
    static curvatureToRadius(curvature) {
        if (Math.abs(curvature) < Geometry_1.Geometry.smallAngleRadians)
            return 0.0;
        return 1.0 / curvature;
    }
    // return the average curvature for two limit values.
    static averageCurvature(radiusLimits) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));
    }
    /**
     * Given two radii (or zeros for 0 curvature) return the average curvature
     * @param r0 start radius, or 0 for line
     * @param r1 end radius, or 0 for line
     */
    static averageCurvatureR0R1(r0, r1) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));
    }
    static radiusRadiusSweepRadiansToArcLength(radius0, radius1, sweepRadians) {
        return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));
    }
    static radiusRadiusLengthToSweepRadians(radius0, radius1, arcLength) {
        return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;
    }
    static radius0LengthSweepRadiansToRadius1(radius0, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));
    }
    static radius1LengthSweepRadiansToRadius0(radius1, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));
    }
    /** Return the origial defining properties (if any) saved by the constructor. */
    get originalProperties() { return this.properties; }
    /** return the spiral type as a string (undefined resolves to default type "clothoid") */
    getSpiralType() { if (this.spiralType === undefined)
        return TransitionSpiral3d.defaultSpiralType; return this.spiralType; }
    /** Return the bearing at given fraction .... */
    fractionToBearingRadians(fraction) {
        // BUG? active interval?
        return this.bearing01.startRadians + fraction * (this.curvature01.x0 + 0.5 * fraction * (this.curvature01.x1 - this.curvature01.x0));
    }
    /** Return the curvature at given fraction ... */
    fractionToCurvature(fraction) {
        // BUG? active interval
        return this.curvature01.fractionToPoint(fraction);
    }
    static initWorkSpace() {
        TransitionSpiral3d.sGaussFraction = new Float64Array(5);
        TransitionSpiral3d.sGaussWeight = new Float64Array(5);
        TransitionSpiral3d.sGaussMapper = Quadrature_1.Quadrature.setupGauss5;
    }
    /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.
     * (recall that theta is a nonlinear function of the fraction.)
     * * This is a single interval of gaussian integration.
     * * The fraction is on the full spiral (not in the mapped active interval)
     * @param xyz advancing integrated point.
     * @param fractionA fraction at start of interval
     * @param fractionB fraction at end of interval.
     * @param unitArcLength length of curve for 0 to 1 fractional
     */
    fullSpiralIncrementalIntegral(xyz, fractionA, fractionB) {
        const gaussFraction = TransitionSpiral3d.sGaussFraction;
        const gaussWeight = TransitionSpiral3d.sGaussWeight;
        const numEval = TransitionSpiral3d.sGaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);
        const deltaL = this.arcLength01;
        let w = 0;
        for (let k = 0; k < numEval; k++) {
            const radians = this.fractionToBearingRadians(gaussFraction[k]);
            w = gaussWeight[k] * deltaL;
            xyz.x += w * Math.cos(radians);
            xyz.y += w * Math.sin(radians);
        }
    }
    refreshComputedProperties() {
        this.curvature01 = PointVector_1.Segment1d.create(TransitionSpiral3d.radiusToCurvature(this.radius01.x0), TransitionSpiral3d.radiusToCurvature(this.radius01.x1));
        this.strokes.clear();
        const currentPoint = PointVector_1.Point3d.create();
        this.strokes.appendStrokePoint(currentPoint);
        const numInterval = 8;
        const fractionStep = 1.0 / numInterval;
        for (let i = 1; i <= numInterval; i++) {
            const fraction0 = (i - 1) * fractionStep;
            const fraction1 = i * fractionStep;
            this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1);
            this.strokes.appendStrokePoint(currentPoint);
        }
        this.strokes.tryTransformInPlace(this.localToWorld);
    }
    /**
     * Create a transition spiral with radius and bearing conditions.
     * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)
     * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis
     * @param activeFractionInterval fractional limits of the active portion of the spiral.
     * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.
     */
    static createRadiusRadiusBearingBearing(radius01, bearing01, activeFractionInterval, localToWorld) {
        const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);
        return new TransitionSpiral3d("clothoid", radius01.clone(), bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength, new TransitionConditionalProperties(radius01.x0, radius01.x1, bearing01.startAngle.clone(), bearing01.endAngle.clone(), undefined));
    }
    /**
     * Create a transition spiral.
     * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.
     * @param spiralType one of "clothoid", "bloss", "biquadratic", "cosine", "sine".  If undefined, "clothoid" is used.
     * @param radius0 radius (or 0 for tangent to line) at start
     * @param radius1 radius (or 0 for tangent to line) at end
     * @param bearing0 bearing, measured CCW from x axis at start.
     * @param bearing1 bearing, measured CCW from x axis at end.
     * @param fractionInterval optional fractional interval for an "active" portion of the curve.   if omitted, the full [0,1] is used.
     * @param localToWorld placement transform
     */
    static create(spiralType, radius0, radius1, bearing0, bearing1, arcLength, fractionInterval, localToWorld) {
        const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);
        const data1 = data.clone();
        if (!data.tryResolveAnySingleUnknown())
            return undefined;
        if (fractionInterval === undefined)
            fractionInterval = PointVector_1.Segment1d.create(0, 1);
        return new TransitionSpiral3d(spiralType, PointVector_1.Segment1d.create(data.radius0, data.radius1), Geometry_1.AngleSweep.createStartEnd(data.bearing0, data.bearing1), fractionInterval ? fractionInterval.clone() : PointVector_1.Segment1d.create(0, 1), localToWorld, data.curveLength, data1);
    }
    setFrom(other) {
        this.localToWorld.setFrom(other.localToWorld);
        this.radius01.setFrom(other.radius01);
        this.radius01.setFrom(other.radius01);
        this.bearing01.setFrom(other.bearing01);
        this.localToWorld.setFrom(other.localToWorld);
        return this;
    }
    clone() {
        return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01, this.bearing01, this.activeFractionInterval, this.localToWorld);
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform); // ok, we're confident it will always work.
        return result;
    }
    startPoint() { return this.strokes.startPoint(); }
    endPoint() { return this.strokes.endPoint(); }
    isInPlane(plane) {
        return plane.isPointInPlane(this.localToWorld.origin)
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));
    }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    quickLength() { return this.arcLength01; }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    curveLength() { return this.arcLength01; }
    isSameGeometryClass(other) { return other instanceof TransitionSpiral3d; }
    emitStrokes(dest, options) { this.strokes.emitStrokes(dest, options); }
    emitStrokableParts(dest, options) {
        dest.startParentCurvePrimitive(this);
        this.strokes.emitStrokableParts(dest, options);
        dest.endParentCurvePrimitive(this);
    }
    // hm.. nothing to do but reverse the interval . . . maybe that's cheesy . . .
    reverseInPlace() {
        this.activeFractionInterval.reverseInPlace();
        this.strokes.reverseInPlace();
    }
    fractionToPoint(fraction, result) {
        fraction = Geometry_1.Geometry.clampToStartEnd(fraction, 0, 1);
        const numStrokes = this.strokes.points.length - 1;
        const index0 = Math.trunc(fraction * numStrokes); // This indexes the point to the left of the query
        const fraction0 = index0 / numStrokes;
        result = result ? result : new PointVector_1.Point3d();
        result.setFrom(this.strokes.points[index0]);
        const globalFraction0 = this.activeFractionInterval.fractionToPoint(fraction0);
        const globalFraction1 = this.activeFractionInterval.fractionToPoint(fraction);
        this.fullSpiralIncrementalIntegral(result, globalFraction0, globalFraction1);
        this.localToWorld.multiplyPoint3d(result, result);
        return result;
    }
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : AnalyticGeometry_1.Ray3d.createZero();
        this.fractionToPoint(fraction, result.origin);
        const radians = this.fractionToBearingRadians(fraction);
        const a = this.arcLength01;
        this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);
        return result;
    }
    /** Return the frenet frame at fractional position. */
    fractionToFrenetFrame(fraction, result) {
        result = result ? result : Transform_1.Transform.createIdentity();
        result.origin.setFrom(this.fractionToPoint(fraction));
        Transform_1.RotMatrix.createRigidFromRotMatrix(this.localToWorld.matrix, 0 /* XYZ */, result.matrix);
        const radians = this.fractionToBearingRadians(fraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        result.matrix.applyGivensColumnOp(0, 1, c, -s);
        return result;
    }
    /** Return a plane with
     *
     * * origin at fractional position along the curve
     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.
     * * vectorV is the second derivative, i.e.derivative of vectorU.
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const origin = this.fractionToPoint(fraction);
        const radians = this.fractionToBearingRadians(fraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        const vectorX = this.localToWorld.matrix.multiplyXY(c, s);
        const vectorY = this.localToWorld.matrix.multiplyXY(-s, c);
        vectorY.scaleInPlace(this.fractionToCurvature(fraction));
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleTransitionSpiral(this);
    }
    extendRange(rangeToExtend, transform) {
        this.strokes.extendRange(rangeToExtend, transform);
    }
    isAlmostEqual(other) {
        if (other instanceof TransitionSpiral3d) {
            return this.radius01.isAlmostEqual(other.radius01)
                && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)
                && this.localToWorld.isAlmostEqual(other.localToWorld)
                && Geometry_1.Geometry.isSameCoordinate(this.arcLength01, other.arcLength01)
                && this.curvature01.isAlmostEqual(other.curvature01);
        }
        return false;
    }
}
TransitionSpiral3d.defaultSpiralType = "clothoid";
exports.TransitionSpiral3d = TransitionSpiral3d;
// at load time, initialize gauss quadrature workspace
TransitionSpiral3d.initWorkSpace();


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const SolidPrimitive_1 = __webpack_require__(39);
const Geometry_1 = __webpack_require__(3);
const CurveChain_1 = __webpack_require__(14);
const LineString3d_1 = __webpack_require__(10);
/**
 */
class Box extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, baseX, baseY, topX, topY, capped) {
        super(capped);
        this.localToWorld = map;
        this.baseX = baseX;
        this.baseY = baseY;
        this.topX = topX;
        this.topY = topY;
    }
    clone() {
        return new Box(this.localToWorld.clone(), this.baseX, this.baseY, this.topX, this.topY, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin lower left of box
     * * x direction on base rectangle x edge
     * * y direction in base rectangle
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        return this.localToWorld.cloneRigid();
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result.localToWorld, result.localToWorld);
        return result;
    }
    /**
     * @param baseOrigin Origin of base rectangle
     * @param vectorX  Direction for base rectangle
     * @param vectorY Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBox(baseOrigin, vectorX, vectorY, topOrigin, baseX, baseY, topX, topY, capped) {
        const vectorZ = baseOrigin.vectorTo(topOrigin);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(baseOrigin, vectorX, vectorY, vectorZ);
        return new Box(localToWorld, baseX, baseY, topX, topY, capped);
    }
    /**
     * @param baseOrigin Origin of base rectangle
     * @param vectorX  Direction for base rectangle
     * @param vectorY Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped) {
        return Box.createDgnBox(baseOrigin, axes.columnX(), axes.columnY(), topOrigin, baseX, baseY, topX, topY, capped);
    }
    getBaseX() { return this.baseX; }
    getBaseY() { return this.baseY; }
    getTopX() { return this.topX; }
    getTopY() { return this.topY; }
    getBaseOrigin() { return this.localToWorld.multiplyXYZ(0, 0, 0); }
    getTopOrigin() { return this.localToWorld.multiplyXYZ(0, 0, 1); }
    getVectorX() { return this.localToWorld.matrix.columnX(); }
    getVectorY() { return this.localToWorld.matrix.columnY(); }
    getVectorZ() { return this.localToWorld.matrix.columnZ(); }
    isSameGeometryClass(other) { return other instanceof Box; }
    isAlmostEqual(other) {
        if (other instanceof Box) {
            if (this.capped !== other.capped)
                return false;
            if (!this.localToWorld.isAlmostEqual(other.localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this.baseX, other.baseX)
                && Geometry_1.Geometry.isSameCoordinate(this.baseY, other.baseY)
                && Geometry_1.Geometry.isSameCoordinate(this.topX, other.topX)
                && Geometry_1.Geometry.isSameCoordinate(this.topY, other.topY);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBox(this);
    }
    strokeConstantVSection(zFraction) {
        const ax = Geometry_1.Geometry.interpolate(this.baseX, zFraction, this.topX);
        const ay = Geometry_1.Geometry.interpolate(this.baseY, zFraction, this.topY);
        const result = LineString3d_1.LineString3d.create();
        const transform = this.localToWorld;
        const workPoint = PointVector_1.Point3d.create();
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        return result;
    }
    constantVSection(zFraction) {
        const ls = this.strokeConstantVSection(zFraction);
        return CurveChain_1.Loop.create(ls);
    }
    extendRange(range, transform) {
        const boxTransform = this.localToWorld;
        const ax = this.baseX;
        const ay = this.baseY;
        const bx = this.topX;
        const by = this.topY;
        if (transform) {
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);
            range.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);
        }
        else {
            range.extendTransformedXYZ(boxTransform, 0, 0, 0);
            range.extendTransformedXYZ(boxTransform, ax, 0, 0);
            range.extendTransformedXYZ(boxTransform, 0, ay, 0);
            range.extendTransformedXYZ(boxTransform, ax, ay, 0);
            range.extendTransformedXYZ(boxTransform, 0, 0, 1);
            range.extendTransformedXYZ(boxTransform, bx, 0, 1);
            range.extendTransformedXYZ(boxTransform, 0, by, 1);
            range.extendTransformedXYZ(boxTransform, bx, by, 1);
        }
    }
}
exports.Box = Box;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
const SolidPrimitive_1 = __webpack_require__(39);
const StrokeOptions_1 = __webpack_require__(67);
const CurveChain_1 = __webpack_require__(14);
const AnalyticGeometry_1 = __webpack_require__(11);
const Arc3d_1 = __webpack_require__(47);
const LineString3d_1 = __webpack_require__(10);
/**
 * A cone with axis along the z axis of a (possibly skewed) local coordinate system.
 *
 * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.
 * * Either one individually  may be zero, but they may not both be zero.
 * * The stored matrix has unit vectors in the xy columns, and full-length z column.
 * *
 */
class Cone extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, capped) {
        super(capped);
        this.localToWorld = map;
        this.radiusA = radiusA;
        this.radiusB = radiusB;
        this._maxRadius = Math.max(this.radiusA, this.radiusB); // um... should resolve elliptical sections
    }
    clone() {
        return new Cone(this.localToWorld.clone(), this.radiusA, this.radiusB, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at center of the base circle.
     * * base circle in the xy plane
     * * z axis by right hand rule.
     */
    getConstructiveFrame() {
        return this.localToWorld.cloneRigid();
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result.localToWorld, result.localToWorld);
        return result;
    }
    /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line
     * from start to end point.
     */
    static createAxisPoints(centerA, centerB, radiusA, radiusB, capped) {
        const zDirection = centerA.vectorTo(centerB);
        const a = zDirection.magnitude();
        if (Geometry_1.Geometry.isSmallMetricDistance(a))
            return undefined;
        // force near-zero radii to true zero
        radiusA = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusA));
        radiusB = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusB));
        // cone tip may not be "within" the z range.
        if (radiusA * radiusB < 0.0)
            return undefined;
        // at least one must be nonzero.
        if (radiusA + radiusB === 0.0)
            return undefined;
        const matrix = Transform_1.RotMatrix.createRigidHeadsUp(zDirection);
        matrix.scaleColumns(1.0, 1.0, a, matrix);
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(centerA, matrix);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or
     * to the axis.
     */
    static createBaseAndTarget(centerA, centerB, vectorX, vectorY, radiusA, radiusB, capped) {
        radiusA = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusA));
        radiusB = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusB));
        const vectorZ = centerA.vectorTo(centerB);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    getCenterA() { return this.localToWorld.multiplyXYZ(0, 0, 0); }
    getCenterB() { return this.localToWorld.multiplyXYZ(0, 0, 1); }
    getVectorX() { return this.localToWorld.matrix.columnX(); }
    getVectorY() { return this.localToWorld.matrix.columnY(); }
    getRadiusA() { return this.radiusA; }
    getRadiusB() { return this.radiusB; }
    getMaxRadius() { return this._maxRadius; }
    vFractionToRadius(v) { return Geometry_1.Geometry.interpolate(this.radiusA, v, this.radiusB); }
    isSameGeometryClass(other) { return other instanceof Cone; }
    isAlmostEqual(other) {
        if (other instanceof Cone) {
            if (this.capped !== other.capped)
                return false;
            if (!this.localToWorld.isAlmostEqual(other.localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this.radiusA, other.radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this.radiusB, other.radiusB);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleCone(this);
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * @param v fractional position along the cone axis
     * @param strokes stroke count or options.
     */
    strokeConstantVSection(v, strokes) {
        let strokeCount = 16;
        if (strokes === undefined) {
            // accept the default above.
        }
        else if (strokes instanceof Number) {
            strokeCount = strokes;
        }
        else if (strokes instanceof StrokeOptions_1.StrokeOptions) {
            strokeCount = strokes.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const r = this.vFractionToRadius(v);
        const result = LineString3d_1.LineString3d.create();
        const deltaRadians = Math.PI * 2.0 / strokeCount;
        let radians = 0;
        const transform = this.localToWorld;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            const xyz = transform.multiplyXYZ(r * Math.cos(radians), r * Math.sin(radians), v);
            result.addPoint(xyz);
        }
        return result;
    }
    /**
     * @returns Return the Arc3d section at vFraction
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const r = this.vFractionToRadius(vFraction);
        const transform = this.localToWorld;
        const center = transform.multiplyXYZ(0, 0, vFraction);
        const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, r, 0);
        return CurveChain_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    extendRange(range, transform) {
        const arc0 = this.constantVSection(0.0);
        const arc1 = this.constantVSection(1.0);
        arc0.extendRange(range, transform);
        arc1.extendRange(range, transform);
    }
    UVFractionToPoint(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this.radiusA, vFraction, this.radiusB);
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        return this.localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);
    }
    UVFractionToPointAndTangents(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this.radiusA, vFraction, this.radiusB);
        const drdv = this.radiusB - this.radiusA;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        const fTheta = 2.0 * Math.PI;
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectors(this.localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction), this.localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0), this.localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0), result);
    }
}
exports.Cone = Cone;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const CurveChain_1 = __webpack_require__(14);
const LineString3d_1 = __webpack_require__(10);
const PointHelpers_1 = __webpack_require__(22);
const SweepContour_1 = __webpack_require__(91);
const SolidPrimitive_1 = __webpack_require__(39);
/**
 * A LinearSweep is
 *
 * * A planar contour (any Loop, Path, or parityRegion)
 * * A sweep vector
 */
class LinearSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, direction, capped) {
        super(capped);
        this.contour = contour;
        this.direction = direction;
    }
    static create(contour, direction, capped) {
        const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour, direction);
        if (!sweepable)
            return undefined;
        return new LinearSweep(sweepable, direction, capped);
    }
    /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.
     * * If not capped, the xyPoints array is always used unchanged.
     * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:
     * * * If the final point is almost equal to the first, it is replaced by the exact first point.
     * * * if the final point is not close to the first an extra point is added.
     * * If capped, the point order will be reversed if necessary to produce positive volume.
     * @param xyPoints array of xy coordinates
     * @param z z value to be used for all coordinates
     * @param zSweep the sweep distance in the z direction.
     * @param capped true if caps are to be added.
     */
    static createZSweep(xyPoints, z, zSweep, capped) {
        const xyz = LineString3d_1.LineString3d.createXY(xyPoints, z, capped);
        if (capped) {
            const area = PointHelpers_1.PolygonOps.areaXY(xyz.points);
            if (area * zSweep < 0.0)
                xyz.points.reverse();
        }
        const contour = capped ? CurveChain_1.Loop.create(xyz) : CurveChain_1.Path.create(xyz);
        return LinearSweep.create(contour, PointVector_1.Vector3d.create(0, 0, zSweep), capped);
    }
    getCurvesRef() { return this.contour.curves; }
    getSweepContourRef() { return this.contour; }
    cloneSweepVector() { return this.direction.clone(); }
    isSameGeometryClass(other) { return other instanceof LinearSweep; }
    clone() {
        return new LinearSweep(this.contour.clone(), this.direction.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        if (this.contour.tryTransformInPlace(transform)) {
            transform.multiplyVector(this.direction, this.direction);
        }
        return false;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        return this.contour.localToWorld.cloneRigid();
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    isAlmostEqual(other) {
        if (other instanceof LinearSweep) {
            return this.contour.isAlmostEqual(other.contour)
                && this.direction.isAlmostEqual(other.direction)
                && this.capped === other.capped;
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleLinearSweep(this);
    }
    /**
     * @returns Return the curves of a constant-v section of the solid.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this.contour.curves.clone();
        if (section && vFraction !== 0.0)
            section.tryTransformInPlace(Transform_1.Transform.createTranslation(this.direction.scale(vFraction)));
        return section;
    }
    extendRange(range, transform) {
        const contourRange = this.contour.curves.range(transform);
        range.extendRange(contourRange);
        if (transform) {
            const transformedDirection = transform.multiplyVector(this.direction);
            contourRange.low.addInPlace(transformedDirection);
            contourRange.high.addInPlace(transformedDirection);
        }
        else {
            contourRange.low.addInPlace(this.direction);
            contourRange.high.addInPlace(this.direction);
        }
        range.extendRange(contourRange);
    }
}
exports.LinearSweep = LinearSweep;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Geometry, AxisOrder, Angle, AngleSweep, BSIJSONValues } from "./Geometry";
const Polyface_1 = __webpack_require__(92);
const GrowableArray_1 = __webpack_require__(37);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const BoxTopology_1 = __webpack_require__(148);
const StrokeOptions_1 = __webpack_require__(67);
const CurveChain_1 = __webpack_require__(14);
const Geometry_1 = __webpack_require__(3);
const LineString3d_1 = __webpack_require__(10);
const Graph_1 = __webpack_require__(149);
const GeometryHandler_1 = __webpack_require__(90);
/**
 *
 * * Simple construction for strongly typed GeometryQuery objects:
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add GeemotryQuery objects:
 *
 * *** `builder.addGeometryQuery(g: GeometryQuery)`
 * *** `builder.addCone(cone: Cone)`
 * *** `builder.addTorusPipe(surface: TorusPipe)`
 * *** `builder.addLinearSweepLineStrings(surface: LinearSweep)`
 * *** `builder.addRotationalSweep(surface: RotatationalSweep)`
 * *** `builder.addLinearSweep(surface: LinearSweep)`
 * *** `builder.addRuledSweep(surface: RuledSweep)`
 * *** `builder.addSphere(sphere: Sphere)`
 * *** `builder.addBox(box: Box)`
 * *** `buidler.addIndexedPolyface(polyface)`
 * **  Extract with `builder.claimPolyface (true)`
 *
 * * Simple construction for ephemeral constructive data:
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add from fragmentary data:
 *
 * *** `builder.addBetweenLineStrings (linestringA, linestringB, addClosure)`
 * *** `builder.addBetweenTransformedLineStrings (curves, transformA, transformB, addClosure)`
 * *** `builder.addBetweenStroked (curveA, curveB)`
 * *** `builder.addLinearSweepLineStrigns (contour, vector)`
 * *** `builder.addPolygon (points, numPointsToUse)`
 * *** `builder.addTransformedUnitBox (transform)`
 * *** `builder.addTriangleFan (conePoint, linestring, toggleOrientation)`
 * *** `builder.addTrianglesInUnchedkedPolygon (linestring, toggle)`
 * *** `builder.addUVGrid(surface,numU, numV, createFanInCaps)`
 * *** `builder.addGraph(Graph, acceptFaceFunction)`
 * **  Extract with `builder.claimPolyface(true)`
 *
 * * Low-level detail construction -- direct use of indices
 *
 * ** Create a builder with `builder = PolyfaceBuilder.create()`
 * ** Add GeometryQuery objects
 *
 * *** `builder.findOrAddPoint(point)`
 * *** `builder.findOrAddPointInLineString (linestring, index)`
 * *** `builder.findorAddTransformedPointInLineString(linestring, index, transform)`
 * *** `builder.findOrAddPointXYZ(x,y,z)`
 * *** `builder.addTriangleFanFromIndex0(indexArray, toggle)`
 * *** `builder.addTriangle (point0, point1, point2)`
 * *** `builder.addQuad (point0, point1, point2, point3)`
 * *** `builder.addOneBasedPointIndex (index)`
 */
class PolyfaceBuilder extends GeometryHandler_1.NullGeometryHandler {
    constructor(options) {
        super();
        this._options = options ? options : StrokeOptions_1.StrokeOptions.createForFacets();
        this.polyface = Polyface_1.IndexedPolyface.create(this._options.needNormals, this._options.needParams, this._options.needColors);
        this.reversed = false;
    }
    get options() { return this._options; }
    /** extract the polyface. */
    claimPolyface(compress = true) {
        if (compress)
            this.polyface.data.compress();
        return this.polyface;
    }
    toggleReversedFacetFlag() { this.reversed = !this.reversed; }
    static create(options) {
        return new PolyfaceBuilder(options);
    }
    /** add facets for a transformed unit box. */
    addTransformedUnitBox(transform) {
        const pointIndex0 = this.polyface.data.pointCount;
        // these will have sequential indices starting at pointIndex0 . . .
        for (const p of BoxTopology_1.BoxTopology.points)
            this.polyface.addPoint(transform.multiplyPoint3d(p));
        for (const facet of BoxTopology_1.BoxTopology.cornerIndexCCW) {
            for (const pointIndex of facet)
                this.polyface.addPointIndex(pointIndex0 + pointIndex);
            this.polyface.terminateFacet();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTriangleFan(conePoint, ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = this.findOrAddPoint(conePoint);
            let index1 = this.findOrAddPointInLineString(ls, 0);
            let index2 = 0;
            for (let i = 1; i < n; i++) {
                index2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTrianglesInUncheckedPolygon(ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = this.findOrAddPointInLineString(ls, 0);
            let index1 = this.findOrAddPointInLineString(ls, 1);
            let index2 = 0;
            for (let i = 2; i < n; i++) {
                index2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTriangleFanFromIndex0(index, toggle, needNormals = false, needParams = false) {
        const n = index.length;
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = index.at(0);
            let index1 = index.at(1);
            let index2 = 0;
            for (let i = 2; i < n; i++) {
                index2 = index.at(i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                if (needNormals)
                    this.addIndexedTriangleNormalIndexes(index0, index1, index2);
                if (needParams)
                    this.addIndexedTriangleParamIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return indxex of a prior point with the same coordinates.
     */
    findOrAddPoint(xyz) {
        return this.polyface.addPoint(xyz);
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new param or (if known) return indxex of a prior param with the same coordinates.
     */
    findOrAddParamXY(x, y) {
        return this.polyface.addParamXY(x, y);
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if knonw) return indxex of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddPointInLineString(ls, index, transform) {
        const q = ls.pointAt(index, PolyfaceBuilder.workPointFindOrAdd);
        if (q) {
            if (transform)
                transform.multiplyPoint3d(q, q);
            return this.polyface.addPoint(q);
        }
        return undefined;
    }
    /**
     * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     */
    findOrAddPointXYZ(x, y, z) {
        return this.polyface.addPointXYZ(x, y, z);
    }
    // ###: Consider case where normals will be reversed and point through the other end of the facet
    // ###: We should be able to only append one normal for this entire quad
    // ###: May want to use Growable iterable due to the way we pass onto addTriangle()...
    /**
     * Add a quad to the polyface given its points in order around the edges.
     * Optionally provide params and normals, otherwise they will be calculated without reference data.
     * Optionally mark this quad as the last piece of a face in this polyface.
     */
    addQuadFacet(points, params, normals) {
        if (this._options.shouldTriangulate) {
            // Add as two triangles, with a diagonal along the shortest distance
            const vectorAC = points[0].vectorTo(points[2]);
            const vectorBD = points[1].vectorTo(points[3]);
            if (vectorAC.magnitude() >= vectorBD.magnitude()) {
                this.addTriangleFacet([points[0], points[1], points[2]], params ? [params[0], params[1], params[2]] : undefined, normals ? [normals[0], normals[1], normals[2]] : undefined);
                this.addTriangleFacet([points[0], points[2], points[3]], params ? [params[0], params[2], params[3]] : undefined, normals ? [normals[0], normals[2], normals[3]] : undefined);
            }
            else {
                this.addTriangleFacet([points[0], points[1], points[3]], params ? [params[0], params[1], params[3]] : undefined, normals ? [normals[0], normals[1], normals[3]] : undefined);
                this.addTriangleFacet([points[1], points[2], points[3]], params ? [params[1], params[2], params[3]] : undefined, normals ? [normals[1], normals[2], normals[3]] : undefined);
            }
            return;
        }
        let idx0;
        let idx1;
        let idx2;
        let idx3;
        // Add params if needed
        if (this._options.needParams) {
            if (params && params.length >= 4) {
                idx0 = this.polyface.addParam(params[0]);
                idx1 = this.polyface.addParam(params[1]);
                idx2 = this.polyface.addParam(params[2]);
                idx3 = this.polyface.addParam(params[3]);
            }
            else {
                const vectorAB = points[0].vectorTo(points[1]);
                const vectorAC = points[0].vectorTo(points[2]);
                const unitAxes = Transform_1.RotMatrix.createRigidFromColumns(vectorAB, vectorAC, 0 /* XYZ */);
                const localToWorld = Transform_1.Transform.createOriginAndMatrix(points[0], unitAxes);
                idx0 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[0])));
                idx1 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[1])));
                idx2 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[2])));
                idx3 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[3])));
            }
            this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);
        }
        // Add normals if needed
        if (this._options.needParams) {
            if (normals && normals.length >= 4) {
                const normal0 = normals[0].normalize();
                const normal1 = normals[1].normalize();
                const normal2 = normals[2].normalize();
                const normal3 = normals[3].normalize();
                idx0 = this.polyface.addNormal(normal0 ? normal0 : PointVector_1.Vector3d.create());
                idx1 = this.polyface.addNormal(normal1 ? normal1 : PointVector_1.Vector3d.create());
                idx2 = this.polyface.addNormal(normal2 ? normal2 : PointVector_1.Vector3d.create());
                idx3 = this.polyface.addNormal(normal3 ? normal3 : PointVector_1.Vector3d.create());
            }
            else {
                const vectorAB = points[0].vectorTo(points[1]);
                const vectorAC = points[0].vectorTo(points[2]);
                let normal = vectorAB.crossProduct(vectorAC).normalize();
                normal = normal ? normal : PointVector_1.Vector3d.create(); // Will be cloned in addNormal() method
                idx0 = this.polyface.addNormal(normal);
                idx1 = this.polyface.addNormal(normal);
                idx2 = this.polyface.addNormal(normal);
                idx3 = this.polyface.addNormal(normal);
            }
            this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(points[0]);
        idx1 = this.findOrAddPoint(points[1]);
        idx2 = this.findOrAddPoint(points[2]);
        idx3 = this.findOrAddPoint(points[3]);
        this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);
    }
    /** Announce a single quad facet's point indexes.
     *
     * * The actual quad may be reversed or trianglulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of the quad.
     */
    addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this.reversed) {
            this.polyface.addPointIndex(indexA0);
            this.polyface.addPointIndex(indexB0);
            this.polyface.addPointIndex(indexB1);
            this.polyface.addPointIndex(indexA1);
            this.polyface.terminateFacet();
        }
        else {
            this.polyface.addPointIndex(indexA0);
            this.polyface.addPointIndex(indexA1);
            this.polyface.addPointIndex(indexB1);
            this.polyface.addPointIndex(indexB0);
            this.polyface.terminateFacet();
        }
    }
    /** For a single quad facet, add the indexes of the corresponding param points. */
    addIndexedQuadParamIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this.reversed) {
            this.polyface.addParamIndex(indexA0);
            this.polyface.addParamIndex(indexB0);
            this.polyface.addParamIndex(indexB1);
            this.polyface.addParamIndex(indexA1);
        }
        else {
            this.polyface.addParamIndex(indexA0);
            this.polyface.addParamIndex(indexA1);
            this.polyface.addParamIndex(indexB1);
            this.polyface.addParamIndex(indexB0);
        }
    }
    /** For a single quad facet, add the indexes of the corresponding normal vectors. */
    addIndexedQuadNormalIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this.reversed) {
            this.polyface.addNormalIndex(indexA0);
            this.polyface.addNormalIndex(indexB0);
            this.polyface.addNormalIndex(indexB1);
            this.polyface.addNormalIndex(indexA1);
        }
        else {
            this.polyface.addNormalIndex(indexA0);
            this.polyface.addNormalIndex(indexA1);
            this.polyface.addNormalIndex(indexB1);
            this.polyface.addNormalIndex(indexB0);
        }
    }
    // ### TODO: Consider case where normals will be reversed and point through the other end of the facet
    // ### TODO: We should be able to only append one normal for this entire quad
    /**
     * Add a triangle to the polyface given its points in order around the edges.
     * Optionally provide params and normals, otherwise they will be calculated without reference data.
     * Optionally mark this triangle as the last piece of a face in this polyface.
     */
    addTriangleFacet(points, params, normals) {
        let idx0;
        let idx1;
        let idx2;
        // Add params if needed
        if (this._options.needParams) {
            if (params && params.length >= 3) {
                idx0 = this.polyface.addParam(params[0]);
                idx1 = this.polyface.addParam(params[1]);
                idx2 = this.polyface.addParam(params[2]);
            }
            else {
                const vectorAB = points[0].vectorTo(points[1]);
                const vectorAC = points[0].vectorTo(points[2]);
                const unitAxes = Transform_1.RotMatrix.createRigidFromColumns(vectorAB, vectorAC, 0 /* XYZ */);
                const localToWorld = Transform_1.Transform.createOriginAndMatrix(points[0], unitAxes);
                idx0 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[0])));
                idx1 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[1])));
                idx2 = this.polyface.addParam(PointVector_1.Point2d.createFrom(localToWorld.multiplyInversePoint3d(points[2])));
            }
            this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);
        }
        // Add normals if needed
        if (this._options.needParams) {
            if (normals && normals.length >= 3) {
                const normal0 = normals[0].normalize();
                const normal1 = normals[1].normalize();
                const normal2 = normals[2].normalize();
                idx0 = this.polyface.addNormal(normal0 ? normal0 : PointVector_1.Vector3d.create());
                idx1 = this.polyface.addNormal(normal1 ? normal1 : PointVector_1.Vector3d.create());
                idx2 = this.polyface.addNormal(normal2 ? normal2 : PointVector_1.Vector3d.create());
            }
            else {
                const vectorAB = points[0].vectorTo(points[1]);
                const vectorAC = points[0].vectorTo(points[2]);
                let normal = vectorAB.crossProduct(vectorAC).normalize();
                normal = normal ? normal : PointVector_1.Vector3d.create(); // Will be cloned in addNormal() method
                idx0 = this.polyface.addNormal(normal);
                idx1 = this.polyface.addNormal(normal);
                idx2 = this.polyface.addNormal(normal);
            }
            this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(points[0]);
        idx1 = this.findOrAddPoint(points[1]);
        idx2 = this.findOrAddPoint(points[3]);
        this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);
    }
    /** Announce a single triangle facet's point indexes.
     *
     * * The actual quad may be reversed or trianglulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of hte quad.
     */
    addIndexedTrianglePointIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this.reversed) {
            this.polyface.addPointIndex(indexA);
            this.polyface.addPointIndex(indexB);
            this.polyface.addPointIndex(indexC);
            this.polyface.terminateFacet();
        }
        else {
            this.polyface.addPointIndex(indexA);
            this.polyface.addPointIndex(indexC);
            this.polyface.addPointIndex(indexB);
            this.polyface.terminateFacet();
        }
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleParamIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this.reversed) {
            this.polyface.addParamIndex(indexA);
            this.polyface.addParamIndex(indexB);
            this.polyface.addParamIndex(indexC);
        }
        else {
            this.polyface.addParamIndex(indexA);
            this.polyface.addParamIndex(indexC);
            this.polyface.addParamIndex(indexB);
        }
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleNormalIndexes(indexA, indexB, indexC) {
        if (indexA === indexB || indexB === indexC || indexC === indexA)
            return;
        if (!this.reversed) {
            this.polyface.addNormalIndex(indexA);
            this.polyface.addNormalIndex(indexB);
            this.polyface.addNormalIndex(indexC);
        }
        else {
            this.polyface.addNormalIndex(indexA);
            this.polyface.addNormalIndex(indexC);
            this.polyface.addNormalIndex(indexB);
        }
    }
    /** Add facets betwee lineStrings with matched point counts.
     *
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenLineStrings(lineStringA, lineStringB, addClosure = false) {
        const pointA = lineStringA.points;
        const pointB = lineStringB.points;
        const numPoints = pointA.length;
        if (numPoints < 2 || numPoints !== pointB.length)
            return;
        let indexA0 = this.findOrAddPoint(pointA[0]);
        let indexB0 = this.findOrAddPoint(pointB[0]);
        const indexA00 = indexA0;
        const indexB00 = indexB0;
        let indexA1 = 0;
        let indexB1 = 0;
        for (let i = 1; i < numPoints; i++) {
            indexA1 = this.findOrAddPoint(pointA[i]);
            indexB1 = this.findOrAddPoint(pointB[i]);
            this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
            indexA0 = indexA1;
            indexB0 = indexB1;
        }
        if (addClosure)
            this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);
    }
    /** Add facets betwee lineStrings with matched point counts.
     *
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenTransformedLineStrings(curves, transformA, transformB, addClosure = false) {
        if (curves instanceof LineString3d_1.LineString3d) {
            const pointA = curves.points;
            const numPoints = pointA.length;
            let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA);
            let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB);
            const indexA00 = indexA0;
            const indexB00 = indexB0;
            let indexA1 = 0;
            let indexB1 = 0;
            for (let i = 1; i < numPoints; i++) {
                indexA1 = this.findOrAddPointInLineString(curves, i, transformA);
                indexB1 = this.findOrAddPointInLineString(curves, i, transformB);
                this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
            if (addClosure)
                this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);
        }
        else {
            const children = curves.children;
            // just send the children individually -- final compres will fix things??
            if (children)
                for (const c of children) {
                    this.addBetweenTransformedLineStrings(c, transformA, transformB);
                }
        }
    }
    addBetweenStroked(dataA, dataB) {
        if (dataA instanceof LineString3d_1.LineString3d && dataB instanceof LineString3d_1.LineString3d) {
            this.addBetweenLineStrings(dataA, dataB, false);
        }
        else if (dataA instanceof CurveChain_1.CurveChain && dataB instanceof CurveChain_1.CurveChain) {
            const chainA = dataA.children;
            const chainB = dataB.children;
            if (chainA.length === chainB.length) {
                for (let i = 0; i < chainA.length; i++) {
                    const cpA = chainA[i];
                    const cpB = chainB[i];
                    if (cpA instanceof LineString3d_1.LineString3d && cpB instanceof LineString3d_1.LineString3d) {
                        this.addBetweenLineStrings(cpA, cpB);
                    }
                }
            }
        }
    }
    /**
     *
     * @param cone cone to facet
     * @param strokeCount number of strokes around the cone.  If omitted, use the strokeOptions previously supplied to the builder.
     */
    addCone(cone, strokeCount) {
        // assume cone strokes consistently at both ends ....
        const lineStringA = cone.strokeConstantVSection(0.0, strokeCount ? strokeCount : this._options);
        const lineStringB = cone.strokeConstantVSection(1.0, strokeCount ? strokeCount : this._options);
        this.addBetweenLineStrings(lineStringA, lineStringB, false);
        if (cone.capped) {
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
            this.addTrianglesInUncheckedPolygon(lineStringB, false); // upper triangles to not flip.
        }
    }
    /**
     *
     * @param surface TorusPipe to facet
     * @param strokeCount number of strokes around the cone.  If omitted, use the strokeOptions previously supplied to the builder.
     */
    addTorusPipe(surface, phiStrokeCount, thetaStrokeCount) {
        this.toggleReversedFacetFlag();
        this.addUVGrid(surface, phiStrokeCount ? phiStrokeCount : 8, thetaStrokeCount ? thetaStrokeCount : Math.ceil(16 * surface.getThetaFraction()), surface.capped);
        this.toggleReversedFacetFlag();
    }
    /**
     *
     * @param vector sweep vector
     * @param contour contour which contains only linestrings
     */
    addLinearSweepLineStrings(contour, vector) {
        if (contour instanceof LineString3d_1.LineString3d) {
            const ls = contour;
            let pointA = PointVector_1.Point3d.create();
            let pointB = PointVector_1.Point3d.create();
            let indexA0 = 0;
            let indexA1 = 0;
            let indexB0 = 0;
            let indexB1 = 0;
            const n = ls.numPoints();
            for (let i = 0; i < n; i++) {
                pointA = ls.pointAt(i, pointA);
                pointB = pointA.plus(vector, pointB);
                indexA1 = this.findOrAddPoint(pointA);
                indexB1 = this.findOrAddPoint(pointB);
                if (i > 0) {
                    this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                }
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
        }
        else if (contour instanceof CurveChain_1.CurveChain) {
            for (const ls of contour.children) {
                this.addLinearSweepLineStrings(ls, vector);
            }
        }
    }
    addRotationalSweep(surface) {
        const strokes = surface.getCurves().cloneStroked();
        const numStep = StrokeOptions_1.StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);
        const transformA = Transform_1.Transform.createIdentity();
        const transformB = Transform_1.Transform.createIdentity();
        for (let i = 1; i <= numStep; i++) {
            surface.getFractionalRotationTransform(i / numStep, transformB);
            this.addBetweenTransformedLineStrings(strokes, transformA, transformB);
            transformA.setFrom(transformB);
        }
        if (surface.capped) {
            const contour = surface.getSweepContourRef();
            contour.emitFacets(this, true, undefined);
            contour.emitFacets(this, false, transformB);
        }
    }
    /**
     *
     * @param cone cone to facet
     */
    addLinearSweep(surface) {
        const baseStrokes = surface.getCurvesRef().cloneStroked();
        this.addLinearSweepLineStrings(baseStrokes, surface.cloneSweepVector());
        if (surface.capped) {
            const contour = surface.getSweepContourRef();
            contour.emitFacets(this, true, undefined);
            contour.emitFacets(this, false, Transform_1.Transform.createTranslation(surface.cloneSweepVector()));
        }
    }
    /**
     *
     * @param cone cone to facet
     */
    addRuledSweep(surface) {
        const contours = surface.sweepContoursRef();
        let stroke0;
        let stroke1;
        for (let i = 0; i < contours.length; i++) {
            stroke1 = contours[i].curves.cloneStroked();
            if (i > 0 && stroke0 && stroke1)
                this.addBetweenStroked(stroke0, stroke1);
            stroke0 = stroke1;
        }
        contours[0].emitFacets(this, true, undefined);
        contours[contours.length - 1].emitFacets(this, false, undefined);
    }
    addSphere(sphere, strokeCount) {
        const numLongitudeStroke = strokeCount ? strokeCount : this._options.defaultCircleStrokes;
        const numLatitudeStroke = Geometry_1.Geometry.clampToStartEnd(numLongitudeStroke * 0.5, 4, 32);
        let lineStringA = sphere.strokeConstantVSection(0.0, numLongitudeStroke);
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringA.quickLength()))
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
        for (let i = 1; i <= numLatitudeStroke; i++) {
            const lineStringB = sphere.strokeConstantVSection(i / numLatitudeStroke, numLongitudeStroke);
            this.addBetweenLineStrings(lineStringA, lineStringB);
            lineStringA = lineStringB;
        }
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringA.quickLength()))
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // upper triangles do not flip
    }
    addBox(box) {
        const lineStringA = box.strokeConstantVSection(0.0);
        const lineStringB = box.strokeConstantVSection(1.0);
        this.addBetweenLineStrings(lineStringA, lineStringB);
        if (box.capped) {
            this.addTrianglesInUncheckedPolygon(lineStringA, true); // lower triangles flip
            this.addTrianglesInUncheckedPolygon(lineStringB, false); // upper triangles to not flip.
        }
    }
    /** Add a polygon to the evolving facets.
     *
     * * Add points to the polyface
     * * indices are added (in reverse order if indicated by the builder state)
     * @param points array of points.  This may contain extra points not to be used in the polygon
     * @param numPointsToUse number of points to use.
     */
    addPolygon(points, numPointsToUse) {
        // don't use trailing points that match start point.
        while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))
            numPointsToUse--;
        let index = 0;
        if (this.reversed) {
            for (let i = 0; i < numPointsToUse; i++) {
                index = this.findOrAddPoint(points[i]);
                this.polyface.addPointIndex(index);
            }
        }
        else {
            for (let i = numPointsToUse; --i >= 0;) {
                index = this.findOrAddPoint(points[i]);
                this.polyface.addPointIndex(index);
            }
        }
        this.polyface.terminateFacet();
    }
    /** Add a polyface, with optional reverse and transform. */
    addIndexedPolyface(source, reversed, transform) {
        this.polyface.addIndexedPolyface(source, reversed, transform);
    }
    /**
     * Produce a new FacetFaceData for all terminated facets since construction of the previous face.
     * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.
     * Returns true if successful, and false otherwise.
     */
    endFace() {
        return this.polyface.setNewFaceData();
    }
    // -------------------- double dispatch methods ---------------------------
    handleCone(g) { return this.addCone(g); }
    handleTorusPipe(g) { return this.addTorusPipe(g); }
    handleSphere(g) { return this.addSphere(g); }
    handleBox(g) { return this.addBox(g); }
    handleLinearSweep(g) { return this.addLinearSweep(g); }
    handleRotationalSweep(g) { return this.addRotationalSweep(g); }
    handleRuledSweep(g) { return this.addRuledSweep(g); }
    addGeometryQuery(g) { g.dispatchToGeometryHandler(this); }
    /**
     *
     * * Visit all faces
     * * Test each face with f(node) for any node on the face.
     * * For each face that passes, pass its coordinates to the builder.
     * * Rely on the builder's compress step to find common vertex coordinates
     */
    addGraph(graph, needParams, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        let index = 0;
        graph.announceFaceLoops((_graph, seed) => {
            if (acceptFaceFunction(seed)) {
                let node = seed;
                do {
                    index = this.findOrAddPointXYZ(node.x, node.y, node.z);
                    this.polyface.addPointIndex(index);
                    if (needParams) {
                        index = this.findOrAddParamXY(node.x, node.y);
                        this.polyface.addParamIndex(index);
                    }
                    node = node.faceSuccessor;
                } while (node !== seed);
                this.polyface.terminateFacet();
            }
            return true;
        });
    }
    static graphToPolyface(graph, options, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        const builder = PolyfaceBuilder.create(options);
        builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);
        builder.endFace();
        return builder.claimPolyface();
    }
    /**
     * Given a 2-dimensional grid of points and optional corresponding params and normals, add the grid to the polyface as a series of quads.
     * Each facet in the grid should either be made up of 3 or 4 edges. Optionally specify that this quad is the last piece of a face.
     */
    addGrid(pointArray, paramArray, normalArray, endFace = false) {
        for (let i = 0; i < pointArray.length; i++) {
            const params = paramArray ? paramArray[i] : undefined;
            const normals = normalArray ? normalArray[i] : undefined;
            if (pointArray[i].length === 3)
                this.addTriangleFacet(pointArray[i], params, normals);
            else if (pointArray[i].length === 4)
                this.addQuadFacet(pointArray[i], params, normals);
        }
        if (endFace)
            this.endFace();
    }
    addUVGrid(surface, numU, numV, createFanInCaps) {
        let index0 = PolyfaceBuilder.index0;
        let index1 = PolyfaceBuilder.index1;
        let indexSwap;
        index0.ensureCapacity(numU);
        index1.ensureCapacity(numU);
        const xyz = PointVector_1.Point3d.create();
        const du = 1.0 / numU;
        const dv = 1.0 / numV;
        for (let v = 0; v <= numV; v++) {
            // evaluate new points ....
            index1.clear();
            for (let u = 0; u <= numU; u++) {
                const uFrac = u * du;
                const vFrac = v * dv;
                if (this._options.needParams) {
                    const plane = surface.UVFractionToPointAndTangents(uFrac, vFrac);
                    this.polyface.addNormal(plane.vectorU.crossProduct(plane.vectorV));
                    index1.push(this.findOrAddPoint(plane.origin.clone()));
                }
                else {
                    surface.UVFractionToPoint(uFrac, vFrac, xyz);
                    index1.push(this.findOrAddPoint(xyz));
                }
                if (this._options.needParams) {
                    this.polyface.addParam(new PointVector_1.Point2d(uFrac, vFrac));
                }
            }
            if (createFanInCaps && (v === 0 || v === numV)) {
                this.addTriangleFanFromIndex0(index1, v === 0, true, true);
            }
            if (v > 0) {
                for (let u = 0; u < numU; u++) {
                    this.addIndexedQuadPointIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                    if (this._options.needParams)
                        this.addIndexedQuadNormalIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                    if (this._options.needParams)
                        this.addIndexedQuadParamIndexes(index0.at(u), index0.at(u + 1), index1.at(u), index1.at(u + 1));
                }
            }
            indexSwap = index1;
            index1 = index0;
            index0 = indexSwap;
        }
        index0.clear();
        index1.clear();
    }
}
PolyfaceBuilder.workPointFindOrAdd = PointVector_1.Point3d.create();
PolyfaceBuilder.index0 = new GrowableArray_1.GrowableFloat64Array();
PolyfaceBuilder.index1 = new GrowableArray_1.GrowableFloat64Array();
exports.PolyfaceBuilder = PolyfaceBuilder;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const PointVector_1 = __webpack_require__(4);
//
//      2------------------3
//      | \     F4       / |
//      |   6----------7   |
//      |   |          |   |   (BOTTOM = F0)
//      |F5 |   F1     |F3 |
//      |   |          |   |
//      |   4----------5   |
//      | /     F2       \ |
//      0------------------1
//
class BoxTopology {
}
/**
 * static readonly array with the coordinates of the 8 unit cube corners in standard order, which is:
 * x varies fastest
 * * The point indices for the x edges are (0 to 1), (2 to 3), (4 to 5), (6 to 7)
 * * The point indices for the y edges are (0 to 2), (1 to 3), (4 to 6), (5 to 7)
 * * The point indices for the z edges are (0 to 4), (1 to 5), (2 to 6), (3 to 7)
 */
BoxTopology.points = [
    PointVector_1.Point3d.create(0, 0, 0),
    PointVector_1.Point3d.create(1, 0, 0),
    PointVector_1.Point3d.create(0, 1, 0),
    PointVector_1.Point3d.create(1, 1, 0),
    PointVector_1.Point3d.create(0, 0, 1),
    PointVector_1.Point3d.create(1, 0, 1),
    PointVector_1.Point3d.create(0, 1, 1),
    PointVector_1.Point3d.create(1, 1, 1),
];
BoxTopology.primaryCapId = -1;
// cornerIndexCCW[face][*] = vertices around face
BoxTopology.cornerIndexCCW = [
    [1, 0, 2, 3],
    [4, 5, 7, 6],
    [0, 1, 5, 4],
    [1, 3, 7, 5],
    [3, 2, 6, 7],
    [2, 0, 4, 6]
];
// [partnerFace[faceIndex][*] = adjacent face indices.
BoxTopology.partnerFace = [
    [5, 4, 3, 2],
    [2, 3, 4, 5],
    [0, 3, 1, 5],
    [0, 4, 1, 2],
    [0, 5, 1, 3],
    [0, 2, 1, 4],
];
BoxTopology.faceId = [
    [BoxTopology.primaryCapId, 0],
    [BoxTopology.primaryCapId, 1],
    [0, 0],
    [0, 1],
    [0, 2],
    [0, 3]
];
// faceDirections[faceIndex] =[[edge0AxisIndex, edge1AxisIndex, normalAxisIndex],[direction sign for along the axis]
BoxTopology.faceDirections = [
    [[0, 1, 2], [-1, 1, -1]],
    [[0, 1, 2], [1, 1, 1]],
    [[0, 2, 1], [1, -1, 1]],
    [[1, 2, 0], [1, 1, 1]],
    [[0, 2, 1], [-1, 1, 1]],
    [[1, 2, 0], [-1, 1, -1]]
];
// axisEdgeVertex[axisIndex][edgeIndex 0..3][*] = vertex index at end of edge in axisIndex direction.
BoxTopology.axisEdgeVertex = [
    [[0, 1], [2, 3], [4, 5], [6, 7]],
    [[0, 2], [1, 3], [4, 6], [5, 7]],
    [[0, 4], [1, 5], [2, 6], [3, 7]]
];
exports.BoxTopology = BoxTopology;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const PointVector_1 = __webpack_require__(4);
const LineSegment3d_1 = __webpack_require__(38);
const Geometry_1 = __webpack_require__(3);
/**
 *
 * * A HalfEdge is "one side of an edge" in a structure of faces, edges and vertices.  From a node there are navigational links to:
 * ** "faceSuccessor" -- the next half edge in a loop around a face.
 * ** "facePredecessor" -- the previous half edge in a loop around a face.
 * ** "edgeMate"  -- the node's partner on the other side of the edge.
 * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific
 *     uses.  The most useful ones are:
 * ** x,y -- coordinates in the xy plane
 * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.
 * ** buffer -- a integer value manipulated as individual bits.
 * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with
 *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases
 *      of graph manipulation.
 */
class HalfEdge {
    constructor(x = 0, y = 0, z = 0, i = 0) {
        this._id = HalfEdge.totalNodesCreated++;
        this.i = i;
        this.maskBits = 0x00000000;
        this.x = x;
        this.y = y;
        this.z = z;
        this.steiner = false;
        // Other variables are by default undefined
    }
    get id() { return this._id; }
    /** previous half edge "around the face"
     */
    get facePredecessor() { return this._facePredecessor; }
    /** next half edge "around the face" */
    get faceSuccessor() { return this._faceSuccessor; }
    /** Half edge on the other side of this edge.
     */
    get edgeMate() { return this._edgeMate; }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePair(heArray) {
        const a = new HalfEdge();
        const b = new HalfEdge();
        if (heArray) {
            heArray.push(a);
            heArray.push(b);
        }
        HalfEdge.setFaceLinks(a, b);
        HalfEdge.setFaceLinks(b, a);
        HalfEdge.setEdgeMates(a, b);
        return a;
    }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * Properties x,y,z,i are inserted in each
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePairWithCoordinates(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0, heArray) {
        const a = HalfEdge.createHalfEdgePair(heArray);
        const b = a._edgeMate;
        a.x = xA;
        a.y = yA;
        a.z = zA;
        a.i = iA;
        b.x = xB;
        b.y = yB;
        b.z = zB;
        b.i = iB;
        return a;
    }
    /**
     * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor
     * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.
     * * this must always be done with another call to restablish the entire double-linked list.
     */
    static setFaceLinks(heA, heB) {
        heA._faceSuccessor = heB;
        heB._facePredecessor = heA;
    }
    /**
     * * set heA <==> heB pointer relation edgeMate
     */
    static setEdgeMates(heA, heB) {
        heA._edgeMate = heB;
        heB._edgeMate = heA;
    }
    /**
     * * Create a new vertex within the edge from base.
     * * Insert it "within" the base edge.
     * * This requires two new half edges.
     * * if the base is undefined, create a single-edge loop.
     * * This (unlike pinch) breaks the edgeMate pairing of the base edge.
     * * This preserves xyzi properties at all existing vertices.
     * @returns Returns the reference to the half edge created.
     */
    static splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0, heArray) {
        const newA = new HalfEdge(xA, yA, zA, iA);
        const newB = new HalfEdge(xA, yA, zA, iA);
        if (heArray) {
            heArray.push(newA);
            heArray.push(newB);
        }
        if (base === undefined) {
            newA._faceSuccessor = newA._facePredecessor = newA;
            newB._faceSuccessor = newB._facePredecessor = newB;
            HalfEdge.setEdgeMates(newA, newB);
        }
        else {
            const nextA = base._faceSuccessor;
            const mateA = base._edgeMate;
            const vpredA = mateA._faceSuccessor;
            HalfEdge.setFaceLinks(newA, nextA);
            HalfEdge.setFaceLinks(base, newA);
            HalfEdge.setFaceLinks(mateA, newB);
            HalfEdge.setFaceLinks(newB, vpredA);
            HalfEdge.setEdgeMates(newA, mateA);
            HalfEdge.setEdgeMates(newB, base);
        }
        return newA;
    }
    /**
     * @returns Return the next outbound half edge around this vertex in the CCW direction
     */
    get vertexSuccessor() { return this.facePredecessor.edgeMate; }
    /**
     * @returns Return the next outbound half edge around this vertex in the CW direction
     */
    get vertexPredecessor() { return this.edgeMate.faceSuccessor; }
    /**
     * Set mask bits on this HalfEdge
     * @param mask mask to apply
     */
    setMask(mask) { this.maskBits |= mask; }
    /**
     * Get mask bits from this HalfEdge
     * @param mask mask to query
     */
    getMask(mask) { return (this.maskBits & mask); }
    /**
     * Clear mask bits from this HalfEdge
     * @param mask mask to clear
     */
    clearMask(mask) { this.maskBits &= ~mask; }
    /**
     *
     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop
     */
    setMaskAroundVertex(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /**
     *
     * @param mask mask to apply to the half edges around this HalfEdge's face loop
     */
    setMaskAroundFace(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /**
     * @returns Returns the number of edges around this face.
     */
    countEdgesAroundFace() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.faceSuccessor;
        } while (node !== this);
        return count;
    }
    /**
     * @returns Returns the number of edges around vertex.
     */
    countEdgesAroundVertex() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.vertexSuccessor;
        } while (node !== this);
        return count;
    }
    /**
     * @returns Returns the number of nodes found with the given mask value around this vertex loop.
     */
    countMaskAroundFace(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /**
     * @returns Returns the number of nodes found with the given mask value around this vertex loop.
     */
    countMaskAroundVertex(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /**
     * @returns the mask value prior to the call to this method.
     * @param mask mask to apply
     */
    testAndSetMask(mask) {
        const oldMask = this.maskBits & mask;
        this.maskBits |= mask;
        return oldMask;
    }
    /**
     * Test if mask bits are set in the node's bitMask.
     * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask
     */
    isMaskSet(mask) { return (this.maskBits & mask) !== 0; }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `node.isMaskSet (mask)`
     */
    static filterIsMaskOn(node, mask) {
        return node.isMaskSet(mask);
    }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `!node.isMaskSet (mask)`
     */
    static filterIsMaskOff(node, mask) {
        return !node.isMaskSet(mask);
    }
    /**
     * @param id0 id for first node
     * @param x0  x coordinate for first node
     * @param y0  y coordinate for first node
     * @param id1 id for second node
     * @param x1 x coordinate for second node
     * @param y1 y coordinate for second node
     */
    static createEdgeXYXY(id0, x0, y0, id1, x1, y1) {
        const node0 = new HalfEdge(x0, y0);
        const node1 = new HalfEdge(x1, y1);
        node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;
        node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;
        node0._id = id0;
        node1._id = id1;
        return node0;
    }
    /** "pinch" ...
     *
     * * is the universal manipulator for manipulating a node's next and prev pointers
     * * swaps face precessors of nodeA and nodeB.
     * *  is its own inverse.
     * *  does nothing if either node does not have a predecessor (this is obviously a logic error in the caller algorithm)
     * *  if nodeA, nodeB are in different face loops, the loops join to one loop.
     * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.
     */
    static pinch(nodeA, nodeB) {
        const predA = nodeA._facePredecessor;
        const predB = nodeB._facePredecessor;
        if (predA && predB) {
            nodeB._facePredecessor = predA;
            nodeA._facePredecessor = predB;
            predB._faceSuccessor = nodeA;
            predA._faceSuccessor = nodeB;
        }
    }
    /** Turn all pointers to undefined so garbage collector can reuse the object.
     *  This is to be called only by a Graph object that is being decomissioned.
     */
    decomission() {
        this._facePredecessor = undefined;
        this._faceSuccessor = undefined;
        this._edgeMate = undefined;
        this.nextZ = undefined;
        this.prevZ = undefined;
    }
    /** @returns Return the node. This identity function is useful as the NodeFunction in collector methods. */
    static nodeToSelf(node) { return node; }
    /** @returns Return the id of a node.  Useful for collector methods. */
    static nodeToId(node) { return node.id; }
    /** @returns Return the id of a node.Useful for collector methods. */
    static nodeToIdString(node) { return node.id.toString(); }
    /** @returns Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdMaskXY(node) {
        return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };
    }
    /** @returns Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdXYString(node) {
        const s = node.id.toString() + " " +
            HalfEdge.nodeToMaskString(node) + " [" + node.x + "," + node.y + "]";
        return s;
    }
    /**  */
    static nodeToMaskString(node) {
        let s = "";
        if (node.isMaskSet(2 /* BOUNDARY */))
            s += "B";
        if (node.isMaskSet(512 /* PRIMARY_EDGE */))
            s += "P";
        if (node.isMaskSet(1 /* EXTERIOR */))
            s += "X";
        return s;
    }
    /** @returns Return [x,y] with coordinates of node */
    static nodeToXY(node) { return [node.x, node.y]; }
    /** @returns Return Vector2d to face successor, with only xy coordinates */
    vectorToFaceSuccessorXY(result) {
        return PointVector_1.Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);
    }
    /** @returns Return Vector3d to face successor */
    vectorToFaceSuccessor(result) {
        return PointVector_1.Vector3d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, this.faceSuccessor.z - this.z, result);
    }
    /** @returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */
    static testNodeMaskNotExterior(node) { return !node.isMaskSet(1 /* EXTERIOR */); }
    /** @return Return true if x and y coordinates of this and other are exactly equal */
    isEqualXY(other) {
        return this.x === other.x && this.y === other.y;
    }
    /** @return Return true if x and y coordinates of this and other are exactly equal */
    distanceXY(other) {
        return Geometry_1.Geometry.distanceXYXY(this.x, this.y, other.x, other.y);
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundFace(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.faceSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundVertex(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundFace(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.faceSuccessor;
        } while (node !== this);
        return sum;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundVertex(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return sum;
    }
    /** For all the nodes in the face loop of the given node, clear out the mask given */
    clearMaskAroundFace(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /** For all the nodes in the vertex loop of the given node, clear out the mask given */
    clearMaskAroundVertex(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /** Returns the signed sum of a loop of nodes.
     *
     * * A positive area is counterclockwise.
     * * A negative area is clockwise.
     */
    signedFaceArea() {
        let sum = 0;
        // sum area of trapezoids.
        // * the formula in the loop gives twice the area (because it does nto average the y values).
        // * this is fixed up at the end by a single multiply by 0.5
        // * indidual trapezoid heights are measured from y at the start node to keep area values numericall smaller.
        const y0 = this.y;
        let dy0 = 0.0;
        let dy1 = 0.0;
        let x0 = this.x;
        let x1 = x0;
        let node1 = this; // just to initialize -- reassigned in each loop pass.
        let node0 = this;
        do {
            node1 = node0.faceSuccessor;
            x1 = node1.x;
            dy1 = node1.y - y0;
            sum += (x0 - x1) * (dy0 + dy1);
            x0 = x1;
            dy0 = dy1;
            node0 = node1;
            node0 = node1;
        } while (node0 !== this);
        return 0.5 * sum;
    }
}
HalfEdge.totalNodesCreated = 0;
exports.HalfEdge = HalfEdge;
/**
 * A HalfEdgeGraph has:
 * * An array of (pointers to ) HalfEdge objects.
 */
class HalfEdgeGraph {
    constructor() {
        this._numNodesCreated = 0;
        this.allHalfEdges = [];
    }
    /**
     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * The two edges are added to the graph's HalfEdge set
     * @returns Return pointer to the first half edge created.
     */
    createEdgeXYZXYZ(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);
        return a;
    }
    /**
     * * Insert a vertex in the edge begining at base.
     * * this creates two half edges.
     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.
     * * The existing mate retains its base xyzi properties but is no longer the mate of base.
     * * The base and existing mate each become mates with a new half edge.
     * @returns Returns the reference to the half edge created.
     */
    splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0) {
        const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);
        return he;
    }
    /** This is a destructor-like action that elminates all interconnection among the graph's nodes.
     * After this is called the graph is unusable.
     */
    decommission() {
        for (const node of this.allHalfEdges) {
            node.decomission();
        }
        this.allHalfEdges.length = 0;
        this.allHalfEdges = undefined;
    }
    /** create two nodes of a new edge.
     * @returns Return one of the two nodes, which the caller may consider as the start of the edge.
     */
    addEdgeXY(x0, y0, x1, y1) {
        const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);
        this._numNodesCreated += 2;
        this.allHalfEdges.push(baseNode);
        this.allHalfEdges.push(baseNode.faceSuccessor);
        return baseNode;
    }
    /** Clear selected bits in all nodes of the graph. */
    clearMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits &= ~mask;
    }
    /** Set selected bits in all nodes of the graph. */
    setMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits |= mask;
    }
    /** toggle selected bits in all nodes of the graph. */
    reverseMask(mask) {
        for (const node of this.allHalfEdges) {
            node.maskBits ^= mask;
        }
    }
    /**
     * @returns Return the number of nodes that have a specified mask bit set.
     * @param mask mask to count
     */
    countMask(mask) {
        let n = 0;
        for (const node of this.allHalfEdges)
            if (node.isMaskSet(mask))
                n++;
        return n;
    }
    /** Return an array LineSegment3d.
     * * The array has one segment per edge
     * * The coordinates are taken from a node and its face successor.
     * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.
     */
    collectSegments() {
        const segments = [];
        for (const node of this.allHalfEdges) {
            if (node.id < node.edgeMate.id)
                segments.push(LineSegment3d_1.LineSegment3d.create(PointVector_1.Point3d.create(node.x, node.y), PointVector_1.Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));
        }
        return segments;
    }
    /** Returns the number of vertex loops in a graph structure */
    countVertexLoops() {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceVertexLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /** @returns Returns the number of face loops */
    countFaceLoops() {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceFaceLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /**
     * @returns Returns the number of face loops satisfying a filter function with mask argument.
     *
     */
    countFaceLoopsWithMaskFilter(filter, mask) {
        this.clearMask(8192 /* VISITED */);
        let count = 0;
        this.announceFaceLoops((_graph, seed) => {
            if (filter(seed, mask))
                count++;
            return true;
        });
        return count;
    }
    /** @returns Returns an array of nodes, where each node represents a starting point of a face loop.
     */
    collectFaceLoops() {
        const returnArray = [];
        this.announceFaceLoops((_graph, node) => { returnArray.push(node); return true; });
        return returnArray;
    }
    /** @returns Returns an array of nodes, where each node represents a starting point of a vertex loop.
     */
    collectVertexLoops() {
        this.clearMask(8192 /* VISITED */);
        const returnArray = [];
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            returnArray.push(node);
            node.setMaskAroundVertex(8192 /* VISITED */);
        }
        return returnArray;
    }
    /**
     * * Visit each facet of the graph once.
     * * Call the announceFace function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announceface (graph, node) returns false
     * @param  annonceFace function to apply at one node of each face.
     */
    announceFaceLoops(announceFace) {
        this.clearMask(8192 /* VISITED */);
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            node.setMaskAroundFace(8192 /* VISITED */);
            if (!announceFace(this, node))
                break;
        }
    }
    /**
     * * Visit each vertex loop of the graph once.
     * * Call the announceVertex function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announceface (graph, node) returns false
     * @param  annonceFace function to apply at one node of each face.
     */
    announceVertexLoops(announceVertex) {
        this.clearMask(8192 /* VISITED */);
        for (const node of this.allHalfEdges) {
            if (node.getMask(8192 /* VISITED */))
                continue;
            node.setMaskAroundVertex(8192 /* VISITED */);
            if (!announceVertex(this, node))
                break;
        }
    }
    /** @returns Return the number of nodes in the graph */
    countNodes() { return this.allHalfEdges.length; }
}
exports.HalfEdgeGraph = HalfEdgeGraph;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Graph_1 = __webpack_require__(149);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
class Triangulator {
    /** Given the six nodes that make up two bordering triangles, "pinch" and relocate the nodes to flip them */
    static flipTriangles(a, b, c, d, e, f) {
        // Reassign all of the pointers
        Graph_1.HalfEdge.pinch(a, e);
        Graph_1.HalfEdge.pinch(c, d);
        Graph_1.HalfEdge.pinch(f, c);
        Graph_1.HalfEdge.pinch(e, b);
        // Move alpha and beta into the xy coordinates of their predecessors
        e.x = b.x;
        e.y = b.y;
        e.z = b.z;
        e.i = b.i;
        c.i = f.i;
        c.x = f.x;
        c.y = f.y;
        c.z = f.z;
    }
    /**
     *  *  Visit each node of the graph array
     *  *  If a flip would be possible, test the results of flipping using an RotMatrix
     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited
     */
    static cleanupTriangulation(graph) {
        const nodeArray = graph.allHalfEdges;
        graph.clearMask(8192 /* VISITED */);
        let foundNonVisited = false;
        for (let i = 0; i < nodeArray.length; i++) {
            const node = nodeArray[i];
            // HalfEdge has already been visited or is exterior node
            if (node.isMaskSet(8192 /* VISITED */))
                continue;
            node.setMask(8192 /* VISITED */);
            if (node.edgeMate === undefined || node.isMaskSet(1 /* EXTERIOR */) || node.isMaskSet(512 /* PRIMARY_EDGE */))
                continue;
            foundNonVisited = true;
            // Grab 4 points between the two triangles
            const alphaPoint = PointVector_1.Point3d.create(node.x, node.y, node.z);
            const betaPoint = PointVector_1.Point3d.create(node.edgeMate.x, node.edgeMate.y, node.edgeMate.z);
            const preAlphaPoint = PointVector_1.Point3d.create(node.facePredecessor.x, node.facePredecessor.y, node.edgeMate.z);
            const preBetaPoint = PointVector_1.Point3d.create(node.edgeMate.facePredecessor.x, node.edgeMate.facePredecessor.y, node.edgeMate.facePredecessor.z);
            // Convert to vectors
            const sharedVector = PointVector_1.Vector3d.createStartEnd(alphaPoint, betaPoint);
            const alphaVector = PointVector_1.Vector3d.createStartEnd(alphaPoint, preAlphaPoint);
            const betaVector = PointVector_1.Vector3d.createStartEnd(alphaPoint, preBetaPoint);
            // Use RotMatrix to determine if flip is necessary
            const matrix = Transform_1.RotMatrix.createRowValues(betaVector.x, betaVector.y, betaVector.x * betaVector.x + betaVector.y * betaVector.y, alphaVector.x, alphaVector.y, alphaVector.x * alphaVector.x + alphaVector.y * alphaVector.y, sharedVector.x, sharedVector.y, sharedVector.x * sharedVector.x + sharedVector.y * sharedVector.y);
            if (matrix.determinant() > 0.0) {
                // Mark all nodes involved in flip as needing to be buffer (other than alpha and beta node we started with)
                node.facePredecessor.clearMask(8192 /* VISITED */);
                node.faceSuccessor.clearMask(8192 /* VISITED */);
                node.edgeMate.facePredecessor.clearMask(8192 /* VISITED */);
                node.edgeMate.faceSuccessor.clearMask(8192 /* VISITED */);
                // Flip the triangles
                Triangulator.flipTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);
            }
            // If at the end of the loop, check if we found an unvisited node we tried to flip.. if so, restart loop
            if (i === nodeArray.length - 1 && foundNonVisited) {
                i = -1;
                foundNonVisited = false;
            }
        }
        graph.clearMask(8192 /* VISITED */);
    }
    /**
     *
     * @param strokedLoops an array of loops as GrowableXYZArray.
     * @returns triangulated graph, or undefined if bad data.
     */
    static triangulateStrokedLoops(strokedLoops) {
        if (strokedLoops.length < 1)
            return undefined;
        Triangulator.returnGraph = new Graph_1.HalfEdgeGraph();
        let maxArea = strokedLoops[0].areaXY();
        let largestLoopIndex = 0;
        for (let i = 0; i < strokedLoops.length; i++) {
            const area = Math.abs(strokedLoops[i].areaXY());
            if (area > maxArea) {
                maxArea = area;
                largestLoopIndex = i;
            }
        }
        // NOW WE KNOW ...
        // strokedLoops[largestAreaIndex] is the largest loop.  (Hence outer, but orientation is not guaranteed.)
        const holeLoops = [];
        const startingNode = Triangulator.createFaceLoopFromGrowableXYZArray(strokedLoops[largestLoopIndex], true, true);
        if (!startingNode)
            return Triangulator.returnGraph;
        for (let i = 0; i < strokedLoops.length; i++) {
            if (i !== largestLoopIndex) {
                const holeLoop = Triangulator.createFaceLoopFromGrowableXYZArray(strokedLoops[i], false, true);
                if (holeLoop)
                    holeLoops.push(holeLoop);
            }
        }
        // HERE .. NATE ... all the hole loops been created.  Make sure the settings for returnPositiveAreaLoop and markExterior had the effect you need !!!
        return undefined;
    }
    /**
     * Triangulate the polygon made up of by a series of points
     *
     * *  Outer-edge points must be passed in counter-clockwise order
     * *  Inner-edge (hole) indices must be passed in clockwise order (following the outer edge points)
     * *  Optional holeIndices array specifies which indices of points array given are the starts of holes
     */
    static earcutFromPoints(data, holeIndices) {
        Triangulator.returnGraph = new Graph_1.HalfEdgeGraph();
        let outerLen = (holeIndices && holeIndices.length) ? holeIndices[0] : data.length;
        // Do not include points on end of array that match the starting point
        for (let i = outerLen - 1; i > 0; i--) {
            if (Geometry_1.Geometry.isSameCoordinate(data[i].x, data[0].x) && Geometry_1.Geometry.isSameCoordinate(data[i].y, data[0].y))
                outerLen--;
            else
                break;
        }
        let startingNode = Triangulator.createFaceLoop(data, 0, outerLen, true, true);
        if (!startingNode)
            return Triangulator.returnGraph;
        let minX;
        let minY;
        let maxX;
        let maxY;
        let x;
        let y;
        let size;
        if (holeIndices && holeIndices.length)
            startingNode = Triangulator.eliminateHoles(data, startingNode, holeIndices);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80) {
            minX = maxX = data[0].x;
            minY = maxY = data[0].y;
            for (let i = 1; i < outerLen; i++) {
                x = data[i].x;
                y = data[i].y;
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
            }
            // minX, minY and size are later used to transform coords into integers for z-order calculation
            size = Math.max(maxX - minX, maxY - minY);
        }
        Triangulator.earcutLinked(startingNode, minX, minY, size);
        return Triangulator.returnGraph;
    }
    static directcreateFaceLoopFromGrowableXYZ(graph, data) {
        let i;
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        let base;
        const xyz = PointVector_1.Point3d.create();
        for (i = 0; i < data.length; i++) {
            data.getPoint3dAt(i, xyz);
            base = graph.splitEdge(base, xyz.x, xyz.y, xyz.z);
        }
        return base;
    }
    static directCreateFaceLoopFromPointArraySubset(graph, data, start, end) {
        let i;
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        let base;
        for (i = start; i < end; i++) {
            base = graph.splitEdge(base, data[i].x, data[i].y, data[i].z);
        }
        return base;
    }
    /**
     * @param graph the containing graph
     * @praam base base node of newly created loop.
     * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.
     * @param markExterior
     */
    static assignMasksToNewFaceLoop(_graph, base, returnPositiveAreaLoop, markExterior) {
        // base is the final coordinates
        if (base) {
            base = base.faceSuccessor;
            const area = base.signedFaceArea();
            base.setMaskAroundFace(2 /* BOUNDARY */ | 512 /* PRIMARY_EDGE */);
            base.edgeMate.setMaskAroundFace(markExterior ? (2 /* BOUNDARY */ | 512 /* PRIMARY_EDGE */ | 1 /* EXTERIOR */)
                : (2 /* BOUNDARY */ | 512 /* PRIMARY_EDGE */));
            if (area > 0 === returnPositiveAreaLoop)
                return base;
            else
                return base.vertexSuccessor;
        }
        return undefined; // caller should not be calling with start <= end
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order
     */
    static createFaceLoop(data, start, end, returnPositiveAreaLoop, markExterior) {
        const graph = Triangulator.returnGraph;
        const base = Triangulator.directCreateFaceLoopFromPointArraySubset(graph, data, start, end);
        return Triangulator.assignMasksToNewFaceLoop(graph, base, returnPositiveAreaLoop, markExterior);
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order
     */
    static createFaceLoopFromGrowableXYZArray(data, returnPositiveAreaLoop, markExterior) {
        const graph = Triangulator.returnGraph;
        const base = Triangulator.directcreateFaceLoopFromGrowableXYZ(graph, data);
        return Triangulator.assignMasksToNewFaceLoop(graph, base, returnPositiveAreaLoop, markExterior);
    }
    /** eliminate colinear or duplicate points using starting and ending nodes */
    static filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        let p = start;
        let again;
        do {
            again = false;
            if (!p.steiner && (Triangulator.equals(p, p.faceSuccessor) || Triangulator.area(p.facePredecessor, p, p.faceSuccessor) === 0)) {
                Triangulator.join(p);
                p = end = p.facePredecessor;
                if (p === p.faceSuccessor)
                    return undefined;
                again = true;
            }
            else {
                p = p.faceSuccessor;
            }
        } while (again || p !== end);
        return end;
    }
    /** Cut off an ear, forming a new face loop of nodes
     * @param ear the vertex being cut off.
     * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.
     * *  Reassigns the pointers such that beta is left behind with the new face created
     * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon
     * * Reassigns prevZ and nextZ pointers
     */
    static join(ear) {
        const alpha = Triangulator.returnGraph.createEdgeXYZXYZ(ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i, ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);
        const beta = alpha.edgeMate;
        // Take care of z-ordering
        if (ear.prevZ)
            ear.prevZ.nextZ = ear.nextZ;
        if (ear.nextZ)
            ear.nextZ.prevZ = ear.prevZ;
        // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)
        Graph_1.HalfEdge.pinch(ear.faceSuccessor, beta);
        Graph_1.HalfEdge.pinch(ear.facePredecessor, alpha);
        ear.setMaskAroundFace(16384 /* TRIANGULATED_NODE_MASK */);
    }
    /**
     * main ear slicing loop which triangulates a polygon (given as a linked list)
     * While there still exists ear nodes that have not yet been triangulated...
     *
     * *  Check if the ear is hashed, and can easily be split off. If so, "join" that ear.
     * *  If not hashed, move on to a seperate ear.
     * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing
     */
    static earcutLinked(ear, minX, minY, size, pass) {
        if (!ear)
            return;
        // interlink polygon nodes in z-order
        if (!pass && size)
            Triangulator.indexCurve(ear, minX, minY, size);
        let stop = ear;
        let next;
        // iterate through ears, slicing them one by one
        while (!ear.isMaskSet(16384 /* TRIANGULATED_NODE_MASK */)) {
            next = ear.faceSuccessor;
            if (size ? Triangulator.isEarHashed(ear, minX, minY, size) : Triangulator.isEar(ear)) {
                // skipping the next vertice leads to less sliver triangles
                stop = next.faceSuccessor;
                // If we already have a seperated triangle, do not join
                if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {
                    Triangulator.join(ear);
                    ear = ear.faceSuccessor.edgeMate.faceSuccessor.faceSuccessor;
                }
                else {
                    ear.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear.faceSuccessor.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear.facePredecessor.setMask(16384 /* TRIANGULATED_NODE_MASK */);
                    ear = next.faceSuccessor;
                }
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                // if (!pass) {
                //  Triangulator.earcutLinked(Triangulator.filterPoints(ear), minX, minY, size, 1);
                // }
                // if this didn't work, try curing all small self-intersections locally
                if (!pass) {
                    ear = Triangulator.cureLocalIntersections(ear);
                    Triangulator.earcutLinked(ear, minX, minY, size, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    Triangulator.splitEarcut(ear, minX, minY, size);
                }
                break;
            }
        }
    }
    /** Check whether a polygon node forms a valid ear with adjacent nodes */
    static isEar(ear) {
        const a = ear.facePredecessor;
        const b = ear;
        const c = ear.faceSuccessor;
        if (Triangulator.area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        let p = ear.faceSuccessor.faceSuccessor;
        while (p !== ear.facePredecessor) {
            if (Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.area(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.faceSuccessor;
        }
        return true;
    }
    /** Check whether a polygon node forms a valid ear with adjacent nodes using bounded boxes of z-ordering of this and adjacent nodes */
    static isEarHashed(ear, minX, minY, size) {
        const a = ear.facePredecessor;
        const b = ear;
        const c = ear.faceSuccessor;
        if (Triangulator.area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x);
        const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y);
        const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x);
        const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        const minZ = Triangulator.zOrder(minTX, minTY, minX, minY, size);
        const maxZ = Triangulator.zOrder(maxTX, maxTY, minX, minY, size);
        // first look for points inside the triangle in increasing z-order
        let p = ear.nextZ;
        while (p && p.zOrder <= maxZ) {
            if (p !== ear.facePredecessor && p !== ear.faceSuccessor &&
                Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.area(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.nextZ;
        }
        // then look for points in decreasing z-order
        p = ear.prevZ;
        while (p && p.zOrder >= minZ) {
            if (p !== ear.facePredecessor && p !== ear.faceSuccessor &&
                Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.area(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.prevZ;
        }
        return true;
    }
    /** Go through all polygon nodes and cure small local self-intersections */
    static cureLocalIntersections(start) {
        let p = start;
        do {
            const a = p.facePredecessor;
            const b = p.faceSuccessor.faceSuccessor;
            if (!Triangulator.equals(a, b) && Triangulator.intersects(a, p, p.faceSuccessor, b) &&
                Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a)) {
                // remove two nodes involved
                Triangulator.join(p);
                Triangulator.join(p.faceSuccessor);
                p = start = b;
            }
            p = p.faceSuccessor;
        } while (p !== start);
        return p;
    }
    /** try splitting polygon into two and triangulate them independently */
    static splitEarcut(start, minX, minY, size) {
        // look for a valid diagonal that divides the polygon into two
        let a = start;
        do {
            let b = a.faceSuccessor.faceSuccessor;
            while (b !== a.facePredecessor) {
                if (a.i !== b.i && Triangulator.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    let c = Triangulator.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = Triangulator.filterPoints(a, a.faceSuccessor);
                    c = Triangulator.filterPoints(c, c.faceSuccessor);
                    // run earcut on each half
                    Triangulator.earcutLinked(a, minX, minY, size);
                    Triangulator.earcutLinked(c, minX, minY, size);
                    return;
                }
                b = b.faceSuccessor;
            }
            a = a.faceSuccessor;
        } while (a !== start);
    }
    /** link every hole into the outer loop, producing a single-ring polygon without holes */
    static eliminateHoles(data, outerNode, holeIndices) {
        const queue = [];
        let i;
        let len;
        let start;
        let end;
        let list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i];
            end = i < len - 1 ? holeIndices[i + 1] : data.length;
            list = Triangulator.createFaceLoop(data, start, end, false, false);
            if (list && list === list.faceSuccessor)
                list.steiner = true;
            queue.push(Triangulator.getLeftmost(list));
        }
        queue.sort(Triangulator.compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            Triangulator.eliminateHole(queue[i], outerNode);
            outerNode = Triangulator.filterPoints(outerNode, (outerNode) ? outerNode.faceSuccessor : undefined);
        }
        return outerNode;
    }
    static compareX(a, b) {
        return a.x - b.x;
    }
    /** find a bridge between vertices that connects hole with an outer ring and and link it */
    static eliminateHole(hole, outerNode) {
        outerNode = Triangulator.findHoleBridge(hole, outerNode);
        if (outerNode) {
            const b = Triangulator.splitPolygon(outerNode, hole);
            Triangulator.filterPoints(b, b.faceSuccessor);
        }
    }
    /**
     *  David Eberly's algorithm for finding a bridge between hole and outer polygon:
     *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
     */
    static findHoleBridge(hole, outerNode) {
        let p = outerNode;
        if (!p)
            return undefined;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {
                const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.faceSuccessor.y)
                            return p.faceSuccessor;
                    }
                    m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;
                }
            }
            p = p.faceSuccessor;
        } while (p !== outerNode);
        if (!m)
            return undefined;
        if (hx === qx)
            return m.facePredecessor; // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        let tan;
        p = m.faceSuccessor;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.faceSuccessor;
        }
        return m;
    }
    /** interlink polygon nodes in z-order */
    static indexCurve(start, minX, minY, size) {
        let p = start;
        do {
            if (p.zOrder === undefined)
                p.zOrder = Triangulator.zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.facePredecessor;
            p.nextZ = p.faceSuccessor;
            p = p.faceSuccessor;
        } while (p !== start);
        p.prevZ.nextZ = undefined;
        p.prevZ = undefined;
        Triangulator.sortLinked(p);
    }
    /**
     * Simon Tatham's linked list merge sort algorithm
     * http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
     */
    static sortLinked(list) {
        let i;
        let p;
        let q;
        let e;
        let tail;
        let numMerges;
        let pSize;
        let qSize;
        let inSize = 1;
        do {
            p = list;
            list = undefined;
            tail = undefined;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.zOrder <= q.zOrder)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = undefined;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
     * z-order of a point given coords and size of the data bounding box
     */
    static zOrder(x, y, minX, minY, size) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        let p = start;
        let leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.faceSuccessor;
        } while (p !== start);
        return leftmost;
    }
    /** check if a point lies within a convex triangle */
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    /** check if a diagonal between two polygon nodes is valid (lies in polygon interior) */
    static isValidDiagonal(a, b) {
        return a.faceSuccessor.i !== b.i && a.facePredecessor.i !== b.i && !Triangulator.intersectsPolygon(a, b) &&
            Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a) && Triangulator.middleInside(a, b);
    }
    /** signed area of a triangle */
    static area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    /** check if two points are equal */
    static equals(p1, p2) {
        return Geometry_1.Geometry.isSameCoordinate(p1.x, p2.x) && Geometry_1.Geometry.isSameCoordinate(p1.y, p2.y);
    }
    /** check if two segments intersect */
    static intersects(p1, q1, p2, q2) {
        if ((Triangulator.equals(p1, q1) && Triangulator.equals(p2, q2)) ||
            (Triangulator.equals(p1, q2) && Triangulator.equals(p2, q1)))
            return true;
        return Triangulator.area(p1, q1, p2) > 0 !== Triangulator.area(p1, q1, q2) > 0 &&
            Triangulator.area(p2, q2, p1) > 0 !== Triangulator.area(p2, q2, q1) > 0;
    }
    /** check if a polygon diagonal intersects any polygon segments */
    static intersectsPolygon(a, b) {
        let p = a;
        do {
            if (p.i !== a.i && p.faceSuccessor.i !== a.i && p.i !== b.i && p.faceSuccessor.i !== b.i &&
                Triangulator.intersects(p, p.faceSuccessor, a, b))
                return true;
            p = p.faceSuccessor;
        } while (p !== a);
        return false;
    }
    /** check if a polygon diagonal is locally inside the polygon */
    static locallyInside(a, b) {
        return Triangulator.area(a.facePredecessor, a, a.faceSuccessor) < 0 ?
            Triangulator.area(a, b, a.faceSuccessor) >= 0 && Triangulator.area(a, a.facePredecessor, b) >= 0 :
            Triangulator.area(a, b, a.facePredecessor) < 0 || Triangulator.area(a, a.faceSuccessor, b) < 0;
    }
    /** check if the middle point of a polygon diagonal is inside the polygon */
    static middleInside(a, b) {
        let p = a;
        let inside = false;
        const px = (a.x + b.x) / 2;
        const py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.faceSuccessor.y > py)) && p.faceSuccessor.y !== p.y &&
                (px < (p.faceSuccessor.x - p.x) * (py - p.y) / (p.faceSuccessor.y - p.y) + p.x))
                inside = !inside;
            p = p.faceSuccessor;
        } while (p !== a);
        return inside;
    }
    /**
     * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
     * if one belongs to the outer ring and another to a hole, it merges it into a single ring
     * * Returns the base of the new edge at the "a" end.
     * * "a" and "b" still represent the same physical pieces of edges
     * @returns Returns the (base of) the new half edge, at the "a" end.
     */
    static splitPolygon(a, b) {
        const a2 = Triangulator.returnGraph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);
        const b2 = a2.faceSuccessor;
        Graph_1.HalfEdge.pinch(a, a2);
        Graph_1.HalfEdge.pinch(b, b2);
        return a2;
    }
}
exports.Triangulator = Triangulator;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
const SweepContour_1 = __webpack_require__(91);
const SolidPrimitive_1 = __webpack_require__(39);
class RotationalSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, normalizedAxis, sweepAngle, capped) {
        super(capped);
        this.contour = contour;
        this.normalizedAxis = normalizedAxis;
        this.capped = capped;
        this.sweepAngle = sweepAngle;
    }
    static create(contour, axis, sweepAngle, capped) {
        if (!axis.direction.normalizeInPlace())
            return undefined;
        const sweepable = SweepContour_1.SweepContour.createForRotation(contour, axis);
        if (!sweepable)
            return undefined;
        return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at origin of rotation ray
     * * z direction along the rotation ray.
     * * y direction perpendicular to the base contour plane
     */
    getConstructiveFrame() {
        const contourPerpendicular = this.contour.localToWorld.matrix.columnZ();
        const axes = Transform_1.RotMatrix.createRigidFromColumns(contourPerpendicular, this.normalizedAxis.direction, 1 /* YZX */);
        if (axes) {
            return Transform_1.Transform.createOriginAndMatrix(this.normalizedAxis.origin, axes);
        }
        return undefined;
    }
    cloneAxisRay() { return this.normalizedAxis.clone(); }
    getCurves() { return this.contour.curves; }
    getSweepContourRef() { return this.contour; }
    getSweep() { return this.sweepAngle.clone(); }
    isSameGeometryClass(other) { return other instanceof RotationalSweep; }
    isAlmostEqual(other) {
        if (other instanceof RotationalSweep) {
            return this.contour.isAlmostEqual(other.contour)
                && this.normalizedAxis.isAlmostEqual(other.normalizedAxis)
                && this.capped === other.capped;
        }
        return false;
    }
    clone() {
        return new RotationalSweep(this.contour.clone(), this.normalizedAxis.clone(), this.sweepAngle.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        if (this.contour.tryTransformInPlace(transform)) {
            this.normalizedAxis.transformInPlace(transform);
            return this.normalizedAxis.direction.normalizeInPlace();
        }
        return false;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleRotationalSweep(this);
    }
    getFractionalRotationTransform(vFraction, result) {
        const radians = this.sweepAngle.radians * vFraction;
        const rotation = Transform_1.Transform.createOriginAndMatrix(this.normalizedAxis.origin, Transform_1.RotMatrix.createRotationAroundVector(this.normalizedAxis.direction, Geometry_1.Angle.createRadians(radians), result ? result.matrix : undefined));
        return rotation;
    }
    /**
     * @returns Return the curves of a constant-v section of the solid.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this.contour.curves.clone();
        if (section) {
            section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));
        }
        return section;
    }
    extendRange(range) {
        const strokes = this.contour.curves.cloneStroked();
        const numStep = Geometry_1.Geometry.stepCount(22.5, this.sweepAngle.degrees, 4, 16);
        for (let i = 0; i <= numStep; i++)
            strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep));
    }
}
exports.RotationalSweep = RotationalSweep;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveChain_1 = __webpack_require__(14);
const CurvePrimitive_1 = __webpack_require__(12);
const Geometry_1 = __webpack_require__(3);
const SolidPrimitive_1 = __webpack_require__(39);
const SweepContour_1 = __webpack_require__(91);
const ConstructCurveBetweenCurves_1 = __webpack_require__(140);
class RuledSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contours, capped) {
        super(capped);
        this.contours = contours;
    }
    static create(contours, capped) {
        const sweepContours = [];
        for (const contour of contours) {
            const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour);
            if (sweepable === undefined)
                return undefined;
            sweepContours.push(sweepable);
        }
        return new RuledSweep(sweepContours, capped);
    }
    /** @returns Return a reference to the array of sweep contours. */
    sweepContoursRef() { return this.contours; }
    cloneSweepContours() {
        const result = [];
        for (const sweepable of this.contours) {
            result.push(sweepable.clone());
        }
        return result;
    }
    cloneContours() {
        const result = [];
        for (const sweepable of this.contours) {
            result.push(sweepable.curves.clone());
        }
        return result;
    }
    clone() {
        return new RuledSweep(this.cloneSweepContours(), this.capped);
    }
    tryTransformInPlace(transform) {
        for (const contour of this.contours) {
            contour.tryTransformInPlace(transform);
        }
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpenedicular
     */
    getConstructiveFrame() {
        if (this.contours.length === 0)
            return undefined;
        return this.contours[0].localToWorld.cloneRigid();
    }
    isSameGeometryClass(other) { return other instanceof RuledSweep; }
    isAlmostEqual(other) {
        if (other instanceof RuledSweep) {
            if (this.capped !== other.capped)
                return false;
            if (this.contours.length !== other.contours.length)
                return false;
            for (let i = 0; i < this.contours.length; i++) {
                if (!this.contours[i].isAlmostEqual(other.contours[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleRuledSweep(this);
    }
    /**
     * @returns Return the section curves at a fraction of the sweep
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const numSection = this.contours.length;
        if (numSection < 2)
            return undefined;
        const q = vFraction * numSection;
        let section0 = 0;
        if (vFraction >= 1.0)
            section0 = numSection - 1;
        else
            section0 = Math.floor(q);
        if (section0 + 1 >= numSection)
            section0 = numSection - 2;
        const section1 = section0 + 1;
        const localFraction = Geometry_1.Geometry.clampToStartEnd(q - section0, 0, 1);
        return CurveChain_1.CurveCollection.mutatePartners(this.contours[section0].curves, this.contours[section1].curves, (primitive0, primitive1) => {
            const newPrimitive = ConstructCurveBetweenCurves_1.ConstructCurveBetweenCurves.InterpolateBetween(primitive0, localFraction, primitive1);
            if (newPrimitive instanceof CurvePrimitive_1.CurvePrimitive)
                return newPrimitive;
            return undefined;
        });
    }
    extendRange(rangeToExtend, transform) {
        for (const contour of this.contours)
            contour.curves.extendRange(rangeToExtend, transform);
    }
}
exports.RuledSweep = RuledSweep;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(6);
const StrokeOptions_1 = __webpack_require__(67);
const Geometry_1 = __webpack_require__(3);
const SolidPrimitive_1 = __webpack_require__(39);
const CurveChain_1 = __webpack_require__(14);
const Arc3d_1 = __webpack_require__(47);
const LineString3d_1 = __webpack_require__(10);
const AnalyticGeometry_1 = __webpack_require__(11);
/**
 * A Sphere is
 *
 * * A unit sphere (but read on ....)
 * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform
 * * hence possibly the final geometry is ellipsoidal
 */
class Sphere extends SolidPrimitive_1.SolidPrimitive {
    /** Return the latitude (in radians) all fractional v. */
    vFractionToRadians(v) {
        return this.latitudeSweep.fractionToRadians(v);
    }
    /** Return the longitude (in radians) all fractional u. */
    uFractionToRadians(u) {
        return u * Math.PI * 2.0;
    }
    constructor(localToWorld, latitudeSweep, capped) {
        super(capped);
        this.localToWorld = localToWorld;
        this.latitudeSweep = latitudeSweep ? latitudeSweep : Geometry_1.AngleSweep.createFullLatitude();
    }
    clone() {
        return new Sphere(this.localToWorld.clone(), this.latitudeSweep.clone(), this.capped);
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const sphere1 = this.clone();
        transform.multiplyTransformTransform(sphere1.localToWorld, sphere1.localToWorld);
        return sphere1;
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at sphere center
     * * equator in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this.localToWorld.cloneRigid();
    }
    static createCenterRadius(center, radius, latitudeSweep) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, Transform_1.RotMatrix.createUniformScale(radius));
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep : Geometry_1.AngleSweep.createFullLatitude(), false);
    }
    /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */
    static createEllipsoid(localToWorld, latitudeSweep, capped) {
        return new Sphere(localToWorld, latitudeSweep, capped);
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createDgnSphere(center, vectorX, vectorZ, radiusXY, radiusZ, latitudeSweep, capped) {
        const vectorY = vectorX.rotate90Around(vectorZ);
        if (vectorY) {
            const matrix = Transform_1.RotMatrix.createColumns(vectorX, vectorY, vectorZ);
            matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);
            const frame = Transform_1.Transform.createOriginAndMatrix(center, matrix);
            return new Sphere(frame, latitudeSweep.clone(), capped);
        }
        return undefined;
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeSweep, capped) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, axes);
        localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : Geometry_1.AngleSweep.createFullLatitude(), capped);
    }
    /** return (copy of) sphere center */
    cloneCenter() { return this.localToWorld.getOrigin(); }
    /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */
    cloneVectorX() { return this.localToWorld.matrix.columnX(); }
    /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */
    cloneVectorY() { return this.localToWorld.matrix.columnY(); }
    /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */
    cloneVectorZ() { return this.localToWorld.matrix.columnZ(); }
    /** return (a copy of) the sphere's angle sweep. */
    cloneLatitudeSweep() { return this.latitudeSweep.clone(); }
    trueSphereRadius() {
        const factors = this.localToWorld.matrix.factorRigidWithSignedScale();
        if (!factors)
            return undefined;
        if (factors && factors.scale > 0)
            return factors.scale;
        return undefined;
    }
    /**
     * @returns Return a (clone of) the sphere's local to world transformation.
     */
    cloneLocalToWorld() { return this.localToWorld.clone(); }
    isSameGeometryClass(other) { return other instanceof Sphere; }
    isAlmostEqual(other) {
        if (other instanceof Sphere) {
            if (this.capped !== other.capped)
                return false;
            if (!this.localToWorld.isAlmostEqual(other.localToWorld))
                return false;
            return true;
        }
        return false;
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * @param v fractional position along the cone axis
     * @param strokes stroke count or options.
     */
    strokeConstantVSection(v, strokes) {
        let strokeCount = 16;
        if (strokes === undefined) {
            // accept the default above.
        }
        else if (strokes instanceof Number) {
            strokeCount = strokes;
        }
        else if (strokes instanceof StrokeOptions_1.StrokeOptions) {
            strokeCount = strokes.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const phi = this.vFractionToRadians(v);
        const c1 = Math.cos(phi);
        const s1 = Math.sin(phi);
        const result = LineString3d_1.LineString3d.create();
        const deltaRadians = Math.PI * 2.0 / strokeCount;
        let radians = 0;
        const transform = this.localToWorld;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            const xyz = transform.multiplyXYZ(c1 * Math.cos(radians), c1 * Math.sin(radians), s1);
            result.addPoint(xyz);
        }
        return result;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleSphere(this);
    }
    /**
     * @returns Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const phi = this.latitudeSweep.fractionToRadians(vFraction);
        const s1 = Math.sin(phi);
        const c1 = Math.cos(phi);
        const transform = this.localToWorld;
        const center = transform.multiplyXYZ(0, 0, s1);
        const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);
        return CurveChain_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    extendRange(range, transform) {
        let placement = this.localToWorld;
        if (transform) {
            placement = transform.multiplyTransformTransform(placement);
        }
        range.extendTransformedXYZ(placement, -1, -1, -1);
        range.extendTransformedXYZ(placement, 1, -1, -1);
        range.extendTransformedXYZ(placement, -1, 1, -1);
        range.extendTransformedXYZ(placement, 1, 1, -1);
        range.extendTransformedXYZ(placement, -1, -1, 1);
        range.extendTransformedXYZ(placement, 1, -1, 1);
        range.extendTransformedXYZ(placement, -1, 1, 1);
        range.extendTransformedXYZ(placement, 1, 1, 1);
    }
    /** Evaluate as a uv surface
     * @param uFraction fractional position in minor (phi)
     * @param vFraction fractional position on major (theta) arc
     */
    UVFractionToPoint(uFraction, vFraction, result) {
        // sphere with radius 1 . . .
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return this.localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPointAndTangents(uFraction, vFraction, result) {
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const fTheta = Math.PI * 2.0;
        const fPhi = this.latitudeSweep.sweepRadians;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectors(this.localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi), this.localToWorld.multiplyVectorXYZ(-fTheta * sinTheta * cosPhi, fTheta * cosTheta * cosPhi, 0), this.localToWorld.multiplyVectorXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta, fPhi * cosPhi), result);
    }
}
exports.Sphere = Sphere;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
const SolidPrimitive_1 = __webpack_require__(39);
const CurveChain_1 = __webpack_require__(14);
const Arc3d_1 = __webpack_require__(47);
const AnalyticGeometry_1 = __webpack_require__(11);
/**
 * the stored form of the torus pipe is oriented for positive volume:
 *
 * * Both radii are positive, with r0 >= r1 > 0
 * * The sweep is positive
 * * The coordinate system has positive determinant.
 */
class TorusPipe extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, sweep, capped) {
        super(capped);
        this.localToWorld = map;
        this.radiusA = radiusA;
        this.radiusB = radiusB;
        this.sweep = sweep;
        this.isReversed = false;
    }
    clone() {
        const result = new TorusPipe(this.localToWorld.clone(), this.radiusA, this.radiusB, this.sweep.clone(), this.capped);
        result.isReversed = this.isReversed;
        return result;
    }
    tryTransformInPlace(transform) {
        transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);
        return true;
    }
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result.localToWorld, result.localToWorld);
        return result;
    }
    static createInFrame(frame, majorRadius, minorRadius, sweep, capped) {
        // force near-zero radii to true zero
        majorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(majorRadius));
        minorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(minorRadius));
        if (majorRadius < minorRadius)
            return undefined;
        if (majorRadius === 0.0)
            return undefined;
        if (minorRadius === 0.0)
            return undefined;
        if (sweep.isAlmostZero())
            return undefined;
        const xScale = 1.0;
        let yScale = 1.0;
        let zScale = 1.0;
        if (frame.matrix.determinant() < 0.0)
            zScale *= -1.0;
        let isReversed = false;
        const sweep1 = sweep.clone();
        if (sweep.radians < 0.0) {
            sweep1.setRadians(-sweep.radians);
            zScale *= -1.0;
            yScale *= -1.0;
            isReversed = true;
        }
        const frame1 = frame.clone();
        frame1.matrix.scaleColumns(xScale, yScale, zScale, frame1.matrix);
        const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);
        result.isReversed = isReversed;
        return result;
    }
    /** Create a TorusPipe from the typical parameters of the Dgn file */
    static createDgnTorusPipe(center, vectorX, vectorY, majorRadius, minorRadius, sweep, capped) {
        const vectorZ = vectorX.crossProduct(vectorY);
        vectorZ.scaleToLength(vectorX.magnitude(), vectorZ);
        const frame = Transform_1.Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);
        return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at center of major circle
     * * major circle in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this.localToWorld.cloneRigid();
    }
    cloneCenter() { return this.localToWorld.getOrigin(); }
    cloneVectorX() { return this.localToWorld.matrix.columnX(); }
    cloneVectorY() { return this.localToWorld.matrix.columnY(); }
    getMinorRadius() { return this.radiusB; }
    getMajorRadius() { return this.radiusA; }
    getSweepAngle() { return this.sweep.clone(); }
    getIsReversed() { return this.isReversed; }
    getThetaFraction() { return this.sweep.radians / (Math.PI * 2.0); }
    isSameGeometryClass(other) { return other instanceof TorusPipe; }
    isAlmostEqual(other) {
        if (other instanceof TorusPipe) {
            if (this.capped !== other.capped)
                return false;
            if (!this.localToWorld.isAlmostEqual(other.localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this.radiusA, other.radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this.radiusB, other.radiusB)
                && this.sweep.isAlmostEqualNoPeriodShift(other.sweep);
        }
        return false;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleTorusPipe(this);
    }
    /**
     * @returns Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const thetaRadians = this.sweep.radians * vFraction;
        const c0 = Math.cos(thetaRadians);
        const s0 = Math.sin(thetaRadians);
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const center = this.localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);
        const vector0 = this.localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);
        const vector90 = this.localToWorld.multiplyVectorXYZ(0, 0, minorRadius);
        return CurveChain_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    constantUSection(uFraction) {
        const theta1Radians = this.sweep.radians;
        const phiRadians = uFraction * Math.PI;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform = this.localToWorld;
        const axes = transform.matrix;
        const center = this.localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));
        const rxy = majorRadius + minorRadius * Math.cos(phiRadians);
        const vector0 = axes.multiplyXYZ(rxy, 0, 0);
        const vector90 = axes.multiplyXYZ(0, rxy, 0);
        return CurveChain_1.Path.create(Arc3d_1.Arc3d.create(center, vector0, vector90, Geometry_1.AngleSweep.createStartEndRadians(0.0, theta1Radians)));
    }
    extendRange(range, transform) {
        const theta1Radians = this.sweep.radians;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform0 = this.localToWorld;
        const numThetaSample = Math.ceil(theta1Radians / (Math.PI * 0.125));
        const numHalfPhiSample = 8;
        let phi0 = 0;
        let dphi = 0;
        let numPhiSample = 0;
        let theta = 0;
        let cosTheta = 0;
        let sinTheta = 0;
        let rxy = 0;
        let phi = 0;
        let j = 0;
        const dTheta = theta1Radians / numThetaSample;
        for (let i = 0; i <= numThetaSample; i++) {
            theta = i * dTheta;
            cosTheta = Math.cos(theta);
            sinTheta = Math.sin(theta);
            // At the ends, do the entire phi circle.
            // Otherwise only do the outer half
            if (i === 0 || i === numThetaSample) {
                phi0 = -Math.PI;
                dphi = 2.0 * Math.PI / numHalfPhiSample;
                numPhiSample = numHalfPhiSample;
            }
            else {
                phi0 = -0.5 * Math.PI;
                dphi = Math.PI / numHalfPhiSample;
                numPhiSample = 2 * numHalfPhiSample - 1;
            }
            if (transform) {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.cos(phi);
                    range.extendTransformTransformedXYZ(transform, transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
            else {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.sin(phi);
                    range.extendTransformedXYZ(transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
        }
    }
    /** Evaluate as a uv surface
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPoint(u, v, result) {
        const thetaRadians = v * this.sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        return this.localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    UVFractionToPointAndTangents(u, v, result) {
        const thetaRadians = v * this.sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const fTheta = this.sweep.radians;
        const fPhi = Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        const rSinPhi = minorRadius * sinPhi;
        const rCosPhi = minorRadius * cosPhi; // appears only as derivative of rSinPhi.
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectors(this.localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi), this.localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0), this.localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi), result);
    }
}
exports.TorusPipe = TorusPipe;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const PointHelpers_1 = __webpack_require__(22);
const AnalyticGeometry_1 = __webpack_require__(11);
const KnotVector_1 = __webpack_require__(108);
const Geometry_1 = __webpack_require__(3);
const Geometry4d_1 = __webpack_require__(46);
const CurvePrimitive_1 = __webpack_require__(12);
/**
 * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.
 */
var UVSelect;
(function (UVSelect) {
    UVSelect[UVSelect["uDirection"] = 0] = "uDirection";
    UVSelect[UVSelect["VDirection"] = 1] = "VDirection";
})(UVSelect = exports.UVSelect || (exports.UVSelect = {}));
var WeightStyle;
(function (WeightStyle) {
    /** There are no weights. */
    WeightStyle[WeightStyle["UnWeighted"] = 0] = "UnWeighted";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`
     * */
    WeightStyle[WeightStyle["WeightsAlreadyAppliedToCoordinates"] = 1] = "WeightsAlreadyAppliedToCoordinates";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`
     * */
    WeightStyle[WeightStyle["WeightsSeparateFromCoordinates"] = 2] = "WeightsSeparateFromCoordinates";
})(WeightStyle = exports.WeightStyle || (exports.WeightStyle = {}));
/** Bspline knots and poles for 2d-to-Nd.
 * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.
 */
class BSpline2dNd extends CurvePrimitive_1.GeometryQuery {
    degreeUV(select) { return this.knots[select].degree; }
    orderUV(select) { return this.knots[select].degree + 1; }
    numSpanUV(select) { return this.numPoles[select] - this.knots[select].degree; }
    numPolesTotal() { return this.coffs.length / this.poleDimension; }
    numPolesUV(select) { return this.numPoles[select]; }
    poleStepUV(select) { return select === 0 ? 1 : this.numPoles[0]; }
    getPoint3dPole(i, j, result) {
        return PointVector_1.Point3d.createFromPacked(this.coffs, i + j * this.numPoles[0], result);
    }
    // Get a pole (from i,j indices) as Point3d, assuming data is stored xyzw
    getPoint3dPoleXYZW(i, j, result) {
        return PointVector_1.Point3d.createFromPackedXYZW(this.coffs, i + j * this.numPoles[0], result);
    }
    /**
     * @param value numeric value to convert to strict 0 or 1.
     * @returns Return 0 for 0 input, 1 for any nonzero input.
     */
    numberToUVSelect(value) { return value === 0 ? 0 : 1; }
    /** extend a range, treating each block as simple XYZ */
    extendRangeXYZ(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
    /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */
    extendRangeXYZH(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        let w = 0;
        let divW = 0;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendTransformedXYZ(transform, buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendXYZ(buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
    }
    /**
       * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.
       * @param fractionU u parameter
       * @param fractionV v parameter
       * @param result undefined if surface derivatives are parallel (or either alone is zero)
       */
    fractionToRigidFrame(fractionU, fractionV, result) {
        const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);
        if (!skewVectors)
            return undefined;
        const axes = Transform_1.RotMatrix.createColumnsInAxisOrder(0 /* XYZ */, skewVectors.vectorU, skewVectors.vectorV, undefined);
        const axes1 = Transform_1.RotMatrix.createRigidFromRotMatrix(axes, 0 /* XYZ */, axes);
        if (axes1)
            result = Transform_1.Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);
        return result;
    }
    /**
     * initialize arrays for given spline dimensions.
     */
    constructor(numPolesU, numPolesV, poleLength, knotsU, knotsV) {
        super();
        const orderU = knotsU.degree + 1;
        const orderV = knotsV.degree + 1;
        this.knots = [knotsU, knotsV];
        this.coffs = new Float64Array(numPolesU * numPolesV * poleLength);
        this.poleDimension = poleLength;
        this.basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];
        this.basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];
        this.numPoles = [numPolesU, numPolesV];
        this.poleBuffer = new Float64Array(poleLength);
        this.poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];
    }
    /**
     * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overal knot value.
     * @param select selector indicating U or V direction.
     * @param span index of bezier span
     * @param localFraction fractional coordinate within the bezier span
     */
    spanFractionToKnot(select, span, localFraction) {
        return this.knots[select].spanFractionToKnot(span, localFraction);
    }
    // ASSUME f is sized for {order} basis funtions !!!
    spanFractionsToBasisFunctions(select, spanIndex, spanFraction, f, df) {
        spanIndex = Geometry_1.Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));
        const knotIndex0 = spanIndex + this.degreeUV(select) - 1;
        const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :
            this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBufferForSpan(spanIndexU, spanIndexV) {
        const poleBuffer = this.poleBuffer;
        const coffs = this.coffs;
        poleBuffer.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this.numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        let g = 0;
        for (const fV of this.basisBufferUV[1]) {
            let k = kU;
            for (const fU of this.basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer[j] += g * coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    /** sum derivatives by the weights in the basisBuffer, using poles for given span */
    sumpoleBufferDerivativesForSpan(spanIndexU, spanIndexV) {
        const poleBuffer1U = this.poleBuffer1UV[0];
        const poleBuffer1V = this.poleBuffer1UV[1];
        poleBuffer1U.fill(0);
        poleBuffer1V.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this.numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        // U partial derivatives ...
        let g = 0;
        for (const fV of this.basisBufferUV[1]) {
            let k = kU;
            for (const fU of this.basisBuffer1UV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1U[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
        // V partial derivatives ...
        kU = m * spanIndexU + spanIndexV * stepV;
        for (const fV of this.basisBuffer1UV[1]) {
            let k = kU;
            for (const fU of this.basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1V[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    evaluateBuffersAtKnot(u, v, numDerivative = 0) {
        const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);
        const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);
        const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;
        const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;
        if (numDerivative < 1) {
            this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this.basisBufferUV[0]);
            this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this.basisBufferUV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
        }
        else {
            this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this.basisBufferUV[0], this.basisBuffer1UV[0]);
            this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this.basisBufferUV[1], this.basisBuffer1UV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
            this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);
        }
    }
    // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)
    swapBlocks(i0, i1, numSwap) {
        let a;
        for (let i = 0; i < numSwap; i++) {
            a = this.coffs[i0 + i];
            this.coffs[i0 + i] = this.coffs[i1 + i];
            this.coffs[i1 + i] = a;
        }
    }
    /**
     * Reverse the parameter direction for either u or v.
     * @param select direction to reverse -- 0 for u, 1 for v.
     */
    reverseInPlace(select) {
        const m = this.poleDimension;
        const numU = this.numPolesUV(0);
        const numV = this.numPolesUV(1);
        if (select === 0) {
            // reverse within rows.
            for (let j = 0; j < numV; j++) {
                const rowStart = j * numU * m;
                for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++, i1--) {
                    this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);
                }
            }
        }
        else {
            // swap full rows ..
            const numPerRow = m * numU;
            for (let i0 = 0, i1 = (numV - 1) * numPerRow; i0 < i1; i0 += numPerRow, i1 -= numPerRow) {
                this.swapBlocks(i0, i1, numPerRow);
            }
        }
        this.knots[select].reflectKnots();
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(select, value) {
        this.knots[select].wrappable = value;
    }
}
exports.BSpline2dNd = BSpline2dNd;
/**  BSplineSurface3d is a parametric surface in xyz space.
 * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.
 *
 * The various static "create" methods have subtle differences in how grid sizes are conveyed:
 * | Method | control point array | counts |
 * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |
 * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |
 */
class BSplineSurface3d extends BSpline2dNd {
    isSameGeometryClass(other) { return other instanceof BSplineSurface3d; }
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this.coffs); return true; }
    getPole(i, j, result) {
        return this.getPoint3dPole(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 3, knotsU, knotsV);
    }
    /**
     * Return control points json arrays.
     * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.
     * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.
     * @param flatArray if true, retur
     */
    getPointArray(flatArray = true) {
        if (flatArray)
            return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);
        return PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));
    }
    /**
     * Return control points json arrays.
     * * Each row of points is an an array.
     * * Within the array for each row, each point is an array [x,y,z]
     */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),
            weighStyle: WeightStyle.UnWeighted,
            numCartesianDimensions: 3,
        };
        return result;
    }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this.coffs.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a row-by-row grid structure
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        let numPoles = controlPointArray.length;
        if (controlPointArray instanceof Float64Array)
            numPoles /= 3;
        if (numPolesU * numPolesV !== numPoles)
            return undefined;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        if (controlPointArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of controlPointArray) {
                surface.coffs[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of controlPointArray) {
                surface.coffs[i++] = p.x;
                surface.coffs[i++] = p.y;
                surface.coffs[i++] = p.z;
            }
        }
        return surface;
    }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "grid" array, with the points from
     * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static createGrid(points, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = points.length;
        const numPolesU = points[0].length;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        let i = 0;
        for (const row of points) {
            for (const xyz of row) {
                surface.coffs[i++] = xyz[0];
                surface.coffs[i++] = xyz[1];
                surface.coffs[i++] = xyz[2];
            }
        }
        return surface;
    }
    /**
     * @returns Return a complete copy of the bspline surface.
     */
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    /**
     * Return a complete copy of the bspline surface, with a transform applied to the control points.
     * @param transform transform to apply to the control points
     */
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /** Evaluate at a position given by u and v coordinates in knot space.
     * @param u u value, in knot range.
     * @param v v value in knot range.
   * @returns Return the xyz coordinates on the surface.
     */
    knotToPoint(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return PointVector_1.Point3d.createFrom(this.poleBuffer);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectorsArrays(this.poleBuffer, this.poleBuffer1UV[0], this.poleBuffer1UV[1], result);
    }
    /** Evalute at a position given by fractional coordinte in each direction.
       * @param fractionU u coordinate, as a fraction of the knot range.
       * @param fractionV v coordinate, as a fraction of the knot range.
     * @returns Return the xyz coordinates on the surface.
     */
    fractionToPoint(fractionU, fractionV) {
        return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3d) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point3dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this.coffs, plane);
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    isClosable(select) {
        if (!this.knots[select].wrappable)
            return false;
        const degree = this.degreeUV(select);
        const knots = this.knots[select];
        const leftKnotIndex = knots.leftKnotIndex;
        const rightKnotIndex = knots.rightKnotIndex;
        const period = knots.rightKnot - knots.leftKnot;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(knots.knots[k0] + period, knots.knots[k1]))
                return false;
        }
        const poleIndexDelta = this.numPolesUV(select) - this.degreeUV(select); // index jump between equal wrapped poles.
        const numStringer = select === 0 ? this.numPolesUV(1) : this.numPolesUV(0);
        const i0Step = select === 0 ? 0 : 1; // to advance stringer
        const j0Step = select === 0 ? 1 : 0; // to advance stringer
        const iStep = 1 - i0Step; // to advance within stringer
        const jStep = 1 - j0Step; // to advance within stringer
        for (let stringer = 0, i0 = 0, j0 = 0; stringer < numStringer; stringer++, i0 += i0Step, j0 += j0Step) {
            for (let p0 = 0; p0 < degree; p0++) {
                const p1 = p0 + poleIndexDelta;
                if (!Geometry_1.Geometry.isSamePoint3d(this.getPole(i0 + p0 * iStep, j0 + p0 * jStep), this.getPole(i0 + p1 * iStep, j0 + p1 * jStep)))
                    return false;
            }
        }
        return true;
    }
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3d(this);
    }
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZ(rangeToExtend, transform);
    }
}
exports.BSplineSurface3d = BSplineSurface3d;
/**  BsplinceCurve in xyzw homogeneous space */
class BSplineSurface3dH extends BSpline2dNd {
    isSameGeometryClass(other) { return other instanceof BSplineSurface3dH; }
    tryTransformInPlace(transform) {
        PointHelpers_1.Point4dArray.multiplyInPlace(transform, this.coffs);
        return true;
    }
    getPole(i, j, result) {
        return this.getPoint3dPoleXYZW(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 4, knotsU, knotsV);
    }
    /** Return a simple array of the control points. */
    copyPoints4d() { return PointHelpers_1.Point4dArray.unpackToPoint4dArray(this.coffs); }
    /** Return a simple array of the control points. */
    copyPointsAndWeights(points, weights, formatter = PointVector_1.Point3d.create) {
        PointHelpers_1.Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights, formatter);
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a deeper grid array structure.
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param weightArray array of weights, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, weightArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        const numPoles = controlPointArray.length;
        if (numPolesU * numPolesV !== numPoles)
            return undefined;
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        PointHelpers_1.Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray, surface.coffs);
        return surface;
    }
    /** Create a bspline with given knots.
     *
     *   Two count conditions are recognized in each direction:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static createGrid(xyzwGrid, weightStyle, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = xyzwGrid.length;
        const numPolesU = xyzwGrid[0].length;
        // const numPoles = numPolesU * numPolesV;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU.length;
        const numKnotsV = knotArrayV.length;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (orderU < 1 || numPolesU < orderU)
            return undefined;
        if (orderV < 1 || numPolesV < orderV)
            return undefined;
        const knotsU = KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);
        const knotsV = KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    const w = point[3];
                    surface.coffs[i++] = point[0] * w;
                    surface.coffs[i++] = point[1] * w;
                    surface.coffs[i++] = point[2] * w;
                    surface.coffs[i++] = point[3];
                }
            }
        }
        else {
            // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    surface.coffs[i++] = point[0];
                    surface.coffs[i++] = point[1];
                    surface.coffs[i++] = point[2];
                    surface.coffs[i++] = point[3];
                }
            }
        }
        return surface;
    }
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /**
      * Return control points json arrays.
      * * Each row of points is an an array.
      * * Within the array for each row, each point is an array [wx,wy,wz,w].
      */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),
            numCartesianDimensions: 3,
            weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,
        };
        return result;
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPoint4d(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return Geometry4d_1.Point4d.createFromPackedXYZW(this.poleBuffer, 0);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return AnalyticGeometry_1.Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this.poleBuffer, this.poleBuffer1UV[0], this.poleBuffer1UV[1], result);
    }
    fractionToPoint4d(fractionU, fractionV) {
        return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * * evaluate the surface and return the cartesian (weight = 1) point.
     * * if the surface XYZW point has weight0, returns point3d at 000.
     * @param fractionU u direction fraction
     * @param fractionV v direction fraction
     * @param result optional result
     */
    fractionToPoint(fractionU, fractionV, result) {
        const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
        return point4d.realPointDefault000(result);
    }
    /**
   * * evaluate the surface and return the cartesian (weight = 1) point.
   * * if the surface XYZW point has weight0, returns point3d at 000.
   * @param knotU u direction knot
   * @param knotV v direction knot
   * @param result optional result
   */
    knotToPoint(knotU, knotV, result) {
        const point4d = this.knotToPoint4d(knotU, knotV);
        return point4d.realPointDefault000(result);
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3dH) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point4dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    isInPlane(plane) {
        return PointHelpers_1.Point4dArray.isCloseToPlane(this.coffs, plane);
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    isClosable(select) {
        if (!this.knots[select].wrappable)
            return false;
        const degree = this.degreeUV(select);
        const knots = this.knots[select];
        const leftKnotIndex = knots.leftKnotIndex;
        const rightKnotIndex = knots.rightKnotIndex;
        const period = knots.rightKnot - knots.leftKnot;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(knots.knots[k0] + period, knots.knots[k1]))
                return false;
        }
        const poleIndexDelta = this.numPolesUV(select) - this.degreeUV(select); // index jump between equal wrapped poles.
        const numStringer = select === 0 ? this.numPolesUV(1) : this.numPolesUV(0);
        const i0Step = select === 0 ? 0 : 1; // to advance stringer
        const j0Step = select === 0 ? 0 : 1; // to advance stringer
        const iStep = 1 - i0Step; // to advance within stringer
        const jStep = 1 - j0Step; // to advance within stringer
        for (let stringer = 0, i0 = 0, j0 = 0; stringer < numStringer; stringer++, i0 += i0Step, j0 += j0Step) {
            for (let p0 = 0; p0 + 1 < degree; p0++) {
                const p1 = p0 + poleIndexDelta;
                if (!Geometry_1.Geometry.isSamePoint3d(this.getPole(i0 + p0 * iStep, j0 + p0 * jStep), this.getPole(i0 + p1 * iStep, j0 + p1 * jStep)))
                    return false;
            }
        }
        return true;
    }
    /**
     * Pass `this` (strongly typed) to `handler.handleBsplineSurface3dH(this)`.
     * @param handler double dispatch handler.
     */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3dH(this);
    }
    /**
     * extend a range to include the (optionally transformed) points of this surface
     * @param rangeToExtend range that is updaatd to include this surface range
     * @param transform transform to apply to the surface points
     */
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZH(rangeToExtend, transform);
    }
}
exports.BSplineSurface3dH = BSplineSurface3dH;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Logging */
Object.defineProperty(exports, "__esModule", { value: true });
const BentleyError_1 = __webpack_require__(157);
var LogLevel;
(function (LogLevel) {
    /** Tracing and debugging - low level */
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    /** Information - mid level */
    LogLevel[LogLevel["Info"] = 1] = "Info";
    /** Warnings - high level */
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    /** Errors - highest level */
    LogLevel[LogLevel["Error"] = 3] = "Error";
    /** Higher than any real logging level. This is used to turn a category off. */
    LogLevel[LogLevel["None"] = 4] = "None";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/** Logger allows libraries and apps to report potentially useful information about operations, and it allows apps and users to control
 * how or if the logged information is displayed or collected. See [Learning about Logging]($docs/learning/common/Logging.md).
 */
class Logger {
    /** Initialize the logger streams. Should be called at application initialization time. */
    static initialize(logError, logWarning, logInfo, logTrace) {
        Logger._logError = logError;
        Logger._logWarning = logWarning;
        Logger._logInfo = logInfo;
        Logger._logTrace = logTrace;
        Logger.turnOffLevelDefault();
        Logger.turnOffCategories();
    }
    /** Initialize the logger streams to the console. Should be called at application initialization time. */
    static initializeToConsole() {
        // tslint:disable:no-console
        Logger.initialize((category, message, getMetaData) => console.log("Error   |" + category + "| " + message + (getMetaData ? " " + JSON.stringify(getMetaData()) : "")), (category, message, getMetaData) => console.log("Warning |" + category + "| " + message + (getMetaData ? " " + JSON.stringify(getMetaData()) : "")), (category, message, getMetaData) => console.log("Info    |" + category + "| " + message + (getMetaData ? " " + JSON.stringify(getMetaData()) : "")), (category, message, getMetaData) => console.log("Trace   |" + category + "| " + message + (getMetaData ? " " + JSON.stringify(getMetaData()) : "")));
    }
    /** Set the least severe level at which messages should be displayed by default. Call setLevel to override this default setting for specific categories. */
    static setLevelDefault(minLevel) {
        Logger._minLevel = minLevel;
    }
    /** Set the minimum logging level for the specified category. The minimum level is least severe level at which messages in the
     * specified category should be displayed.
     */
    static setLevel(category, minLevel) {
        Logger._categoryFilter.set(category, minLevel);
    }
    /** Interpret a string as the name of a LogLevel */
    static ParseLogLevel(str) {
        switch (str.toUpperCase()) {
            case "EXCEPTION": return LogLevel.Error;
            case "FATAL": return LogLevel.Error;
            case "ERROR": return LogLevel.Error;
            case "WARNING": return LogLevel.Warning;
            case "INFO": return LogLevel.Info;
            case "TRACE": return LogLevel.Trace;
            case "DEBUG": return LogLevel.Trace;
        }
        return LogLevel.None;
    }
    /** Set the log level for multiple categories at once. Also see [[validateProps]] */
    static configureLevels(cfg) {
        Logger.validateProps(cfg);
        if (cfg.defaultLevel !== undefined) {
            this.setLevelDefault(Logger.ParseLogLevel(cfg.defaultLevel));
        }
        if (cfg.categoryLevels !== undefined) {
            for (const cl of cfg.categoryLevels) {
                this.setLevel(cl.category, Logger.ParseLogLevel(cl.logLevel));
            }
        }
    }
    static isLogLevel(v) {
        return LogLevel.hasOwnProperty(v);
    }
    /** Check that the specified object is a valid LoggerLevelsConfig. This is useful when reading a config from a .json file. */
    static validateProps(config) {
        const validProps = ["defaultLevel", "categoryLevels"];
        for (const prop of Object.keys(config)) {
            if (!validProps.includes(prop))
                throw new BentleyError_1.BentleyError(65539 /* BadArg */, "LoggerLevelsConfig - unrecognized property: " + prop);
            if (prop === "defaultLevel") {
                if (!Logger.isLogLevel(config.defaultLevel))
                    throw new BentleyError_1.BentleyError(65539 /* BadArg */, "LoggerLevelsConfig.defaultLevel must be a LogLevel. Invalid value: " + JSON.stringify(config.defaultLevel));
            }
            else if (prop === "categoryLevels") {
                const value = config[prop];
                if (!Array.isArray(value))
                    throw new BentleyError_1.BentleyError(65539 /* BadArg */, "LoggerLevelsConfig.categoryLevels must be an array. Invalid value: " + JSON.stringify(value));
                for (const item of config[prop]) {
                    if (!item.hasOwnProperty("category") || !item.hasOwnProperty("logLevel"))
                        throw new BentleyError_1.BentleyError(65539 /* BadArg */, "LoggerLevelsConfig.categoryLevels - each item must be a LoggerCategoryAndLevel {category: logLevel:}. Invalid value: " + JSON.stringify(item));
                    if (!Logger.isLogLevel(item.logLevel))
                        throw new BentleyError_1.BentleyError(65539 /* BadArg */, "LoggerLevelsConfig.categoryLevels - each item's logLevel property must be a LogLevel. Invalid value: " + JSON.stringify(item.logLevel));
                }
            }
        }
    }
    /** Get the minimum logging level for the specified category. */
    static getLevel(category) {
        // Prefer the level set for this category specifically
        const minLevelForThisCategory = Logger._categoryFilter.get(category);
        if (minLevelForThisCategory !== undefined)
            return minLevelForThisCategory;
        // Fall back on the level set for the parent of this category.
        const parent = category.lastIndexOf(".");
        if ((parent !== undefined) && (parent !== -1))
            return Logger.getLevel(category.slice(0, parent));
        // Fall back on the default level.
        return Logger._minLevel;
    }
    /** Turns off the least severe level at which messages should be displayed by default.
     * This turns off logging for all messages for which no category minimum level is defined.
     */
    static turnOffLevelDefault() {
        Logger._minLevel = undefined;
    }
    /** Turns off all category level filters previously defined with [[Logger.setLevel]].
     */
    static turnOffCategories() {
        Logger._categoryFilter.clear();
    }
    /** Check if messages in the specified category should be displayed at this level of severity. */
    static isEnabled(category, level) {
        const minLevel = Logger.getLevel(category);
        return (minLevel !== undefined) && (level >= minLevel);
    }
    /** Log the specified message to the **error** stream.
     * @param category  The category of the message.
     * @param message  The message.
     * @param metaData  Optional data for the message
     */
    static logError(category, message, metaData) {
        if (Logger._logError && Logger.isEnabled(category, LogLevel.Error))
            Logger._logError(category, message, metaData);
    }
    /** Log the specified message to the **warning** stream.
     * @param category  The category of the message.
     * @param message  The message.
     * @param metaData  Optional data for the message
     */
    static logWarning(category, message, metaData) {
        if (Logger._logWarning && Logger.isEnabled(category, LogLevel.Warning))
            Logger._logWarning(category, message, metaData);
    }
    /** Log the specified message to the **info** stream.
     * @param category  The category of the message.
     * @param message  The message.
     * @param metaData  Optional data for the message
     */
    static logInfo(category, message, metaData) {
        if (Logger._logInfo && Logger.isEnabled(category, LogLevel.Info))
            Logger._logInfo(category, message, metaData);
    }
    /** Log the specified message to the **trace** stream.
     * @param category  The category of the message.
     * @param message  The message.
     * @param metaData  Optional data for the message
     */
    static logTrace(category, message, metaData) {
        if (Logger._logTrace && Logger.isEnabled(category, LogLevel.Trace))
            Logger._logTrace(category, message, metaData);
    }
}
Logger._categoryFilter = new Map();
Logger._minLevel = undefined;
exports.Logger = Logger;
/** Simple performance diagnostics utility.
 * It measures the time from construction to disposal. On disposal it logs the routine name along with
 * the duration in milliseconds.
 * It also logs the routine name at construction time so that nested calls can be disambiguated.
 *
 * The timings are logged using the log category **Performance** and log severity [[LogLevel.INFO]].
 * Enable those, if you want to capture timings.
 */
class PerfLogger {
    constructor(routine) {
        this._routine = routine;
        if (!Logger.isEnabled(PerfLogger._loggerName, PerfLogger._severity)) {
            this._startTimeStamp = 0;
            return;
        }
        Logger.logInfo(PerfLogger._loggerName, `${this._routine},START`);
        this._startTimeStamp = new Date().getTime(); // take timestamp
    }
    dispose() {
        const endTimeStamp = new Date().getTime();
        if (!Logger.isEnabled(PerfLogger._loggerName, PerfLogger._severity))
            return;
        Logger.logInfo(PerfLogger._loggerName, `${this._routine},END,${endTimeStamp - this._startTimeStamp} ms`);
    }
}
PerfLogger._loggerName = "Performance";
PerfLogger._severity = LogLevel.Info;
exports.PerfLogger = PerfLogger;
/** Helps with macro-substitution */
class EnvMacroSubst {
    /** Replace macros delimited by ${} assuming that they refer to environment variables. */
    static replace(str, defaultValues) {
        let startMacro;
        let startNext = 0;
        // tslint:disable-next-line:no-conditional-assignment
        while ((startMacro = str.indexOf("${", startNext)) !== -1) {
            const endMacro = str.indexOf("}", startMacro + 2);
            if (endMacro === -1) {
                startNext = startMacro + 2;
                continue;
            }
            const envvar = str.slice(startMacro + 2, endMacro);
            let subst = process.env[envvar];
            if (subst === undefined) {
                if ((defaultValues === undefined) || !defaultValues.hasOwnProperty(envvar)) {
                    startNext = endMacro + 1;
                    continue;
                }
                subst = defaultValues[envvar];
            }
            str = str.slice(0, startMacro) + subst + str.slice(endMacro + 1);
            startNext += startMacro + subst.length;
        }
        return str;
    }
    /** Check if the string contains ${}, indicating the presence of a macro. */
    static containsEnvvars(str) {
        return str.includes("${") && str.includes("}");
    }
    /** Replace macros delimited by ${} that are found in any of the object's properties */
    static replaceInProperties(obj, recurse, defaultValues) {
        for (const prop of Object.keys(obj)) {
            if (typeof obj[prop] === "string") {
                if (EnvMacroSubst.containsEnvvars(obj[prop]))
                    obj[prop] = EnvMacroSubst.replace(obj[prop], defaultValues);
            }
            else if (recurse && (typeof obj[prop] === "object")) {
                EnvMacroSubst.replaceInProperties(obj[prop], true, defaultValues);
            }
        }
    }
    /** Check if the string contains ${}, indicating the presence of a macro. */
    static anyPropertyContainsEnvvars(obj, recurse) {
        for (const prop of Object.keys(obj)) {
            if (typeof obj[prop] === "string") {
                if (EnvMacroSubst.containsEnvvars(obj[prop]))
                    return true;
            }
            else if (recurse && (typeof obj[prop] === "object")) {
                if (EnvMacroSubst.anyPropertyContainsEnvvars(obj[prop], true))
                    return true;
            }
        }
        return false;
    }
}
exports.EnvMacroSubst = EnvMacroSubst;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Errors */
Object.defineProperty(exports, "__esModule", { value: true });
// iModel Hub Services Errors
var IModelHubStatus;
(function (IModelHubStatus) {
    IModelHubStatus[IModelHubStatus["Success"] = 0] = "Success";
    IModelHubStatus[IModelHubStatus["IMODELHUBERROR_BASE"] = 102400] = "IMODELHUBERROR_BASE";
    IModelHubStatus[IModelHubStatus["IMODELHUBERROR_REQUESTERRORBASE"] = 102656] = "IMODELHUBERROR_REQUESTERRORBASE";
    IModelHubStatus[IModelHubStatus["Unknown"] = 102401] = "Unknown";
    IModelHubStatus[IModelHubStatus["MissingRequiredProperties"] = 102402] = "MissingRequiredProperties";
    IModelHubStatus[IModelHubStatus["InvalidPropertiesValues"] = 102403] = "InvalidPropertiesValues";
    IModelHubStatus[IModelHubStatus["UserDoesNotHavePermission"] = 102404] = "UserDoesNotHavePermission";
    IModelHubStatus[IModelHubStatus["InvalidBriefcase"] = 102405] = "InvalidBriefcase";
    IModelHubStatus[IModelHubStatus["BriefcaseDoesNotExist"] = 102406] = "BriefcaseDoesNotExist";
    IModelHubStatus[IModelHubStatus["BriefcaseDoesNotBelongToUser"] = 102407] = "BriefcaseDoesNotBelongToUser";
    IModelHubStatus[IModelHubStatus["AnotherUserPushing"] = 102408] = "AnotherUserPushing";
    IModelHubStatus[IModelHubStatus["ChangeSetAlreadyExists"] = 102409] = "ChangeSetAlreadyExists";
    IModelHubStatus[IModelHubStatus["ChangeSetDoesNotExist"] = 102410] = "ChangeSetDoesNotExist";
    IModelHubStatus[IModelHubStatus["FileIsNotUploaded"] = 102411] = "FileIsNotUploaded";
    IModelHubStatus[IModelHubStatus["iModelIsNotInitialized"] = 102412] = "iModelIsNotInitialized";
    IModelHubStatus[IModelHubStatus["ChangeSetPointsToBadSeed"] = 102413] = "ChangeSetPointsToBadSeed";
    IModelHubStatus[IModelHubStatus["iModelHubOperationFailed"] = 102414] = "iModelHubOperationFailed";
    IModelHubStatus[IModelHubStatus["PullIsRequired"] = 102415] = "PullIsRequired";
    IModelHubStatus[IModelHubStatus["MaximumNumberOfBriefcasesPerUser"] = 102416] = "MaximumNumberOfBriefcasesPerUser";
    IModelHubStatus[IModelHubStatus["MaximumNumberOfBriefcasesPerUserPerMinute"] = 102417] = "MaximumNumberOfBriefcasesPerUserPerMinute";
    IModelHubStatus[IModelHubStatus["DatabaseTemporarilyLocked"] = 102418] = "DatabaseTemporarilyLocked";
    IModelHubStatus[IModelHubStatus["iModelAlreadyExists"] = 102419] = "iModelAlreadyExists";
    IModelHubStatus[IModelHubStatus["iModelDoesNotExist"] = 102420] = "iModelDoesNotExist";
    IModelHubStatus[IModelHubStatus["LockDoesNotExist"] = 102421] = "LockDoesNotExist";
    IModelHubStatus[IModelHubStatus["LocksExist"] = 102422] = "LocksExist";
    IModelHubStatus[IModelHubStatus["LockOwnedByAnotherBriefcase"] = 102423] = "LockOwnedByAnotherBriefcase";
    IModelHubStatus[IModelHubStatus["UserAlreadyExists"] = 102424] = "UserAlreadyExists";
    IModelHubStatus[IModelHubStatus["UserDoesNotExist"] = 102425] = "UserDoesNotExist";
    IModelHubStatus[IModelHubStatus["CodeStateInvalid"] = 102426] = "CodeStateInvalid";
    IModelHubStatus[IModelHubStatus["CodeReservedByAnotherBriefcase"] = 102427] = "CodeReservedByAnotherBriefcase";
    IModelHubStatus[IModelHubStatus["CodeDoesNotExist"] = 102428] = "CodeDoesNotExist";
    IModelHubStatus[IModelHubStatus["CodesExist"] = 102429] = "CodesExist";
    IModelHubStatus[IModelHubStatus["FileDoesNotExist"] = 102430] = "FileDoesNotExist";
    IModelHubStatus[IModelHubStatus["FileAlreadyExists"] = 102431] = "FileAlreadyExists";
    IModelHubStatus[IModelHubStatus["iModelIsLocked"] = 102432] = "iModelIsLocked";
    IModelHubStatus[IModelHubStatus["EventTypeDoesNotExist"] = 102433] = "EventTypeDoesNotExist";
    IModelHubStatus[IModelHubStatus["EventSubscriptionDoesNotExist"] = 102434] = "EventSubscriptionDoesNotExist";
    IModelHubStatus[IModelHubStatus["EventSubscriptionAlreadyExists"] = 102435] = "EventSubscriptionAlreadyExists";
    IModelHubStatus[IModelHubStatus["ProjectAssociationIsNotEnabled"] = 102436] = "ProjectAssociationIsNotEnabled";
    IModelHubStatus[IModelHubStatus["ProjectIdIsNotSpecified"] = 102437] = "ProjectIdIsNotSpecified";
    IModelHubStatus[IModelHubStatus["FailedToGetProjectPermissions"] = 102438] = "FailedToGetProjectPermissions";
    IModelHubStatus[IModelHubStatus["ChangeSetAlreadyHasVersion"] = 102439] = "ChangeSetAlreadyHasVersion";
    IModelHubStatus[IModelHubStatus["VersionAlreadyExists"] = 102440] = "VersionAlreadyExists";
    IModelHubStatus[IModelHubStatus["QueryIdsNotSpecified"] = 102441] = "QueryIdsNotSpecified";
    IModelHubStatus[IModelHubStatus["ConflictsAggregate"] = 102442] = "ConflictsAggregate";
    IModelHubStatus[IModelHubStatus["SeedFileInitializationFailed"] = 102443] = "SeedFileInitializationFailed";
    /** Id for errors that are returned for incorrect iModel Hub request. */
    IModelHubStatus[IModelHubStatus["UndefinedArgumentError"] = 102657] = "UndefinedArgumentError";
    IModelHubStatus[IModelHubStatus["InvalidArgumentError"] = 102658] = "InvalidArgumentError";
    IModelHubStatus[IModelHubStatus["MissingDownloadUrlError"] = 102659] = "MissingDownloadUrlError";
    IModelHubStatus[IModelHubStatus["NotSupportedInBrowser"] = 102660] = "NotSupportedInBrowser";
    IModelHubStatus[IModelHubStatus["FileHandlerNotSet"] = 102661] = "FileHandlerNotSet";
    IModelHubStatus[IModelHubStatus["FileNotFound"] = 102662] = "FileNotFound";
})(IModelHubStatus = exports.IModelHubStatus || (exports.IModelHubStatus = {}));
/** The error type thrown by this module. `BentleyError` subclasses `Error` to add an `errorNumber` member. See [[IModelStatus]] for `errorNumber` values. */
class BentleyError extends Error {
    constructor(errorNumber, message, log, category, getMetaData) {
        super(message);
        this.errorNumber = errorNumber;
        this._getMetaData = getMetaData;
        this.name = this._initName();
        if (log)
            log(category || "BentleyError", this.toString(), this._getMetaData); // TODO: Can we come up with a better default category?
    }
    hasMetaData() { return this._getMetaData !== undefined; }
    getMetaData() {
        return this.hasMetaData() ? this._getMetaData() : undefined;
    }
    /** This function returns the name of each error status. Override this method to handle more error status codes. */
    _initName() {
        switch (this.errorNumber) {
            // IModelStatus cases
            case 65537 /* AlreadyLoaded */: return "Already Loaded";
            case 65538 /* AlreadyOpen */: return "Already Open";
            case 65539 /* BadArg */: return "Bad Arg";
            case 65540 /* BadElement */: return "Bad Element";
            case 65541 /* BadModel */: return "Bad Model";
            case 65542 /* BadRequest */: return "Bad Request";
            case 65543 /* BadSchema */: return "Bad Schema";
            case 65544 /* CannotUndo */: return "Can not Undo";
            case 65545 /* CodeNotReserved */: return "Code Not Reserved";
            case 65546 /* DeletionProhibited */: return "Deletion Prohibited";
            case 65547 /* DuplicateCode */: return "Duplicate Code";
            case 65548 /* DuplicateName */: return "Duplicate Name";
            case 65549 /* ElementBlockedChange */: return "Element Blocked Change";
            case 65550 /* FileAlreadyExists */: return "File Already Exists";
            case 65551 /* FileNotFound */: return "File Not Found";
            case 65552 /* FileNotLoaded */: return "File Not Loaded";
            case 65553 /* ForeignKeyConstraint */: return "ForeignKey Constraint";
            case 65554 /* IdExists */: return "Id Exists";
            case 65555 /* InDynamicTransaction */: return "InDynamicTransaction";
            case 65556 /* InvalidCategory */: return "Invalid Category";
            case 65557 /* InvalidCode */: return "Invalid Code";
            case 65558 /* InvalidCodeSpec */: return "Invalid CodeSpec";
            case 65559 /* InvalidId */: return "Invalid Id";
            case 65560 /* InvalidName */: return "Invalid Name";
            case 65561 /* InvalidParent */: return "Invalid Parent";
            case 65562 /* InvalidProfileVersion */: return "Invalid Profile Version";
            case 65563 /* IsCreatingChangeSet */: return "IsCreatingChangeSet";
            case 65564 /* LockNotHeld */: return "Lock Not Held";
            case 65565 /* Mismatch2d3d */: return "Mismatch 2d3d";
            case 65566 /* MismatchGcs */: return "Mismatch Gcs";
            case 65567 /* MissingDomain */: return "Missing Domain";
            case 65568 /* MissingHandler */: return "Missing Handler";
            case 65569 /* MissingId */: return "Missing Id";
            case 65570 /* NoGeometry */: return "No Geometry";
            case 65571 /* NoMultiTxnOperation */: return "NoMultiTxnOperation";
            case 65572 /* NotDgnMarkupProject */: return "NotDgnMarkupProject";
            case 65573 /* NotEnabled */: return "Not Enabled";
            case 65574 /* NotFound */: return "Not Found";
            case 65575 /* NotOpen */: return "Not Open";
            case 65576 /* NotOpenForWrite */: return "Not Open For Write";
            case 65577 /* NotSameUnitBase */: return "Not Same Unit Base";
            case 65578 /* NothingToRedo */: return "Nothing To Redo";
            case 65579 /* NothingToUndo */: return "Nothing To Undo";
            case 65580 /* ParentBlockedChange */: return "Parent Blocked Change";
            case 65581 /* ReadError */: return "Read Error";
            case 65582 /* ReadOnly */: return "ReadOnly";
            case 65583 /* ReadOnlyDomain */: return "ReadOnlyDomain";
            case 65584 /* RepositoryManagerError */: return "RepositoryManagerError";
            case 65585 /* SQLiteError */: return "SQLiteError";
            case 65586 /* TransactionActive */: return "Transaction Active";
            case 65587 /* UnitsMissing */: return "Units Missing";
            case 65588 /* UnknownFormat */: return "Unknown Format";
            case 65589 /* UpgradeFailed */: return "Upgrade Failed";
            case 65590 /* ValidationFailed */: return "Validation Failed";
            case 65591 /* VersionTooNew */: return "Version Too New";
            case 65592 /* VersionTooOld */: return "Version Too Old";
            case 65593 /* ViewNotFound */: return "View Not Found";
            case 65594 /* WriteError */: return "Write Error";
            case 65595 /* WrongClass */: return "Wrong Class";
            case 65596 /* WrongIModel */: return "Wrong IModel";
            case 65597 /* WrongDomain */: return "Wrong Domain";
            case 65598 /* WrongElement */: return "Wrong Element";
            case 65599 /* WrongHandler */: return "Wrong Handler";
            case 65600 /* WrongModel */: return "Wrong Model";
            // DbResult cases
            case 1 /* BE_SQLITE_ERROR */: return "BE_SQLITE_ERROR";
            case 2 /* BE_SQLITE_INTERNAL */: return "BE_SQLITE_INTERNAL";
            case 3 /* BE_SQLITE_PERM */: return "BE_SQLITE_PERM";
            case 4 /* BE_SQLITE_ABORT */: return "BE_SQLITE_ABORT";
            case 5 /* BE_SQLITE_BUSY */: return "Db is busy";
            case 6 /* BE_SQLITE_LOCKED */: return "Db is Locked";
            case 7 /* BE_SQLITE_NOMEM */: return "BE_SQLITE_NOMEM";
            case 8 /* BE_SQLITE_READONLY */: return "Readonly";
            case 9 /* BE_SQLITE_INTERRUPT */: return "BE_SQLITE_INTERRUPT";
            case 10 /* BE_SQLITE_IOERR */: return "BE_SQLITE_IOERR";
            case 11 /* BE_SQLITE_CORRUPT */: return "BE_SQLITE_CORRUPT";
            case 12 /* BE_SQLITE_NOTFOUND */: return "Not Found";
            case 13 /* BE_SQLITE_FULL */: return "BE_SQLITE_FULL";
            case 14 /* BE_SQLITE_CANTOPEN */: return "Can't open";
            case 15 /* BE_SQLITE_PROTOCOL */: return "BE_SQLITE_PROTOCOL";
            case 16 /* BE_SQLITE_EMPTY */: return "BE_SQLITE_EMPTY";
            case 17 /* BE_SQLITE_SCHEMA */: return "BE_SQLITE_SCHEMA";
            case 18 /* BE_SQLITE_TOOBIG */: return "BE_SQLITE_TOOBIG";
            case 20 /* BE_SQLITE_MISMATCH */: return "BE_SQLITE_MISMATCH";
            case 21 /* BE_SQLITE_MISUSE */: return "BE_SQLITE_MISUSE";
            case 22 /* BE_SQLITE_NOLFS */: return "BE_SQLITE_NOLFS";
            case 23 /* BE_SQLITE_AUTH */: return "BE_SQLITE_AUTH";
            case 24 /* BE_SQLITE_FORMAT */: return "BE_SQLITE_FORMAT";
            case 25 /* BE_SQLITE_RANGE */: return "BE_SQLITE_RANGE";
            case 26 /* BE_SQLITE_NOTADB */: return "Not a Database";
            case 266 /* BE_SQLITE_IOERR_READ */: return "BE_SQLITE_IOERR_READ";
            case 522 /* BE_SQLITE_IOERR_SHORT_READ */: return "BE_SQLITE_IOERR_SHORT_READ";
            case 778 /* BE_SQLITE_IOERR_WRITE */: return "BE_SQLITE_IOERR_WRITE";
            case 1034 /* BE_SQLITE_IOERR_FSYNC */: return "BE_SQLITE_IOERR_FSYNC";
            case 1290 /* BE_SQLITE_IOERR_DIR_FSYNC */: return "BE_SQLITE_IOERR_DIR_FSYNC";
            case 1546 /* BE_SQLITE_IOERR_TRUNCATE */: return "BE_SQLITE_IOERR_TRUNCATE";
            case 1802 /* BE_SQLITE_IOERR_FSTAT */: return "BE_SQLITE_IOERR_FSTAT";
            case 2058 /* BE_SQLITE_IOERR_UNLOCK */: return "BE_SQLITE_IOERR_UNLOCK";
            case 2314 /* BE_SQLITE_IOERR_RDLOCK */: return "BE_SQLITE_IOERR_RDLOCK";
            case 2570 /* BE_SQLITE_IOERR_DELETE */: return "BE_SQLITE_IOERR_DELETE";
            case 2826 /* BE_SQLITE_IOERR_BLOCKED */: return "BE_SQLITE_IOERR_BLOCKED";
            case 3082 /* BE_SQLITE_IOERR_NOMEM */: return "BE_SQLITE_IOERR_NOMEM";
            case 3338 /* BE_SQLITE_IOERR_ACCESS */: return "BE_SQLITE_IOERR_ACCESS";
            case 3594 /* BE_SQLITE_IOERR_CHECKRESERVEDLOCK */: return "BE_SQLITE_IOERR_CHECKRESERVEDLOCK";
            case 3850 /* BE_SQLITE_IOERR_LOCK */: return "BE_SQLITE_IOERR_LOCK";
            case 4106 /* BE_SQLITE_IOERR_CLOSE */: return "BE_SQLITE_IOERR_CLOSE";
            case 4362 /* BE_SQLITE_IOERR_DIR_CLOSE */: return "BE_SQLITE_IOERR_DIR_CLOSE";
            case 4618 /* BE_SQLITE_IOERR_SHMOPEN */: return "BE_SQLITE_IOERR_SHMOPEN";
            case 4874 /* BE_SQLITE_IOERR_SHMSIZE */: return "BE_SQLITE_IOERR_SHMSIZE";
            case 5130 /* BE_SQLITE_IOERR_SHMLOCK */: return "BE_SQLITE_IOERR_SHMLOCK";
            case 5386 /* BE_SQLITE_IOERR_SHMMAP */: return "BE_SQLITE_IOERR_SHMMAP";
            case 5642 /* BE_SQLITE_IOERR_SEEK */: return "BE_SQLITE_IOERR_SEEK";
            case 5898 /* BE_SQLITE_IOERR_DELETE_NOENT */: return "BE_SQLITE_IOERR_DELETE_NOENT";
            case 16777226 /* BE_SQLITE_ERROR_FileExists */: return "File Exists";
            case 33554442 /* BE_SQLITE_ERROR_AlreadyOpen */: return "Already Open";
            case 50331658 /* BE_SQLITE_ERROR_NoPropertyTable */: return "No Property Table";
            case 67108874 /* BE_SQLITE_ERROR_FileNotFound */: return "File Not Found";
            case 83886090 /* BE_SQLITE_ERROR_NoTxnActive */: return "No Txn Active";
            case 100663306 /* BE_SQLITE_ERROR_BadDbProfile */: return "Bad Db Profile";
            case 117440522 /* BE_SQLITE_ERROR_InvalidProfileVersion */: return "Invalid Profile Version";
            case 134217738 /* BE_SQLITE_ERROR_ProfileUpgradeFailed */: return "Profile Upgrade Failed";
            case 150994954 /* BE_SQLITE_ERROR_ProfileTooOldForReadWrite */: return "Profile Too Old For ReadWrite";
            case 167772170 /* BE_SQLITE_ERROR_ProfileTooOld */: return "Profile Too Old";
            case 184549386 /* BE_SQLITE_ERROR_ProfileTooNewForReadWrite */: return "Profile Too New For ReadWrite";
            case 201326602 /* BE_SQLITE_ERROR_ProfileTooNew */: return "Profile Too New";
            case 218103818 /* BE_SQLITE_ERROR_ChangeTrackError */: return "ChangeTrack Error";
            case 234881034 /* BE_SQLITE_ERROR_InvalidChangeSetVersion */: return "Invalid ChangeSet Version";
            case 251658250 /* BE_SQLITE_ERROR_SchemaUpgradeRequired */: return "Schema Upgrade Required";
            case 268435466 /* BE_SQLITE_ERROR_SchemaTooNew */: return "Schema Too New";
            case 285212682 /* BE_SQLITE_ERROR_SchemaTooOld */: return "Schema Too Old";
            case 301989898 /* BE_SQLITE_ERROR_SchemaLockFailed */: return "Schema Lock Failed";
            case 318767114 /* BE_SQLITE_ERROR_SchemaUpgradeFailed */: return "Schema Upgrade Failed";
            case 335544330 /* BE_SQLITE_ERROR_SchemaImportFailed */: return "Schema Import Failed";
            case 352321546 /* BE_SQLITE_ERROR_CouldNotAcquireLocksOrCodes */: return "Could Not Acquire Locks Or Codes";
            case 262 /* BE_SQLITE_LOCKED_SHAREDCACHE */: return "BE_SQLITE_LOCKED_SHAREDCACHE";
            case 261 /* BE_SQLITE_BUSY_RECOVERY */: return "BE_SQLITE_BUSY_RECOVERY";
            case 270 /* BE_SQLITE_CANTOPEN_NOTEMPDIR */: return "SQLite No Temp Dir";
            case 526 /* BE_SQLITE_CANTOPEN_ISDIR */: return "BE_SQLITE_CANTOPEN_ISDIR";
            case 782 /* BE_SQLITE_CANTOPEN_FULLPATH */: return "BE_SQLITE_CANTOPEN_FULLPATH";
            case 267 /* BE_SQLITE_CORRUPT_VTAB */: return "BE_SQLITE_CORRUPT_VTAB";
            case 264 /* BE_SQLITE_READONLY_RECOVERY */: return "BE_SQLITE_READONLY_RECOVERY";
            case 520 /* BE_SQLITE_READONLY_CANTLOCK */: return "BE_SQLITE_READONLY_CANTLOCK";
            case 776 /* BE_SQLITE_READONLY_ROLLBACK */: return "BE_SQLITE_READONLY_ROLLBACK";
            case 516 /* BE_SQLITE_ABORT_ROLLBACK */: return "BE_SQLITE_ABORT_ROLLBACK";
            case 275 /* BE_SQLITE_CONSTRAINT_CHECK */: return "BE_SQLITE_CONSTRAINT_CHECK";
            case 531 /* BE_SQLITE_CONSTRAINT_COMMITHOOK */: return "CommitHook Constraint Error";
            case 787 /* BE_SQLITE_CONSTRAINT_FOREIGNKEY */: return "Foreign Key Constraint Error";
            case 1043 /* BE_SQLITE_CONSTRAINT_FUNCTION */: return "Function Constraint Error";
            case 1299 /* BE_SQLITE_CONSTRAINT_NOTNULL */: return "NotNull Constraint Error";
            case 1555 /* BE_SQLITE_CONSTRAINT_PRIMARYKEY */: return "Primary Key Constraint Error";
            case 1811 /* BE_SQLITE_CONSTRAINT_TRIGGER */: return "Trigger Constraint Error";
            case 2067 /* BE_SQLITE_CONSTRAINT_UNIQUE */: return "Unique Constraint Error";
            case 2323 /* BE_SQLITE_CONSTRAINT_VTAB */: return "VTable Constraint Error";
            // BentleyStatus cases
            case 32768 /* ERROR */: return "Error";
            // BriefcaseStatus
            case 131072 /* CannotAcquire */: return "CannotAcquire";
            case 131073 /* CannotDownload */: return "CannotDownload";
            case 131075 /* CannotCopy */: return "CannotCopy";
            case 131076 /* CannotDelete */: return "CannotDelete";
            case 131077 /* VersionNotFound */: return "VersionNotFound";
            // ChangeSetStatus
            case 90113 /* ApplyError */: return "Error applying a change set when reversing or reinstating it";
            case 90114 /* ChangeTrackingNotEnabled */: return "Change tracking has not been enabled. The ChangeSet API mandates this";
            case 90115 /* CorruptedChangeStream */: return "Contents of the change stream are corrupted and does not match the ChangeSet";
            case 90116 /* FileNotFound */: return "File containing the changes to the change set is not found";
            case 90117 /* FileWriteError */: return "Error writing the contents of the change set to the backing change stream file";
            case 90118 /* HasLocalChanges */: return "Cannot perform the operation since the Db has local changes";
            case 90119 /* HasUncommittedChanges */: return "Cannot perform the operation since current transaction has uncommitted changes";
            case 90120 /* InvalidId */: return "Invalid ChangeSet Id";
            case 90121 /* InvalidVersion */: return "Invalid version of the change set";
            case 90122 /* InDynamicTransaction */: return "Cannot perform the operation since system is in the middle of a dynamic transaction";
            case 90123 /* IsCreatingChangeSet */: return "Cannot perform operation since system is in the middle of a creating a change set";
            case 90124 /* IsNotCreatingChangeSet */: return "Cannot perform operation since the system is not creating a change set";
            case 90125 /* MergePropagationError */: return "Error propagating the changes after the merge";
            case 90126 /* NothingToMerge */: return "No change sets to merge";
            case 90127 /* NoTransactions */: return "No transactions are available to create a change set";
            case 90128 /* ParentMismatch */: return "Parent change set of the Db does not match the parent id of the change set";
            case 90129 /* SQLiteError */: return "Error performing a SQLite operation on the Db";
            case 90130 /* WrongDgnDb */: return "ChangeSet originated in a different Db";
            case 90131 /* CouldNotOpenDgnDb */: return "Could not open the DgnDb to merge change set";
            case 90132 /* MergeSchemaChangesOnOpen */: return "Cannot merge changes in in an open DgnDb. Close the DgnDb, and process the operation when it is opened";
            case 90133 /* ReverseOrReinstateSchemaChangesOnOpen */: return "Cannot reverse or reinstate schema changes in an open DgnDb. Close the DgnDb, and process the operation when it is opened";
            case 90134 /* ProcessSchemaChangesOnOpen */: return "Cannot process changes schema changes in an open DgnDb. Close the DgnDb, and process the operation when it is opened";
            case 90135 /* CannotMergeIntoReadonly */: return "Cannot merge changes into a Readonly DgnDb";
            case 90136 /* CannotMergeIntoMaster */: return "Cannot merge changes into a Master DgnDb";
            case 90137 /* CannotMergeIntoReversed */: return "Cannot merge changes into a DgnDb that has reversed change sets";
            // RepositoryStatus
            case 86017 /* ServerUnavailable */: return "ServerUnavailable";
            case 86018 /* LockAlreadyHeld */: return "LockAlreadyHeld";
            case 86019 /* SyncError */: return "SyncError";
            case 86020 /* InvalidResponse */: return "InvalidResponse";
            case 86021 /* PendingTransactions */: return "PendingTransactions";
            case 86022 /* LockUsed */: return "LockUsed";
            case 86023 /* CannotCreateChangeSet */: return "CannotCreateChangeSet";
            case 86024 /* InvalidRequest */: return "InvalidRequest";
            case 86025 /* ChangeSetRequired */: return "ChangeSetRequired";
            case 86026 /* CodeUnavailable */: return "CodeUnavailable";
            case 86027 /* CodeNotReserved */: return "CodeNotReserved";
            case 86028 /* CodeUsed */: return "CodeUsed";
            case 86029 /* LockNotHeld */: return "LockNotHeld";
            case 86030 /* RepositoryIsLocked */: return "RepositoryIsLocked";
            // HTTP Status
            case 94209 /* Info */: return "HTTP Info";
            case 94210 /* Redirection */: return "HTTP Redirection";
            case 94211 /* ClientError */: return "HTTP Client error";
            case 94212 /* ServerError */: return "HTTP Server error";
            // WSStatus
            case 98305 /* Unknown */: return "Unknown error";
            case 98311 /* ClassNotFound */: return "Class not found";
            case 98314 /* FileNotFound */: return "File not found";
            case 98313 /* InstanceNotFound */: return "Instance not found";
            case 98306 /* LoginFailed */: return "Login failed";
            case 98317 /* NoClientLicense */: return "No client license";
            case 98316 /* NoServerLicense */: return "No server license";
            case 98308 /* NotEnoughRights */: return "Not enough rights";
            case 98315 /* NotSupported */: return "Not supported";
            case 98312 /* PropertyNotFound */: return "Property not found";
            case 98309 /* RepositoryNotFound */: return "Repository not found";
            case 98310 /* SchemaNotFound */: return "Schema not found";
            case 98307 /* SslRequired */: return "SSL required";
            case 98318 /* TooManyBadLoginAttempts */: return "Too many bad login attempts";
            // IModelHubStatus
            case IModelHubStatus.Unknown: return "Unknown error";
            case IModelHubStatus.MissingRequiredProperties: return "Missing required properties";
            case IModelHubStatus.InvalidPropertiesValues: return "Invalid properties values";
            case IModelHubStatus.UserDoesNotHavePermission: return "User does not have permission";
            case IModelHubStatus.InvalidBriefcase: return "Invalid briefcase";
            case IModelHubStatus.BriefcaseDoesNotExist: return "Briefcase does not exist";
            case IModelHubStatus.BriefcaseDoesNotBelongToUser: return "Briefcase does not belong to user";
            case IModelHubStatus.AnotherUserPushing: return "Another user pushing";
            case IModelHubStatus.ChangeSetAlreadyExists: return "ChangeSet already exists";
            case IModelHubStatus.ChangeSetDoesNotExist: return "ChangeSet does not exist";
            case IModelHubStatus.FileIsNotUploaded: return "File is not uploaded";
            case IModelHubStatus.iModelIsNotInitialized: return "iModel is not initialized";
            case IModelHubStatus.ChangeSetPointsToBadSeed: return "ChangeSet points to a bad seed file";
            case IModelHubStatus.iModelHubOperationFailed: return "iModelHub operation failed";
            case IModelHubStatus.PullIsRequired: return "Pull is required";
            case IModelHubStatus.MaximumNumberOfBriefcasesPerUser: return "Limit of briefcases per user was reached";
            case IModelHubStatus.MaximumNumberOfBriefcasesPerUserPerMinute: return "Limit of briefcases per user per minute was reached";
            case IModelHubStatus.DatabaseTemporarilyLocked: return "Database is temporarily locked";
            case IModelHubStatus.iModelAlreadyExists: return "iModel already exists";
            case IModelHubStatus.iModelDoesNotExist: return "iModel does not exist";
            case IModelHubStatus.LockDoesNotExist: return "Lock does not exist";
            case IModelHubStatus.LocksExist: return "Lock already exists";
            case IModelHubStatus.LockOwnedByAnotherBriefcase: return "Lock is owned by another briefcase";
            case IModelHubStatus.UserAlreadyExists: return "User already exists";
            case IModelHubStatus.UserDoesNotExist: return "User does not exist";
            case IModelHubStatus.CodeStateInvalid: return "Code state is invalid";
            case IModelHubStatus.CodeReservedByAnotherBriefcase: return "Code is reserved by another briefcase";
            case IModelHubStatus.CodeDoesNotExist: return "Code does not exist";
            case IModelHubStatus.CodesExist: return "Code already exists";
            case IModelHubStatus.FileDoesNotExist: return "File does not exist";
            case IModelHubStatus.FileAlreadyExists: return "File already exists";
            case IModelHubStatus.iModelIsLocked: return "iModel is locked";
            case IModelHubStatus.EventTypeDoesNotExist: return "Event type does not exist";
            case IModelHubStatus.EventSubscriptionDoesNotExist: return "Event subscription does not exist";
            case IModelHubStatus.EventSubscriptionAlreadyExists: return "Event subscription already exists";
            case IModelHubStatus.ProjectAssociationIsNotEnabled: return "Project association is not enabled";
            case IModelHubStatus.ProjectIdIsNotSpecified: return "Project Id is not specified";
            case IModelHubStatus.FailedToGetProjectPermissions: return "Failed to get project permissions";
            case IModelHubStatus.ChangeSetAlreadyHasVersion: return "ChangeSet already has version";
            case IModelHubStatus.VersionAlreadyExists: return "Version already exists";
            case IModelHubStatus.QueryIdsNotSpecified: return "Query Id is not specified";
            case IModelHubStatus.ConflictsAggregate: return "Codes or locks are owned by another briefcase";
            /** Id for errors that are returned for incorrect iModel Hub request. */
            case IModelHubStatus.UndefinedArgumentError: return "Undefined argument";
            case IModelHubStatus.InvalidArgumentError: return "Invalid argument";
            case IModelHubStatus.MissingDownloadUrlError: return "Missing download url";
            case IModelHubStatus.NotSupportedInBrowser: return "Not supported in browser";
            case IModelHubStatus.FileHandlerNotSet: return "File handler is not set";
            case IModelHubStatus.FileNotFound: return "File not found";
            // Unexpected cases
            case 0 /* Success */:
            case 0 /* BE_SQLITE_OK */:
            case 100 /* BE_SQLITE_ROW */:
            case 101 /* BE_SQLITE_DONE */:
            case 0 /* SUCCESS */:
                return "Success";
            default:
                return "Error (" + this.errorNumber + ")";
        }
    }
}
exports.BentleyError = BentleyError;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

exports.arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

exports.isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/** Function for disposing of a disposable object that may be undefined. */
function dispose(disposable) {
    if (undefined !== disposable)
        disposable.dispose();
    return undefined;
}
exports.dispose = dispose;
/** A 'using' function which is a substitution for .NET's using statement. It makes sure that 'dispose'
 * is called on the resource no matter if the func returns or throws. If func returns, the return value
 * of this function is equal to return value of func. If func throws, this function also throws (after
 * disposing the resource).
 */
function using(resources, func) {
    if (!Array.isArray(resources))
        return using([resources], func);
    const doDispose = () => resources.forEach((disposable) => disposable.dispose());
    let shouldDisposeImmediately = true;
    try {
        const result = func.apply(undefined, resources);
        if (result && result.then) {
            shouldDisposeImmediately = false;
            result.then(doDispose, doDispose);
        }
        return result;
    }
    finally {
        if (shouldDisposeImmediately)
            doDispose();
    }
}
exports.using = using;
class FuncDisposable {
    constructor(disposeFunc) { this._disposeFunc = disposeFunc; }
    dispose() { this._disposeFunc(); }
}
/** A disposable container of disposable objects. */
class DisposableList {
    /** Creates a disposable list. */
    constructor(disposables = []) {
        this._disposables = [];
        disposables.forEach((disposable) => {
            this.add(disposable);
        });
    }
    isDisposable(x) {
        return x.dispose !== undefined;
    }
    /** Register an object for disposal. */
    add(disposable) {
        if (this.isDisposable(disposable))
            this._disposables.push(disposable);
        else
            this._disposables.push(new FuncDisposable(disposable));
    }
    /** Unregister disposable object. */
    remove(disposable) {
        const idx = this._disposables.indexOf(disposable);
        if (-1 !== idx)
            this._disposables.splice(idx, 1);
    }
    /** Disposes all registered objects. */
    dispose() {
        for (const disposable of this._disposables)
            disposable.dispose();
    }
}
exports.DisposableList = DisposableList;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Ids */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A 64 bit Id, stored as a hex string. This is necessary since JavaScript does not intrinsically support 64-bit integers.
 * @note If invalid, value will be "0".
 * @note Id64 is an immutable class. Its value cannot be changed.
 */
class Id64 {
    /**
     * Constructor for Id64
     * @param prop either a string with a hex number, another Id64, or an array of two numbers with [low,high]. Otherwise result will be invalid.
     * @note If valid, the value will be *normalized* to always be in the form "0x123abc". That is, it will
     * only have lowercase letters, with no leading zeros after the "0x"
     */
    constructor(prop) {
        if (!prop) {
            this.value = "0";
            return;
        }
        let low = 0;
        let high = 0;
        if (typeof prop === "string") {
            prop = prop.toLowerCase().trim();
            if (prop[0] !== "0" || !(prop[1] === "x")) {
                this.value = "0";
                return;
            }
            let start = 2;
            const len = prop.length;
            if (len > 12) {
                start = (len - 10);
                high = Id64.toHex(prop.slice(2, start));
            }
            low = Id64.toHex(prop.slice(start));
        }
        else if (prop instanceof Id64) {
            this.value = prop.value;
            return;
        }
        if (Array.isArray(prop) && prop.length >= 2 && "number" === typeof prop[0] && "number" === typeof prop[1]) {
            low = Math.floor(prop[0]);
            high = Math.floor(prop[1]);
        }
        if (low === 0) {
            this.value = "0";
            return;
        }
        const lowStr = low.toString(16).toLowerCase();
        this.value = "0x" + ((high === 0) ? lowStr : (high.toString(16).toLowerCase() + ("0000000000" + lowStr).substr(-10)));
    }
    static toHex(str) { const v = parseInt(str, 16); return Number.isNaN(v) ? 0 : v; }
    toJSON() { return this.value; }
    /** get the "low" part of this Id64. This is the "local id", and is the lower 40 bits of the 64 bit value. */
    getLow() {
        if (!this.isValid())
            return 0;
        let start = 2;
        const len = this.value.length;
        if (len > 12)
            start = (len - 10);
        return Id64.toHex(this.value.slice(start));
    }
    /** Get the "high" part of this Id64. This is the "briefcase id", and is the high 24 bits of the 64 bit value. */
    getHigh() {
        if (!this.isValid())
            return 0;
        let start = 2;
        const len = this.value.length;
        if (len <= 12)
            return 0;
        start = (len - 10);
        return Id64.toHex(this.value.slice(2, start));
    }
    /** Convert this Id64 to a string */
    toString() { return this.value; }
    /** Determine whether this Id64 is valid.
     * @note The value of an invalid Id64 is "0".
     */
    isValid() { return this.value !== "0"; }
    /** Test whether two Id64s are the same
     * @param other the other Id64 to compare
     */
    equals(other) { return this.value === other.value; }
    /** Compare two (potentially undefined) Id64 values.
     * @param a The first value, may be undefined
     * @param b The second value, may be undefined
     */
    static areEqual(a, b) { return (a === b) || (a !== undefined && b !== undefined && a.equals(b)); }
    /** Create an Id64 from a json object. If val is already an Id64, just return it since Id64s are immutable.
     * @param val the json object containing Id64Props. If val does not contain valid values, result will be an invalid Id64.
     */
    static fromJSON(val) { return val instanceof Id64 ? val : new Id64(val); }
    /** Create an Id64 from a pair of unsigned 32-bit integers.
     * @param lowBytes The lower 4 bytes of the ID
     * @param highBytes The upper 4 bytes of the ID
     * @returns an Id64 containing the hexadecimal string representation of the unsigned 64-bit integer which would result from the
     * operation lowBytes | (highBytes << 32).
     */
    static fromUint32Pair(lowBytes, highBytes) {
        const localIdLow = lowBytes >>> 0;
        const localIdHigh = (highBytes & 0x000000ff) * (0xffffffff + 1); // aka (highBytes & 0xff) << 32
        const localId = localIdLow + localIdHigh; // aka localIdLow | localIdHigh
        const briefcaseId = (highBytes & 0xffffff00) >>> 8;
        return new Id64([localId, briefcaseId]);
    }
    /** Extract an unsigned 32-bit integer from the low 4 bytes of an Id64's value.
     * @returns the unsigned 32-bit integer value stored in the id's lower 4 bytes
     */
    getLowUint32() {
        if (!this.isValid())
            return 0;
        let start = 2;
        const len = this.value.length;
        if (len > 10)
            start = len - 8;
        return Id64.toHex(this.value.slice(start));
    }
    /** Extract an unsigned 32-bit integer from the high 4 bytes of an Id64's value.
     * @returns the unsigned 32-bit integer value stored in the id's upper 4 bytes
     */
    getHighUint32() {
        if (!this.isValid())
            return 0;
        const len = this.value.length;
        if (len <= 10)
            return 0;
        const start = len - 8;
        return Id64.toHex(this.value.slice(2, start));
    }
    /** Convert an Id64Arg into an Id64Set.
     * This method can be used by functions that accept an Id64Arg to conveniently process the value(s).
     *
     * For example:
     * ```ts
     *   public addCategories(arg: Id64Arg) { Id64.toIdSet(arg).forEach((id) => this.categories.add(id)); }
     * ```
     */
    static toIdSet(arg) {
        if (arg instanceof Set)
            return arg;
        const ids = new Set();
        if (typeof arg === "string")
            ids.add(arg);
        else if (arg instanceof Id64)
            ids.add(arg.value);
        else if (Array.isArray(arg)) {
            if (arg.length > 0) {
                (typeof arg[0] === "string") ? arg.forEach((id) => ids.add(id)) : arg.forEach((id) => ids.add(id.value));
            }
        }
        return ids;
    }
}
/** Obtain an Id64 instance with an invalid value. */
Id64.invalidId = new Id64();
exports.Id64 = Id64;
/**
 * Generates unique Id64 values in sequence, which are guaranteed not to conflict with Id64s associated with persistent elements or models.
 * This is useful for associating stable, non-persistent identifiers with things like view decorations.
 * A TransientIdSequence can generate a maximum of (2^40)-2 unique IDs.
 */
class TransientIdSequence {
    constructor() {
        this._localId = 0;
    }
    /** Generate and return the next transient Id64 in the sequence. */
    get next() { return new Id64([++this._localId, 0xffffffff]); }
}
exports.TransientIdSequence = TransientIdSequence;
/** A string in the "8-4-4-4-12" pattern. Does not enforce that the Guid is a valid v4 format uuid.
 * @note Guid is an immutable class. Its value cannot be changed.
 */
class Guid {
    /** construct  */
    constructor(input) {
        if (typeof input === "string") {
            this.value = input.toLowerCase();
            if (Guid.isGuid(this.value))
                return;
        }
        if (input instanceof Guid) {
            this.value = input.value;
            return;
        }
        if (typeof input === "boolean") {
            if (input) {
                this.value = Guid.createValue();
                return;
            }
        }
        this.value = "";
    }
    equals(other) { return this.value === other.value; }
    isValid() { return this.value !== ""; }
    toString() { return this.value; }
    toJSON() { return this.value; }
    static fromJSON(val) { return val ? new Guid(val) : undefined; }
    /** determine whether the input string is "guid-like". That is, it follows the 8-4-4-4-12 pattern. This does not enforce
     *  that the string is actually in valid UUID format.
     */
    static isGuid(value) { return Guid.uuidPattern.test(value); }
    /** determine whether the input string is a valid V4 Guid string */
    static isV4Guid(value) { return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(value); }
    static randomCharFrom(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    /** Create a new V4 Guid value */
    static createValue() {
        return [
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            "-",
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            "-",
            "4",
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            "-",
            Guid.randomCharFrom(Guid.v4VariantChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            "-",
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
            Guid.randomCharFrom(Guid.hexChars),
        ].join("");
    }
}
Guid.uuidPattern = new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$");
Guid.hexChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
Guid.v4VariantChars = ["8", "9", "a", "b"];
exports.Guid = Guid;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/** Utility functions for converting from JSON objects, with default values. */
var JsonUtils;
(function (JsonUtils) {
    /** Get a value as a boolean.
     * @param json the input JSON object
     * @param defaultVal default value if json cannot be converted to boolean
     * @returns the value of json as a boolean, or default value
     */
    function asBool(json, defaultVal = false) { return isNullOrUndefined(json) ? defaultVal : !!json; }
    JsonUtils.asBool = asBool;
    /** Get a value as an integer.
     * @param json the input JSON object
     * @param defaultVal default value if json cannot be converted to integer
     * @returns the value of json as an integer, or default value
     */
    function asInt(json, defaultVal = 0) { return (typeof json === "number") ? Math.trunc(json) : defaultVal; }
    JsonUtils.asInt = asInt;
    /** Get a value as a double.
     * @param json the input JSON object
     * @param defaultVal default value if json cannot be converted to double
     * @returns the value of json as a double, or default value
     */
    function asDouble(json, defaultVal = 0) { return (typeof json === "number") ? json : defaultVal; }
    JsonUtils.asDouble = asDouble;
    /** Get a value as a string.
     * @param json the input JSON object
     * @param defaultVal default value if json cannot be converted to string
     * @returns the value of json as a string, or default value
     */
    function asString(json, defaultVal = "") { return isNullOrUndefined(json) ? defaultVal : json.toString(); }
    JsonUtils.asString = asString;
    /** Get a value as an array.
     * @param json the input JSON object
     * @returns the input JSON object if it is an array, otherwise undefined
     */
    function asArray(json) { return Array.isArray(json) ? json : undefined; }
    JsonUtils.asArray = asArray;
    /** Get a value as an object.
     * @param json the input JSON object
     * @returns the input JSON object if it is an object, otherwise undefined
     */
    function asObject(json) { return "object" === typeof json ? json : undefined; }
    JsonUtils.asObject = asObject;
    /** Set or remove a number on a json object, given a key name, a value, and a default value. Sets `json[key] = val` if val is *not* equal to the default,
     * otherwise `delete json[key]`. This is used to omit values from JSON strings that are of known defaults.
     * @param json the JSON object to affect
     * @param key the name of the member to set or remove
     * @param val the value to set
     * @param defaultVal the default value.
     */
    function setOrRemoveNumber(json, key, val, defaultVal) { if (val === defaultVal)
        delete json[key];
    else
        json[key] = val; }
    JsonUtils.setOrRemoveNumber = setOrRemoveNumber;
    /** Set or remove a boolean on a json object, given a key name, a value, and a default value. Sets `json[key] = val` if val is *not* equal to the default,
     * otherwise `delete json[key]`. This is used to omit values from JSON strings that are of known defaults.
     * @param json the JSON object to affect
     * @param key the name of the member to set or remove
     * @param val the value to set
     * @param defaultVal the default value.
     */
    function setOrRemoveBoolean(json, key, val, defaultVal) { if (val === defaultVal)
        delete json[key];
    else
        json[key] = val; }
    JsonUtils.setOrRemoveBoolean = setOrRemoveBoolean;
    function isNullOrUndefined(json) { return null === json || undefined === json; }
    /**
     * Convert the input object into a "pure" JavaScript object, with only instances of "object" or primitives in the returned value.
     * Works recursively for object members, and over arrays entries. Calls "toJSON" on any members that implement it.
     */
    function toObject(val) {
        if (typeof val === "boolean" || typeof val === "number" || typeof val === "string")
            return val;
        if (typeof val !== "object")
            return undefined;
        // See if the object has toJSON() function defined.
        if (typeof val.toJSON !== "undefined")
            return toObject(val.toJSON());
        // if it's an array, convert each member.
        if (Array.isArray(val)) {
            const arr = new Array(val.length);
            val.forEach((el, i) => { arr[i] = toObject(el); });
            return arr;
        }
        // Convert each property
        const out = {};
        Object.getOwnPropertyNames(val).forEach((prop) => {
            const transformVal = toObject(val[prop]);
            if (transformVal !== undefined)
                out[prop] = transformVal;
        });
        return out;
    }
    JsonUtils.toObject = toObject;
})(JsonUtils = exports.JsonUtils || (exports.JsonUtils = {}));


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/** A duration of time. Can be either positive (towards future) or negative (in the past).
 * BeDurations are immutable.
 */
class BeDuration {
    constructor(milliseconds = 0) { this._milliseconds = milliseconds; }
    /** The duration in milliseconds */
    get milliseconds() { return this._milliseconds; }
    get seconds() { return this._milliseconds / 1000; }
    /** Create a BeDuration from seconds.
     * @param seconds the number of seconds for this BeDuration
     */
    static fromSeconds(seconds) { return new BeDuration(seconds * 1000); }
    /** Create a BeDuration from milliseconds.
     * @param milliseconds the number of milliseconds for this BeDuration
     */
    static fromMilliseconds(milliseconds) { return new BeDuration(milliseconds); }
    /** Determine whether this BeDuration is 0 seconds */
    isZero() { return this._milliseconds === 0; }
    /** Determine whether this BeDuration is towards the future */
    isTowardsFuture() { return this._milliseconds > 0; }
    /** Determine whether this BeDuration is towards the past */
    isTowardsPast() { return this._milliseconds < 0; }
    /** Subtract a BeDuration from this BeDuration, returning a new BeDuration. */
    minus(other) { return new BeDuration(this._milliseconds - other._milliseconds); }
    /** Add a BeDuration to this BeDuration, returning a new BeDuration */
    plus(other) { return new BeDuration(this._milliseconds + other._milliseconds); }
}
exports.BeDuration = BeDuration;
/** A specific point in time relative to the current time.
 * BeTimePoints are used for timing operations. They are created from a BeDuration relative to the "now".
 * BeTimePoints are immutable.
 */
class BeTimePoint {
    /** the time in milliseconds, of this BeTimePoint (relative to January 1, 1970 00:00:00 UTC.) */
    get milliseconds() { return this._milliseconds; }
    constructor(milliseconds) { this._milliseconds = milliseconds; }
    /** Create a BeTimePoint from Date.now() */
    static now() { return new BeTimePoint(Date.now()); }
    /** Create a BeTimePoint at a specified duration in the future from now
     *  @param val the duration from now
     */
    static fromNow(val) { return new BeTimePoint(Date.now() + val.milliseconds); }
    /** Create a BeTimePoint at a specified duration in the past before now
     * @param val the duration before now
     */
    static beforeNow(val) { return new BeTimePoint(Date.now() - val.milliseconds); }
    /** Determine whether this BeTimePoint is a time in the future from the time this method is called (it calls now()!) */
    isInFuture() { return Date.now() < this._milliseconds; }
    /** Determine whether this BeTimePoint is a time that has already passed before the time this method is called (it calls now()!) */
    isInPast() { return Date.now() > this._milliseconds; }
    /** Determine whether this BeTimePoint happens before another one.
     * @param other the other BeTimePoint.
     */
    before(other) { return this._milliseconds < other._milliseconds; }
    /** Determine whether this BeTimePoint happens after another one.
     * @param other the other BeTimePoint.
     */
    after(other) { return this._milliseconds > other._milliseconds; }
    /** Subtract a BeDuration from this BeTimePoint, returning a new BeTimePoint. This moves this BeTimePoint backwards in time if BeDuration.isTowardsFuture() === true
     * @param duration the duration to subtract.
     */
    minus(duration) { return new BeTimePoint(this._milliseconds - duration.milliseconds); }
    /** Subtract a BeDuration from this BeTimePoint, returning a new BeTimePoint. This moves this BeTimePoint backwards in time if BeDuration.isTowardsFuture() === true
     * @param duration the duration to subtract.
     */
    plus(duration) { return new BeTimePoint(this._milliseconds + duration.milliseconds); }
}
exports.BeTimePoint = BeTimePoint;
/** A StopWatch for timing operations. */
class StopWatch {
    /** ctor for StopWatch
     * @param description optional string stored with the StopWatch
     * @param startImmediately if true, StopWatch is started when created. Otherwise, call start() explicitly.
     */
    constructor(description, startImmediately = false) {
        this.description = description;
        if (startImmediately)
            this.start();
    }
    /** Get the elapsed time since start() on a running timer. */
    get current() { return BeDuration.fromMilliseconds(BeTimePoint.now().milliseconds - (!!this._start ? this._start.milliseconds : 0)); }
    /** Get the elapsed time, in seconds, since start() on a running timer. */
    get currentSeconds() { return this.current.seconds; }
    /** Get the elapsed time between start() and stop() on this timer. */
    get elapsed() { return BeDuration.fromMilliseconds((!!this._stop ? this._stop.milliseconds : BeTimePoint.now().milliseconds) - (!!this._start ? this._start.milliseconds : 0)); }
    /** Get the elapsed time, in seconds, between start() and stop() on this  timer. */
    get elapsedSeconds() { return this.elapsed.seconds; }
    /** Start the stopwatch. Any future time measurements will be based on this new value. */
    start() { this.reset(); this._start = BeTimePoint.now(); }
    /** Stop the stopwatch so that the duration can be viewed later. */
    stop() { this._stop = BeTimePoint.now(); return this.elapsed; }
    /** Clear the StopWatch */
    reset() { this._start = this._stop = undefined; }
}
exports.StopWatch = StopWatch;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const xpath = __webpack_require__(167);
const xmldom_1 = __webpack_require__(168);
const js_base64_1 = __webpack_require__(274);
/** Token base class */
class Token {
    constructor(samlAssertion) {
        this.samlAssertion = samlAssertion;
    }
    getSamlAssertion() {
        return this.samlAssertion;
    }
    getUserProfile() {
        return this.userProfile;
    }
    getExpiresAt() {
        return this.expiresAt;
    }
    getStartsAt() {
        return this.startsAt;
    }
    parseSamlAssertion() {
        if (!this.samlAssertion)
            return false;
        const select = xpath.useNamespaces({
            ds: "http://www.w3.org/2000/09/xmldsig#",
            saml: "urn:oasis:names:tc:SAML:1.0:assertion",
        });
        const dom = (new xmldom_1.DOMParser()).parseFromString(this.samlAssertion);
        this.x509Certificate = select("/saml:Assertion/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate/text()", dom).toString();
        const startsAtStr = select("string(/saml:Assertion/saml:Conditions/@NotBefore)", dom).toString();
        this.startsAt = new Date(startsAtStr);
        const expiresAtStr = select("string(/saml:Assertion/saml:Conditions/@NotOnOrAfter)", dom).toString();
        const extractAttribute = (attributeName) => select("/saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='" +
            attributeName + "']/saml:AttributeValue/text()", dom).toString();
        this.userProfile = {
            firstName: extractAttribute("givenname"),
            lastName: extractAttribute("surname"),
            email: extractAttribute("emailaddress"),
            userId: extractAttribute("userid"),
            organization: extractAttribute("organization"),
        };
        this.startsAt = new Date(startsAtStr);
        this.expiresAt = new Date(expiresAtStr);
        return !!this.x509Certificate && !!this.startsAt && !!this.expiresAt && !!this.userProfile;
    }
}
exports.Token = Token;
/** Token issued by Active Secure Token Service or Federated Authentication Service for user authentication/authorization  */
class AuthorizationToken extends Token {
    static fromSamlAssertion(samlAssertion) {
        const token = new AuthorizationToken(samlAssertion);
        return token.parseSamlAssertion() ? token : undefined;
    }
    toTokenString() {
        if (!this.x509Certificate)
            return undefined;
        return "X509 access_token=" + Buffer.from(this.x509Certificate, "utf8").toString("base64");
    }
    static clone(unTypedObj) {
        const authToken = new AuthorizationToken(unTypedObj.samlAssertion);
        Object.assign(authToken, unTypedObj);
        return authToken;
    }
}
exports.AuthorizationToken = AuthorizationToken;
/** Token issued by DelegationSecureTokenService for API access  */
class AccessToken extends Token {
    static fromSamlAssertion(samlAssertion) {
        const token = new AccessToken(samlAssertion);
        return token.parseSamlAssertion() ? token : undefined;
    }
    static fromForeignProjectAccessTokenJson(foreignJsonStr) {
        if (!foreignJsonStr.startsWith(`{\"${this.foreignProjectAccessTokenJsonProperty}\":`))
            return undefined;
        const props = JSON.parse(foreignJsonStr);
        if (props[this.foreignProjectAccessTokenJsonProperty] === undefined)
            return undefined;
        const tok = new AccessToken(foreignJsonStr);
        tok.userProfile = props[this.foreignProjectAccessTokenJsonProperty].userProfile;
        return tok;
    }
    static fromTokenString(accessTokenString) {
        const index = accessTokenString.toLowerCase().indexOf(AccessToken.tokenPrefix.toLowerCase());
        if (index < 0)
            return undefined;
        const extractedStr = accessTokenString.slice(6);
        if (!extractedStr)
            return undefined;
        // Need to replace the trailing \u0000 - see https://github.com/nodejs/node/issues/4775
        const samlStr = js_base64_1.Base64.atob(extractedStr).replace(/\0$/, "");
        if (!samlStr)
            return undefined;
        return AccessToken.fromSamlAssertion(samlStr);
    }
    toTokenString() {
        if (this.accessTokenString)
            return this.accessTokenString;
        if (!this.samlAssertion)
            return undefined;
        const tokenStr = js_base64_1.Base64.btoa(this.samlAssertion);
        return AccessToken.tokenPrefix + " " + tokenStr;
    }
    static fromJson(jsonObj) {
        const foreignTok = AccessToken.fromForeignProjectAccessTokenJson(jsonObj.samlAssertion);
        if (foreignTok !== undefined)
            return foreignTok;
        return AccessToken.fromSamlAssertion(jsonObj.samlAssertion);
    }
}
AccessToken.tokenPrefix = "Token";
AccessToken.foreignProjectAccessTokenJsonProperty = "ForeignProjectAccessToken";
exports.AccessToken = AccessToken;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer))

/***/ }),
/* 166 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the MIT License.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
var xpath = ( false) ? {} : exports;

(function(exports) {
"use strict";

// functional helpers
function curry( func ) {
    var slice = Array.prototype.slice,
        totalargs = func.length,
        partial = function( args, fn ) {
            return function( ) {
                return fn.apply( this, args.concat( slice.call( arguments ) ) );
            }
        },
        fn = function( ) {
            var args = slice.call( arguments );
            return ( args.length < totalargs ) ?
                partial( args, fn ) :
                func.apply( this, slice.apply( arguments, [ 0, totalargs ] ) );
        };
    return fn;
}

var forEach = curry(function (f, xs) {
	for (var i = 0; i < xs.length; i += 1) {
		f(xs[i], i, xs);
	}
});

var reduce = curry(function (f, seed, xs) {
	var acc = seed;

	forEach(function (x, i) { acc = f(acc, x, i); }, xs);

	return acc;
});

var map = curry(function (f, xs) { 
	var mapped = new Array(xs.length);
	
	forEach(function (x, i) { mapped[i] = f(x); }, xs);

	return mapped;
});

var filter = curry(function (f, xs) {
	var filtered = [];
	
	forEach(function (x, i) { if(f(x, i)) { filtered.push(x); } }, xs);
	
	return filtered;
});

function compose() {
    if (arguments.length === 0) { throw new Error('compose requires at least one argument'); }

    var funcs = Array.prototype.slice.call(arguments).reverse();
	
    var f0 = funcs[0];
    var fRem = funcs.slice(1);

    return function () {
        return reduce(function (acc, next) {
            return next(acc);
        }, f0.apply(null, arguments), fRem);
    };
}

var includes = curry(function (values, value) {
	for (var i = 0; i < values.length; i += 1) {
		if (values[i] === value){
			return true;
		}
	}
	
	return false;
});

function always(value) { return function () { return value ;} }

var prop = curry(function (name, obj) { return obj[name]; });

function toString (x) { return x.toString(); }
var join = curry(function (s, xs) { return xs.join(s); });
var wrap = curry(function (pref, suf, str) { return pref + str + suf; });

function assign(target) { // .length of function is 2
    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
            for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                }
            }
        }
    }

    return to;
}

// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return NodeTest.commentTest;
		} else if (rhs[0] == "text") {
			return NodeTest.textTest;
		} else if (rhs[0] == "processing-instruction") {
			return NodeTest.anyPiTest;
		} else if (rhs[0] == "node") {
			return NodeTest.nodeTest;
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest.PITest(rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, NodeTest.nodeTest, []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, NodeTest.nodeTest, []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return NodeTest.nameTestAny;
	};
	this.reduceActions[69] = function(rhs) {
		return new NodeTest.NameTestPrefixAny(rhs[0].split(':')[0]);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest.NameTestQName(rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
				literal += c;
                pos += 1;
			}
            if (c !== delimiter) {
                throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
            }
            pos += 1;
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

function setIfUnset(obj, prop, value) {
	if (!(prop in obj)) {
		obj[prop] = value;
	}
}

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;

	// [2017-11-25] Removed usage of .implementation.hasFeature() since it does
	//              not reliably detect HTML DOMs (always returns false in xmldom and true in browsers)
	if (c.isHtml) {
		setIfUnset(c, 'caseInsensitive', true);
		setIfUnset(c, 'allowAnyNamespaceForNoPrefix', true);
	}
	
    setIfUnset(c, 'caseInsensitive', false);

	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return map(toString, [this.lhs, this.rhs]).join(' | ');
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

/**
 * Returns the topmost node of the tree containing node
 */
function findRoot(node) {
    while (node && node.parentNode) {
        node = node.parentNode;
    }

    return node;
}

PathExpr.applyPredicates = function (predicates, c, nodes) {
	return reduce(function (inNodes, pred) {
		var ctx = c.extend({ contextSize: inNodes.length });
		
		return filter(function (node, i) {
			return PathExpr.predicateMatches(pred, ctx.extend({ contextNode: node, contextPosition: i + 1 }));
		}, inNodes);
	}, nodes, predicates);
};

PathExpr.getRoot = function (xpc, nodes) {
	var firstNode = nodes[0];
	
    if (firstNode.nodeType === 9 /*Node.DOCUMENT_NODE*/) {
		return firstNode;
	}
	
    if (xpc.virtualRoot) {
    	return xpc.virtualRoot;
    }
		
	var ownerDoc = firstNode.ownerDocument;
	
	if (ownerDoc) {
		return ownerDoc;
	}
			
    // IE 5.5 doesn't have ownerDocument?
    var n = firstNode;
    while (n.parentNode != null) {
    	n = n.parentNode;
    }
    return n;
}

PathExpr.applyStep = function (step, xpc, node) {
	var self = this;
	var newNodes = [];
    xpc.contextNode = node;
    
    switch (step.axis) {
    	case Step.ANCESTOR:
    		// look at all the ancestor nodes
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		var m;
    		if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
    			m = PathExpr.getOwnerElement(xpc.contextNode);
    		} else {
    			m = xpc.contextNode.parentNode;
    		}
    		while (m != null) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    			if (m === xpc.virtualRoot) {
    				break;
    			}
    			m = m.parentNode;
    		}
    		break;
    
    	case Step.ANCESTORORSELF:
    		// look at all the ancestor nodes and the current node
    		for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? PathExpr.getOwnerElement(m) : m.parentNode) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    			if (m === xpc.virtualRoot) {
    				break;
    			}
    		}
    		break;
    
    	case Step.ATTRIBUTE:
    		// look at the attributes
    		var nnm = xpc.contextNode.attributes;
    		if (nnm != null) {
    			for (var k = 0; k < nnm.length; k++) {
    				var m = nnm.item(k);
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    			}
    		}
    		break;
    
    	case Step.CHILD:
    		// look at all child elements
    		for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.DESCENDANT:
    		// look at all descendant nodes
    		var st = [ xpc.contextNode.firstChild ];
    		while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.DESCENDANTORSELF:
    		// look at self
    		if (step.nodeTest.matches(xpc.contextNode, xpc)) {
    			newNodes.push(xpc.contextNode);
    		}
    		// look at all descendant nodes
    		var st = [ xpc.contextNode.firstChild ];
    		while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.FOLLOWING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		var st = [];
    		if (xpc.contextNode.firstChild != null) {
    			st.unshift(xpc.contextNode.firstChild);
    		} else {
    			st.unshift(xpc.contextNode.nextSibling);
    		}
    		for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
    			st.unshift(m.nextSibling);
    		}
    		do {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		} while (st.length > 0);
    		break;
    
    	case Step.FOLLOWINGSIBLING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.NAMESPACE:
    		var n = {};
    		if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
    			n["xml"] = XPath.XML_NAMESPACE_URI;
    			n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
    			for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
    				for (var k = 0; k < m.attributes.length; k++) {
    					var attr = m.attributes.item(k);
    					var nm = String(attr.name);
    					if (nm == "xmlns") {
    						if (n[""] == undefined) {
    							n[""] = attr.value;
    						}
    					} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
    						var pre = nm.substring(6, nm.length);
    						if (n[pre] == undefined) {
    							n[pre] = attr.value;
    						}
    					}
    				}
    			}
    			for (var pre in n) {
    				var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
    				if (step.nodeTest.matches(nsn, xpc)) {
    					newNodes.push(nsn);
    				}
    			}
    		}
    		break;
    
    	case Step.PARENT:
    		m = null;
    		if (xpc.contextNode !== xpc.virtualRoot) {
    			if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
    				m = PathExpr.getOwnerElement(xpc.contextNode);
    			} else {
    				m = xpc.contextNode.parentNode;
    			}
    		}
    		if (m != null && step.nodeTest.matches(m, xpc)) {
    			newNodes.push(m);
    		}
    		break;
    
    	case Step.PRECEDING:
    		var st;
    		if (xpc.virtualRoot != null) {
    			st = [ xpc.virtualRoot ];
    		} else {
                // cannot rely on .ownerDocument because the node may be in a document fragment
                st = [findRoot(xpc.contextNode)];
    		}
    		outer: while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (m == xpc.contextNode) {
    					break outer;
    				}
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.unshift(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.PRECEDINGSIBLING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.SELF:
    		if (step.nodeTest.matches(xpc.contextNode, xpc)) {
    			newNodes.push(xpc.contextNode);
    		}
    		break;
    
    	default:
    }
	
	return newNodes;
};

PathExpr.applySteps = function (steps, xpc, nodes) {
	return reduce(function (inNodes, step) {
		return [].concat.apply([], map(function (node) {
			return PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));
		}, inNodes));
	}, nodes, steps);
}

PathExpr.prototype.applyFilter = function(c, xpc) {
	if (!this.filter) {
		return { nodes: [ c.contextNode ] };
	}
	
	var ns = this.filter.evaluate(c);

	if (!Utilities.instance_of(ns, XNodeSet)) {
        if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
		    throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
		}

		return { nonNodes: ns };
	}
	
	return { 
	    nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray())
	};
};

PathExpr.applyLocationPath = function (locationPath, xpc, nodes) {
	if (!locationPath) {
		return nodes;
	}
	
	var startNodes = locationPath.absolute ? [ PathExpr.getRoot(xpc, nodes) ] : nodes;
		
    return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
};

PathExpr.prototype.evaluate = function(c) {
	var xpc = assign(new XPathContext(), c);
	
    var filterResult = this.applyFilter(c, xpc);
	
	if ('nonNodes' in filterResult) {
		return filterResult.nonNodes;
	}	
	
	var ns = new XNodeSet();
	ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
	return ns;
};

PathExpr.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	
	return Utilities.instance_of(res, XNumber)
		? c.contextPosition == res.numberValue()
		: res.booleanValue();
};

PathExpr.predicateString = compose(wrap('[', ']'), toString);
PathExpr.predicatesString = compose(join(''), map(PathExpr.predicateString));

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var filterStr = toString(this.filter);

		if (Utilities.instance_of(this.filter, XString)) {
			return wrap("'", "'", filterStr);
		}
		if (this.filterPredicates != undefined && this.filterPredicates.length) {
			return wrap('(', ')', filterStr) + 
			    PathExpr.predicatesString(this.filterPredicates);
		}
		if (this.locationPath != undefined) {
			return filterStr + 
			    (this.locationPath.absolute ? '' : '/') +
				toString(this.locationPath);
		}

		return filterStr;
	}

	return toString(this.locationPath);
};

PathExpr.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	return (
	    (this.absolute ? '/' : '') +
		map(toString, this.steps).join('/')
    );
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	return Step.STEPNAMES[this.axis] +
        "::" +
        this.nodeTest.toString() +
	    PathExpr.predicatesString(this.predicates);
};


Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

Step.STEPNAMES = reduce(function (acc, x) { return acc[x[0]] = x[1], acc; }, {}, [
	[Step.ANCESTOR, 'ancestor'],
	[Step.ANCESTORORSELF, 'ancestor-or-self'],
	[Step.ATTRIBUTE, 'attribute'],
	[Step.CHILD, 'child'],
	[Step.DESCENDANT, 'descendant'],
	[Step.DESCENDANTORSELF, 'descendant-or-self'],
	[Step.FOLLOWING, 'following'],
	[Step.FOLLOWINGSIBLING, 'following-sibling'],
	[Step.NAMESPACE, 'namespace'],
	[Step.PARENT, 'parent'],
	[Step.PRECEDING, 'preceding'],
	[Step.PRECEDINGSIBLING, 'preceding-sibling'],
	[Step.SELF, 'self']
  ]);
  
// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function (n, xpc) {
    console.warn('unknown node test type');
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

NodeTest.isNodeType = function (types){
	return compose(includes(types), prop('nodeType'));
};

NodeTest.makeNodeTestType = function (type, members, ctor) {
	var newType = ctor || function () {};
	
	newType.prototype = new NodeTest(members.type);
	newType.prototype.constructor = type;
	
	for (var key in members) {
		newType.prototype[key] = members[key];
	}
	
	return newType;
};
// create invariant node test for certain node types
NodeTest.makeNodeTypeTest = function (type, nodeTypes, stringVal) {
	return new (NodeTest.makeNodeTestType(type, {
		matches: NodeTest.isNodeType(nodeTypes),
		toString: always(stringVal)
	}))();
};

NodeTest.hasPrefix = function (node) {
	return node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;
};

NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
NodeTest.nameSpaceMatches = function (prefix, xpc, n) {
	var nNamespace = (n.namespaceURI || '');
	
	if (!prefix) { 
	    return !nNamespace || (xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n)); 
	}
	
    var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);

	if (ns == null) {
        throw new Error("Cannot resolve QName " + prefix);
    }

    return ns === nNamespace;
};
NodeTest.localNameMatches = function (localName, xpc, n) {
	var nLocalName = (n.localName || n.nodeName);
	
	return xpc.caseInsensitive
	    ? localName.toLowerCase() === nLocalName.toLowerCase()
		: localName === nLocalName;
};

NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {
	matches: function (n, xpc){
        return NodeTest.isElementOrAttribute(n) && 
		    NodeTest.nameSpaceMatches(this.prefix, xpc, n);
	},
	toString: function () {
		return this.prefix + ":*";
	}
}, function (prefix) { this.prefix = prefix; });

NodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {
	matches: function (n, xpc) {
		return NodeTest.isNodeType([1, 2, XPathNamespace.XPATH_NAMESPACE_NODE])(n) &&
		    NodeTest.nameSpaceMatches(this.prefix, xpc, n) &&
            NodeTest.localNameMatches(this.localName, xpc, n);
	},
	toString: function () {
        return this.name;
	}
}, function (name) { 
    var nameParts = name.split(':');
	
	this.name = name;
	this.prefix = nameParts.length > 1 ? nameParts[0] : null;
	this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
});

NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
	matches: function (n, xpc) {
		return NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;
	},
	toString: function () {
        return wrap('processing-instruction("', '")', this.name);
	}
}, function (name) { this.name = name; })

// singletons

// elements, attributes, namespaces
NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, XPathNamespace.XPATH_NAMESPACE_NODE], '*');
// text, cdata
NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], 'text()');
NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], 'comment()');
// elements, attributes, text, cdata, PIs, comments, document nodes
NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], 'node()');
NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], 'processing-instruction()');

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
    var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);

    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	var result = c.variableResolver.getVariable(parts[1], parts[0]);
    if (!result) {
        throw XPathException.fromMessage("Undeclared variable: " + this.toString());
    }
    return result;
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
    var f = FunctionResolver.getFunctionFromContext(this.functionName, c);

    if (!f) {
		throw new Error("Unknown function " + this.functionName);
	}

    var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = String(s);
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	return this.number().lessthan(r);
};

XString.prototype.greaterthan = function(r) {
	return this.number().greaterthan(r);
};

XString.prototype.lessthanorequal = function(r) {
	return this.number().lessthanorequal(r);
};

XString.prototype.greaterthanorequal = function(r) {
	return this.number().greaterthanorequal(r);
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = typeof n === "string" ? this.parse(n) : Number(n);
};

XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;

XNumber.prototype.parse = function(s) {
    // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow
    return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;
};

function padSmallNumber(numberStr) {
	var parts = numberStr.split('e-');
	var base = parts[0].replace('.', '');
	var exponent = Number(parts[1]);
	
	for (var i = 0; i < exponent - 1; i += 1) {
		base = '0' + base;
	}
	
	return '0.' + base;
}

function padLargeNumber(numberStr) {
	var parts = numberStr.split('e');
	var base = parts[0].replace('.', '');
	var exponent = Number(parts[1]);
	var zerosToAppend = exponent + 1 - base.length;
	
	for (var i = 0; i < zerosToAppend; i += 1){
		base += '0';
	}
	
	return base;
}

XNumber.prototype.toString = function() {
	var strValue = this.num.toString();

	if (strValue.indexOf('e-') !== -1) {
		return padSmallNumber(strValue);
	}
    
	if (strValue.indexOf('e') !== -1) {
		return padLargeNumber(strValue);
	}
	
	return strValue;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	
	
	return new XString(this.toString());
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.number().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	return this.number().lessthan(r);
};

XBoolean.prototype.greaterthan = function(r) {
	return this.number().greaterthan(r);
};

XBoolean.prototype.lessthanorequal = function(r) {
	return this.number().lessthanorequal(r);
};

XBoolean.prototype.greaterthanorequal = function(r) {
	return this.number().greaterthanorequal(r);
};

XBoolean.true_ = new XBoolean(true);
XBoolean.false_ = new XBoolean(false);

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

function nodeOrder(n1, n2) {
	if (n1 === n2) {
		return 0;
	}

	if (n1.compareDocumentPosition) {
	    var cpos = n1.compareDocumentPosition(n2);

        if (cpos & 0x01) {
            // not in the same document; return an arbitrary result (is there a better way to do this)
            return 1;
        }
        if (cpos & 0x0A) {
            // n2 precedes or contains n1
            return 1;
        }
        if (cpos & 0x14) {
            // n2 follows or is contained by n1
            return -1;
        }

	    return 0;
	}

	var d1 = 0,
	    d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
		d2++;
	}

    // step up to same depth
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode || n1.ownerElement;
			d1--;
		}
		if (n1 === n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode || n2.ownerElement;
			d2--;
		}
		if (n1 === n2) {
			return -1;
		}
	}

    var n1Par = n1.parentNode || n1.ownerElement,
        n2Par = n2.parentNode || n2.ownerElement;

    // find common parent
	while (n1Par !== n2Par) {
		n1 = n1Par;
		n2 = n2Par;
		n1Par = n1.parentNode || n1.ownerElement;
	    n2Par = n2.parentNode || n2.ownerElement;
	}
    
    var n1isAttr = Utilities.isAttribute(n1);
    var n2isAttr = Utilities.isAttribute(n2);
    
    if (n1isAttr && !n2isAttr) {
        return -1;
    }
    if (!n1isAttr && n2isAttr) {
        return 1;
    }
    
    if(n1Par) {
	    var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,
	        len = cn.length;
        for (var i = 0; i < len; i += 1) {
            var n = cn[i];
            if (n === n1) {
                return -1;
            }
            if (n === n2) {
                return 1;
            }
        }
    }        
    
    throw new Error('Unexpected: could not determine node order');
}

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = nodeOrder(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
    this.tree = null;
	this.nodes = [];
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.booleanValue());
};

XNodeSet.prototype.booleanValue = function() {
	return !!this.size;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9   /*Node.DOCUMENT_NODE*/ || 
        n.nodeType == 1   /*Node.ELEMENT_NODE */ || 
        n.nodeType === 11 /*Node.DOCUMENT_FRAGMENT*/) {
		return this.stringForContainerNode(n);
	}
    if (n.nodeType === 2 /* Node.ATTRIBUTE_NODE */) {
        return n.value || n.nodeValue;
    }
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForContainerNode = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
        var nt = n2.nodeType;
        //  Element,    Text,       CDATA,      Document,   Document Fragment
        if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {
            s += this.stringForNode(n2);
        }
	}
	return s;
};

XNodeSet.prototype.buildTree = function () {
    if (!this.tree && this.nodes.length) {
        this.tree = new AVLTree(this.nodes[0]);
        for (var i = 1; i < this.nodes.length; i += 1) {
            this.tree.add(this.nodes[i]);
        }
    }

    return this.tree;
};

XNodeSet.prototype.first = function() {
	var p = this.buildTree();
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    for (var i = 0; i < this.nodes.length; i += 1) {
        if (n === this.nodes[i]) {
            return;
        }
    }

    this.tree = null;
    this.nodes.push(n);
    this.size += 1;
};

XNodeSet.prototype.addArray = function(ns) {
	var self = this;
	
	forEach(function (x) { self.add(x); }, ns);
};

/**
 * Returns an array of the node set's contents in document order
 */
XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.buildTree(), a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

/**
 * Returns an array of the node set's contents in arbitrary order
 */
XNodeSet.prototype.toUnsortedArray = function () {
    return this.nodes.slice();
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toUnsortedArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toUnsortedArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var arr = this.toUnsortedArray();
	var oInvert = function (lop, rop) { return o(rop, lop); };
	
	for (var i = 0; i < arr.length; i++) {
		var l = new XString(this.stringForNode(arr[i]));

		var res = r.compareWithString(l, oInvert);
		if (res.booleanValue()) {
			return res;
		}
	}
	
	return new XBoolean(false);
};

XNodeSet.compareWith = curry(function (o, r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, o);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, o);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, o);
	}
	return this.compareWithNodeSet(r, o);
});

XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
    ns.addArray(this.toUnsortedArray());
	ns.addArray(r.toUnsortedArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

XPathContext.prototype.extend = function (newProps) {
	return assign(new XPathContext(), this, newProps);
};

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(ln, ns) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.getFunctionFromContext = function(qName, context) {
    var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);

    if (parts[0] === null) {
        throw new Error("Cannot resolve QName " + name);
    }

    return context.functionResolver.getFunction(parts[1], parts[0]);
};

FunctionResolver.prototype.getFunction = function(localName, namespace) {
	return this.functions["{" + namespace + "}" + localName];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.name || a.nodeName;
			if ((aname === "xmlns" && prefix === "")
					|| aname === "xmlns:" + prefix) {
				return String(a.value || a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

var Functions = new Object();

Functions.last = function(c) {
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}

	return new XNumber(c.contextSize);
};

Functions.position = function(c) {
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}

	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function(c, eNode) {
	var n;
	
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = eNode.evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	
	if (n == null) {
		return new XString("");
	}

	return new XString(n.localName ||     //  standard elements and attributes
	                   n.baseName  ||     //  IE
					   n.target    ||     //  processing instructions
                       n.nodeName  ||     //  DOM1 elements
					   "");               //  fallback
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.name || n.nodeName);
	} else if (n.nodeType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/) {
	    return new XString(n.target || n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function(c) {
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string[, string]*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) !== -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(i + s2.length));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function(c, eValue, eFrom, eTo) {
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}

	var value = eValue.evaluate(c).stringValue();
	var from = eFrom.evaluate(c).stringValue();
	var to = eTo.evaluate(c).stringValue();
	
	var cMap = reduce(function (acc, ch, i) {
		if (!(ch in acc)) {
			acc[ch] = i > to.length ? '' : to[i];
		}
		return acc;
	}, {}, from);

    var t = join('', map(function (ch) {
        return ch in cMap ? cMap[ch] : ch;
    }, value));

	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function(c, eValue) {
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return eValue.evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return XBoolean.true_;
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return XBoolean.false_;
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return XBoolean.false_;
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toUnsortedArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

var Utilities = new Object();

Utilities.isAttribute = function (val) {
    return val && (val.nodeType === 2 || val.ownerElement);
}

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

var XPathException = (function () {
    function getMessage(code, exception) {
        var msg = exception ? ": " + exception.toString() : "";
        switch (code) {
            case XPathException.INVALID_EXPRESSION_ERR:
                return "Invalid expression" + msg;
            case XPathException.TYPE_ERR:
                return "Type error" + msg;
        }
        return null;
    }

    function XPathException(code, error, message) {
        var err = Error.call(this, getMessage(code, error) || message);

        err.code = code;
        err.exception = error;

        return err;
    }

    XPathException.prototype = Object.create(Error.prototype);
    XPathException.prototype.constructor = XPathException;
    XPathException.superclass = Error;

    XPathException.prototype.toString = function() {
        return this.message;
    };

    XPathException.fromMessage = function(message, error) {
        return new XPathException(null, error, message);
    };

    XPathException.INVALID_EXPRESSION_ERR = 51;
    XPathException.TYPE_ERR = 52;

    return XPathException;
})();

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.getOwnerDocument = function (n) {
	return n.nodeType === 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;
}

XPathExpression.detectHtmlDom = function (n) {
	if (!n) { return false; }
	
	var doc = XPathExpression.getOwnerDocument(n);
	
	try {
		return doc.implementation.hasFeature("HTML", "2.0");
	} catch (e) {
		return true;
	}
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	// backward compatibility - no reliable way to detect whether the DOM is HTML, but
	// this library has been using this method up until now, so we will continue to use it
	// ONLY when using an XPathExpression
	this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);
	
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

(function() {
    var parser = new XPathParser();

    var defaultNSResolver = new NamespaceResolver();
    var defaultFunctionResolver = new FunctionResolver();
    var defaultVariableResolver = new VariableResolver();

    function makeNSResolverFromFunction(func) {
        return {
            getNamespace: function (prefix, node) {
                var ns = func(prefix, node);

                return ns || defaultNSResolver.getNamespace(prefix, node);
            }
        };
    }

    function makeNSResolverFromObject(obj) {
        return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
    }

    function makeNSResolverFromMap(map) {
        return makeNSResolverFromFunction(function (prefix) {
            return map[prefix];
        });
    }

    function makeNSResolver(resolver) {
        if (resolver && typeof resolver.getNamespace === "function") {
            return makeNSResolverFromObject(resolver);
        }

        if (typeof resolver === "function") {
            return makeNSResolverFromFunction(resolver);
        }

        // assume prefix -> uri mapping
        if (typeof resolver === "object") {
            return makeNSResolverFromMap(resolver);
        }

        return defaultNSResolver;
    }

    /** Converts native JavaScript types to their XPath library equivalent */
    function convertValue(value) {
        if (value === null ||
            typeof value === "undefined" ||
            value instanceof XString ||
            value instanceof XBoolean ||
            value instanceof XNumber ||
            value instanceof XNodeSet) {
            return value;
        }

        switch (typeof value) {
            case "string": return new XString(value);
            case "boolean": return new XBoolean(value);
            case "number": return new XNumber(value);
        }

        // assume node(s)
        var ns = new XNodeSet();
        ns.addArray([].concat(value));
        return ns;
    }

    function makeEvaluator(func) {
        return function (context) {
            var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {
                return arg.evaluate(context);
            });
            var result = func.apply(this, [].concat(context, args));
            return convertValue(result);
        };
    }

    function makeFunctionResolverFromFunction(func) {
        return {
            getFunction: function (name, namespace) {
                var found = func(name, namespace);
                if (found) {
                    return makeEvaluator(found);
                }
                return defaultFunctionResolver.getFunction(name, namespace);
            }
        };
    }

    function makeFunctionResolverFromObject(obj) {
        return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
    }

    function makeFunctionResolverFromMap(map) {
        return makeFunctionResolverFromFunction(function (name) {
            return map[name];
        });
    }

    function makeFunctionResolver(resolver) {
        if (resolver && typeof resolver.getFunction === "function") {
            return makeFunctionResolverFromObject(resolver);
        }

        if (typeof resolver === "function") {
            return makeFunctionResolverFromFunction(resolver);
        }

        // assume map
        if (typeof resolver === "object") {
            return makeFunctionResolverFromMap(resolver);
        }

        return defaultFunctionResolver;
    }

    function makeVariableResolverFromFunction(func) {
        return {
            getVariable: function (name, namespace) {
                var value = func(name, namespace);
                return convertValue(value);
            }
        };
    }

    function makeVariableResolver(resolver) {
        if (resolver) {
            if (typeof resolver.getVariable === "function") {
                return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
            }

            if (typeof resolver === "function") {
                return makeVariableResolverFromFunction(resolver);
            }

            // assume map
            if (typeof resolver === "object") {
                return makeVariableResolverFromFunction(function (name) {
                    return resolver[name];
                });
            }
        }

        return defaultVariableResolver;
    }
	
	function copyIfPresent(prop, dest, source) {
		if (prop in source) { dest[prop] = source[prop]; }
	}

    function makeContext(options) {
        var context = new XPathContext();

        if (options) {
            context.namespaceResolver = makeNSResolver(options.namespaces);
            context.functionResolver = makeFunctionResolver(options.functions);
            context.variableResolver = makeVariableResolver(options.variables);
			context.expressionContextNode = options.node;
			copyIfPresent('allowAnyNamespaceForNoPrefix', context, options);
			copyIfPresent('isHtml', context, options);
        } else {
            context.namespaceResolver = defaultNSResolver;
        }

        return context;
    }

    function evaluate(parsedExpression, options) {
        var context = makeContext(options);

        return parsedExpression.evaluate(context);
    }

    var evaluatorPrototype = {
        evaluate: function (options) {
            return evaluate(this.expression, options);
        }

        ,evaluateNumber: function (options) {
            return this.evaluate(options).numberValue();
        }

        ,evaluateString: function (options) {
            return this.evaluate(options).stringValue();
        }

        ,evaluateBoolean: function (options) {
            return this.evaluate(options).booleanValue();
        }

        ,evaluateNodeSet: function (options) {
            return this.evaluate(options).nodeset();
        }

        ,select: function (options) {
            return this.evaluateNodeSet(options).toArray()
        }

        ,select1: function (options) {
            return this.select(options)[0];
        }
    };

    function parse(xpath) {
        var parsed = parser.parse(xpath);

        return Object.create(evaluatorPrototype, {
            expression: {
                value: parsed
            }
        });
    }

    exports.parse = parse;
})();

exports.XPath = XPath;
exports.XPathParser = XPathParser;
exports.XPathResult = XPathResult;

exports.Step = Step;
exports.NodeTest = NodeTest;
exports.BarOperation = BarOperation;

exports.NamespaceResolver = NamespaceResolver;
exports.FunctionResolver = FunctionResolver;
exports.VariableResolver = VariableResolver;

exports.Utilities = Utilities;

exports.XPathContext = XPathContext;
exports.XNodeSet = XNodeSet;
exports.XBoolean = XBoolean;
exports.XString = XString;
exports.XNumber = XNumber;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(xpath);


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(273).XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(169).DOMImplementation;
	exports.XMLSerializer = __webpack_require__(169).XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),
/* 169 */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(170)
var inherits = __webpack_require__(50)
var stream = __webpack_require__(172)

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(40).Buffer, __webpack_require__(13)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(173);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(177);
exports.Duplex = __webpack_require__(57);
exports.Transform = __webpack_require__(179);
exports.PassThrough = __webpack_require__(286);


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(94);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(166);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(174).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(175);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(95).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(70);
util.inherits = __webpack_require__(50);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(280);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(281);
var destroyImpl = __webpack_require__(176);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(57);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(178).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(57);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(178).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(26)))

/***/ }),
/* 174 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(174).EventEmitter;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(94);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(94);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(70);
util.inherits = __webpack_require__(50);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(285)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(175);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(95).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(176);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(57);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(57);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(283).setImmediate, __webpack_require__(13)))

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(95).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(57);

/*<replacement>*/
var util = __webpack_require__(70);
util.inherits = __webpack_require__(50);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const ECJsonTypeMap_1 = __webpack_require__(9);
const Request_1 = __webpack_require__(23);
const bentleyjs_core_1 = __webpack_require__(0);
const Query_1 = __webpack_require__(41);
const index_1 = __webpack_require__(69);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Code State enumeration */
var CodeState;
(function (CodeState) {
    /** Code with this state is not persisted in the database. Code that is updated to 'Available' state is deleted from the database */
    CodeState[CodeState["Available"] = 0] = "Available";
    /** Code is reserved by the briefcase, no one else is allowed to change its state */
    CodeState[CodeState["Reserved"] = 1] = "Reserved";
    /** Code is used in the changeSet committed to the server */
    CodeState[CodeState["Used"] = 2] = "Used";
    /** Retired code can't be reserved or used. It can only be deleted and then reserved again */
    CodeState[CodeState["Retired"] = 3] = "Retired";
})(CodeState = exports.CodeState || (exports.CodeState = {}));
/** Base class for Code and MultiCode */
class CodeBase extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeSpecId")
], CodeBase.prototype, "codeSpecId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeScope")
], CodeBase.prototype, "codeScope", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.State")
], CodeBase.prototype, "state", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], CodeBase.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], CodeBase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.QueryOnly")
], CodeBase.prototype, "queryOnly", void 0);
exports.CodeBase = CodeBase;
/** Code */
let Code = class Code extends CodeBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Value")
], Code.prototype, "value", void 0);
Code = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Code", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Code);
exports.Code = Code;
/**
 * MultiCode
 * Data about codes grouped by CodeSpecId, State and Briefcase
 */
let MultiCode = class MultiCode extends CodeBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Values")
], MultiCode.prototype, "values", void 0);
MultiCode = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.MultiCode", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], MultiCode);
exports.MultiCode = MultiCode;
/**
 * Encodes part of the code to be used in URI
 * @param str Part of the code.
 * @returns Encoded part of a code.
 */
function encodeForCodeId(str) {
    return encodeURIComponent(str.replace("-", "_0x2D_"))
        .replace("~", "~7E")
        .replace("*", "~2A")
        .replace("%", "~");
}
/**
 * Gets encoded instance id for a code to be used in an URI.
 * @param code Code to get instance id for.
 * @returns Encoded code instance id.
 */
function getCodeInstanceId(code) {
    if (!code || !code.codeSpecId || !code.codeScope || !code.value)
        return undefined;
    return `'${code.codeSpecId}-${encodeForCodeId(code.codeScope)}-${encodeForCodeId(code.value)}'`;
}
/**
 * Provider for default CodeUpdateOptions, used by CodeHandler to set defaults.
 */
class DefaultCodeUpdateOptionsProvider {
    /**
     * Creates an instance of DefaultRequestOptionsProvider and sets up the default options.
     */
    constructor() {
        this.defaultOptions = {
            codesPerRequest: 2000,
        };
    }
    /**
     * Augments options with the provider's default values.
     * @note The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this.defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultCodeUpdateOptionsProvider = DefaultCodeUpdateOptionsProvider;
/** Error for conflicting codes */
class ConflictingCodesError extends index_1.IModelHubError {
    /**
     * Create ConflictingCodesError from IModelHubError instance.
     * @param error IModelHubError to get error data from.
     * @returns Undefined if the error is not for a code conflict, otherwise newly created error instance.
     */
    static fromError(error) {
        if (error.errorNumber !== bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase &&
            error.errorNumber !== bentleyjs_core_1.IModelHubStatus.ConflictsAggregate) {
            return undefined;
        }
        const result = new ConflictingCodesError(error.errorNumber);
        deepAssign(result, error);
        result.addCodes(error);
        return result;
    }
    /**
     * Amends this error instance with conflicting codes from another IModelHubError.
     * @param error Error to get additional conflicting codes from.
     */
    addCodes(error) {
        if (!error.data || !error.data.ConflictingCodes) {
            return;
        }
        if (!this.conflictingCodes) {
            this.conflictingCodes = [];
        }
        for (const value of error.data.ConflictingCodes) {
            const instance = { className: "Code", schemaName: "iModelScope", properties: value };
            const code = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(Code, "wsg", instance);
            if (code) {
                this.conflictingCodes.push(code);
            }
        }
    }
}
exports.ConflictingCodesError = ConflictingCodesError;
/**
 * Query object for getting Codes. You can use this to modify the query.
 * @see CodeHandler.get()
 */
class CodeQuery extends Query_1.Query {
    constructor() {
        super(...arguments);
        this._isMultiCodeQuery = true;
    }
    /**
     * Used by the hanlder to check whether codes in query can be grouped.
     */
    isMultiCodeQuery() {
        return this._isMultiCodeQuery;
    }
    /**
     * Query Codes by Briefcase id.
     * @param briefcaseId Id of the Briefcase.
     * @returns This query.
     */
    byBriefcaseId(briefcaseId) {
        this.addFilter(`BriefcaseId+eq+${briefcaseId}`);
        return this;
    }
    /**
     * Query Codes by CodeSpec id.
     * @param codeSpecId Id of the CodeSpec.
     * @returns This query.
     */
    byCodeSpecId(codeSpecId) {
        this.addFilter(`CodeSpecId+eq+'${codeSpecId}'`);
        return this;
    }
    /**
     * Query Codes by Code Scope.
     * @param codeScope Scope of the Code.
     * @returns This query.
     */
    byCodeScope(codeScope) {
        this.addFilter(`CodeScope+eq+'${codeScope}'`);
        return this;
    }
    /**
     * Query Codes by their instance ids.
     * @param codes Codes to query. They must have their CodeSpec, Scope and Value set.
     * @returns This query.
     */
    byCodes(codes) {
        this._isMultiCodeQuery = false;
        if (codes.length < 1) {
            throw index_1.IModelHubRequestError.invalidArgument("codes");
        }
        let filter = "$id+in+[";
        let first = true;
        for (const code of codes) {
            const id = getCodeInstanceId(code);
            if (!id) {
                throw index_1.IModelHubRequestError.invalidArgument("codes");
            }
            first ? first = false : filter += ",";
            filter += id;
        }
        filter += "]";
        this.addFilter(filter);
        return this;
    }
    /**
     * Select only top entries from the query.
     * This is applied after @see Query.skip parameter.
     * @param n Number of top entries to select.
     * @returns This query.
     */
    top(n) {
        this._isMultiCodeQuery = false;
        return super.top(n);
    }
    /**
     * Query unavailable Codes.
     * @param briefcaseId Id of the briefcase.
     * @returns This query.
     */
    unavailableCodes(briefcaseId) {
        const filter = `BriefcaseId+ne+${briefcaseId}`;
        this.addFilter(filter);
        return this;
    }
}
exports.CodeQuery = CodeQuery;
/**
 * Handler for all methods related to @see Code instances.
 */
class CodeHandler {
    /**
     * Constructor for CodeHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for Code requests.
     * @param imodelId Id of the iModel.
     * @param codeId Id of the code.
     */
    getRelativeUrl(imodelId, multiCode = true, codeId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/${multiCode ? "MultiCode" : "Code"}/${codeId || ""}`;
    }
    /** Convert Codes to MultiCodes. */
    static convertCodesToMultiCodes(codes) {
        const map = new Map();
        for (const code of codes) {
            const id = `${code.codeScope}-${code.codeSpecId}-${code.state}`;
            if (map.has(id)) {
                map.get(id).values.push(code.value);
            }
            else {
                const multiCode = new MultiCode();
                multiCode.changeState = "new";
                multiCode.briefcaseId = code.briefcaseId;
                multiCode.codeScope = code.codeScope;
                multiCode.codeSpecId = code.codeSpecId;
                multiCode.state = code.state;
                multiCode.values = [code.value];
                map.set(id, multiCode);
            }
        }
        return Array.from(map.values());
    }
    /** Convert MultiCodes to Codes. */
    static convertMultiCodesToCodes(multiCodes) {
        const result = [];
        for (const multiCode of multiCodes) {
            for (const value of multiCode.values) {
                const code = new Code();
                code.briefcaseId = multiCode.briefcaseId;
                code.codeScope = multiCode.codeScope;
                code.codeSpecId = multiCode.codeSpecId;
                code.state = multiCode.state;
                code.value = value;
                result.push(code);
            }
        }
        return result;
    }
    /**
     * Augments update options with defaults returned by the DefaultCodeUpdateOptionsProvider.
     * @note The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!CodeHandler._defaultUpdateOptionsProvider)
            CodeHandler._defaultUpdateOptionsProvider = new DefaultCodeUpdateOptionsProvider();
        return CodeHandler._defaultUpdateOptionsProvider.assignOptions(options);
    }
    /** Send partial request for code updates */
    async updateInternal(token, imodelId, codes, updateOptions) {
        let requestOptions;
        if (updateOptions) {
            requestOptions = {};
            requestOptions.CustomOptions = {};
            if (updateOptions.deniedCodes === false) {
                requestOptions.CustomOptions.DetailedError_Codes = "false";
            }
            if (updateOptions.unlimitedReporting) {
                requestOptions.CustomOptions.DetailedError_MaximumInstances = "-1";
            }
            if (updateOptions.continueOnConflict) {
                requestOptions.CustomOptions.ConflictStrategy = "Continue";
            }
            if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0)
                requestOptions = undefined;
        }
        const result = await this._handler.postInstances(MultiCode, token, `/Repositories/iModel--${imodelId}/$changeset`, CodeHandler.convertCodesToMultiCodes(codes), requestOptions);
        return CodeHandler.convertMultiCodesToCodes(result);
    }
    /**
     * Updates multiple codes.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param codes Code to reserve. Requires briefcaseId to be set in the code. Can also set state, codeSpecId, codeScope and value. Set queryOnly to true
     * to just check if a code can be reserved.
     * @param updateOptions Options for the update request.
     * @returns The code that was just obtained from the server.
     */
    async update(token, imodelId, codes, updateOptions) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Requesting codes for iModel ${imodelId}`);
        updateOptions = updateOptions || {};
        this.setupOptionDefaults(updateOptions);
        const result = [];
        let conflictError;
        const aggregateError = new index_1.AggregateResponseError();
        for (let i = 0; i < codes.length; i += updateOptions.codesPerRequest) {
            const chunk = codes.slice(i, i + updateOptions.codesPerRequest);
            try {
                result.push(...await this.updateInternal(token, imodelId, chunk, updateOptions));
            }
            catch (error) {
                if (error instanceof Request_1.ResponseError) {
                    if (updateOptions && updateOptions.deniedCodes && error instanceof index_1.IModelHubError && (error.errorNumber === bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase ||
                        error.errorNumber === bentleyjs_core_1.IModelHubStatus.ConflictsAggregate)) {
                        if (conflictError) {
                            conflictError.addCodes(error);
                        }
                        else {
                            conflictError = ConflictingCodesError.fromError(error);
                        }
                        if (!updateOptions.continueOnConflict) {
                            return Promise.reject(conflictError);
                        }
                    }
                    else {
                        aggregateError.errors.push(error);
                    }
                }
            }
        }
        if (conflictError) {
            return Promise.reject(conflictError);
        }
        if (aggregateError.errors.length > 0) {
            return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Requested ${codes.length} codes for iModel ${imodelId}`);
        return result;
    }
    /**
     * Gets the codes that have been issued for the iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object used to modify results of this query.
     * @returns Resolves to an array of codes.
     */
    async get(token, imodelId, query = new CodeQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying codes for iModel ${imodelId}`);
        let codes;
        if (query.isMultiCodeQuery()) {
            const multiCodes = await this._handler.getInstances(MultiCode, token, this.getRelativeUrl(imodelId), query.getQueryOptions());
            codes = CodeHandler.convertMultiCodesToCodes(multiCodes);
        }
        else {
            codes = await this._handler.postQuery(Code, token, this.getRelativeUrl(imodelId, false), query.getQueryOptions());
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${codes.length} codes for iModel ${imodelId}`);
        return codes;
    }
    /**
     * Deletes all codes owned by the specified briefcase
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param briefcaseId Id of the briefcacase
     */
    async deleteAll(token, imodelId, briefcaseId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting all codes from briefcase ${briefcaseId} in iModel ${imodelId}`);
        if (!index_1.isBriefcaseIdValid(briefcaseId))
            return Promise.reject(index_1.IModelHubRequestError.invalidArgument("briefcaseId"));
        await this._handler.delete(token, this.getRelativeUrl(imodelId, false, `DiscardReservedCodes-${briefcaseId}`));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted all codes from briefcase ${briefcaseId} in iModel ${imodelId}`);
    }
}
exports.CodeHandler = CodeHandler;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Config_1 = __webpack_require__(31);
const Client_1 = __webpack_require__(68);
const ECJsonTypeMap_1 = __webpack_require__(9);
const bentleyjs_core_1 = __webpack_require__(0);
class BaseEventSAS extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BaseAddress")
], BaseEventSAS.prototype, "baseAddress", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventServiceSASToken")
], BaseEventSAS.prototype, "sasToken", void 0);
exports.BaseEventSAS = BaseEventSAS;
/** Base type for all iModelHub global events */
class IModelHubBaseEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        this.eventTopic = obj.EventTopic;
        this.fromEventSubscriptionId = obj.FromEventSubscriptionId;
        this.toEventSubscriptionId = obj.ToEventSubscriptionId;
    }
}
exports.IModelHubBaseEvent = IModelHubBaseEvent;
class EventBaseHandler {
    /** Gets service bus parser depending on the environment. */
    setServiceBusOptions(options) {
        const parse = (message) => {
            if (!message)
                return undefined;
            return JSON.parse(message.substring(message.indexOf("{"), message.lastIndexOf("}") + 1));
        };
        if (Config_1.Config.isBrowser()) {
            options.parser = (_, message) => parse(message);
        }
        else {
            options.buffer = true;
            options.parser = (res, cb) => {
                res.on("data", (chunk) => { res.text += chunk; });
                res.on("end", () => {
                    try {
                        if (res.statusCode === 200) {
                            cb(null, parse(res.text));
                        }
                        else if (res.statusCode === 204) {
                            cb(null, "");
                        }
                        else {
                            cb(res, null);
                        }
                    }
                    catch (err) {
                        cb(err, null);
                    }
                });
            };
        }
    }
    /**
     * Gets event from Service Bus Topic.
     * @param sasToken Service Bus SAS Token.
     * @param requestTimeout Timeout for the request.
     * @return Event if it exists.
     */
    getEventRequestOptions(sasToken, requestTimeout) {
        const options = {
            method: "DELETE",
            headers: { authorization: sasToken },
            agent: this._handler.getAgent(),
        };
        // Request timeout is in seconds, wait 50% more than the expected timeout from server
        if (requestTimeout)
            options.timeout = requestTimeout * 1500;
        new Client_1.DefaultRequestOptionsProvider().assignOptions(options);
        this.setServiceBusOptions(options);
        return options;
    }
}
exports.EventBaseHandler = EventBaseHandler;
class ListenerSubscription {
}
exports.ListenerSubscription = ListenerSubscription;
class EventListener {
    static create(subscription, listener) {
        if (!this.subscriptions) {
            this.subscriptions = new Map();
        }
        let existingSubscription = this.subscriptions.get(subscription.id);
        let deleteListener;
        if (!existingSubscription) {
            existingSubscription = subscription;
            existingSubscription.listeners = new bentleyjs_core_1.BeEvent();
            deleteListener = subscription.listeners.addListener(listener);
            this.getEvents(subscription);
        }
        else {
            deleteListener = subscription.listeners.addListener(listener);
        }
        this.subscriptions.set(subscription.id, existingSubscription);
        const subscriptionId = subscription.id;
        return () => {
            deleteListener();
            const sub = this.subscriptions.get(subscriptionId);
            if (sub) {
                if (sub.listeners && sub.listeners.numberOfListeners === 0)
                    this.subscriptions.delete(subscription.id);
            }
        };
    }
    static async getEvents(subscription) {
        let accessToken = await subscription.authenticationCallback();
        let eventSAS;
        mainLoop: while (subscription.listeners.numberOfListeners > 0) {
            try {
                eventSAS = (await subscription.getSASToken(accessToken));
            }
            catch (err) {
                if (err.status === 401) {
                    try {
                        accessToken = await subscription.authenticationCallback();
                    }
                    catch (_a) {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            while (subscription.listeners.numberOfListeners > 0) {
                try {
                    const event = await subscription.getEvent(eventSAS.sasToken, eventSAS.baseAddress, subscription.id, 60);
                    if (event)
                        subscription.listeners.raiseEvent(event);
                }
                catch (err) {
                    if (err.status === 401) {
                        break;
                    }
                    else {
                        break mainLoop;
                    }
                }
            }
        }
        this.subscriptions.delete(subscription.id);
    }
}
exports.EventListener = EventListener;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Request_1 = __webpack_require__(23);
const bentleyjs_core_1 = __webpack_require__(0);
const EventsBase_1 = __webpack_require__(181);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Base type for all iModelHub global events */
class IModelHubGlobalEvent extends EventsBase_1.IModelHubBaseEvent {
    /**
     * Construct this global event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        this.iModelId = obj.iModelId;
        this.projectId = obj.ProjectId;
    }
}
exports.IModelHubGlobalEvent = IModelHubGlobalEvent;
/** Sent when iModel is archived */
class SoftiModelDeleteEvent extends IModelHubGlobalEvent {
}
exports.SoftiModelDeleteEvent = SoftiModelDeleteEvent;
/** Sent when archived iModel is deleted */
class HardiModelDeleteEvent extends IModelHubGlobalEvent {
}
exports.HardiModelDeleteEvent = HardiModelDeleteEvent;
/** Sent when new iModel is created */
class IModelCreatedEvent extends IModelHubGlobalEvent {
}
exports.IModelCreatedEvent = IModelCreatedEvent;
/** Sent when a ChangeSet push has started */
class ChangeSetCreatedEvent extends IModelHubGlobalEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.changeSetId = obj.ChangeSetId;
        this.changeSetIndex = obj.ChangeSetIndex;
        this.briefcaseId = obj.BriefcaseId;
    }
}
exports.ChangeSetCreatedEvent = ChangeSetCreatedEvent;
/** Sent when a new Named Version is created */
class NamedVersionCreatedEvent extends IModelHubGlobalEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.versionId = obj.VersionId;
        this.versionName = obj.VersionName;
        this.changeSetId = obj.ChangeSetId;
    }
}
exports.NamedVersionCreatedEvent = NamedVersionCreatedEvent;
/** Get constructor from GlobalEventType name. */
function ConstructorFromEventType(type) {
    switch (type) {
        case "SoftiModelDeleteEvent":
            return SoftiModelDeleteEvent;
        case "HardiModelDeleteEvent":
            return HardiModelDeleteEvent;
        case "iModelCreatedEvent":
            return IModelCreatedEvent;
        case "ChangeSetCreatedEvent":
            return ChangeSetCreatedEvent;
        case "NamedVersionCreatedEvent":
            return NamedVersionCreatedEvent;
    }
}
/**
 * Parse @see IModelHubGlobalEvent from response object.
 * @param response Response object to parse.
 * @returns Appropriate global event object.
 */
function ParseGlobalEvent(response) {
    const constructor = ConstructorFromEventType(response.header["content-type"]);
    const globalEvent = new constructor();
    globalEvent.fromJson(response.body);
    return globalEvent;
}
exports.ParseGlobalEvent = ParseGlobalEvent;
/** GlobalEventSubscription */
let GlobalEventSubscription = class GlobalEventSubscription extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventTypes")
], GlobalEventSubscription.prototype, "eventTypes", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SubscriptionId")
], GlobalEventSubscription.prototype, "subscriptionId", void 0);
GlobalEventSubscription = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "GlobalScope.GlobalEventSubscription", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], GlobalEventSubscription);
exports.GlobalEventSubscription = GlobalEventSubscription;
/** GlobalEventSAS */
let GlobalEventSAS = class GlobalEventSAS extends EventsBase_1.BaseEventSAS {
};
GlobalEventSAS = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "GlobalScope.GlobalEventSAS", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], GlobalEventSAS);
exports.GlobalEventSAS = GlobalEventSAS;
/**
 * Handler for all methods related to @see GlobalEventSubscription instances.
 */
class GlobalEventSubscriptionHandler {
    /**
     * Constructor for GlobalEventSubscriptionHandler. Should use @see GlobalEventHandler instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for GlobalEventSubscription requests.
     * @param instanceId Id of the subscription.
     */
    getRelativeUrl(instanceId) {
        return `/Repositories/Global--Global/GlobalScope/GlobalEventSubscription/${instanceId || ""}`;
    }
    /**
     * Creates global event subscription.
     * @param token Delegation token of the authorized Service Account.
     * @param subscriptionId Id of the global event subscription.
     * @param globalEvents Array of GlobalEventTypes to subscribe to.
     * @return Created GlobalEventSubscription instance.
     */
    async create(token, subscriptionId, globalEvents) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Creating global event subscription with instance id: ${subscriptionId}`);
        let subscription = new GlobalEventSubscription();
        subscription.eventTypes = globalEvents;
        subscription.subscriptionId = subscriptionId;
        subscription = await this._handler.postInstance(GlobalEventSubscription, token, this.getRelativeUrl(), subscription);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Created global event subscription with instance id: ${subscriptionId}`);
        return subscription;
    }
    /**
     * Updates global event subscription.
     * @param token Delegation token of the authorized Service Account.
     * @param subscription Updated global events subscription.
     * @return Updated GlobalEventSubscription instance.
     */
    async update(token, subscription) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Updating global event subscription with instance id: ${subscription.wsgId} and subscription id: ${subscription.subscriptionId}`);
        const updatedSubscription = await this._handler.postInstance(GlobalEventSubscription, token, this.getRelativeUrl(subscription.wsgId), subscription);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Updated global event subscription with instance id: ${subscription.wsgId} and subscription id: ${subscription.subscriptionId}`);
        return updatedSubscription;
    }
    /**
     * Deletes global event subscription.
     * @param token Delegation token of the authorized Service Account.
     * @param eventSubscriptionInstanceId Id of the global event subscription instance.
     * @returns Resolves if the GlobalEventSubscription has been successfully deleted.
     */
    async delete(token, eventSubscriptionInstanceId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting global event subscription with instance id: ${eventSubscriptionInstanceId}`);
        await this._handler.delete(token, this.getRelativeUrl(eventSubscriptionInstanceId));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted global event subscription with instance id: ${eventSubscriptionInstanceId}`);
    }
}
exports.GlobalEventSubscriptionHandler = GlobalEventSubscriptionHandler;
/**
 * Handler for all methods related to iModel Hub global events.
 */
class GlobalEventHandler extends EventsBase_1.EventBaseHandler {
    /**
     * Constructor for GlobalEventHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        super();
        this._handler = handler;
    }
    /**
     * Get a handler for @see GlobalEventSubscription related methods.
     */
    Subscriptions() {
        if (!this._subscriptionHandler) {
            this._subscriptionHandler = new GlobalEventSubscriptionHandler(this._handler);
        }
        return this._subscriptionHandler;
    }
    /**
     * Gets relative url for GlobalEventSAS requests.
     */
    getGlobalEventSASRelativeUrl() {
        return `/Repositories/Global--Global/GlobalScope/GlobalEventSAS/`;
    }
    /**
     * Gets global event SAS Token.
     * @param token Delegation token of the authorized Service Account.
     * @return SAS Token to connect to the topic.
     */
    async getSASToken(token) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Getting global event SAS token`);
        const globalEventSAS = await this._handler.postInstance(GlobalEventSAS, token, this.getGlobalEventSASRelativeUrl(), new GlobalEventSAS());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Got global event SAS token`);
        return globalEventSAS;
    }
    /**
     * Gets absolute url for global event requests.
     * @param baseAddress Base address for the serviceBus.
     * @param subscriptionInstanceId Id of the subscription instance.
     * @param timeout Optional timeout for long polling.
     */
    getGlobalEventUrl(baseAddress, subscriptionInstanceId, timeout) {
        let url = `${baseAddress}/Subscriptions/${subscriptionInstanceId}/messages/head`;
        if (timeout) {
            url = url + `?timeout=${timeout}`;
        }
        return url;
    }
    /**
     * Gets global event from Service Bus Topic.
     * @param sasToken Service Bus SAS Token.
     * @param baseAddress Base address of Service Bus topic.
     * @param subscriptionInstanceId Id of the subscription instance to the topic.
     * @param timeout Optional timeout duration in seconds for request, when using long polling.
     * @return Global Event if it exists, undefined otherwise.
     */
    async getEvent(sasToken, baseAddress, subscriptionInstanceId, timeout) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Getting global event from subscription with instance id: ${subscriptionInstanceId}`);
        const options = this.getEventRequestOptions(sasToken, timeout);
        const result = await Request_1.request(this.getGlobalEventUrl(baseAddress, subscriptionInstanceId, timeout), options);
        if (result.status === 204) {
            bentleyjs_core_1.Logger.logTrace(loggingCategory, `No events found on subscription ${subscriptionInstanceId}`);
            return undefined;
        }
        const event = ParseGlobalEvent(result);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Got Global Event from subscription with instance id: ${subscriptionInstanceId}`);
        return Promise.resolve(event);
    }
    /**
     * Creates a listener for long polling events from a subscription.
     * @param authenticationCallback Callback used to get AccessToken. Only the first registered callback for this subscription will be used.
     * @param subscriptionId Id of subscription.
     * @param listener Callback that is called when an event is received.
     * @returns Function that deletes the listener.
     */
    createListener(authenticationCallback, subscriptionId, listener) {
        const subscription = new EventsBase_1.ListenerSubscription();
        subscription.authenticationCallback = authenticationCallback;
        subscription.getEvent = (sasToken, baseAddress, id, timeout) => this.getEvent(sasToken, baseAddress, id, timeout);
        subscription.getSASToken = (accessToken) => this.getSASToken(accessToken);
        subscription.id = subscriptionId;
        return EventsBase_1.EventListener.create(subscription, listener);
    }
}
exports.GlobalEventHandler = GlobalEventHandler;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const bentleyjs_core_1 = __webpack_require__(0);
const Query_1 = __webpack_require__(41);
const Errors_1 = __webpack_require__(49);
const loggingCategory = "imodeljs-clients.imodelhub";
/** UserInfo */
let UserInfo = class UserInfo extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], UserInfo.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], UserInfo.prototype, "firstName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Surname")
], UserInfo.prototype, "lastName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Email")
], UserInfo.prototype, "email", void 0);
UserInfo = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.UserInfo", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], UserInfo);
exports.UserInfo = UserInfo;
/**
 * Query object for getting UserInfos. You can use this to modify the query.
 * @see UserInfoHandler.get()
 */
class UserInfoQuery extends Query_1.InstanceIdQuery {
    constructor() {
        super(...arguments);
        this.queriedByIds = false;
    }
    /**
     * Query User info by user ids.
     * @param ids Ids of the users.
     * @returns This query.
     */
    byIds(ids) {
        if (ids.length < 1) {
            throw Errors_1.IModelHubRequestError.invalidArgument("ids");
        }
        let filter = "$id+in+[";
        ids.forEach((id, index) => {
            if (index > 0)
                filter += ",";
            filter += `'${id}'`;
        });
        filter += "]";
        this.addFilter(filter);
        this.queriedByIds = true;
        return this;
    }
    /** Returns whether was object queried by ids or no */
    isQueriedByIds() {
        return this.queriedByIds;
    }
}
exports.UserInfoQuery = UserInfoQuery;
/**
 * Handler for all methods related to @see UserInfo instances.
 */
class UserInfoHandler {
    /**
     * Constructor for UserInfoHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for UserInfo requests.
     * @param imodelId Id of the iModel.
     * @param userId Id of the user.
     */
    getRelativeUrl(imodelId, userId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/UserInfo/${userId || ""}`;
    }
    /**
     * Gets information on a specific user(s) that has accessed the iModel
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object used to modify results of this query.
     */
    async get(token, imodelId, query = new UserInfoQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying users for iModel ${imodelId}`);
        let users;
        if (query.isQueriedByIds()) {
            users = await this._handler.postQuery(UserInfo, token, this.getRelativeUrl(imodelId, query.getId()), query.getQueryOptions());
        }
        else {
            users = await this._handler.getInstances(UserInfo, token, this.getRelativeUrl(imodelId, query.getId()), query.getQueryOptions());
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried users for iModel ${imodelId}`);
        return users;
    }
}
exports.UserInfoHandler = UserInfoHandler;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Request_1 = __webpack_require__(23);
const bentleyjs_core_1 = __webpack_require__(0);
const Query_1 = __webpack_require__(41);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Thumbnail */
class Thumbnail extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "workaround.to.add.class.to.map")
], Thumbnail.prototype, "workaround", void 0);
exports.Thumbnail = Thumbnail;
let SmallThumbnail = class SmallThumbnail extends Thumbnail {
};
SmallThumbnail = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.SmallThumbnail", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], SmallThumbnail);
exports.SmallThumbnail = SmallThumbnail;
let LargeThumbnail = class LargeThumbnail extends Thumbnail {
};
LargeThumbnail = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.LargeThumbnail", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], LargeThumbnail);
exports.LargeThumbnail = LargeThumbnail;
/**
 * Query object for getting Thumbnails. You can use this to modify the query.
 * @see ThumbnailHandler.get()
 */
class ThumbnailQuery extends Query_1.InstanceIdQuery {
    /**
     * Query thumbnails by version id.
     * @param versionId Id of the version.
     * @returns This query.
     */
    byVersionId(versionId) {
        this.addFilter(`HasThumbnail-backward-Version.Id+eq+'${versionId}'`);
        return this;
    }
}
exports.ThumbnailQuery = ThumbnailQuery;
/**
 * Handler for all methods related to thumbnails.
 */
class ThumbnailHandler {
    /**
     * Constructor for ThumbnailHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for tip Thumbnail requests.
     * @param projectId Id of the project.
     * @param imodelId Id of the imodel.
     * @param size Size of the thumbnail.
     */
    getRelativeProjectUrl(projectId, imodelId, size) {
        return `/Repositories/Project--${this._handler.formatProjectIdForUrl(projectId)}/ProjectScope/${size}Thumbnail/${imodelId}/$file`;
    }
    /**
     * Gets relative url for Thumbnail requests.
     * @param imodelId Id of the iModel.
     * @param size Size of the thumbnail.
     * @param thumbnailId Id of the thumbnail.
     */
    getRelativeUrl(imodelId, size, thumbnailId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/${size}Thumbnail/${thumbnailId || ""}`;
    }
    /**
     * Returns true if given thumbnail is TipThumbnail.
     * @param thumbnail SmallThumbnail, LargeThumbnail or TipThumbnail.
     */
    isTipThumbnail(thumbnail) {
        return thumbnail.projectId !== undefined;
    }
    /**
     * Downloads the thumbnail.
     * @param token Delegation token of the authorized user.
     * @param url Url to download thumbnail.
     * @return String for the PNG image that includes the base64 encoded array of the image bytes.
     */
    async downloadThumbnail(token, url) {
        const options = {
            method: "GET",
            headers: { authorization: token.toTokenString() },
            responseType: "arraybuffer",
            agent: this._handler.getAgent(),
        };
        const response = await Request_1.request(url, options);
        const byteArray = new Uint8Array(response.body);
        if (!byteArray || byteArray.length === 0) {
            return Promise.reject(new Error("Expected an image to be returned from the query"));
        }
        const base64Data = Base64.btoa(String.fromCharCode.apply(null, byteArray));
        return "data:image/png;base64," + base64Data;
    }
    /**
     * Downloads the most latest iModel's thumbnail.
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the connect project.
     * @param imodelId Id of the iModel
     * @param size Size of the thumbnail. Pass 'Small' for 400x250 PNG image, and 'Large' for a 800x500 PNG image.
     * @return String for the PNG image that includes the base64 encoded array of the image bytes.
     */
    async downloadTipThumbnail(token, projectId, imodelId, size) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Downloading tip ${size}Thumbnail for iModel ${imodelId}`);
        const url = await this._handler.getUrl() + this.getRelativeProjectUrl(projectId, imodelId, size);
        const pngImage = await this.downloadThumbnail(token, url);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Downloaded tip ${size}Thumbnail for iModel ${imodelId}`);
        return pngImage;
    }
    /**
     * Gets the thumbnails.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param size Size of the thumbnail. Pass 'Small' for 400x250 PNG image, and 'Large' for a 800x500 PNG image.
     * @param query Optional query object to filter the queried thumbnails.
     * @return Resolves to array of thumbnails.
     */
    async get(token, imodelId, size, query = new ThumbnailQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying iModel ${imodelId} thumbnails`);
        let thumbnails = [];
        if (size === "Small")
            thumbnails = await this._handler.getInstances(SmallThumbnail, token, this.getRelativeUrl(imodelId, size, query.getId()), query.getQueryOptions());
        else
            thumbnails = await this._handler.getInstances(LargeThumbnail, token, this.getRelativeUrl(imodelId, size, query.getId()), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried iModel ${imodelId} thumbnails`);
        return thumbnails;
    }
    /**
     * Downloads the thumbnail.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel.
     * @param thumbnail Small, Large or Tip thumbnail. Use 'get' function to query thumbnails or create tip thumbnail object.
     * @return String for the PNG image that includes the base64 encoded array of the image bytes.
     */
    async download(token, imodelId, thumbnail) {
        if (this.isTipThumbnail(thumbnail)) {
            return await this.downloadTipThumbnail(token, thumbnail.projectId, imodelId, thumbnail.size);
        }
        const size = thumbnail instanceof SmallThumbnail ? "Small" : "Large";
        const thumbnailId = thumbnail.wsgId;
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Downloading ${size}Thumbnail ${thumbnailId} for iModel ${imodelId}`);
        const url = await this._handler.getUrl() + this.getRelativeUrl(imodelId, size, thumbnailId) + "/$file";
        const pngImage = await this.downloadThumbnail(token, url);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Downloaded ${size}Thumbnail ${thumbnailId} for iModel ${imodelId}`);
        return pngImage;
    }
}
exports.ThumbnailHandler = ThumbnailHandler;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Users_1 = __webpack_require__(183);
const index_1 = __webpack_require__(69);
const bentleyjs_core_1 = __webpack_require__(0);
const loggingCategory = "imodeljs-clients.imodelhub";
/** User Statistics */
let UserStatistics = class UserStatistics extends Users_1.UserInfo {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.BriefcasesCount")
], UserStatistics.prototype, "briefcasesCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.OwnedLocksCount")
], UserStatistics.prototype, "ownedLocksCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.PushedChangeSetsCount")
], UserStatistics.prototype, "pushedChangeSetsCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.LastChangeSetPushDate")
], UserStatistics.prototype, "lastChangeSetPushDate", void 0);
UserStatistics = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.UserInfo", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], UserStatistics);
exports.UserStatistics = UserStatistics;
/**
 * Query object for getting User Statistics. You can use this to modify the query.
 * @see UserStatisticsHandler.get()
 */
class UserStatisticsQuery extends index_1.InstanceIdQuery {
    /**
     * Constructor for UserStatisticsQuery.
     */
    constructor() {
        super();
        this.statisticsPrefix = "HasStatistics-forward-Statistics";
        this.queriedByIds = false;
        this.select(`*`);
    }
    /**
     * Query User Statistics by ids.
     * @param ids Ids of the users.
     * @returns This query.
     */
    byIds(ids) {
        if (ids.length < 1) {
            throw index_1.IModelHubRequestError.invalidArgument("ids");
        }
        let filter = "$id+in+[";
        ids.forEach((id, index) => {
            if (index > 0)
                filter += ",";
            filter += `'${id}'`;
        });
        filter += "]";
        this.addFilter(filter);
        this.queriedByIds = true;
        return this;
    }
    /** Select all statistics */
    selectAll() {
        return this.addSelect(`${this.statisticsPrefix}.*`);
    }
    /** Select Briefcases count */
    selectBriefcasesCount() {
        return this.addSelect(`${this.statisticsPrefix}.BriefcasesCount`);
    }
    /** Select pushed ChangeSets count */
    selectPushedChangeSetsCount() {
        return this.addSelect(`${this.statisticsPrefix}.PushedChangeSetsCount`);
    }
    /** Select Owned locks count */
    selectOwnedLocksCount() {
        return this.addSelect(`${this.statisticsPrefix}.OwnedLocksCount`);
    }
    /** Select last ChangeSet push date count */
    selectLastChangeSetPushDate() {
        return this.addSelect(`${this.statisticsPrefix}.LastChangeSetPushDate`);
    }
    /** Returns whether was object queried by ids or no */
    isQueriedByIds() {
        return this.queriedByIds;
    }
}
exports.UserStatisticsQuery = UserStatisticsQuery;
class UserStatisticsHandler {
    /**
     * Constructor for UserStatistics. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for UserStatistics requests.
     * @param imodelId Id of the iModel.
     * @param userId Id of the user.
     */
    getRelativeUrl(imodelId, userId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/UserInfo/${userId ? userId : ""}`;
    }
    /**
     * Gets users statistics.
     * @param token Delegation token of the authorized user.
     * @param iModelId Id of the iModel.
     * @param query Object used to modify results of this query.
     */
    async get(token, iModelId, query = new UserStatisticsQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying user statistics for iModel ${iModelId}`);
        // if there are no specific selects defined, select all statistics
        if (query.getQueryOptions().$select === "*") {
            query.selectAll();
        }
        let userStatistics;
        if (query.isQueriedByIds()) {
            userStatistics = await this._handler.postQuery(UserStatistics, token, this.getRelativeUrl(iModelId), query.getQueryOptions());
        }
        else {
            userStatistics = await this._handler.getInstances(UserStatistics, token, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${userStatistics.length} user statistics for iModel ${iModelId}`);
        return userStatistics;
    }
}
exports.UserStatisticsHandler = UserStatisticsHandler;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class IModelAccessContext {
}
exports.IModelAccessContext = IModelAccessContext;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Client_1 = __webpack_require__(68);
/**
 * Client wrapper to IModel Web Service
 */
class IModelWebNavigatorClient extends Client_1.Client {
    /**
     * Creates an instance of IModelWebNavigatorClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return IModelWebNavigatorClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return IModelWebNavigatorClient.defaultUrlDescriptor[this.deploymentEnv];
    }
}
IModelWebNavigatorClient.searchKey = "iModelWeb.Url";
IModelWebNavigatorClient.defaultUrlDescriptor = {
    DEV: "https://dev-connect-imodelweb.bentley.com",
    QA: "https://qa-connect-imodelweb.bentley.com",
    PROD: "https://connect-imodelweb.bentley.com",
    PERF: "https://connect-imodelweb.bentley.com",
};
exports.IModelWebNavigatorClient = IModelWebNavigatorClient;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const IModelBankHandler_1 = __webpack_require__(309);
const IModelClient_1 = __webpack_require__(114);
const UrlFileHandler_1 = __webpack_require__(115);
const __1 = __webpack_require__(18);
function constructUrlFileHandler() {
    return __1.Config.isBrowser() ? undefined : new UrlFileHandler_1.UrlFileHandler();
}
/** Class that allows access to different iModel Hub class handlers.
 * Handlers should be accessed through an instance of this class, rather than constructed directly.
 */
class IModelBankClient extends IModelClient_1.IModelClient {
    /**
     * Creates an instance of IModelBankClient.
     * @param url Url to iModel Bank instance.
     */
    constructor(url, deploymentEnv) {
        super(new IModelBankHandler_1.IModelBankHandler(url), deploymentEnv, constructUrlFileHandler());
    }
}
exports.IModelBankClient = IModelBankClient;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2017 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const IModelBankClient_1 = __webpack_require__(188);
const IModelAccessContext_1 = __webpack_require__(186);
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"; // (needed temporarily to use self-signed cert to communicate with iModelBank via https)
class IModelBankAccessContext extends IModelAccessContext_1.IModelAccessContext {
    constructor(iModelId, url, env) {
        super();
        this._iModelId = iModelId;
        this._client = new IModelBankClient_1.IModelBankClient(url, env);
        this._url = url;
        this._env = env;
    }
    get client() { return this._client; }
    toJson() {
        return {
            imodeljsCoreClientsIModelBankAccessContext: {
                iModelId: this._iModelId,
                url: this._url,
                env: this._env,
            },
        };
    }
    static fromJson(obj) {
        const props = obj.imodeljsCoreClientsIModelBankAccessContext;
        return new IModelBankAccessContext(props.iModelId, props.url, props.env);
    }
    /** Store the definition of this context as a string that can be used as the contextId property of an IModelToken */
    toIModelTokenContextId() {
        return JSON.stringify(this.toJson());
    }
    /** Create a IModelBankAccessContext from the contextId property of an IModelToken. BriefcaseManager should call this. */
    static fromIModelTokenContextId(contextStr) {
        if (!contextStr.startsWith("{\"imodeljsCoreClientsIModelBankAccessContext\":"))
            return undefined;
        return this.fromJson(JSON.parse(contextStr));
    }
}
exports.IModelBankAccessContext = IModelBankAccessContext;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const EventController_1 = __webpack_require__(191);
const IModelApp_1 = __webpack_require__(5);
const IModelConnection_1 = __webpack_require__(120);
const UpdatePlan_1 = __webpack_require__(213);
const ModelState_1 = __webpack_require__(76);
const WebMercatorTileTree_1 = __webpack_require__(341);
/**
 * The ViewManager holds the list of opened views, plus the *selected view*. It also provides notifications of view open/close and suspend/resume.
 * Applications must call [[addViewport]] when new Viewports that should be associated with user events are created.
 *
 * A single ViewManager is created when [[IModelApp.startup]] is called. It can be accessed via the static member [[IModelApp.viewManager]].
 */
class ViewManager {
    constructor() {
        this.inDynamicsMode = false;
        this._viewports = [];
        this._invalidateScenes = false;
        this._skipSceneCreation = false;
        /** Called after the selected view changes.
         * @param old Previously selected viewport.
         * @param current Currently selected viewport.
         */
        this.onSelectedViewportChanged = new bentleyjs_core_1.BeEvent();
        /** Called after a view is opened. This can happen when the iModel is first opened or when a user opens a closed view. */
        this.onViewOpen = new bentleyjs_core_1.BeEvent();
        /** Called after a view is closed. This can happen when the iModel is closed or when a user closes an open view. */
        this.onViewClose = new bentleyjs_core_1.BeEvent();
        /** Called after a view is suspended. This can happen when the application is minimized. */
        this.onViewSuspend = new bentleyjs_core_1.BeEvent();
        /**
         * Called after a suspended view is resumed. This can happen when a minimized application is restored
         * or, on a tablet, when the application is moved to the foreground.
         */
        this.onViewResume = new bentleyjs_core_1.BeEvent();
        /** Called when rendering a frame to allow decorations to be added */
        this.onDecorate = new bentleyjs_core_1.BeEvent();
    }
    onInitialized() {
        const models = IModelConnection_1.IModelConnection.Models;
        models.registerClass(ModelState_1.SpatialModelState.getClassFullName(), ModelState_1.SpatialModelState);
        models.registerClass("BisCore:PhysicalModel", ModelState_1.SpatialModelState);
        models.registerClass("BisCore:SpatialLocationModel", ModelState_1.SpatialModelState);
        models.registerClass(ModelState_1.DrawingModelState.getClassFullName(), ModelState_1.DrawingModelState);
        models.registerClass(ModelState_1.SectionDrawingModelState.getClassFullName(), ModelState_1.SectionDrawingModelState);
        models.registerClass(ModelState_1.SheetModelState.getClassFullName(), ModelState_1.SheetModelState);
        models.registerClass(WebMercatorTileTree_1.WebMercatorModelState.getClassFullName(), WebMercatorTileTree_1.WebMercatorModelState);
    }
    endDynamicsMode() {
        if (!this.inDynamicsMode)
            return;
        this.inDynamicsMode = false;
        const cursorVp = IModelApp_1.IModelApp.toolAdmin.getCursorView();
        if (cursorVp)
            cursorVp.changeDynamics(undefined);
        for (const vp of this._viewports) {
            if (vp !== cursorVp)
                vp.changeDynamics(undefined);
        }
    }
    beginDynamicsMode() { this.inDynamicsMode = true; }
    doesHostHaveFocus() { return document.hasFocus(); }
    isInfoWindowUp() { return false; } // NEEDS_WORK
    clearInfoWindow() { }
    showInfoWindow(_viewPt, _vp, _msg) {
        //   if (this.doesHostHaveFocus())
        //     this.getInfoWindow().show(viewPt, vp, msg);
    }
    clearSelectedView() {
        const previousVp = this.selectedView;
        this._selectedView = undefined;
        this.notifySelectedViewportChanged(previousVp, undefined);
    }
    setSelectedView(vp) {
        if (undefined === vp)
            vp = this.getFirstOpenView();
        if (vp === this.selectedView)
            return 0 /* SUCCESS */;
        if (undefined === vp) {
            this.clearSelectedView();
            return 32768 /* ERROR */;
        }
        const previousVp = this.selectedView;
        this._selectedView = vp;
        this.notifySelectedViewportChanged(previousVp, vp);
        IModelApp_1.IModelApp.toolAdmin.startDefaultTool(); // ###TODO not in native, where should defaultTool be called?
        return 0 /* SUCCESS */;
    }
    notifySelectedViewportChanged(previous, current) {
        IModelApp_1.IModelApp.toolAdmin.onSelectedViewportChanged(previous, current);
        this.onSelectedViewportChanged.raiseEvent(previous, current);
    }
    /** The "selected view" is the default for certain operations.  */
    get selectedView() { return this._selectedView; }
    /** Get the first opened view. */
    getFirstOpenView() { return this._viewports.length > 0 ? this._viewports[0] : undefined; }
    /**
     * Add a new Viewport to the list of opened views and create an EventController for it.
     * @param newVp the Viewport to add
     * @note raises onViewOpen event with newVp.
     * @note Does nothing if newVp is already present in the list.
     */
    addViewport(newVp) {
        for (const vp of this._viewports) {
            if (vp === newVp)
                return;
        } // make sure its not already in view array
        newVp.setEventController(new EventController_1.EventController(newVp)); // this will direct events to the viewport
        this._viewports.push(newVp);
        // See DgnClientFxViewport::Initialize()
        this.setSelectedView(newVp);
        // Start up the render loop if necessary.
        if (1 === this._viewports.length)
            IModelApp_1.IModelApp.toolAdmin.startEventLoop();
        this.onViewOpen.raiseEvent(newVp);
    }
    /**
     * Remove a Viewport from the list of opened views.
     * @param vp the Viewport to remove.
     * @return SUCCESS if vp was successfully removed, ERROR if it was not present.
     * @note raises onViewClose event with vp.
     */
    dropViewport(vp) {
        this.onViewClose.raiseEvent(vp);
        IModelApp_1.IModelApp.toolAdmin.onViewportClosed(vp); // notify tools that this view is no longer valid
        let didDrop = false;
        const vpList = this._viewports;
        for (let i = 0; i < vpList.length; ++i) {
            if (vpList[i] === vp) {
                vp.setEventController(undefined);
                vpList.splice(i, 1);
                didDrop = true;
                break;
            }
        }
        if (!didDrop)
            return 32768 /* ERROR */;
        if (this.selectedView === vp)
            this.setSelectedView(undefined);
        return 0 /* SUCCESS */;
    }
    forEachViewport(func) { this._viewports.forEach((vp) => func(vp)); }
    invalidateDecorationsAllViews() { this._viewports.forEach((vp) => vp.invalidateDecorations()); }
    onSelectionSetChanged(_iModel) {
        this._viewports.forEach((vp) => vp.view.setSelectionSetDirty());
        // for (auto & vp : m_viewports)
        // if (& vp -> GetViewController().GetDgnDb() == & db)
        //   vp -> GetViewControllerR().SetSelectionSetDirty();
    }
    invalidateViewportScenes() { this._viewports.forEach((vp) => vp.sync.invalidateScene()); }
    validateViewportScenes() { this._viewports.forEach((vp) => vp.sync.setValidScene()); }
    invalidateScenes() { this._invalidateScenes = true; }
    onNewTilesReady() { this.invalidateScenes(); }
    // Invoked by ToolAdmin event loop.
    renderLoop() {
        if (0 === this._viewports.length)
            return;
        if (this._skipSceneCreation)
            this.validateViewportScenes();
        else if (this._invalidateScenes)
            this.invalidateViewportScenes();
        this._invalidateScenes = false;
        const cursorVp = IModelApp_1.IModelApp.toolAdmin.getCursorView();
        const plan = new UpdatePlan_1.UpdatePlan();
        if (undefined === cursorVp || cursorVp.renderFrame(plan))
            for (const vp of this._viewports)
                if (vp !== cursorVp && !vp.renderFrame(plan))
                    break;
        // const tileGenerationSeconds = 5.0;
        // requests.requestMissing(BeDuration.fromSeconds(tileGenerationSeconds));
        this.processIdle();
    }
    processIdle() {
        // ###TODO: precompile shaders?
    }
    callDecorators(context) {
        IModelApp_1.IModelApp.accuSnap.decorate(context);
        IModelApp_1.IModelApp.tentativePoint.decorate(context);
        IModelApp_1.IModelApp.accuDraw.decorate(context);
        IModelApp_1.IModelApp.toolAdmin.decorate(context);
        context.viewport.decorate(context);
        this.onDecorate.raiseEvent(context);
    }
    setViewCursor(cursor) {
        if (cursor === this.cursor)
            return;
        this.cursor = cursor;
        if (undefined !== this.selectedView) {
            this.selectedView.setCursor(cursor);
        }
    }
}
exports.ViewManager = ViewManager;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(15);
const geometry_core_1 = __webpack_require__(1);
const IModelApp_1 = __webpack_require__(5);
class TouchPoint extends geometry_core_1.Point2d {
    constructor(x = 0, y = 0, pointId, downTime = 0) {
        super(x, y);
        this.pointId = pointId;
        this.downTime = downTime;
        this.initialX = this.x;
        this.initialY = this.y;
        this.previousTime = this.downTime;
        this.velocityX = 0;
        this.velocityY = 0;
        this.updated = false;
    }
    static touchExceedsThreshold(actualPixels, thresholdInches, vp) {
        const thresholdPixels = vp.pixelsFromInches(thresholdInches);
        return actualPixels >= thresholdPixels;
    }
    copyFrom(src) {
        this.x = src.x;
        this.y = src.y;
        this.initialX = src.initialX;
        this.initialY = src.initialY;
        this.pointId = src.pointId;
        this.downTime = src.downTime;
        this.previousTime = src.previousTime;
        this.velocityX = src.velocityX;
        this.velocityY = src.velocityY;
        this.updated = src.updated;
    }
    update(x, y, vp) {
        const threshold = 0.09 /* INITIAL_MOVE_THRESHOLD */;
        if (!this.updated && !TouchPoint.touchExceedsThreshold(Math.abs(x - this.initialX), threshold, vp) && !TouchPoint.touchExceedsThreshold(Math.abs(y - this.initialY), threshold, vp))
            return false;
        const current = Date.now();
        const timeDelta = current - this.previousTime;
        if (timeDelta > 2.0) {
            this.previousTime = current;
            const xVelocity = (x - this.x) / timeDelta;
            const yVelocity = (y - this.y) / timeDelta;
            if (this.velocityX !== 0.0) {
                const oldFactor = 0.2;
                const currentFactor = 0.8;
                this.velocityX = oldFactor * this.velocityX + currentFactor * xVelocity;
                this.velocityY = oldFactor * this.velocityY + currentFactor * yVelocity;
            }
            else {
                this.velocityX = xVelocity;
                this.velocityY = yVelocity;
            }
        }
        this.updated = true;
        this.x = x;
        this.y = y;
        return true;
    }
}
/**
 * An EventController maps user input events from the canvas of a Viewport to the ToolAdmin so that tools can process them.
 * Viewports are assigned an EventController when they are registered with ViewManager.addViewport, and they are destroyed with
 * ViewManager.dropViewport.
 */
class EventController {
    constructor(vp) {
        this.vp = vp;
        this.touchPoints = [];
        this.touchQueue = [];
        this.previousNumberTouches = 0;
        this.firstDown = new TouchPoint();
        this.firstTap1 = new TouchPoint(); // 1- and 2-finger taps
        this.firstTap2 = new TouchPoint(); // 2-finger taps only
        this.secondTap1 = new TouchPoint(); // 1- and 2-finger taps
        this.lastTouchEventTime = 0;
        this.touchTimer = Date.now();
        this.tapDownTime = 0;
        this.tapUpTime = 0;
        this.state = 0 /* Invalid */;
        this.interpretingDataButtonAsTouch = false;
        this.endGestureId = 0 /* None */;
        this.removals = [];
        this.registerListeners();
        this.initializeTouches();
    }
    destroy() {
        this.unregisterListeners();
    }
    unregisterListeners() {
        for (const removeFunc of this.removals) {
            removeFunc();
        }
        this.removals.length = 0;
    }
    registerListener(domType, element, callback) {
        const that = this;
        const listener = (e) => { callback.call(that, e); };
        element.addEventListener(domType, listener, false);
        this.removals.push(() => { element.removeEventListener(domType, listener, false); });
    }
    registerListeners() {
        const element = this.vp.canvas;
        if (!element)
            return;
        this.registerListener("mousedown", element, this.handleMouseDown);
        this.registerListener("mouseup", element, this.handleMouseUp);
        this.registerListener("mousemove", element, this.handleMouseMove);
        this.registerListener("mouseleave", element, this.handleMouseLeave);
        this.registerListener("wheel", element, this.handleMouseWheel);
        this.registerListener("touchstart", element, this.handleTouchStart);
        this.registerListener("touchend", element, this.handleTouchEnd);
        this.registerListener("touchmove", element, this.handleTouchMove);
        this.registerListener("touchcancel", element, this.handleTouchCancel);
        element.oncontextmenu = () => false;
        element.onselectstart = () => false;
    }
    recordShiftKey() { IModelApp_1.IModelApp.toolAdmin.currentInputState.setKeyQualifier(4 /* Shift */, true); }
    recordControlKey() { IModelApp_1.IModelApp.toolAdmin.currentInputState.setKeyQualifier(1 /* Control */, true); }
    clearKeyboardModifiers() { IModelApp_1.IModelApp.toolAdmin.currentInputState.clearKeyQualifiers(); }
    handleMiddleDown(pos) { IModelApp_1.IModelApp.toolAdmin.onMiddleButtonDown(this.vp, pos); }
    handleMiddleUp(pos) { IModelApp_1.IModelApp.toolAdmin.onMiddleButtonUp(this.vp, pos); }
    handleLeftDown(pos) { IModelApp_1.IModelApp.toolAdmin.onDataButtonDown(this.vp, pos, 1 /* Mouse */); }
    handleLeftUp(pos) { IModelApp_1.IModelApp.toolAdmin.onDataButtonUp(this.vp, pos, 1 /* Mouse */); }
    handleRightDown(pos) { IModelApp_1.IModelApp.toolAdmin.onResetButtonDown(this.vp, pos); }
    handleRightUp(pos) { IModelApp_1.IModelApp.toolAdmin.onResetButtonUp(this.vp, pos); }
    getMouseButtonHandler(button, isDown) {
        switch (button) {
            case 0 /* LEFT */: return isDown ? this.handleLeftDown : this.handleLeftUp;
            case 1 /* MIDDLE */: return isDown ? this.handleMiddleDown : this.handleMiddleUp;
            case 2 /* RIGHT */: return isDown ? this.handleRightDown : this.handleRightUp;
            default: return undefined;
        }
    }
    recordKeyboardModifiers(ev) {
        this.clearKeyboardModifiers();
        if (ev.shiftKey)
            this.recordShiftKey();
        if (ev.ctrlKey)
            this.recordControlKey();
    }
    getPosition(ev, result) {
        const rect = this.vp.getClientRect();
        return geometry_core_1.Point2d.createFrom({ x: ev.clientX - rect.left, y: ev.clientY - rect.top }, result);
    }
    handleMouseUpDown(ev, isDown) {
        const handler = this.getMouseButtonHandler(ev.button, isDown);
        if (!handler)
            return;
        this.recordKeyboardModifiers(ev);
        const pos = this.getPosition(ev);
        handler.call(this, pos);
        ev.preventDefault();
    }
    handleMouseDown(ev) { this.handleMouseUpDown(ev, true); }
    handleMouseUp(ev) { this.handleMouseUpDown(ev, false); }
    handleMouseMove(ev) {
        ev.preventDefault();
        this.recordKeyboardModifiers(ev);
        // catch exceptions caused by aborting previous snap attempts
        IModelApp_1.IModelApp.toolAdmin.onMouseMotion(this.vp, this.getPosition(ev), 1 /* Mouse */).catch((_error) => { });
    }
    handleMouseLeave(ev) {
        IModelApp_1.IModelApp.toolAdmin.onMouseLeave(this.vp);
        ev.preventDefault();
    }
    handleMouseWheel(ev) {
        this.recordKeyboardModifiers(ev);
        let delta;
        const deltaMode = ev.deltaMode;
        if (deltaMode === ev.DOM_DELTA_PIXEL)
            delta = -ev.deltaY;
        else if (deltaMode === ev.DOM_DELTA_LINE)
            delta = -ev.deltaY * 40;
        else
            delta = -ev.deltaY * 120;
        if (!delta)
            return;
        IModelApp_1.IModelApp.toolAdmin.onWheel(this.vp, delta, IModelApp_1.IModelApp.toolAdmin.currentInputState.lastMotion);
        ev.preventDefault();
    }
    initializeTouches() {
        this.tapDownTime = 0;
        this.tapUpTime = 0;
        this.touchPoints.length = 0;
        this.state = 1 /* Initial */;
        this.interpretingDataButtonAsTouch = false;
        this.endGestureId = 0 /* None */;
    }
    pushTouch(info) {
        // Try to replace the last entry in the queue
        if (this.touchQueue.length === 0 || !this.tryReplaceTouch(this.touchQueue[this.touchQueue.length - 1], info))
            this.touchQueue.push(info.clone());
    }
    tryReplaceTouch(existing, replacement) {
        if (existing.isEndGesture)
            return false;
        const gestureId = existing.gestureId;
        if (replacement.gestureId !== gestureId)
            return false;
        switch (gestureId) {
            case 2 /* SingleFingerMove */:
            case 1 /* MultiFingerMove */:
                if (existing.numberTouches === replacement.numberTouches && existing.previousNumberTouches === replacement.previousNumberTouches) {
                    replacement.copyFrom(existing);
                    return true;
                }
                break;
        }
        return false;
    }
    processTouchEvent(vp) {
        const len = this.touchQueue.length;
        if (len > 0) {
            for (let i = 0; i < len; i++)
                this.dispatchTouchEvent(this.touchQueue[i], vp);
            this.touchQueue.length = 0;
        }
    }
    dispatchTouchEvent(info, vp) {
        if (info.isEndGesture) {
            IModelApp_1.IModelApp.toolAdmin.onEndGesture(vp, info);
            return;
        }
        switch (info.gestureId) {
            case 1 /* MultiFingerMove */: return IModelApp_1.IModelApp.toolAdmin.onMultiFingerMove(vp, info);
            case 2 /* SingleFingerMove */: return IModelApp_1.IModelApp.toolAdmin.onSingleFingerMove(vp, info);
            case 3 /* TwoFingerTap */: return IModelApp_1.IModelApp.toolAdmin.onTwoFingerTap(vp, info);
            case 4 /* PressAndTap */: return IModelApp_1.IModelApp.toolAdmin.onPressAndTap(vp, info);
            case 5 /* SingleTap */: return IModelApp_1.IModelApp.toolAdmin.onSingleTap(vp, info);
            case 6 /* DoubleTap */: return IModelApp_1.IModelApp.toolAdmin.onDoubleTap(vp, info);
            case 7 /* LongPress */: return IModelApp_1.IModelApp.toolAdmin.onLongPress(vp, info);
        }
    }
    getPreviousNumberTouches(update) {
        const val = this.previousNumberTouches;
        if (update)
            this.previousNumberTouches = this.touchPoints.length;
        return val;
    }
    setTouchState(newState) {
        //  reportStateTransition(newState, this.state);
        if (0 /* Invalid */ === newState) {
            if (0 !== this.endGestureId && (0 !== this.touchPoints.length || 0 !== this.previousNumberTouches))
                this.sendEndGestureEvent(this.endGestureId, this.touchPoints[0].x, this.touchPoints[0].y, this.touchPoints, this.interpretingDataButtonAsTouch);
            this.previousNumberTouches = 0;
        }
        if (1 /* Initial */ === newState || 0 /* Invalid */ === newState)
            this.initializeTouches();
        this.state = newState;
    }
    initGestureInfo(gestureId, centerX, centerY, distance, points, isEnding, isFromMouse) {
        const info = new Tool_1.GestureInfo();
        info.init(gestureId, centerX, centerY, distance, points, isEnding, isFromMouse, this.getPreviousNumberTouches(true));
        return info;
    }
    sendGestureEvent(info) {
        this.pushTouch(info);
    }
    sendEndGestureEvent(gestureId, x, y, points, isFromMouse) {
        const info = this.initGestureInfo(gestureId, x, y, 0.0, points, true, isFromMouse);
        this.sendGestureEvent(info);
    }
    touchCanceled() { this.setTouchState(0 /* Invalid */); }
    onTouchEvent() { this.lastTouchEventTime = Date.now(); }
    getTouchPoint(id) {
        for (const cur of this.touchPoints) {
            if (cur.pointId === id)
                return cur;
        }
        return undefined;
    }
    removeTouchPoint(id) {
        for (let i = 0; i < this.touchPoints.length; i++) {
            const cur = this.touchPoints[i];
            if (cur.pointId === id) {
                this.touchPoints.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    touchDown(x, y, id, numberFingers, interpretingDataButtonAsTouch) {
        this.onTouchEvent();
        if (numberFingers <= this.touchPoints.length) {
            // We lost some transition. Doing nothing is better than doing the wrong thins.
            this.setTouchState(0 /* Invalid */);
        }
        if (this.state === 0 /* Invalid */)
            this.setTouchState(1 /* Initial */);
        if (interpretingDataButtonAsTouch)
            this.interpretingDataButtonAsTouch = true;
        const eventTime = Date.now();
        this.touchPoints.push(new TouchPoint(x, y, id, eventTime));
        if (this.touchPoints.length === 1)
            this.firstDown.copyFrom(this.touchPoints[0]);
        switch (this.state) {
            case 1 /* Initial */:
                this.previousNumberTouches = 0;
                this.tapDownTime = eventTime;
                this.tapUpTime = 4294967295 /* TAP_INVALID_UP_TIME */;
                this.setTouchState(2 /* FirstDown */);
                break;
            case 2 /* FirstDown */:
                this.setTouchState(3 /* SecondDown */);
                break;
            case 3 /* SecondDown */:
                this.setTouchState(7 /* MovePending */);
                break;
            case 4 /* TapPending */:
                this.setTouchState(5 /* SecondTapDown */);
                break;
            case 5 /* SecondTapDown */:
                this.setTouchState(0 /* Invalid */);
                break;
            case 6 /* SecondDownOneUp */:
                this.setTouchState(8 /* Moving */);
                break;
            case 8 /* Moving */:
                break; // no state changes once we start moving.
            case 9 /* InLongPress */:
                this.firstTap1.copyFrom(this.touchPoints[0]);
                this.setTouchState(10 /* InLongPressAwaitingTap */);
                break;
            case 10 /* InLongPressAwaitingTap */:
                this.setTouchState(0 /* Invalid */);
                break;
        }
    }
    touchUp(id) {
        this.onTouchEvent();
        const interpretingDataButtonAsTouch = this.interpretingDataButtonAsTouch;
        const upPoint = this.getTouchPoint(id);
        if (!upPoint)
            this.setTouchState(0 /* Invalid */);
        const handlerState = this.state;
        if (0 /* Invalid */ === handlerState)
            return;
        const eventTime = Date.now();
        switch (handlerState) {
            case 1 /* Initial */:
            case 4 /* TapPending */:
                break;
            case 2 /* FirstDown */:
                const interval1 = eventTime - this.tapDownTime;
                if (interval1 < 800 /* TAP_LIMIT */) {
                    this.setTouchState(4 /* TapPending */);
                    this.tapUpTime = eventTime;
                    this.firstTap1.copyFrom(upPoint);
                }
                else {
                    this.setTouchState(1 /* Initial */);
                }
                break;
            case 5 /* SecondTapDown */:
                const interval2 = eventTime - this.tapDownTime;
                if (interval2 < 800 /* TAP_LIMIT */) {
                    this.tapUpTime = eventTime;
                    this.secondTap1.copyFrom(upPoint);
                    this.handleTaps(true);
                }
                this.setTouchState(1 /* Initial */);
                break;
            case 3 /* SecondDown */:
                const interval3 = eventTime - this.tapDownTime;
                if (interval3 > 800 /* TAP_LIMIT */) {
                    this.setTouchState(0 /* Invalid */);
                    break;
                }
                this.firstTap1.copyFrom(upPoint);
                this.setTouchState(6 /* SecondDownOneUp */);
                break;
            case 6 /* SecondDownOneUp */:
                const interval = eventTime - this.tapDownTime;
                if (interval > 800 /* TAP_LIMIT */) {
                    this.setTouchState(0 /* Invalid */);
                    break;
                }
                this.firstTap2.copyFrom(upPoint);
                this.handle2FingerTap();
                this.setTouchState(1 /* Initial */);
                break;
            case 7 /* MovePending */:
                if (this.touchPoints.length === 1)
                    this.setTouchState(1 /* Initial */);
                break;
            case 8 /* Moving */:
                if (this.touchPoints.length === 1) {
                    const endGestureId1 = this.endGestureId;
                    const touchPoint1 = this.touchPoints[0];
                    this.setTouchState(1 /* Initial */);
                    this.sendEndGestureEvent(endGestureId1, touchPoint1.x, touchPoint1.y, this.touchPoints, interpretingDataButtonAsTouch);
                }
                break;
            case 9 /* InLongPress */:
                const endGestureId = (4 /* PressAndTap */ !== this.endGestureId) ? 7 /* LongPress */ : this.endGestureId;
                const touchPoint = this.touchPoints[0];
                this.setTouchState(1 /* Initial */);
                this.sendEndGestureEvent(endGestureId, touchPoint.x, touchPoint.y, this.touchPoints, interpretingDataButtonAsTouch);
                break;
            case 10 /* InLongPressAwaitingTap */:
                if (upPoint.pointId === this.firstTap1.pointId) {
                    this.setTouchState(0 /* Invalid */);
                    break;
                }
                this.handlePressAndTap();
                this.setTouchState(9 /* InLongPress */);
                this.endGestureId = 4 /* PressAndTap */;
                break;
        }
        this.removeTouchPoint(id);
    }
    touchMove(x, y, id) {
        this.onTouchEvent();
        const p = this.getTouchPoint(id);
        if (!p)
            this.setTouchState(0 /* Invalid */);
        if (0 /* Invalid */ === this.state)
            return;
        if (!p.update(x, y, this.vp))
            return;
        switch (this.state) {
            case 1 /* Initial */:
            case 4 /* TapPending */:
                break;
            case 6 /* SecondDownOneUp */:
            case 7 /* MovePending */:
            case 2 /* FirstDown */:
            case 3 /* SecondDown */:
                this.setTouchState(8 /* Moving */);
                break;
            case 5 /* SecondTapDown */:
                this.setTouchState(8 /* Moving */);
                break;
            case 8 /* Moving */:
            case 9 /* InLongPress */:
                break;
            case 10 /* InLongPressAwaitingTap */:
                this.setTouchState(0 /* Invalid */);
                break;
        }
        const newState = this.state;
        if (9 /* InLongPress */ === newState || 8 /* Moving */ === newState)
            this.handleMove(this.touchPoints);
    }
    tryLongPress() {
        if (2 /* FirstDown */ !== this.state && this.touchPoints.length !== 1)
            return false;
        if ((Date.now() - this.touchPoints[0].previousTime) < 500 /* LONG_PRESS_LIMIT */)
            return false;
        this.sendLongPressEvent(this.touchPoints, this.interpretingDataButtonAsTouch);
        return true;
    }
    sendLongPressEvent(touchPoints, isFromMouse) {
        const info = this.initGestureInfo(7 /* LongPress */, touchPoints[0].initialX, touchPoints[0].initialY, 0.0, touchPoints, false, isFromMouse);
        this.sendGestureEvent(info);
    }
    updateTouches() {
        const now = Date.now();
        if ((now - this.touchTimer) >= 0.016 /* TICK */) {
            this.touchTimer = now;
            this.touchTimerExpired();
        }
    }
    touchTimerExpired() {
        this.processTouchEvent(this.vp);
        switch (this.state) {
            case 2 /* FirstDown */:
                if (this.tryLongPress())
                    this.setTouchState(9 /* InLongPress */);
                break;
            case 4 /* TapPending */:
                if (this.handleTaps(false))
                    this.setTouchState(1 /* Initial */);
                break;
        }
    }
    handle2FingerTap() {
        const x = (this.firstTap1.x + this.firstTap2.x) / 2;
        const y = (this.firstTap1.y + this.firstTap2.y) / 2;
        this.sendTapEvent(x, y, 2 /* TwoFingerSingleTap */, this.touchPoints, this.interpretingDataButtonAsTouch);
    }
    sendTapEvent(x, y, eventType, touchPoints, isFromMouse) {
        let gestureId = 5 /* SingleTap */;
        switch (eventType) {
            case 1 /* OneFingerDoubleTap */:
                gestureId = 6 /* DoubleTap */;
                break;
            case 2 /* TwoFingerSingleTap */:
                gestureId = 3 /* TwoFingerTap */;
                break;
        }
        const info = this.initGestureInfo(gestureId, x, y, 0.0, touchPoints, false, isFromMouse);
        this.sendGestureEvent(info);
    }
    handlePressAndTap() {
        this.sendPressAndTapEvent(this.touchPoints, this.interpretingDataButtonAsTouch);
    }
    sendPressAndTapEvent(points, isFromMouse) {
        const anchor = points[0];
        const tap = points[1];
        const tapDistance = tap.distance(anchor);
        const info = this.initGestureInfo(4 /* PressAndTap */, anchor.x, anchor.y, tapDistance, points, false, isFromMouse);
        this.sendGestureEvent(info);
    }
    handleTap(x, y, isDouble) {
        this.sendTapEvent(x, y, isDouble ? 1 /* OneFingerDoubleTap */ : 0 /* OneFingerSingleTap */, this.touchPoints, this.interpretingDataButtonAsTouch);
    }
    handleTaps(allowDoubleTap) {
        if (!allowDoubleTap) {
            const interval = Date.now() - this.tapUpTime;
            if (interval < 200 /* TAP_CONFIRM_SINGLE_LIMIT */)
                return false;
            this.handleTap(this.firstTap1.x, this.firstTap1.y, false);
            return true;
        }
        const d = this.firstTap1.distance(this.secondTap1);
        if (TouchPoint.touchExceedsThreshold(d, 0.25 /* DOUBLE_TAP_DIST_THRESHOLD */, this.vp)) {
            this.handleTap(this.firstTap1.x, this.firstTap1.y, false);
            this.handleTap(this.secondTap1.x, this.secondTap1.y, false);
        }
        else {
            this.handleTap(this.firstTap1.x, this.firstTap1.y, true);
        }
        return true;
    }
    handleMultiFingerMove(points) {
        if (points.length < 2)
            return false;
        if (2 /* SingleFingerMove */ === this.endGestureId)
            this.sendEndGestureEvent(this.endGestureId, this.touchPoints[0].x, this.touchPoints[0].y, this.touchPoints, this.interpretingDataButtonAsTouch);
        const p0 = points[0];
        const p1 = points[1];
        const pinchDistance = p0.distance(p1);
        const cx = (p0.x + p1.x) / 2;
        const cy = (p0.y + p1.y) / 2;
        this.sendMultiFingerMoveEvent(cx, cy, pinchDistance, points, this.interpretingDataButtonAsTouch);
        this.endGestureId = 1 /* MultiFingerMove */;
        return true;
    }
    sendMultiFingerMoveEvent(centerX, centerY, distance, points, isFromMouse) {
        const info = this.initGestureInfo(1 /* MultiFingerMove */, centerX, centerY, distance, points, false, isFromMouse);
        this.sendGestureEvent(info);
    }
    handleSingleFingerMove(points) {
        if (1 !== points.length)
            return false;
        if (1 /* MultiFingerMove */ === this.endGestureId)
            this.sendEndGestureEvent(this.endGestureId, this.touchPoints[0].x, this.touchPoints[0].y, this.touchPoints, this.interpretingDataButtonAsTouch);
        if (0 === this.previousNumberTouches) {
            const startPoint = [this.firstDown];
            this.sendSingleFingerMoveEvent(startPoint, this.interpretingDataButtonAsTouch);
        }
        this.sendSingleFingerMoveEvent(points, this.interpretingDataButtonAsTouch);
        this.endGestureId = 2 /* SingleFingerMove */;
        return true;
    }
    sendSingleFingerMoveEvent(points, isFromMouse) {
        const info = this.initGestureInfo(2 /* SingleFingerMove */, points[0].x, points[0].y, 1.0, points, false, isFromMouse);
        this.sendGestureEvent(info);
    }
    handleMove(points) {
        return this.handleSingleFingerMove(points) || this.handleMultiFingerMove(points);
    }
    processTouches(ev, func) {
        const touches = ev.changedTouches;
        const numFingers = touches.length;
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < touches.length; ++i) {
            const touch = touches[i];
            const pos = this.getPosition(touch);
            func(touch.identifier, numFingers, pos.x, pos.y);
        }
        ev.preventDefault();
    }
    handleTouchStart(ev) {
        this.processTouches(ev, (id, num, x, y) => { this.touchDown(x, y, id, num, false); });
    }
    handleTouchEnd(ev) {
        this.processTouches(ev, (id, _num, _x, _y) => { this.touchUp(id); });
    }
    handleTouchMove(ev) {
        this.processTouches(ev, (id, _num, x, y) => { this.touchMove(x, y, id); });
    }
    handleTouchCancel(_ev) {
        this.touchCanceled();
    }
}
exports.EventController = EventController;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Codes */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
/** A three part [BIS Code]($docs/bis/intro/codes) that identifies an Element */
class Code {
    constructor(val) {
        this.spec = new bentleyjs_core_1.Id64(val.spec);
        this.scope = bentleyjs_core_1.JsonUtils.asString(val.scope, "");
        this.value = bentleyjs_core_1.JsonUtils.asString(val.value);
    }
    /** Create an empty, non-unique code with no special meaning. */
    static createEmpty() { const id = new bentleyjs_core_1.Id64([1, 0]); return new Code({ spec: id, scope: id.value }); }
    static fromJSON(json) { return json ? new Code(json) : Code.createEmpty(); }
    getValue() { return this.value ? this.value : ""; }
    equals(other) { return this.spec.equals(other.spec) && this.scope === other.scope && this.value === other.value; }
}
exports.Code = Code;
/**
 * A [Code Specification]($docs/bis/intro/glossary#codespec) captures the rules for encoding and decoding significant business information into
 * and from a Code (string). This specification is used to generate and validate Codes.
 *
 * A CodeSpec defines the format of a Code for a certain type of Element in an IModel.
 * A CodeSpec can identify an external system that maintains and/or assigns Codes.
 */
class CodeSpec {
    constructor(iModel, id, name, specScopeType, scopeReq, properties) {
        this.iModel = iModel;
        this.id = id;
        this.name = name;
        this.specScopeType = specScopeType;
        this.scopeReq = (undefined !== scopeReq) ? scopeReq : 1 /* ElementId */;
        this.properties = properties;
    }
    isValid() { return this.id.isValid(); }
}
exports.CodeSpec = CodeSpec;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WireFormats */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const IModelError_1 = __webpack_require__(16);
/** The Id and relationship class of an Element that is somehow related to another Element */
class RelatedElement {
    constructor(props) { this.id = bentleyjs_core_1.Id64.fromJSON(props.id); this.relClassName = props.relClassName; }
    static fromJSON(json) { return json ? new RelatedElement(json) : undefined; }
    /** Accept the value of a navigation property that might be in the shortened format of just an id or might be in the full RelatedElement format. */
    static idFromJson(json) {
        if ((typeof json === "object") && ("id" in json)) {
            const r = RelatedElement.fromJSON(json);
            if (r === undefined)
                throw new IModelError_1.IModelError(65539 /* BadArg */);
            return r.id;
        }
        return bentleyjs_core_1.Id64.fromJSON(json);
    }
}
exports.RelatedElement = RelatedElement;
/** A [RelatedElement]($common) relationship that describes the [TypeDefinitionElement]($backend) of an element. */
class TypeDefinition extends RelatedElement {
}
exports.TypeDefinition = TypeDefinition;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/** A position on the earth defined by longitude, latitude, and height above the WSG84 ellipsoid . */
class Cartographic {
    /**
     * @param longitude longitude, in radians.
     * @param latitude latitude, in radians.
     * @param height The height, in meters, above the ellipsoid.
     */
    constructor(longitude = 0, latitude = 0, height = 0) {
        this.longitude = longitude;
        this.latitude = latitude;
        this.height = height;
    }
    /**
     * Create a new Cartographic from longitude and latitude specified in radians.
     * @param longitude longitude, in radians.
     * @param latitude latitude, in radians.
     * @param height The height, in meters, above the ellipsoid.
     * @param result The object onto which to store the result.
     */
    static fromRadians(longitude, latitude, height = 0, result) {
        if (!result)
            return new Cartographic(longitude, latitude, height);
        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    }
    /**
     * Create a new Cartographic from longitude and latitude specified in degrees. The values in the resulting object will
     * be in radians.
     * @param longitude longitude, in degrees.
     * @param latitude latitude, in degrees.
     * @param height The height, in meters, above the ellipsoid.
     * @param result The object onto which to store the result.
     */
    static fromDegrees(longitude, latitude, height, result) {
        return Cartographic.fromRadians(geometry_core_1.Angle.degreesToRadians(longitude), geometry_core_1.Angle.degreesToRadians(latitude), height, result);
    }
    /**
     * Create a new Cartographic from longitude and latitude in [Angle]($geometry)s. The values in the resulting object will
     * be in radians.
     * @param longitude longitude.
     * @param latitude latitude.
     * @param height The height, in meters, above the ellipsoid.
     * @param result The object into which to store the result (optional)
     */
    static fromAngles(longitude, latitude, height, result) {
        return Cartographic.fromRadians(longitude.radians, latitude.radians, height, result);
    }
    /**
     * Creates a new Cartographic from an [ECEF](https://en.wikipedia.org/wiki/ECEF) position.
     * @param cartesian The position, in ECEF, to convert to cartographic representation.
     * @param [result] The object onto which to store the result.
     * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
     */
    static fromEcef(cartesian, result) {
        const oneOverRadii = Cartographic.wgs84OneOverRadii;
        const oneOverRadiiSquared = Cartographic.wgs84OneOverRadiiSquared;
        const centerToleranceSquared = Cartographic.wgs84CenterToleranceSquared;
        const p = Cartographic.scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, Cartographic.cartesianToCartographicP);
        if (!p)
            return undefined;
        const n = Cartographic.cartesianToCartographicN;
        Cartographic.multiplyComponents(p, oneOverRadiiSquared, n);
        Cartographic.normalize(n, n);
        const h = p.vectorTo(cartesian, Cartographic.cartesianToCartographicH);
        const longitude = Math.atan2(n.y, n.x);
        const latitude = Math.asin(n.z);
        const height = Math.sign(h.dotProduct(cartesian)) * h.magnitude();
        if (!result)
            return new Cartographic(longitude, latitude, height);
        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    }
    /** Duplicates a Cartographic. */
    clone(result) {
        if (!result)
            return new Cartographic(this.longitude, this.latitude, this.height);
        result.longitude = this.longitude;
        result.latitude = this.latitude;
        result.height = this.height;
        return result;
    }
    /** Return true if this Cartographic is the same as right */
    equals(right) {
        return (this === right) ||
            ((this.longitude === right.longitude) &&
                (this.latitude === right.latitude) &&
                (this.height === right.height));
    }
    /** Compares this Cartographic component-wise and returns true if they are within the provided epsilon, */
    equalsEpsilon(right, epsilon) {
        return (this === right) ||
            ((Math.abs(this.longitude - right.longitude) <= epsilon) &&
                (Math.abs(this.latitude - right.latitude) <= epsilon) &&
                (Math.abs(this.height - right.height) <= epsilon));
    }
    static normalize(cartesian, result) {
        const magnitude = cartesian.magnitude();
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        result.z = cartesian.z / magnitude;
    }
    static multiplyComponents(left, right, result) {
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        result.z = left.z * right.z;
    }
    static scalePoint(cartesian, scalar, result) {
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        result.z = cartesian.z * scalar;
    }
    static addPoints(left, right, result) {
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
    }
    /** Create a string representing this cartographic in the format '(longitude, latitude, height)'. */
    toString() { return "(" + this.longitude + ", " + this.latitude + ", " + this.height + ")"; }
    static scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {
        const positionX = cartesian.x;
        const positionY = cartesian.y;
        const positionZ = cartesian.z;
        const oneOverRadiiX = oneOverRadii.x;
        const oneOverRadiiY = oneOverRadii.y;
        const oneOverRadiiZ = oneOverRadii.z;
        const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
        const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
        const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
        // Compute the squared ellipsoid norm.
        const squaredNorm = x2 + y2 + z2;
        const ratio = Math.sqrt(1.0 / squaredNorm);
        // As an initial approximation, assume that the radial intersection is the projection point.
        const intersection = Cartographic.scaleToGeodeticSurfaceIntersection;
        Cartographic.scalePoint(cartesian, ratio, intersection);
        // If the position is near the center, the iteration will not converge.
        if (squaredNorm < centerToleranceSquared) {
            return !isFinite(ratio) ? undefined : geometry_core_1.Point3d.createFrom(intersection, result);
        }
        const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
        const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
        const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
        // Use the gradient at the intersection point in place of the true unit normal.
        // The difference in magnitude will be absorbed in the multiplier.
        const gradient = Cartographic.scaleToGeodeticSurfaceGradient;
        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;
        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;
        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;
        // Compute the initial guess at the normal vector multiplier, lambda.
        let lambda = (1.0 - ratio) * cartesian.magnitude() / (0.5 * gradient.magnitude());
        let correction = 0.0;
        let func;
        let denominator;
        let xMultiplier;
        let yMultiplier;
        let zMultiplier;
        let xMultiplier2;
        let yMultiplier2;
        let zMultiplier2;
        let xMultiplier3;
        let yMultiplier3;
        let zMultiplier3;
        do {
            lambda -= correction;
            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);
            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);
            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);
            xMultiplier2 = xMultiplier * xMultiplier;
            yMultiplier2 = yMultiplier * yMultiplier;
            zMultiplier2 = zMultiplier * zMultiplier;
            xMultiplier3 = xMultiplier2 * xMultiplier;
            yMultiplier3 = yMultiplier2 * yMultiplier;
            zMultiplier3 = zMultiplier2 * zMultiplier;
            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;
            // "denominator" here refers to the use of this expression in the velocity and acceleration
            // computations in the sections to follow.
            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
            const derivative = -2.0 * denominator;
            correction = func / derivative;
        } while (Math.abs(func) > 0.01);
        if (!result)
            return new geometry_core_1.Point3d(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
        result.x = positionX * xMultiplier;
        result.y = positionY * yMultiplier;
        result.z = positionZ * zMultiplier;
        return result;
    }
    /** Return an ECEF point from a Cartographic point */
    toEcef(result) {
        const cosLatitude = Math.cos(this.latitude);
        const scratchN = Cartographic.scratchN;
        const scratchK = Cartographic.scratchK;
        scratchN.x = cosLatitude * Math.cos(this.longitude);
        scratchN.y = cosLatitude * Math.sin(this.longitude);
        scratchN.z = Math.sin(this.latitude);
        Cartographic.normalize(scratchN, scratchN);
        Cartographic.multiplyComponents(Cartographic.wgs84RadiiSquared, scratchN, scratchK);
        const gamma = Math.sqrt(scratchN.dotProduct(scratchK));
        Cartographic.scalePoint(scratchK, 1.0 / gamma, scratchK);
        Cartographic.scalePoint(scratchN, this.height, scratchN);
        result = result ? result : new geometry_core_1.Point3d();
        Cartographic.addPoints(scratchK, scratchN, result);
        return result;
    }
}
Cartographic.cartesianToCartographicN = new geometry_core_1.Point3d();
Cartographic.cartesianToCartographicP = new geometry_core_1.Point3d();
Cartographic.cartesianToCartographicH = new geometry_core_1.Vector3d();
Cartographic.wgs84OneOverRadii = new geometry_core_1.Point3d(1.0 / 6378137.0, 1.0 / 6378137.0, 1.0 / 6356752.3142451793);
Cartographic.wgs84OneOverRadiiSquared = new geometry_core_1.Point3d(1.0 / (6378137.0 * 6378137.0), 1.0 / (6378137.0 * 6378137.0), 1.0 / (6356752.3142451793 * 6356752.3142451793));
Cartographic.wgs84RadiiSquared = new geometry_core_1.Point3d(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);
Cartographic.wgs84CenterToleranceSquared = 0.1;
Cartographic.scratchN = new geometry_core_1.Vector3d();
Cartographic.scratchK = new geometry_core_1.Vector3d();
Cartographic.scaleToGeodeticSurfaceIntersection = new geometry_core_1.Point3d();
Cartographic.scaleToGeodeticSurfaceGradient = new geometry_core_1.Point3d();
exports.Cartographic = Cartographic;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
/** Uncompressed bitmap image data */
class ImageBuffer {
    get numBytesPerPixel() { return ImageBuffer.getNumBytesPerPixel(this.format); }
    static getNumBytesPerPixel(format) {
        switch (format) {
            case 5 /* Alpha */: return 1;
            case 2 /* Rgb */: return 3;
            default: return 4;
        }
    }
    /** Get the height of this image in pixels. */
    get height() { return ImageBuffer.computeHeight(this.data, this.format, this.width); }
    static create(data, format, width) {
        return this.isValidData(data, format, width) ? new ImageBuffer(data, format, width) : undefined;
    }
    static isValidData(data, format, width) {
        const height = this.computeHeight(data, format, width);
        return width > 0 && height > 0 && Math.floor(width) === width && Math.floor(height) === height;
    }
    static computeHeight(data, format, width) {
        return data.length / (width * this.getNumBytesPerPixel(format));
    }
    constructor(data, format, width) {
        this.data = data;
        this.format = format;
        this.width = width;
    }
}
exports.ImageBuffer = ImageBuffer;
/** Returns whether the input is a power of two */
function isPowerOfTwo(num) { return 0 === (num & (num - 1)); }
exports.isPowerOfTwo = isPowerOfTwo;
/** Returns the first power-of-two value greater than or equal to the input */
function nextHighestPowerOfTwo(num) {
    --num;
    for (let i = 1; i < 32; i <<= 1)
        num = num | num >> i;
    return num + 1;
}
exports.nextHighestPowerOfTwo = nextHighestPowerOfTwo;
/** Image data encoded and compressed in either Jpeg or Png format. */
class ImageSource {
    constructor(data, format) {
        this.data = data;
        this.format = format;
    }
}
exports.ImageSource = ImageSource;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module iModels */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_clients_1 = __webpack_require__(18);
const IModelError_1 = __webpack_require__(16);
/** Option to specify the version of the iModel to be acquired and used */
class IModelVersion {
    constructor() { }
    /** Describes the first version of the iModel */
    static first() {
        const version = new IModelVersion();
        version._first = true;
        return version;
    }
    /** Describes the latest version of the iModel  */
    static latest() {
        const version = new IModelVersion();
        version._latest = true;
        return version;
    }
    /** Describes a version of the iModel by the last change set that needs
     * to be applied or merged to the iModel.
     * Note that all ChangeSets up to and and including the specified ChangeSet
     * needs to be applied.
     * If the changeSetId is an empty string, it is assumed to be the first version
     * before any change sets have been applied.
     */
    static asOfChangeSet(changeSetId) {
        const version = new IModelVersion();
        if (changeSetId === "") {
            version._first = true;
            return version;
        }
        version._afterChangeSetId = changeSetId;
        return version;
    }
    /** Describes a version of the iModel with the specified version name  */
    static named(versionName) {
        const version = new IModelVersion();
        version._versionName = versionName;
        return version;
    }
    /** Creates a version from an untyped JSON object */
    static fromJson(jsonObj) {
        const version = new IModelVersion();
        Object.assign(version, jsonObj);
        return version;
    }
    /** Returns true if this describes the first version */
    isFirst() { return !!this._first; }
    /** Returns true if this describes the latest version */
    isLatest() { return !!this._latest; }
    /** Returns the last change set id to be applied to the iModel
     * to get to this specified version. @see asOfChangeSet().
     * Note that this method does not attempt to resolve the change set
     * if this describes the first version, last version, named version, etc.
     * @see evaluateChangeSet() for those use cases.
     */
    getAsOfChangeSet() { return this._afterChangeSetId; }
    /** Returns the name of the version if this describes a named version. @see named() */
    getName() { return this._versionName; }
    /** Evaluate the ChangeSet Id corresponding to the version. All change sets up to and including
     * the returned ChangeSet Id need to be applied to update the iModel to this version.
     * Returns an empty string if this contains the first version (before any change sets). If the
     * version was already specified as of a ChangeSet, the method simply returns
     * that Id without any validation.
     */
    evaluateChangeSet(accessToken, iModelId, imodelClient) {
        if (this._first)
            return Promise.resolve("");
        if (this._afterChangeSetId) {
            return Promise.resolve(this._afterChangeSetId);
        }
        if (this._latest) {
            return IModelVersion.getLatestChangeSetId(imodelClient, accessToken, iModelId);
        }
        if (this._versionName) {
            return IModelVersion.getChangeSetFromNamedVersion(imodelClient, accessToken, iModelId, this._versionName);
        }
        return Promise.reject(new IModelError_1.IModelError(32768 /* ERROR */, "Invalid version"));
    }
    /** Gets the last change set that was applied to the imodel */
    static async getLatestChangeSetId(imodelClient, accessToken, iModelId) {
        const changeSets = await imodelClient.ChangeSets().get(accessToken, iModelId, new imodeljs_clients_1.ChangeSetQuery().top(1).latest());
        // todo: Need a more efficient iModel Hub API to get this information from the Hub.
        return (changeSets.length === 0) ? "" : changeSets[changeSets.length - 1].wsgId;
    }
    /** Get the change set from the specified named version */
    static async getChangeSetFromNamedVersion(imodelClient, accessToken, iModelId, versionName) {
        const versions = await imodelClient.Versions().get(accessToken, iModelId, new imodeljs_clients_1.VersionQuery().select("ChangeSetId").byName(versionName));
        if (!versions[0] || !versions[0].changeSetId) {
            return Promise.reject(new IModelError_1.IModelError(32768 /* ERROR */));
        }
        return versions[0].changeSetId;
    }
}
exports.IModelVersion = IModelVersion;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
class PointUtil {
    static isNaN(val) { return Number.isNaN(Number.parseFloat(val)); }
    static isNumber(val) { return !PointUtil.isNaN(val); }
    static isNumberArray(arr) { return arr.every(PointUtil.isNumber); }
    static isVector(val) { return typeof val === "object" && (val instanceof geometry_core_1.XY || val instanceof geometry_core_1.XYZ); }
    static isXY(val) { return val instanceof geometry_core_1.XY; }
    static isXYZ(val) { return val instanceof geometry_core_1.XYZ; }
    static isPoint2d(val) { return val instanceof geometry_core_1.Point2d; }
    static isPoint3d(val) { return val instanceof geometry_core_1.Point3d; }
    static isXYArray(arr) { return arr.every((n) => PointUtil.isXY(n)); }
    static isXYZArray(arr) { return arr.every((n) => PointUtil.isXYZ(n)); }
    static isPoint2dArray(arr) { return arr.every((n) => PointUtil.isPoint2d(n)); }
    static isPoint3dArray(arr) { return arr.every((n) => PointUtil.isPoint3d(n)); }
    static toNumberArray(pt) { return (PointUtil.isVector(pt) ? pt.toJSON() : [pt]); }
    static toPoint(...scalars) { return PointUtil.fromNumberArray(scalars); }
    static fromNumberArray(data) {
        if (data.length === 1)
            return data[0];
        if (data.length === 2)
            return geometry_core_1.Vector2d.fromJSON(data);
        return geometry_core_1.Vector3d.fromJSON(data);
    }
    static fromFloat32Array(data) { return PointUtil.fromNumberArray(Array.from(data)); }
    static fromUint16Array(data) { return PointUtil.fromNumberArray(Array.from(data)); }
    static toUint16Array(pt) { return new Uint16Array(PointUtil.toNumberArray(pt)); }
    static toFloat32Array(pt) { return new Float32Array(PointUtil.toNumberArray(pt)); }
    static asFloat32Point(pt) { return PointUtil.fromFloat32Array((PointUtil.toFloat32Array(pt))); }
    static to2dNumberArray(...pts) { return pts.map(PointUtil.toNumberArray); }
    static toUint16(val) { return new Uint16Array([val])[0]; }
    static asNumberArray(pt, func) { return PointUtil.fromNumberArray(func(PointUtil.toNumberArray(pt))); }
    static eachScalar(pt, func) { return PointUtil.asNumberArray(pt, (pts) => pts.map((v, i) => func(v, i))); }
    static fromNumberArrays(...arrs) { return arrs.map((arr) => PointUtil.fromNumberArray(arr)); }
    static clone(pt) { return PointUtil.fromNumberArray(PointUtil.toNumberArray(pt)); }
}
exports.PointUtil = PointUtil;
class RangeUtil {
    static isRange1d(val) { return val instanceof geometry_core_1.Range1d; }
    static isRange2d(val) { return val instanceof geometry_core_1.Range2d; }
    static isRange3d(val) { return val instanceof geometry_core_1.Range3d; }
    static isRange(val) { return RangeUtil.isRange3d(val) || RangeUtil.isRange2d(val) || RangeUtil.isRange1d(val); }
    // computes diagonal for a range of any dimension and returns a zeroed point of same dimension if range is invalid
    static toDiagonal(range) {
        if (RangeUtil.isRange1d(range))
            return range.length(); // Range1d length bottoms out at zero, so no null check required
        else if (RangeUtil.isRange2d(range))
            return range.isNull() ? new geometry_core_1.Vector2d(0, 0) : range.diagonal();
        else
            return range.isNull() ? new geometry_core_1.Vector3d(0, 0, 0) : range.diagonal();
    }
    static fromPoints(...pts) {
        if (PointUtil.isNumberArray(pts))
            return geometry_core_1.Range1d.createArray(pts);
        if (PointUtil.isPoint2dArray(pts))
            return geometry_core_1.Range2d.createArray(pts);
        if (PointUtil.isPoint3dArray(pts))
            return geometry_core_1.Range3d.createArray(pts);
        return undefined;
    }
    static clone(range) { return RangeUtil.fromPoints(range.low, range.high); }
}
exports.RangeUtil = RangeUtil;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WireFormats */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
class TileId {
    constructor(treeId, tileId) {
        this.treeId = treeId;
        this.tileId = tileId;
    }
    static fromJSON(props) { return new TileId(bentleyjs_core_1.Id64.fromJSON(props.treeId), props.tileId); }
}
exports.TileId = TileId;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
var AreaPattern;
(function (AreaPattern) {
    class HatchDefLine {
        constructor(json) {
            this.angle = json.angle ? geometry_core_1.Angle.fromJSON(json.angle) : undefined;
            this.through = json.through ? geometry_core_1.Point2d.fromJSON(json.through) : undefined;
            this.offset = json.offset ? geometry_core_1.Point2d.fromJSON(json.offset) : undefined;
            if (json.dashes) {
                const dashes = [];
                json.dashes.forEach((dash) => dashes.push(dash));
                this.dashes = dashes;
            }
        }
    }
    AreaPattern.HatchDefLine = HatchDefLine;
    /** Defines a hatch, cross hatch, or area pattern. */
    class Params {
        /** create an AreaPattern.Params from a json object. */
        static fromJSON(json) {
            const result = new Params();
            if (!json)
                return result;
            result.origin = json.origin ? geometry_core_1.Point3d.fromJSON(json.origin) : undefined;
            result.rotation = json.rotation ? geometry_core_1.YawPitchRollAngles.fromJSON(json.rotation) : undefined;
            result.space1 = json.space1;
            result.space2 = json.space2;
            result.angle1 = json.angle1 ? geometry_core_1.Angle.fromJSON(json.angle1) : undefined;
            result.angle2 = json.angle2 ? geometry_core_1.Angle.fromJSON(json.angle2) : undefined;
            result.scale = json.scale;
            result.color = json.color;
            result.weight = json.weight;
            result.invisibleBoundary = json.invisibleBoundary;
            result.snappable = json.snappable;
            result.symbolId = json.symbolId ? new bentleyjs_core_1.Id64(json.symbolId) : undefined;
            if (!json.defLines)
                return result;
            const defLines = [];
            json.defLines.forEach((defLine) => defLines.push(new HatchDefLine(defLine)));
            result.defLines = defLines;
            return result;
        }
        clone() {
            return Params.fromJSON(this);
        }
        isEqualTo(other) {
            if (this === other)
                return true; // Same pointer
            if (this.scale !== other.scale ||
                this.space1 !== other.space1 ||
                this.space2 !== other.space2 ||
                this.weight !== other.weight ||
                this.invisibleBoundary !== other.invisibleBoundary ||
                this.snappable !== other.snappable)
                return false;
            if ((this.color === undefined) !== (other.color === undefined))
                return false;
            if (this.color && !this.color.equals(other.color))
                return false;
            if ((this.angle1 === undefined) !== (other.angle1 === undefined))
                return false;
            if (this.angle1 && !this.angle1.isAlmostEqualNoPeriodShift(other.angle1))
                return false;
            if ((this.angle2 === undefined) !== (other.angle2 === undefined))
                return false;
            if (this.angle2 && !this.angle2.isAlmostEqualNoPeriodShift(other.angle2))
                return false;
            if ((this.origin === undefined) !== (other.origin === undefined))
                return false;
            if (this.origin && !this.origin.isAlmostEqual(other.origin))
                return false;
            if ((this.rotation === undefined) !== (other.rotation === undefined))
                return false;
            if (this.rotation && !this.rotation.isAlmostEqual(other.rotation))
                return false;
            if ((this.symbolId === undefined) !== (other.symbolId === undefined))
                return false;
            if (this.symbolId && !this.symbolId.equals(other.symbolId))
                return false;
            if ((this.defLines === undefined) !== (other.defLines === undefined))
                return false;
            if (this.defLines) {
                if (this.defLines.length !== other.defLines.length)
                    return false;
                for (let i = 0; i < this.defLines.length; ++i) {
                    const otherLine = other.defLines[i];
                    const thisLine = this.defLines[i];
                    if ((thisLine.angle === undefined) !== (otherLine.angle === undefined))
                        return false;
                    if (thisLine.angle && !thisLine.angle.isAlmostEqualNoPeriodShift(otherLine.angle))
                        return false;
                    if ((thisLine.through === undefined) !== (otherLine.through === undefined))
                        return false;
                    if (thisLine.through && !thisLine.through.isAlmostEqual(otherLine.through))
                        return false;
                    if ((thisLine.offset === undefined) !== (otherLine.offset === undefined))
                        return false;
                    if (thisLine.offset && !thisLine.offset.isAlmostEqual(otherLine.offset))
                        return false;
                    if ((thisLine.dashes === undefined) !== (otherLine.dashes === undefined))
                        return false;
                    if (thisLine.dashes && thisLine.dashes.length !== otherLine.dashes.length)
                        return false;
                    if (thisLine.dashes) {
                        for (let dash = 0; dash < thisLine.dashes.length; ++dash) {
                            if (!geometry_core_1.Geometry.isSameCoordinate(thisLine.dashes[dash], otherLine.dashes[dash]))
                                return false;
                        }
                    }
                }
            }
            return true;
        }
        static transformPatternSpace(transform, oldSpace, patRot, angle) {
            let tmpRot;
            if (angle && !angle.isAlmostZero()) {
                const yprTriple = new geometry_core_1.YawPitchRollAngles(angle);
                const angRot = yprTriple.toRotMatrix();
                tmpRot = patRot.multiplyMatrixMatrix(angRot);
            }
            else {
                tmpRot = patRot;
            }
            const yDir = tmpRot.getColumn(1);
            yDir.scale(oldSpace, yDir);
            transform.multiplyVector(yDir, yDir);
            return yDir.magnitude();
        }
        static getTransformPatternScale(transform) {
            const xDir = transform.matrix.getColumn(0);
            const mag = xDir.magnitude();
            return (mag > 1.0e-10) ? mag : 1.0;
        }
        applyTransform(transform) {
            if (transform.isIdentity())
                return true;
            const origin = this.origin ? this.origin : geometry_core_1.Point3d.createZero();
            const rMatrix = this.rotation ? this.rotation.toRotMatrix() : geometry_core_1.RotMatrix.createIdentity();
            if (this.symbolId !== undefined) {
                this.space1 = Params.transformPatternSpace(transform, this.space1 ? this.space1 : 0.0, rMatrix, this.angle1);
                this.space2 = Params.transformPatternSpace(transform, this.space2 ? this.space2 : 0.0, rMatrix, this.angle2);
                const scale = Params.getTransformPatternScale(transform);
                this.scale = this.scale ? this.scale *= scale : scale;
            }
            else if (this.defLines) {
                const scale = Params.getTransformPatternScale(transform);
                if (!geometry_core_1.Geometry.isSameCoordinate(scale, 1.0)) {
                    this.scale = this.scale ? this.scale *= scale : scale;
                    for (const line of this.defLines) {
                        if (line.through) {
                            line.through.x *= scale;
                            line.through.y *= scale;
                        }
                        if (line.offset) {
                            line.offset.x *= scale;
                            line.offset.y *= scale;
                        }
                        if (line.dashes) {
                            for (let iDash = 0; iDash < line.dashes.length; iDash++)
                                line.dashes[iDash] *= scale;
                        }
                    }
                }
            }
            else {
                this.space1 = Params.transformPatternSpace(transform, this.space1 ? this.space1 : 0.0, rMatrix, this.angle1);
                if (this.space2 && 0 !== this.space2)
                    this.space2 = Params.transformPatternSpace(transform, this.space2, rMatrix, this.angle2);
            }
            transform.multiplyPoint3d(origin);
            rMatrix.multiplyMatrixMatrix(transform.matrix, rMatrix);
            const normalized = geometry_core_1.RotMatrix.createRigidFromRotMatrix(rMatrix);
            if (!normalized)
                return false;
            const newRotation = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(normalized);
            if (undefined === newRotation)
                return false;
            this.origin = origin;
            this.rotation = newRotation;
            return true;
        }
    }
    AreaPattern.Params = Params;
})(AreaPattern = exports.AreaPattern || (exports.AreaPattern = {}));


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/**
 * A single line of text, all with the same font, styles (underline, bold, italic), and size.
 * This class also holds the origin and direction for the text.
 * A paragraph is composed of one or more instances of TextStrings.
 */
class TextString {
    get width() { return this.height * (this.widthFactor ? this.widthFactor : 1.0); }
    constructor(props) {
        this.text = props.text;
        this.font = props.font;
        this.height = props.height;
        this.widthFactor = props.widthFactor;
        this.bold = props.bold;
        this.italic = props.italic;
        this.underline = props.underline;
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.rotation = geometry_core_1.YawPitchRollAngles.fromJSON(props.rotation);
    }
    toJSON() {
        const val = {};
        val.text = this.text;
        val.font = this.font;
        val.height = this.height;
        val.widthFactor = this.widthFactor;
        val.bold = this.bold;
        val.italic = this.italic;
        val.underline = this.underline;
        if (!this.origin.isAlmostZero())
            val.origin = this.origin;
        if (!this.rotation.isIdentity())
            val.rotation = this.rotation;
        return val;
    }
    transformInPlace(transform) {
        const newOrigin = transform.multiplyPoint3d(this.origin, this.origin);
        const newTransform = this.rotation.toRotMatrix().multiplyMatrixTransform(transform);
        const scales = new geometry_core_1.Vector3d();
        if (!newTransform.matrix.normalizeColumnsInPlace(scales))
            return false;
        const newRotation = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(newTransform.matrix);
        if (undefined === newRotation)
            return false;
        const newHeight = this.height * scales.y;
        const newWidth = this.width * scales.x;
        if (newHeight < 1.0e-10 || newWidth < 1.0e-10)
            return false;
        this.origin.setFrom(newOrigin);
        this.rotation.setFrom(newRotation);
        this.height = newHeight;
        this.widthFactor = (newHeight === newWidth ? undefined : (newWidth / newHeight));
        return true;
    }
}
exports.TextString = TextString;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Symbology */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
var LineStyle;
(function (LineStyle) {
    /** Optional modifiers to override line style definition */
    class Modifier {
        /** constructor for LineStyle.Modifier */
        constructor(props) {
            this.scale = props.scale;
            this.dashScale = props.dashScale;
            this.gapScale = props.gapScale;
            this.startWidth = props.startWidth;
            this.endWidth = props.endWidth;
            this.distPhase = props.distPhase;
            this.fractPhase = props.fractPhase;
            this.centerPhase = props.centerPhase;
            this.segmentMode = props.segmentMode;
            this.physicalWidth = props.physicalWidth;
            this.normal = props.normal ? geometry_core_1.Vector3d.fromJSON(props.normal) : undefined;
            this.rotation = props.rotation ? geometry_core_1.YawPitchRollAngles.fromJSON(props.rotation) : undefined;
        }
        /** Returns a deep copy of this object. */
        clone() {
            return new Modifier(this);
        }
        /** Compare two LineStyle.Modifier for equivalence */
        isEqualTo(other) {
            if (this === other)
                return true;
            if (other.scale !== this.scale ||
                other.dashScale !== this.dashScale ||
                other.gapScale !== this.gapScale ||
                other.startWidth !== this.startWidth ||
                other.endWidth !== this.endWidth ||
                other.distPhase !== this.distPhase ||
                other.fractPhase !== this.fractPhase ||
                other.centerPhase !== this.centerPhase ||
                other.segmentMode !== this.segmentMode ||
                other.physicalWidth !== this.physicalWidth)
                return false;
            if ((this.normal === undefined) !== (other.normal === undefined))
                return false;
            if (this.normal && !this.normal.isAlmostEqual(other.normal))
                return false;
            if ((this.rotation === undefined) !== (other.rotation === undefined))
                return false;
            if (this.rotation && !this.rotation.isAlmostEqual(other.rotation))
                return false;
            return true;
        }
        applyTransform(transform) {
            if (transform.isIdentity())
                return true;
            if (this.normal) {
                transform.matrix.multiplyVector(this.normal, this.normal);
                const normalized = this.normal.normalize();
                if (normalized)
                    this.normal.setFrom(normalized);
                else
                    return false;
            }
            if (this.rotation) {
                const newTransform = this.rotation.toRotMatrix().multiplyMatrixTransform(transform);
                const scales = new geometry_core_1.Vector3d();
                if (!newTransform.matrix.normalizeColumnsInPlace(scales))
                    return false;
                const newRotation = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(newTransform.matrix);
                if (undefined === newRotation)
                    return false;
                this.rotation.setFrom(newRotation);
            }
            let scaleFactor = 1.0;
            const scaleVector = geometry_core_1.Vector3d.create();
            const scaleMatrix = transform.matrix;
            scaleMatrix.normalizeRowsInPlace(scaleVector);
            // Check for flatten transform, dividing scaleVector by 3 gives wrong scaleFactor
            if (scaleVector.x !== 0.0 && scaleVector.y !== 0.0 && scaleVector.z !== 0.0)
                scaleFactor = (scaleVector.x + scaleVector.y + scaleVector.z) / 3.0;
            else
                scaleFactor = (scaleVector.x + scaleVector.y + scaleVector.z) / 2.0;
            if (1.0 === scaleFactor)
                return true;
            if (this.scale)
                this.scale *= scaleFactor;
            if (this.physicalWidth)
                return true;
            if (this.startWidth)
                this.startWidth *= scaleFactor;
            if (this.endWidth)
                this.endWidth *= scaleFactor;
            return true;
        }
    }
    LineStyle.Modifier = Modifier;
    /** Line style id and optional modifiers to override line style definition */
    class Info {
        /** Creates a LineStyle.Info object */
        constructor(styleId, styleMod) {
            this.styleId = styleId;
            this.styleMod = styleMod;
        }
        /** Returns a deep copy of this object. */
        clone() {
            return new Info(this.styleId, this.styleMod ? this.styleMod.clone() : undefined);
        }
        isEqualTo(other) {
            if (this === other)
                return true;
            if (!this.styleId.equals(other.styleId))
                return false;
            if ((this.styleMod === undefined) !== (other.styleMod === undefined))
                return false;
            if (this.styleMod && !this.styleMod.isEqualTo(other.styleMod))
                return false;
            return true;
        }
    }
    LineStyle.Info = Info;
})(LineStyle = exports.LineStyle || (exports.LineStyle = {}));


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelError_1 = __webpack_require__(16);
const RpcProtocol_1 = __webpack_require__(28);
const RpcRegistry_1 = __webpack_require__(33);
const ElectronRpcRequest_1 = __webpack_require__(323);
const instances = new Map();
const lookupInstance = (request) => {
    const interfaceName = request.operation.interfaceDefinition;
    let protocol = instances.get(interfaceName);
    if (!protocol) {
        RpcRegistry_1.RpcRegistry.instance.lookupImpl(interfaceName);
        protocol = instances.get(interfaceName);
    }
    return protocol;
};
/** @hidden @internal */
exports.CHANNEL = "@bentley/imodeljs-common/ElectronRpcProtocol";
/** @hidden @internal */
exports.interop = (() => {
    let electron = null;
    if (typeof (global) !== "undefined" && global && global.process && global.process.type) {
        // tslint:disable-next-line:no-eval
        electron = eval("require")("electron");
    }
    return electron;
})();
if (exports.interop) {
    if (exports.interop.ipcMain) {
        exports.interop.ipcMain.on(exports.CHANNEL, async (evt, request) => {
            const response = await lookupInstance(request).fulfill(request);
            evt.sender.send(exports.CHANNEL, response);
        });
    }
    else if (exports.interop.ipcRenderer) {
        exports.interop.ipcRenderer.on(exports.CHANNEL, (_evt, fulfillment) => {
            const protocol = instances.get(fulfillment.interfaceName);
            const request = protocol.configuration.controlChannel.requests.get(fulfillment.id);
            request.fulfillment = fulfillment;
            protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ResponseLoaded, request);
        });
    }
}
/** RPC interface protocol for an Electron-based application. */
class ElectronRpcProtocol extends RpcProtocol_1.RpcProtocol {
    /** Constructs an Electron protocol. */
    constructor(configuration) {
        super(configuration);
        /** The RPC request class for this protocol. */
        this.requestType = ElectronRpcRequest_1.ElectronRpcRequest;
    }
    /** @hidden @internal */
    onRpcClientInitialized(definition, _client) {
        this.registerInterface(definition);
    }
    /** @hidden @internal */
    onRpcImplInitialized(definition, _impl) {
        this.registerInterface(definition);
    }
    /** @hidden @internal */
    onRpcClientTerminated(definition, _client) {
        this.purgeInterface(definition);
    }
    /** @hidden @internal */
    onRpcImplTerminated(definition, _impl) {
        this.purgeInterface(definition);
    }
    registerInterface(definition) {
        if (instances.has(definition.name))
            throw new IModelError_1.IModelError(32768 /* ERROR */, `RPC interface "${definition.name}"" is already associated with a protocol.`);
        instances.set(definition.name, this);
    }
    purgeInterface(definition) {
        instances.delete(definition.name);
    }
}
exports.ElectronRpcProtocol = ElectronRpcProtocol;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelError_1 = __webpack_require__(16);
const RpcProtocol_1 = __webpack_require__(28);
const RpcRequest_1 = __webpack_require__(42);
class WebAppRpcRequest extends RpcRequest_1.RpcRequest {
    /** Constructs a web application request. */
    constructor(client, operation, parameters) {
        super(client, operation, parameters);
        this._loading = false;
        /** Convenience access to the protocol of this request. */
        this.protocol = this.client.configuration.protocol;
        this.path = this.protocol.supplyPathForOperation(this.operation, this);
        this.method = this.protocol.supplyMethodForOperation(this.operation);
    }
    /** Deserializes a request. */
    static deserialize(protocol, req) {
        const operation = protocol.getOperationFromPath(req.path);
        const id = req.header(protocol.requestIdHeaderName);
        if (!id)
            throw new IModelError_1.IModelError(32768 /* ERROR */, `Invalid request.`);
        const authorization = req.header(protocol.authorizationHeaderName) || "";
        return {
            id,
            authorization,
            operation: {
                interfaceDefinition: operation.interfaceDefinition,
                operationName: operation.operationName,
                interfaceVersion: operation.interfaceVersion,
            },
            method: req.method,
            path: req.path,
            parameters: req.body,
        };
    }
    /** Initializes the request communication channel. */
    initializeChannel() {
        if (this._loading)
            throw new IModelError_1.IModelError(32768 /* ERROR */, `Loading in progress.`);
        this.connection = this.protocol.supplyConnectionForRequest();
        this.connection.open(this.method, this.path, true);
        this.connection.addEventListener("load", () => {
            if (!this._loading)
                return;
            if (this.connection.readyState === 4) {
                this._loading = false;
                this.setLastUpdatedTime();
                this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ResponseLoaded, this);
            }
            else {
                this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ResponseLoading, this);
            }
        });
        this.connection.addEventListener("error", () => {
            if (!this._loading)
                return;
            this._loading = false;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ConnectionErrorReceived, this);
        });
        this.connection.addEventListener("abort", () => {
            if (!this._loading)
                return;
            this._loading = false;
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ConnectionAborted, this);
        });
    }
    /** Sets request header values. */
    setHeader(name, value) {
        this.connection.setRequestHeader(name, value);
    }
    /** Sends the request. */
    send() {
        this._loading = true;
        this.connection.send(this.protocol.serialize(this).parameters);
    }
    /** Supplies response status code. */
    getResponseStatusCode() {
        return this.connection.status;
    }
    /** Supplies response text. */
    getResponseText() {
        return this.connection.responseText;
    }
}
exports.WebAppRpcRequest = WebAppRpcRequest;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_clients_1 = __webpack_require__(18);
const geometry_core_1 = __webpack_require__(1);
const Code_1 = __webpack_require__(192);
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const RpcControl_1 = __webpack_require__(59);
const IModel_1 = __webpack_require__(34);
const IModelVersion_1 = __webpack_require__(196);
/** Response if the IModelDb was not found at the backend
 * (if the service has moved)
 */
class IModelNotFoundResponse extends RpcControl_1.RpcNotFoundResponse {
}
exports.IModelNotFoundResponse = IModelNotFoundResponse;
/**
 * The RPC interface for reading from an iModel.
 * All operations only require read-only access.
 * This interface is not normally used directly. See IModelConnection for higher-level and more convenient API for accessing iModels from a frontend.
 */
class IModelReadRpcInterface extends RpcInterface_1.RpcInterface {
    /** Returns the IModelReadRpcInterface instance for the frontend. */
    static getClient() { return RpcManager_1.RpcManager.getClientForInterface(IModelReadRpcInterface); }
    openForRead(_accessToken, _iModelToken) { return this.forward.apply(this, arguments); }
    close(_accessToken, _iModelToken) { return this.forward.apply(this, arguments); }
    executeQuery(_iModelToken, _ecsql, _bindings) { return this.forward.apply(this, arguments); }
    getModelProps(_iModelToken, _modelIds) { return this.forward.apply(this, arguments); }
    queryModelProps(_iModelToken, _params) { return this.forward.apply(this, arguments); }
    getElementProps(_iModelToken, _elementIds) { return this.forward.apply(this, arguments); }
    queryElementProps(_iModelToken, _params) { return this.forward.apply(this, arguments); }
    queryEntityIds(_iModelToken, _params) { return this.forward.apply(this, arguments); }
    formatElements(_iModelToken, _elementIds) { return this.forward.apply(this, arguments); }
    loadMetaDataForClassHierarchy(_iModelToken, _startClassName) { return this.forward.apply(this, arguments); }
    getClassHierarchy(_iModelToken, _startClassName) { return this.forward.apply(this, arguments); }
    getAllCodeSpecs(_iModelToken) { return this.forward.apply(this, arguments); }
    getViewStateData(_iModelToken, _viewDefinitionId) { return this.forward.apply(this, arguments); }
    readFontJson(_iModelToken) { return this.forward.apply(this, arguments); }
    isChangeCacheAttached(_iModelToken) { return this.forward.apply(this, arguments); }
    attachChangeCache(_iModelToken) { return this.forward.apply(this, arguments); }
    detachChangeCache(_iModelToken) { return this.forward.apply(this, arguments); }
    requestSnap(_iModelToken, _connectionId, _props) { return this.forward.apply(this, arguments); }
    cancelSnap(_iModelToken, _connectionId) { return this.forward.apply(this, arguments); }
    loadNativeAsset(_iModelToken, _assetName) { return this.forward.apply(this, arguments); }
}
/** The version of the interface. */
IModelReadRpcInterface.version = "1.0.0";
/** The types that can be marshaled by the interface. */
IModelReadRpcInterface.types = () => [
    imodeljs_clients_1.AccessToken,
    IModelVersion_1.IModelVersion,
    IModel_1.IModelToken,
    bentleyjs_core_1.Id64,
    geometry_core_1.Point2d,
    geometry_core_1.Point3d,
    geometry_core_1.Vector2d,
    geometry_core_1.Vector3d,
    Date,
    Code_1.Code,
    IModelNotFoundResponse,
];
exports.IModelReadRpcInterface = IModelReadRpcInterface;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Fuse = __webpack_require__(333);
class FuzzySearch {
    /** Override to provide non-standard FuseOptions for searches where the a single word pattern is used */
    onGetSingleWordSearchOptions() {
        return {
            shouldSort: true,
            threshold: 0.40,
            location: 0,
            distance: 100,
            maxPatternLength: 32,
            minMatchCharLength: 2,
            includeMatches: true,
            includeScore: true,
        };
    }
    /** Override to provide non-standard FuseOptions for searches where the a multiple word pattern is used */
    onGetMultiWordSearchOptions() {
        return {
            shouldSort: true,
            threshold: 0.40,
            tokenize: true,
            matchAllTokens: true,
            maxPatternLength: 32,
            minMatchCharLength: 2,
            includeMatches: true,
            includeScore: true,
        };
    }
    /** Call to conduct a fuzzy search of searchedObjects, looking at the 'key' member of each such object
     * @param searchedObjects An array of objects to search.
     * @param keys The name of the members to search in the searchedObjects.
     * @param pattern The pattern for which each searchedObject is searched.
     * @return FuzzySearchResults.
     */
    search(searchedObjects, keys, pattern) {
        if (!pattern || pattern.length < 2)
            return new FuzzySearchResults(undefined);
        // it is a multiword pattern if there's a space other than at the end of the pattern.
        const spaceIndex = pattern.indexOf(" ");
        const multiWord = (-1 !== spaceIndex) && (spaceIndex !== (pattern.length - 1));
        const options = multiWord ? this.onGetMultiWordSearchOptions() : this.onGetSingleWordSearchOptions();
        options.keys = keys;
        const fuse = new Fuse(searchedObjects, options);
        let results = fuse.search(pattern);
        // We need to set the threshold fairly high to get results when the user misspells words (otherwise they are not returned),
        // but doing that results in matches that don't make sense when there are "good" matches. So we discard matches where the match
        // score increases by a large amount between results.
        let checkScoreDelta = false;
        let averageScoreDeltaThreshold = 1;
        if (results.length > 30) {
            averageScoreDeltaThreshold = ((results[results.length - 1].score - results[0].score) / results.length) * 10;
            if (averageScoreDeltaThreshold > 0.01)
                checkScoreDelta = true;
        }
        // Sometimes fuse returns results in the array where the matches array is empty. That seems like a bug to me, but it happens when
        // the input  is something like "fjt" and the string it matches is "fit". If we have more than three actual matches, we just truncate the set when we see one.
        // The other use for this loop is to truncate when we see a dramatic increase in the score. The ones after are unlikely
        // to be useful, so we truncate the results when we hit that point also.
        for (let resultIndex = 0; resultIndex < results.length; resultIndex++) {
            const thisResult = results[resultIndex];
            if (0 === thisResult.matches.length) {
                // here we have a result with no matches. If we have other matches, just discard this and the rest.
                if (resultIndex > 2) {
                    results = results.slice(0, resultIndex);
                    break;
                }
                // otherwise we want to keep this result, but we have to add the matched value to the object because we can't get it from the matches array.
                // we assume it came from the first key (usually there's only one anyway).
                thisResult.matchedValue = thisResult.item[keys[0]];
                thisResult.matchedKey = keys[0];
            }
            if (checkScoreDelta && (resultIndex > 0)) {
                const resultScore = results[resultIndex].score;
                if (resultScore < 0.101)
                    continue;
                if ((resultScore - results[resultIndex - 1].score) > averageScoreDeltaThreshold) {
                    results = results.slice(0, resultIndex);
                    break;
                }
            }
        }
        // put the functions on each result so it fulfils the FuzzySearchResult interface.
        for (const thisResult of results) {
            thisResult.getResult = getResult.bind(thisResult);
            thisResult.getBoldMask = getBoldMask.bind(thisResult);
            thisResult.getMatchedKey = getMatchedKey.bind(thisResult);
            thisResult.getMatchedValue = getMatchedValue.bind(thisResult);
        }
        return new FuzzySearchResults(results);
    }
}
exports.FuzzySearch = FuzzySearch;
// this function is added to each result to support the FuzzySearchResult interface.
function getResult() { return this.item; }
// this function is added to each result to support the FuzzySearchResult interface.
function getMatchedKey() { return (this.matches.length > 0) ? this.matches[0].key : this.matchedKey; }
// this function is added to each result to support the FuzzySearchResult interface.
function getMatchedValue() { return (this.matches.length > 0) ? this.matches[0].value : this.matchedValue; }
// this function is added to each result to support the FuzzySearchResult interface.
function getBoldMask() {
    if (this.boldMask)
        return this.boldMask;
    // if we had no matches, we return a bold mask with all false.
    if (0 === this.matches.length) {
        const noBoldMask = new Array(this.matchedValue.length);
        noBoldMask.fill(false);
        return this.boldMask = noBoldMask;
    }
    // we have some matched portions.
    const thisMatchedString = this.matches[0].value;
    const valueLength = thisMatchedString.length;
    const boldMask = new Array(valueLength);
    boldMask.fill(false);
    const indicesArray = this.matches[0].indices;
    indicesArray.forEach((set) => {
        for (let start = set[0], end = set[1]; start <= end; start++) {
            boldMask[start] = true;
        }
    });
    // cache it so if someone asks again we don't have to recalculate it.
    return this.boldMask = boldMask;
}
/** This class is used to return the results of FuzzySearch.search. It is iterable, with each iteration
 * returning an object implementing the FuzzySearchResult interface.
 */
class FuzzySearchResults {
    constructor(results) {
        this.results = [];
        if (results)
            this.results = results;
    }
    [Symbol.iterator]() { return new FuzzySearchResultsIterator(this); }
    get length() { return this.results.length; }
    getResult(resultIndex) {
        if ((resultIndex < 0) || (resultIndex > this.results.length))
            return undefined;
        return this.results[resultIndex];
    }
}
exports.FuzzySearchResults = FuzzySearchResults;
class FuzzySearchResultsIterator {
    constructor(fsr) {
        this.next = () => {
            return {
                done: this.counter === this.fsr.results.length,
                value: this.fsr.results[this.counter++],
            };
        };
        this.fsr = fsr;
        this.counter = 0;
    }
}


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module SelectionSet */
const bentleyjs_core_1 = __webpack_require__(0);
const bentleyjs_core_2 = __webpack_require__(0);
const IModelApp_1 = __webpack_require__(5);
/** A set of *hilited* elements for an IModelConnection, by element id. */
class HilitedSet {
    constructor(iModel) {
        this.iModel = iModel;
        this.elements = new Set();
    }
    setHilite(arg, onOff) {
        bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => onOff ? this.elements.add(id) : this.elements.delete(id));
        IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this.iModel);
    }
    clearAll() {
        this.elements.clear();
        IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this.iModel);
    }
    has(id) { return this.elements.has(id); }
    isHilited(id) { return this.elements.has(id.value); }
    get size() { return this.elements.size; }
}
exports.HilitedSet = HilitedSet;
/** A set of *currently selected* elements for an IModelConnection. */
class SelectionSet {
    constructor(iModel) {
        this.iModel = iModel;
        this.elements = new Set();
        /** Called whenever elements are added or removed from this SelectionSet */
        this.onChanged = new bentleyjs_core_2.BeEvent();
    }
    sendChangedEvent(evType, ids) {
        IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this.iModel);
        this.onChanged.raiseEvent(this.iModel, evType, ids);
    }
    /** Get the number of entries in this selection set. */
    get size() { return this.elements.size; }
    /** Check whether there are any selected elements. */
    isActive() { return this.size !== 0; }
    /** Return true if elemId is in this SelectionSet.
     * @see [[isSelected]]
     */
    has(elemId) { return !!elemId && this.elements.has(elemId); }
    /** Query whether an Ids is in the selection set.
     * @see [[has]]
     */
    isSelected(elemId) { return !!elemId && this.elements.has(elemId.value); }
    /** Clear current selection set.
     * @note raises the [[onChanged]] event with [[SelectEventType.Clear]].
     */
    emptyAll() {
        if (!this.isActive())
            return;
        this.elements.clear();
        this.sendChangedEvent(3 /* Clear */);
    }
    /**
     * Add one or more Ids to the current selection set.
     * @param elem The set of Ids to add.
     * @param sendEvent If true, raise the [[onChanged]] event with [[SelectEventType.Add]]. Default is true.
     * @returns true if any elements were added.
     */
    add(elem, sendEvent = true) {
        const oldSize = this.elements.size;
        elem = bentleyjs_core_1.Id64.toIdSet(elem);
        elem.forEach((id) => this.elements.add(id));
        const changed = oldSize !== this.elements.size;
        if (sendEvent && changed)
            this.sendChangedEvent(0 /* Add */, elem);
        return changed;
    }
    /**
     * Remove one or more Ids from the current selection set.
     * @param elem The set of Ids to remove.
     * @param sendEvent If true, raise the [[onChanged]] event with [[SelectEventType.Remove]]. Default is true.
     * @returns true if any elements were removed.
     */
    remove(elem, sendEvent = true) {
        const oldSize = this.elements.size;
        elem = bentleyjs_core_1.Id64.toIdSet(elem);
        elem.forEach((id) => this.elements.delete(id));
        const changed = oldSize !== this.elements.size;
        if (sendEvent && changed)
            this.sendChangedEvent(1 /* Remove */, elem);
        return changed;
    }
    /**
     * Add one set of Ids, and remove another set of Ids. Any Ids that are in both sets are removed.
     * @returns True if any Ids were either added or removed.
     */
    addAndRemove(adds, removes) {
        const added = this.add(adds);
        const removed = this.remove(removes);
        return added || removed; // don't put this on one line. Make sure we call both.
    }
    /** Invert the state of a set of Ids in the SelectionSet */
    invert(elem) {
        const elementsToAdd = new Set();
        const elementsToRemove = new Set();
        bentleyjs_core_1.Id64.toIdSet(elem).forEach((id) => { if (this.elements.has(id))
            elementsToRemove.add(id);
        else
            elementsToAdd.add(id); });
        return this.addAndRemove(elementsToAdd, elementsToRemove);
    }
    /** Change selection set to be the supplied set of Ids. */
    replace(elem) {
        this.elements.clear();
        this.add(elem, false);
        this.sendChangedEvent(2 /* Replace */, this.elements);
    }
}
exports.SelectionSet = SelectionSet;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const EntityState_1 = __webpack_require__(53);
/** The state of an AuxCoordSystem element in the frontend */
class AuxCoordSystemState extends EntityState_1.ElementState {
    static fromProps(props, iModel) {
        const name = props.classFullName.toLowerCase();
        if (name.endsWith("system2d"))
            return new AuxCoordSystem2dState(props, iModel);
        if (name.endsWith("system3d"))
            return new AuxCoordSystem3dState(props, iModel);
        return new AuxCoordSystemSpatialState(props, iModel);
    }
    /**
     * Create a new AuxCoordSystemState.
     * @param acsName the name for the new AuxCoordSystem
     * @param iModel the iModel for which the ACS applies.
     * @note call this method with the appropriate subclass (e.g. AuxCoordSystemSpatialState, AuxCoordSystem2dState, etc), not on AuxCoordSystemState directly
     */
    static createNew(acsName, iModel) {
        const myCode = new imodeljs_common_1.Code({ spec: "bis:AuxCoordSystemSpatial" /* auxCoordSystemSpatial */, scope: imodeljs_common_1.IModel.dictionaryId.toString(), value: acsName });
        return new AuxCoordSystemSpatialState({ model: imodeljs_common_1.IModel.dictionaryId, code: myCode, classFullName: this.getClassFullName() }, iModel);
    }
    constructor(props, iModel) {
        super(props, iModel);
        this.type = bentleyjs_core_1.JsonUtils.asInt(props.type, 0 /* None */);
        this.description = props.description;
    }
    toJSON() {
        const val = super.toJSON();
        val.type = this.type;
        val.description = this.description;
        return val;
    }
    isValidForView(view) {
        if (view.isSpatialView())
            return this instanceof AuxCoordSystemSpatialState;
        return (view.is3d() === this.is3d());
    }
    is3d() { return this instanceof AuxCoordSystem3dState; }
    drawGrid(context) {
        // Called for active ACS when grid orientation is GridOrientationType::ACS.
        const view = context.viewport.view;
        const fixedRepsAuto = geometry_core_1.Point2d.create(); // limit grid to project extents
        context.drawStandardGrid(this.getOrigin(), this.getRotation(), view.getGridSpacing(), view.getGridsPerRef(), false, fixedRepsAuto);
    }
    /** Returns the value if it falls within the bounds given. Otherwise, returns the offended boundary. */
    static limitRange(min, max, val) {
        if (val < min)
            return min;
        else if (val > max)
            return max;
        return val;
    }
    /**
     * Given an origin point, returns whether the point falls within the view or not. If adjustOrigin is set to true, a point outside
     * the view will be modified to fall within the appropriate range.
     */
    static isOriginInView(drawOrigin, viewport, adjustOrigin) {
        const testPtView = viewport.worldToView(drawOrigin);
        const frustum = viewport.getFrustum(0 /* View */, false);
        const screenRange = geometry_core_1.Point3d.create();
        screenRange.x = frustum.points[0 /* _000 */].distance(frustum.points[1 /* _100 */]);
        screenRange.y = frustum.points[0 /* _000 */].distance(frustum.points[2 /* _010 */]);
        screenRange.z = frustum.points[0 /* _000 */].distance(frustum.points[4 /* _001 */]);
        // Check if current acs origin is outside view...
        const inView = (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));
        if (!adjustOrigin)
            return inView;
        if (!inView) {
            const offset = viewport.pixelsFromInches(0.6 /* TriadSizeInches */);
            testPtView.x = AuxCoordSystemState.limitRange(offset, screenRange.x - offset, testPtView.x);
            testPtView.y = AuxCoordSystemState.limitRange(offset, screenRange.y - offset, testPtView.y);
        }
        // Limit point to NPC box to prevent triad from being clipped from display...
        const originPtNpc = viewport.viewToNpc(testPtView);
        originPtNpc.x = AuxCoordSystemState.limitRange(0, 1, originPtNpc.x);
        originPtNpc.y = AuxCoordSystemState.limitRange(0, 1, originPtNpc.y);
        originPtNpc.z = AuxCoordSystemState.limitRange(0, 1, originPtNpc.z);
        viewport.npcToView(originPtNpc, testPtView);
        viewport.viewToWorld(testPtView, drawOrigin);
        return inView;
    }
    getAdjustedColor(inColor, isFill, viewport, options) {
        const color = new imodeljs_common_1.ColorDef();
        if ((options & 4 /* Hilite */) !== 0 /* None */) {
            color.setFrom(viewport.hilite.color);
        }
        else if ((options & 1 /* Active */) !== 0 /* None */) {
            color.setFrom(inColor.equals(imodeljs_common_1.ColorDef.white) ? viewport.getContrastToBackgroundColor() : inColor);
        }
        else {
            color.colors.r = 150;
            color.colors.g = 150;
            color.colors.b = 150;
            color.colors.t = 0;
        }
        color.adjustForContrast(viewport.view.backgroundColor);
        if (isFill)
            color.setTransparency((options & (2 /* Deemphasized */ | 16 /* Dynamics */)) !== 0 /* None */ ? 225 : 200);
        else
            color.setTransparency((options & 2 /* Deemphasized */) !== 0 /* None */ ? 150 : 75);
        return color;
    }
    addAxisLabel(builder, axis, options, vp) {
        const color = imodeljs_common_1.ColorDef.white;
        const lineColor = this.getAdjustedColor(color, false, vp, options);
        builder.setSymbology(lineColor, lineColor, 2);
        const linePts1 = [];
        if (0 === axis) {
            linePts1[0] = geometry_core_1.Point3d.create(0.4 /* LabelStart */, -0.15 /* LabelWidth */);
            linePts1[1] = geometry_core_1.Point3d.create(0.8 /* LabelEnd */, 0.15 /* LabelWidth */);
        }
        else {
            linePts1[0] = geometry_core_1.Point3d.create(0.0, 0.4 /* LabelStart */);
            linePts1[1] = geometry_core_1.Point3d.create(0.0, (0.4 /* LabelStart */ + 0.8 /* LabelEnd */) * 0.5);
        }
        builder.addLineString(linePts1);
        const linePts2 = []; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...
        if (0 === axis) {
            linePts2[0] = geometry_core_1.Point3d.create(0.4 /* LabelStart */, 0.15 /* LabelWidth */);
            linePts2[1] = geometry_core_1.Point3d.create(0.8 /* LabelEnd */, -0.15 /* LabelWidth */);
        }
        else {
            linePts2[0] = geometry_core_1.Point3d.create(0.15 /* LabelWidth */, 0.8 /* LabelEnd */);
            linePts2[1] = geometry_core_1.Point3d.create(0.0, (0.4 /* LabelStart */ + 0.8 /* LabelEnd */) * 0.5);
            linePts2[2] = geometry_core_1.Point3d.create(-0.15 /* LabelWidth */, 0.8 /* LabelEnd */);
        }
        builder.addLineString(linePts2);
    }
    addAxis(builder, axis, options, vp) {
        const color = (0 === axis ? imodeljs_common_1.ColorDef.red : (1 === axis ? imodeljs_common_1.ColorDef.green : imodeljs_common_1.ColorDef.blue));
        const lineColor = this.getAdjustedColor(color, false, vp, options);
        const fillColor = this.getAdjustedColor(color, true, vp, options);
        if (axis === 2) {
            const linePts1 = [geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create()];
            linePts1[1].z = 0.65 /* ZAxisLength */;
            builder.setSymbology(lineColor, lineColor, 6);
            builder.addPointString(linePts1);
            const linePts2 = [geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create()]; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...
            linePts2[1].z = 0.65 /* ZAxisLength */;
            builder.setSymbology(lineColor, lineColor, 1, (options & 16 /* Dynamics */) === 0 /* None */ ? 0 /* Solid */ : 4177066232 /* Code2 */);
            builder.addLineString(linePts2);
            const scale = 0.4 /* ArrowTipWidth */ / 2;
            const center = geometry_core_1.Point3d.create();
            const viewRMatrix = vp.rotMatrix;
            const xVec = viewRMatrix.getRow(0);
            const yVec = viewRMatrix.getRow(1);
            builder.localToWorldTransform.matrix.multiplyTransposeVectorInPlace(xVec);
            builder.localToWorldTransform.matrix.multiplyTransposeVectorInPlace(yVec);
            xVec.normalize(xVec);
            yVec.normalize(yVec);
            const ellipse = geometry_core_1.Arc3d.createScaledXYColumns(center, geometry_core_1.RotMatrix.createColumns(xVec, yVec, geometry_core_1.Vector3d.create()), scale, scale, geometry_core_1.AngleSweep.createStartEnd(geometry_core_1.Angle.createRadians(0), geometry_core_1.Angle.createRadians(Math.PI * 2)));
            builder.addArc(ellipse, false, false);
            builder.setBlankingFill(fillColor);
            builder.addArc(ellipse, true, true);
            return;
        }
        const shapePts = [];
        /* ### TODO NEEDSWORK PolyfaceBuilder.emitFacets...
            shapePts[0] = Point3d.create(ACSDisplaySizes.ArrowBaseStart, -ACSDisplaySizes.ArrowBaseWidth);
            shapePts[1] = Point3d.create(ACSDisplaySizes.ArrowTipStart, -ACSDisplaySizes.ArrowBaseWidth);
            shapePts[2] = Point3d.create(ACSDisplaySizes.ArrowTipFlange, -ACSDisplaySizes.ArrowTipWidth);
            shapePts[3] = Point3d.create(ACSDisplaySizes.ArrowTipEnd, 0.0);
            shapePts[4] = Point3d.create(ACSDisplaySizes.ArrowTipFlange, ACSDisplaySizes.ArrowTipWidth);
            shapePts[5] = Point3d.create(ACSDisplaySizes.ArrowTipStart, ACSDisplaySizes.ArrowBaseWidth);
            shapePts[6] = Point3d.create(ACSDisplaySizes.ArrowBaseStart, ACSDisplaySizes.ArrowBaseWidth);
            shapePts[7] = shapePts[0].clone();
        */
        shapePts[0] = geometry_core_1.Point3d.create(1.25 /* ArrowTipEnd */, 0.0);
        shapePts[1] = geometry_core_1.Point3d.create(0.75 /* ArrowTipFlange */, 0.4 /* ArrowTipWidth */);
        shapePts[2] = geometry_core_1.Point3d.create(0.85 /* ArrowTipStart */, 0.2 /* ArrowBaseWidth */);
        shapePts[3] = geometry_core_1.Point3d.create(0.3 /* ArrowBaseStart */, 0.2 /* ArrowBaseWidth */);
        shapePts[4] = geometry_core_1.Point3d.create(0.3 /* ArrowBaseStart */, -0.2 /* ArrowBaseWidth */);
        shapePts[5] = geometry_core_1.Point3d.create(0.85 /* ArrowTipStart */, -0.2 /* ArrowBaseWidth */);
        shapePts[6] = geometry_core_1.Point3d.create(0.75 /* ArrowTipFlange */, -0.4 /* ArrowTipWidth */);
        shapePts[7] = shapePts[0].clone();
        if (1 === axis) {
            shapePts.forEach((tmpPt) => { tmpPt.set(tmpPt.y, tmpPt.x); });
        }
        builder.setSymbology(lineColor, lineColor, 1, (options & 16 /* Dynamics */) === 0 /* None */ ? 0 /* Solid */ : 4177066232 /* Code2 */);
        builder.addLineString(shapePts);
        this.addAxisLabel(builder, axis, options, vp);
        builder.setBlankingFill(fillColor);
        builder.addShape(shapePts);
    }
    /** Returns a GraphicBuilder for this AuxCoordSystemState. */
    createGraphic(context, options) {
        const checkOutOfView = (options & 8 /* CheckVisible */) !== 0 /* None */;
        const drawOrigin = this.getOrigin();
        if (checkOutOfView && !AuxCoordSystemState.isOriginInView(drawOrigin, context.viewport, true))
            options = options | 2 /* Deemphasized */;
        let pixelSize = context.viewport.pixelsFromInches(0.6 /* TriadSizeInches */);
        if ((options & 2 /* Deemphasized */) !== 0 /* None */)
            pixelSize *= 0.8;
        else if ((options & 1 /* Active */) !== 0 /* None */)
            pixelSize *= 0.9;
        const exagg = context.viewport.view.getAspectRatioSkew();
        const scale = context.getPixelSizeAtPoint(drawOrigin) * pixelSize;
        const rMatrix = this.getRotation();
        rMatrix.inverse(rMatrix);
        rMatrix.scaleRows(scale, scale / exagg, scale, rMatrix);
        const transform = geometry_core_1.Transform.createOriginAndMatrix(drawOrigin, rMatrix);
        const graphic = context.createWorldOverlay(transform);
        const vp = context.viewport;
        this.addAxis(graphic, 0, options, vp);
        this.addAxis(graphic, 1, options, vp);
        this.addAxis(graphic, 2, options, vp);
        return graphic;
    }
    display(context, options) {
        const graphic = this.createGraphic(context, options);
        if (!graphic)
            return;
        context.addWorldOverlay(graphic.finish());
    }
}
exports.AuxCoordSystemState = AuxCoordSystemState;
/** The state of an AuxCoordSystem2d element in the frontend */
class AuxCoordSystem2dState extends AuxCoordSystemState {
    constructor(props, iModel) {
        super(props, iModel);
        this.origin = geometry_core_1.Point2d.fromJSON(props.origin);
        this.angle = bentleyjs_core_1.JsonUtils.asDouble(props.angle);
        this._rMatrix = geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_1.Angle.createDegrees(this.angle));
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.angle = this.angle;
        return val;
    }
    getOrigin(result) { return geometry_core_1.Point3d.createFrom(this.origin, result); }
    setOrigin(val) { this.origin.setFrom(val); }
    getRotation(result) { return this._rMatrix.clone(result); }
    setRotation(val) {
        this._rMatrix.setFrom(val);
        this.angle = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(val).yaw.degrees;
    }
}
exports.AuxCoordSystem2dState = AuxCoordSystem2dState;
/** The state of an AuxCoordSystem3d element in the frontend */
class AuxCoordSystem3dState extends AuxCoordSystemState {
    constructor(props, iModel) {
        super(props, iModel);
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.yaw = bentleyjs_core_1.JsonUtils.asDouble(props.yaw);
        this.pitch = bentleyjs_core_1.JsonUtils.asDouble(props.pitch);
        this.roll = bentleyjs_core_1.JsonUtils.asDouble(props.roll);
        const angles = new geometry_core_1.YawPitchRollAngles(geometry_core_1.Angle.createRadians(this.yaw), geometry_core_1.Angle.createRadians(this.pitch), geometry_core_1.Angle.createRadians(this.roll));
        this._rMatrix = angles.toRotMatrix();
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.yaw = this.yaw;
        val.pitch = this.pitch;
        val.roll = this.roll;
        return val;
    }
    getOrigin(result) { return geometry_core_1.Point3d.createFrom(this.origin, result); }
    setOrigin(val) { this.origin.setFrom(val); }
    getRotation(result) { return this._rMatrix.clone(result); }
    setRotation(rMatrix) {
        this._rMatrix.setFrom(rMatrix);
        const angles = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(rMatrix);
        this.yaw = angles.yaw.radians;
        this.pitch = angles.pitch.radians;
        this.roll = angles.roll.radians;
    }
}
exports.AuxCoordSystem3dState = AuxCoordSystem3dState;
/** The state of an AuxCoordSystemSpatial element in the frontend */
class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
}
exports.AuxCoordSystemSpatialState = AuxCoordSystemSpatialState;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
class ColorMap extends bentleyjs_core_1.IndexMap {
    constructor() {
        super(bentleyjs_core_1.compareNumbers, 0xffff);
        this._hasTransparency = false;
    }
    hasColor(color) { return -1 !== this.indexOf(color); }
    insert(color) {
        // The table should never contain a mix of opaque and translucent colors.
        if (this.isEmpty)
            this._hasTransparency = ColorMap.isTranslucent(color);
        else
            bentleyjs_core_1.assert(ColorMap.isTranslucent(color) === this.hasTransparency);
        return super.insert(color);
    }
    get hasTransparency() { return this._hasTransparency; }
    get isUniform() { return 1 === this.length; }
    toColorIndex(index, indices) {
        index.reset();
        if (0 === this.length) {
            bentleyjs_core_1.assert(false, "empty color map");
            return;
        }
        else if (1 === this.length) {
            index.initUniform(this.array[0].value);
        }
        else {
            const colors = new Uint32Array(this.length);
            for (const entry of this.array)
                colors[entry.index] = entry.value;
            index.initNonUniform(colors, indices, this.hasTransparency);
        }
    }
    static isTranslucent(color) {
        this.scratchColorDef.tbgr = color;
        return 255 !== this.scratchColorDef.getAlpha();
    }
}
ColorMap.scratchColorDef = new imodeljs_common_1.ColorDef();
exports.ColorMap = ColorMap;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const TileIO_1 = __webpack_require__(74);
const Primitives_1 = __webpack_require__(61);
const MeshPrimitives_1 = __webpack_require__(43);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(17);
const MeshPrimitives_2 = __webpack_require__(43);
const ImageUtil_1 = __webpack_require__(72);
/** Provides facilities for deserializing glTF tile data. */
var GltfTileIO;
(function (GltfTileIO) {
    /** Header preceding glTF tile data. */
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.gltfLength = stream.nextUint32;
            this.sceneStrLength = stream.nextUint32;
            this.gltfSceneFormat = stream.nextUint32;
            if ((1 /* Version1 */ !== this.version && 2 /* Version2 */ !== this.version) || 0 /* SceneFormat */ !== this.gltfSceneFormat)
                this.invalidate();
        }
        get isValid() { return 1179937895 /* Gltf */ === this.format; }
    }
    GltfTileIO.Header = Header;
    /**
     * A chunk of binary data exposed as a typed array.
     * The count member indicates how many elements exist. This may be less than this.buffer.length due to padding added to the
     * binary stream to ensure correct alignment.
     */
    class BufferData {
        constructor(buffer, count) {
            this.buffer = buffer;
            this.count = count;
        }
        /**
         * Create a BufferData of the desired type. The actual type may differ from the desired type - for example, small 32-bit integers
         * may be represented as 8-bit or 16-bit integers instead.
         * If the actual data type is not convertible to the desired type, this function returns undefined.
         */
        static create(bytes, actualType, expectedType, count) {
            if (expectedType !== actualType) {
                // Some data is stored in smaller data types to save space if no values exceed the maximum of the smaller type.
                switch (expectedType) {
                    case 5126 /* Float */:
                    case 5121 /* UnsignedByte */:
                        return undefined;
                    case 5123 /* UnsignedShort */:
                        if (5121 /* UnsignedByte */ !== actualType)
                            return undefined;
                        break;
                    case 5125 /* UInt32 */:
                        if (5121 /* UnsignedByte */ !== actualType && 5123 /* UnsignedShort */ !== actualType)
                            return undefined;
                        break;
                }
            }
            const data = this.createDataBuffer(bytes, actualType);
            return undefined !== data ? new BufferData(data, count) : undefined;
        }
        static createDataBuffer(bytes, actualType) {
            // NB: Endianness of typed array data is determined by the 'platform byte order'. Actual data is always little-endian.
            // We are assuming little-endian platform. If we find a big-endian platform, we'll need to use a DataView instead.
            switch (actualType) {
                case 5121 /* UnsignedByte */:
                    return bytes;
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);
                case 5125 /* UInt32 */:
                    return new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);
                case 5126 /* Float */:
                    return new Float32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);
                default:
                    return undefined;
            }
        }
    }
    GltfTileIO.BufferData = BufferData;
    /**
     * A view of a chunk of a tile's binary data containing an array of elements of a specific data type.
     * The count member indicates how many elements exist; this may be smaller than this.data.length.
     * The count member may also indicate the number of elements of a type containing more than one value of the
     * underlying type. For example, a buffer of 4 32-bit floating point 'vec2' elements will have a count of 4,
     * but its data member will contain 8 32-bit floating point values (2 per vec2).
     * The accessor member may contain additional JSON data specific to a particular buffer.
     */
    class BufferView {
        constructor(data, count, type, accessor) {
            this.data = data;
            this.count = count;
            this.type = type;
            this.accessor = accessor;
        }
        get byteLength() { return this.data.length; }
        toBufferData(desiredType) {
            return BufferData.create(this.data, this.type, desiredType, this.count);
        }
    }
    GltfTileIO.BufferView = BufferView;
    /** Data required for creating a Reader capable of deserializing glTF tile data. */
    class ReaderProps {
        constructor(buffer, binaryData, accessors, bufferViews, scene, meshes, materials, extensions, yAxisUp) {
            this.buffer = buffer;
            this.binaryData = binaryData;
            this.accessors = accessors;
            this.bufferViews = bufferViews;
            this.scene = scene;
            this.meshes = meshes;
            this.materials = materials;
            this.extensions = extensions;
            this.yAxisUp = yAxisUp;
        }
        static create(buffer, yAxisUp = false) {
            const header = new Header(buffer);
            if (!header.isValid)
                return undefined;
            const binaryData = new Uint8Array(buffer.arrayBuffer, buffer.curPos + header.sceneStrLength);
            const sceneStrData = buffer.nextBytes(header.sceneStrLength);
            const sceneStr = bentleyjs_core_1.StringUtils.utf8ToString(sceneStrData);
            if (undefined === sceneStr)
                return undefined;
            try {
                const sceneValue = JSON.parse(sceneStr);
                const meshes = bentleyjs_core_1.JsonUtils.asObject(sceneValue.meshes);
                const materialValues = bentleyjs_core_1.JsonUtils.asObject(sceneValue.materials);
                const accessors = bentleyjs_core_1.JsonUtils.asObject(sceneValue.accessors);
                const bufferViews = bentleyjs_core_1.JsonUtils.asObject(sceneValue.bufferViews);
                const extensions = bentleyjs_core_1.JsonUtils.asObject(sceneValue.extensions);
                if (undefined === materialValues || undefined === meshes || undefined === accessors || undefined === bufferViews)
                    return undefined;
                return new ReaderProps(buffer, binaryData, accessors, bufferViews, sceneValue, meshes, materialValues, extensions, yAxisUp);
            }
            catch (e) {
                return undefined;
            }
        }
    }
    GltfTileIO.ReaderProps = ReaderProps;
    /** Deserializes glTF tile data. */
    class Reader {
        constructor(props, model, system, isCanceled) {
            this.buffer = props.buffer;
            this.binaryData = props.binaryData;
            this.accessors = props.accessors;
            this.bufferViews = props.bufferViews;
            this.meshes = props.meshes;
            this.materialValues = props.materials;
            this.yAxisUp = props.yAxisUp;
            this.returnToCenter = this.extractReturnToCenter(props.extensions);
            this.textures = props.scene.textures;
            this.images = props.scene.images;
            this.renderMaterials = props.scene.renderMaterials;
            this.namedTextures = props.scene.namedTextures;
            this.model = model;
            this.system = system;
            this._isCanceled = isCanceled;
        }
        get modelId() { return this.model.id; }
        get isCanceled() { return undefined !== this._isCanceled && this._isCanceled(this); }
        readGltfAndCreateGraphics(isLeaf, isCurved, isComplete, featureTable, contentRange) {
            if (this.isCanceled)
                return { readStatus: 6 /* Canceled */, isLeaf };
            const geometry = new TileIO_1.TileIO.GeometryCollection(new MeshPrimitives_2.MeshList(featureTable), isComplete, isCurved);
            const readStatus = this.readGltf(geometry);
            let renderGraphic;
            if (!geometry.isEmpty) {
                const meshGraphicArgs = new MeshPrimitives_2.MeshGraphicArgs();
                if (1 === geometry.meshes.length) {
                    renderGraphic = geometry.meshes[0].getGraphics(meshGraphicArgs, this.system);
                }
                else {
                    const renderGraphicList = [];
                    for (const mesh of geometry.meshes) {
                        renderGraphic = mesh.getGraphics(meshGraphicArgs, this.system);
                        if (undefined !== renderGraphic)
                            renderGraphicList.push(renderGraphic);
                    }
                    renderGraphic = this.system.createGraphicList(renderGraphicList);
                }
                if (undefined !== renderGraphic) {
                    renderGraphic = this.system.createBatch(renderGraphic, featureTable, contentRange);
                    if (undefined !== this.returnToCenter || this.yAxisUp) {
                        const branch = new System_1.GraphicBranch();
                        branch.add(renderGraphic);
                        let transform = (undefined === this.returnToCenter) ? geometry_core_1.Transform.createIdentity() : geometry_core_1.Transform.createTranslationXYZ(this.returnToCenter[0], this.returnToCenter[1], this.returnToCenter[2]);
                        if (this.yAxisUp)
                            transform = transform.multiplyTransformRotMatrix(geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.create(1.0, 0.0, 0.0), geometry_core_1.Angle.createRadians(geometry_core_1.Angle.piOver2Radians)));
                        renderGraphic = this.system.createBranch(branch, transform);
                    }
                }
            }
            return {
                readStatus,
                isLeaf,
                contentRange,
                geometry,
                renderGraphic,
            };
        }
        getBufferView(json, accessorName) {
            try {
                const accessorValue = bentleyjs_core_1.JsonUtils.asString(json[accessorName]);
                const accessor = 0 < accessorValue.length ? bentleyjs_core_1.JsonUtils.asObject(this.accessors[accessorValue]) : undefined;
                const bufferViewAccessorValue = undefined !== accessor ? bentleyjs_core_1.JsonUtils.asString(accessor.bufferView) : "";
                const bufferView = 0 < bufferViewAccessorValue.length ? bentleyjs_core_1.JsonUtils.asObject(this.bufferViews[bufferViewAccessorValue]) : undefined;
                if (undefined === bufferView || undefined === accessor)
                    return undefined;
                const type = accessor.componentType;
                let dataSize = 0;
                switch (type) {
                    case 5121 /* UnsignedByte */:
                        dataSize = 1;
                        break;
                    case 5123 /* UnsignedShort */:
                        dataSize = 2;
                        break;
                    case 5125 /* UInt32 */:
                    case 5126 /* Float */:
                        dataSize = 4;
                        break;
                    default:
                        return undefined;
                }
                const offset = bufferView.byteOffset + accessor.byteOffset;
                // If the data is misaligned (Scalable mesh tile publisher) use slice to copy -- else use subarray.
                // assert(0 === offset % dataSize);
                const bytes = (0 === (this.binaryData.byteOffset + offset) % dataSize) ? this.binaryData.subarray(offset, offset + bufferView.byteLength) : this.binaryData.slice(offset, offset + bufferView.byteLength);
                return new BufferView(bytes, accessor.count, type, accessor);
            }
            catch (e) {
                return undefined;
            }
        }
        readBufferData32(json, accessorName) { return this.readBufferData(json, accessorName, 5125 /* UInt32 */); }
        readBufferData16(json, accessorName) { return this.readBufferData(json, accessorName, 5123 /* UnsignedShort */); }
        readBufferData8(json, accessorName) { return this.readBufferData(json, accessorName, 5121 /* UnsignedByte */); }
        readBufferDataFloat(json, accessorName) { return this.readBufferData(json, accessorName, 5126 /* Float */); }
        readBufferData(json, accessorName, type) {
            const view = this.getBufferView(json, accessorName);
            return undefined !== view ? view.toBufferData(type) : undefined;
        }
        readFeatureIndices(_json) { return undefined; }
        readGltf(geometry) {
            for (const meshKey of Object.keys(this.meshes)) {
                const meshValue = this.meshes[meshKey];
                const primitives = bentleyjs_core_1.JsonUtils.asArray(meshValue.primitives);
                if (undefined === primitives)
                    continue;
                for (const primitive of primitives) {
                    const mesh = this.readMeshPrimitive(primitive, geometry.meshes.features);
                    bentleyjs_core_1.assert(undefined !== mesh);
                    if (undefined !== mesh)
                        geometry.meshes.push(mesh);
                }
            }
            return 0 /* Success */;
        }
        readMeshPrimitive(primitive, featureTable) {
            const materialName = bentleyjs_core_1.JsonUtils.asString(primitive.material);
            const materialValue = 0 < materialName.length ? bentleyjs_core_1.JsonUtils.asObject(this.materialValues[materialName]) : undefined;
            const displayParams = undefined !== materialValue ? this.createDisplayParams(materialValue) : undefined;
            if (undefined === displayParams)
                return undefined;
            const primitiveType = bentleyjs_core_1.JsonUtils.asInt(primitive.type, 0 /* Mesh */);
            const isPlanar = bentleyjs_core_1.JsonUtils.asBool(primitive.isPlanar);
            const mesh = MeshPrimitives_1.Mesh.create({
                displayParams,
                features: undefined !== featureTable ? new MeshPrimitives_1.Mesh.Features(featureTable) : undefined,
                type: primitiveType,
                range: geometry_core_1.Range3d.createNull(),
                is2d: this.model.is2d,
                isPlanar,
            });
            if (!this.readVertices(mesh.points, primitive))
                return undefined;
            if (!this.readColorTable(mesh.colorMap, primitive))
                return undefined;
            const colorIndices = this.readColorIndices(primitive);
            if (undefined !== colorIndices)
                mesh.colors = colorIndices;
            else if (mesh.colorMap.length !== 1)
                return undefined;
            if (undefined !== mesh.features && !this.readFeatures(mesh.features, primitive))
                return undefined;
            switch (primitiveType) {
                case 0 /* Mesh */: {
                    if (!this.readMeshIndices(mesh, primitive))
                        return undefined;
                    if (!displayParams.ignoreLighting && !this.readNormals(mesh.normals, primitive.attributes, "NORMAL"))
                        return undefined;
                    this.readUVParams(mesh.uvParams, primitive.attributes, "TEXCOORD_0");
                    this.readMeshEdges(mesh, primitive.edges);
                    break;
                }
                case 1 /* Polyline */:
                case 2 /* Point */: {
                    if (undefined !== mesh.polylines && !this.readPolylines(mesh.polylines, primitive, "indices", 2 /* Point */ === primitiveType))
                        return undefined;
                    break;
                }
                default: {
                    bentleyjs_core_1.assert(false, "unhandled primitive type");
                    return undefined;
                }
            }
            return mesh;
        }
        readVertices(positions, primitive) {
            const view = this.getBufferView(primitive.attributes, "POSITION");
            if (undefined === view || 5123 /* UnsignedShort */ !== view.type)
                return false;
            const extensions = bentleyjs_core_1.JsonUtils.asObject(view.accessor.extensions);
            const quantized = undefined !== extensions ? bentleyjs_core_1.JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;
            if (undefined === quantized)
                return false;
            const rangeMin = bentleyjs_core_1.JsonUtils.asArray(quantized.decodedMin);
            const rangeMax = bentleyjs_core_1.JsonUtils.asArray(quantized.decodedMax);
            if (undefined === rangeMin || undefined === rangeMax)
                return false;
            const buffer = view.toBufferData(5123 /* UnsignedShort */);
            if (undefined === buffer)
                return false;
            const qpt = imodeljs_common_1.QPoint3d.fromScalars(0, 0, 0);
            positions.reset(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.create(geometry_core_1.Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), geometry_core_1.Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2]))));
            for (let i = 0; i < view.count; i++) {
                const index = i * 3; // 3 uint16 per QPoint3d...
                qpt.setFromScalars(buffer.buffer[index], buffer.buffer[index + 1], buffer.buffer[index + 2]);
                positions.push(qpt);
            }
            return true;
        }
        readIndices(json, accessorName) {
            const data = this.readBufferData32(json, accessorName);
            if (undefined === data)
                return undefined;
            const indices = [];
            for (let i = 0; i < data.count; i++)
                indices.push(data.buffer[i]);
            return indices;
        }
        readFeatures(features, json) {
            const indices = this.readFeatureIndices(json);
            if (undefined === indices)
                return false;
            features.setIndices(indices);
            return true;
        }
        readColorIndices(json) {
            const data = this.readBufferData16(json.attributes, "_COLORINDEX");
            if (undefined === data)
                return undefined;
            const colors = new Uint16Array(data.count);
            for (let i = 0; i < data.count; i++)
                colors[i] = data.buffer[i];
            return colors;
        }
        readMeshIndices(mesh, json) {
            const data = this.readBufferData32(json, "indices");
            if (undefined === data)
                return false;
            bentleyjs_core_1.assert(0 === data.count % 3);
            const triangle = new Primitives_1.Triangle(false);
            for (let i = 0; i < data.count; i += 3) {
                triangle.setIndices(data.buffer[i], data.buffer[i + 1], data.buffer[i + 2]);
                mesh.addTriangle(triangle);
            }
            return true;
        }
        readNormals(normals, json, accessorName) {
            const data = this.readBufferData8(json, accessorName);
            if (undefined === data)
                return false;
            // ###TODO: we shouldn't have to allocate OctEncodedNormal objects...just use uint16s / numbers...
            for (let i = 0; i < data.count; i++) {
                // ###TODO? not clear why ray writes these as pairs of uint8...
                const index = i * 2;
                const normal = data.buffer[index] | (data.buffer[index + 1] << 8);
                normals.push(new imodeljs_common_1.OctEncodedNormal(normal));
            }
            return true;
        }
        readUVParams(params, json, accessorName) {
            const view = this.getBufferView(json, accessorName);
            let data;
            if (view === undefined) {
                return false;
            }
            switch (view.type) {
                case 5126 /* Float */: {
                    data = this.readBufferDataFloat(json, accessorName);
                    for (let i = 0; i < data.count; i++) {
                        const index = 2 * i; // 2 float per param...
                        params.push(new geometry_core_1.Point2d(data.buffer[index], data.buffer[index + 1]));
                    }
                    break;
                }
                case 5123 /* UnsignedShort */: {
                    // TBD.   Support quantized UVParams in shaders rather than expanding here.
                    const extensions = bentleyjs_core_1.JsonUtils.asObject(view.accessor.extensions);
                    const quantized = undefined !== extensions ? bentleyjs_core_1.JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;
                    if (undefined === quantized)
                        return false;
                    const decodeMatrix = bentleyjs_core_1.JsonUtils.asArray(quantized.decodeMatrix);
                    if (undefined === decodeMatrix) {
                        return false;
                    }
                    const qData = view.toBufferData(5123 /* UnsignedShort */);
                    if (undefined === qData) {
                        return false;
                    }
                    for (let i = 0; i < view.count; i++) {
                        const index = 2 * i; // 3 uint16 per QPoint3d...
                        params.push(new geometry_core_1.Point2d(qData.buffer[index] * decodeMatrix[0] + decodeMatrix[6], qData.buffer[index + 1] * decodeMatrix[4] + decodeMatrix[7]));
                    }
                    break;
                }
            }
            return true;
        }
        readMeshEdges(mesh, json) {
            if (undefined === json || undefined === mesh)
                return false;
            mesh.edges = new imodeljs_common_1.MeshEdges();
            const visEdges = this.readEdgeIndices(json, "visibles");
            if (undefined !== visEdges)
                mesh.edges.visible = visEdges;
            if (undefined !== json.silhouettes) {
                const normPairs = this.readNormalPairs(json.silhouettes, "normalPairs");
                if (undefined !== normPairs)
                    mesh.edges.silhouetteNormals = normPairs;
                const silEdges = this.readEdgeIndices(json.silhouettes, "indices");
                if (undefined !== silEdges)
                    mesh.edges.silhouette = silEdges;
            }
            mesh.edges.polylines = new imodeljs_common_1.MeshPolylineList();
            return this.readPolylines(mesh.edges.polylines, json, "polylines", false);
        }
        readEdgeIndices(json, accessorName) {
            const data = this.readBufferData32(json, accessorName);
            if (undefined === data)
                return undefined;
            const edges = new Array(data.count / 2);
            let e = 0;
            for (let i = 0; i < data.count; i += 2)
                edges[e++] = new imodeljs_common_1.MeshEdge(data.buffer[i], data.buffer[i + 1]);
            return edges;
        }
        readNormalPairs(json, accessorName) {
            const data = this.readBufferData8(json, accessorName);
            if (undefined === data)
                return undefined;
            const normPairs = new Array(data.count);
            // ###TODO: we shouldn't have to allocate OctEncodedNormal objects...just use uint16s / numbers...
            for (let i = 0; i < data.count; i++) {
                // ###TODO? not clear why ray writes these as pairs of uint8...
                const index = i * 4;
                const normal0 = data.buffer[index] | (data.buffer[index + 1] << 8);
                const normal1 = data.buffer[index + 2] | (data.buffer[index + 3] << 8);
                normPairs[i] = new imodeljs_common_1.OctEncodedNormalPair(new imodeljs_common_1.OctEncodedNormal(normal0), new imodeljs_common_1.OctEncodedNormal(normal1));
            }
            return normPairs;
        }
        readPolylines(polylines, json, accessorName, disjoint) {
            const view = this.getBufferView(json, accessorName);
            if (undefined === view)
                return false;
            const startDistance = new Float32Array(1);
            const sdBytes = new Uint8Array(startDistance.buffer);
            const numIndices = new Uint32Array(1);
            const niBytes = new Uint8Array(numIndices.buffer);
            const index16 = new Uint16Array(1);
            const i16Bytes = new Uint8Array(index16.buffer);
            const index32 = new Uint32Array(1);
            const i32Bytes = new Uint8Array(index32.buffer);
            let ndx = 0;
            for (let p = 0; p < view.count; ++p) {
                for (let b = 0; b < 4; ++b)
                    sdBytes[b] = view.data[ndx++];
                for (let b = 0; b < 4; ++b)
                    niBytes[b] = view.data[ndx++];
                if (!disjoint && numIndices[0] < 2)
                    continue;
                const indices = new Array(numIndices[0]);
                if (5123 /* UnsignedShort */ === view.type) {
                    for (let i = 0; i < numIndices[0]; ++i) {
                        for (let b = 0; b < 2; ++b)
                            i16Bytes[b] = view.data[ndx++];
                        indices[i] = index16[0];
                    }
                    // Need to skip padding if we had an odd number of 16-bit indices.
                    if (0 !== numIndices[0] % 2)
                        ndx += 2;
                }
                else if (5125 /* UInt32 */ === view.type) {
                    for (let i = 0; i < numIndices[0]; ++i) {
                        for (let b = 0; b < 4; ++b)
                            i32Bytes[b] = view.data[ndx++];
                        indices[i] = index32[0];
                    }
                }
                polylines.push(new imodeljs_common_1.MeshPolyline(startDistance[0], indices));
            }
            return true;
        }
        async loadTextures() {
            if (undefined === this.textures)
                return Promise.resolve();
            const promises = new Array();
            for (const name of Object.keys(this.textures))
                promises.push(this.loadTexture(name));
            return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();
        }
        async loadTextureImage(imageJson) {
            try {
                const binaryImageJson = bentleyjs_core_1.JsonUtils.asObject(imageJson.extensions.KHR_binary_glTF);
                const bufferView = this.bufferViews[binaryImageJson.bufferView];
                const mimeType = bentleyjs_core_1.JsonUtils.asString(binaryImageJson.mimeType);
                const format = ImageUtil_1.ImageUtil.getImageSourceFormatForMimeType(mimeType);
                if (undefined === format)
                    return undefined;
                const offset = bufferView.byteOffset;
                const bytes = this.binaryData.subarray(offset, offset + bufferView.byteLength);
                const imageSource = new imodeljs_common_1.ImageSource(bytes, format);
                return ImageUtil_1.ImageUtil.extractImage(imageSource)
                    .then((image) => this.isCanceled ? undefined : this.system.createTextureFromImage(image, 2 /* Png */ === format, this.model.iModel, imodeljs_common_1.RenderTexture.Params.defaults))
                    .catch((_) => undefined);
            }
            catch (e) {
                return undefined;
            }
        }
        async loadTexture(textureId) {
            const textureJson = bentleyjs_core_1.JsonUtils.asObject(this.textures[textureId]);
            if (undefined === textureJson)
                return Promise.resolve();
            return this.loadTextureImage(this.images[textureJson.source]).then((texture) => {
                textureJson.renderTexture = texture;
            });
        }
        findTextureMapping(textureId) {
            const textureJson = bentleyjs_core_1.JsonUtils.asObject(this.textures[textureId]);
            const texture = undefined !== textureJson ? textureJson.renderTexture : undefined;
            return undefined !== texture ? new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params()) : undefined;
        }
    }
    GltfTileIO.Reader = Reader;
})(GltfTileIO = exports.GltfTileIO || (exports.GltfTileIO = {}));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated.All rights reserved.$
 * --------------------------------------------------------------------------------------------*/
/** @module Views */
const bentleyjs_core_1 = __webpack_require__(0);
const EntityState_1 = __webpack_require__(53);
/** A list of Categories to be displayed in a view. */
class CategorySelectorState extends EntityState_1.ElementState {
    constructor(props, iModel) {
        super(props, iModel);
        this.categories = new Set();
        if (props.categories)
            props.categories.forEach((cat) => this.categories.add(cat));
    }
    toJSON() {
        const val = super.toJSON();
        val.categories = [];
        this.categories.forEach((cat) => val.categories.push(cat));
        return val;
    }
    equalState(other) {
        if (this.categories.size !== other.categories.size)
            return false;
        if (this.name !== other.name)
            return false;
        const otherIter = other.categories.keys();
        let otherRes = otherIter.next();
        for (let thisIter = this.categories.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {
            if (thisRes.value !== otherRes.value)
                return false;
        }
        return true;
    }
    /** Get the name of this CategorySelector */
    get name() { return this.code.getValue(); }
    /** Determine whether this CategorySelector includes the specified categoryId string */
    has(id) { return this.categories.has(id); }
    /** Determine whether this CategorySelector includes the specified category */
    isCategoryViewed(categoryId) { return this.has(categoryId.value); }
    /** Add a category to this CategorySelector */
    addCategories(arg) { bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => this.categories.add(id)); }
    /** Drop a category from this CategorySelector */
    dropCategories(arg) { bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => this.categories.delete(id)); }
    /** Add or Drop categories to this CategorySelector */
    changeCategoryDisplay(arg, add) { if (add)
        this.addCategories(arg);
    else
        this.dropCategories(arg); }
}
exports.CategorySelectorState = CategorySelectorState;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
const imodeljs_common_1 = __webpack_require__(2);
const EntityState_1 = __webpack_require__(53);
const bentleyjs_core_1 = __webpack_require__(0);
const System_1 = __webpack_require__(17);
/** A DisplayStyle defines the parameters for 'styling' the contents of a View */
class DisplayStyleState extends EntityState_1.ElementState {
    constructor(props, iModel) {
        super(props, iModel);
        this._subCategoryOverrides = new Map();
        this._viewFlags = imodeljs_common_1.ViewFlags.fromJSON(this.getStyle("viewflags"));
        this._background = imodeljs_common_1.ColorDef.fromJSON(this.getStyle("backgroundColor"));
        const monoName = "monochromeColor"; // because tslint: "object access via string literals is disallowed"...
        const monoJson = this.getStyles()[monoName];
        this._monochrome = undefined !== monoJson ? imodeljs_common_1.ColorDef.fromJSON(monoJson) : imodeljs_common_1.ColorDef.white.clone();
    }
    equalState(other) {
        return JSON.stringify(this.getStyles()) === JSON.stringify(other.getStyles());
    }
    /** Get the name of this DisplayStyle */
    get name() { return this.code.getValue(); }
    get viewFlags() { return this._viewFlags; }
    set viewFlags(flags) {
        flags.clone(this._viewFlags);
        this.setStyle("viewflags", flags);
    }
    getStyles() { const p = this.jsonProperties; if (!p.styles)
        p.styles = new Object(); return p.styles; }
    getStyle(name) {
        const style = this.getStyles()[name];
        return style ? style : {};
    }
    /** change the value of a style on this DisplayStyle */
    setStyle(name, value) { this.getStyles()[name] = value; }
    /** Remove a Style from this DisplayStyle. */
    removeStyle(name) { delete this.getStyles()[name]; }
    /** Get the background color for this DisplayStyle */
    get backgroundColor() { return this._background; }
    set backgroundColor(val) { this._background = val; this.setStyle("backgroundColor", val); }
    getMonochromeColor() { return this._monochrome; }
    setMonochromeColor(val) { this._monochrome = val; this.setStyle("monochromeColor", val); }
    is3d() { return this instanceof DisplayStyle3dState; }
    overrideSubCategory(id, ovr) {
        if (id.isValid)
            this._subCategoryOverrides.set(id.value, ovr);
    }
    dropSubCategoryOverride(id) {
        this._subCategoryOverrides.delete(id.value);
    }
    get hasSubCategoryOverride() { return this._subCategoryOverrides.entries.length > 0; }
    getSubCategoryOverride(id) {
        return this._subCategoryOverrides.get(id.toString());
    }
}
exports.DisplayStyleState = DisplayStyleState;
/** A DisplayStyle for 2d views */
class DisplayStyle2dState extends DisplayStyleState {
    constructor(props, iModel) { super(props, iModel); }
}
exports.DisplayStyle2dState = DisplayStyle2dState;
/** A circle drawn at a Z elevation, whose diameter is the the XY diagonal of the project extents */
class GroundPlane {
    constructor(ground) {
        this.display = false;
        this.elevation = 0.0; // the Z height to draw the ground plane
        ground = ground ? ground : {};
        this.display = bentleyjs_core_1.JsonUtils.asBool(ground.display, false);
        this.elevation = bentleyjs_core_1.JsonUtils.asDouble(ground.elevation, -.01);
        this.aboveColor = ground.aboveColor ? imodeljs_common_1.ColorDef.fromJSON(ground.aboveColor) : new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.darkGreen);
        this.belowColor = ground.belowColor ? imodeljs_common_1.ColorDef.fromJSON(ground.belowColor) : new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.darkBrown);
    }
    /**
     * Returns and locally stores gradient symbology for the ground plane texture depending on whether we are looking from above or below.
     * Will store the ground colors used in the optional ColorDef array provided.
     */
    getGroundPlaneTextureSymb(aboveGround, groundColors) {
        if (aboveGround) {
            if (this.aboveSymb) {
                return this.aboveSymb;
            }
        }
        else {
            if (this.belowSymb)
                return this.belowSymb;
        }
        const values = [0, .25, .5]; // gradient goes from edge of rectangle (0.0) to center (1.0)...
        const color = aboveGround ? this.aboveColor : this.belowColor;
        groundColors = groundColors !== undefined ? groundColors : [];
        groundColors.length = 0;
        groundColors.push(color.clone());
        groundColors.push(color.clone());
        groundColors.push(color.clone());
        const alpha = aboveGround ? 0x80 : 0x85;
        groundColors[0].setTransparency(0xff);
        groundColors[1].setTransparency(alpha);
        groundColors[2].setTransparency(alpha);
        // Get the possibly cached gradient from the system, specific to whether or not we want ground from above or below.
        const gradient = new imodeljs_common_1.Gradient.Symb();
        gradient.mode = 4 /* Spherical */;
        gradient.keys = [{ color: groundColors[0], value: values[0] }, { color: groundColors[1], value: values[1] }, { color: groundColors[2], value: values[2] }];
        // Store the gradient for possible future use
        if (aboveGround)
            this.aboveSymb = gradient;
        else
            this.belowSymb = gradient;
        return gradient;
    }
}
exports.GroundPlane = GroundPlane;
/** The SkyBox is a grid drawn in the background of spatial views to provide context. */
class SkyBox {
    constructor(sky) {
        this.display = false;
        this.twoColor = false;
        this.groundExponent = 4.0; // if no jpeg file, the cutoff between ground and nadir
        this.skyExponent = 4.0; // if no jpeg file, the cutoff between sky and zenith
        sky = sky ? sky : {};
        this.display = bentleyjs_core_1.JsonUtils.asBool(sky.display, false);
        this.twoColor = bentleyjs_core_1.JsonUtils.asBool(sky.twoColor, false);
        this.jpegFile = bentleyjs_core_1.JsonUtils.asString(sky.file);
        this.groundExponent = bentleyjs_core_1.JsonUtils.asDouble(sky.groundExponent, 4.0);
        this.skyExponent = bentleyjs_core_1.JsonUtils.asDouble(sky.skyExponent, 4.0);
        this.groundColor = sky.groundColor ? imodeljs_common_1.ColorDef.fromJSON(sky.groundColor) : imodeljs_common_1.ColorDef.from(120, 143, 125);
        this.zenithColor = sky.zenithColor ? imodeljs_common_1.ColorDef.fromJSON(sky.zenithColor) : imodeljs_common_1.ColorDef.from(54, 117, 255);
        this.nadirColor = sky.nadirColor ? imodeljs_common_1.ColorDef.fromJSON(sky.nadirColor) : imodeljs_common_1.ColorDef.from(40, 15, 0);
        this.skyColor = sky.skyColor ? imodeljs_common_1.ColorDef.fromJSON(sky.skyColor) : imodeljs_common_1.ColorDef.from(143, 205, 255);
    }
    toJSON() {
        const val = {};
        if (this.display)
            val.display = true;
        if (this.twoColor)
            val.twoColor = true;
        if (this.jpegFile !== "")
            val.jpegFile = this.jpegFile;
        if (this.groundExponent !== 4.0)
            val.groundExponent = this.groundExponent;
        if (this.skyExponent !== 4.0)
            val.skyExponent = this.groundExponent;
        val.groundColor = this.groundColor;
        val.zenithColor = this.zenithColor;
        val.nadirColor = this.nadirColor;
        val.skyColor = this.skyColor;
        return val;
    }
}
exports.SkyBox = SkyBox;
/** The skyBox, groundPlane, etc. for a 3d view  */
class Environment {
    constructor(json) {
        this.sky = new SkyBox(json.sky);
        this.ground = new GroundPlane(json.ground);
    }
}
exports.Environment = Environment;
/** A DisplayStyle for 3d views */
class DisplayStyle3dState extends DisplayStyleState {
    constructor(props, iModel) {
        super(props, iModel);
        this._useSkyBoxImages = false;
        this._skyBoxImagePrefix = "";
        this._skyBoxImageSuffix = "";
        // ###TODO: This is all temporary...
        this._loadingImages = false;
    }
    getHiddenLineParams() { return new imodeljs_common_1.HiddenLine.Params(this.getStyle("hline")); }
    setHiddenLineParams(params) { this.setStyle("hline", params); }
    /** change one of the scene light specifications (Ambient, Flash, or Portrait) for this display style */
    setSceneLight(light) {
        if (!light.isValid())
            return;
        const sceneLights = this.getStyle("sceneLights");
        switch (light.lightType) {
            case 2 /* Ambient */:
                sceneLights.ambient = light;
                break;
            case 3 /* Flash */:
                sceneLights.flash = light;
                break;
            case 4 /* Portrait */:
                sceneLights.portrait = light;
                break;
        }
        this.setStyle("sceneLights", sceneLights);
    }
    /** change the light specification and direction of the solar light for this display style */
    setSolarLight(light, direction) {
        const sceneLights = this.getStyle("sceneLights");
        if (light.lightType !== 1 /* Solar */ || !light.isValid()) {
            delete sceneLights.sunDir;
        }
        else {
            sceneLights.sun = light;
            sceneLights.sunDir = direction;
        }
        this.setStyle("sceneLights", sceneLights);
    }
    getEnvironment() { return new Environment(this.getStyle("environment")); }
    setEnvironment(env) { this.setStyle("environment", env); }
    setSceneBrightness(fstop) { fstop = Math.max(-3.0, Math.min(fstop, 3.0)); this.getStyle("sceneLights").fstop = fstop; }
    getSceneBrightness() { return bentleyjs_core_1.JsonUtils.asDouble(this.getStyle("sceneLights").fstop, 0.0); }
    /** Attempts to create textures for the sky of the environment, and load it into the sky. Returns true on success, and false otherwise. */
    loadSkyBoxParams(system) {
        if (this.skyBoxParams !== undefined)
            return true; // skybox textures have already been loaded
        if (this._useSkyBoxImages)
            return this.loadImageSkyBoxParams(system);
        // const env = this.getEnvironment();
        // ###TODO - Use actual textures - just defining our own textures for now (different colors to distinguish them); can key off env.sky.jpegFile (needs more than one file though!)
        // ###TODO - If possible, use a cubemap texture to store all six images in one fell swoop (better use of GPU resources)
        const params = new imodeljs_common_1.RenderTexture.Params(undefined, 3 /* SkyBox */);
        let horizonImage;
        let skyImage;
        const wantSolidTextures = true;
        if (wantSolidTextures) {
            horizonImage = imodeljs_common_1.ImageBuffer.create(new Uint8Array([0x7f, 0, 0]), 2 /* Rgb */, 1);
            skyImage = imodeljs_common_1.ImageBuffer.create(new Uint8Array([0, 0x7f, 0xff]), 2 /* Rgb */, 1);
        }
        else {
            horizonImage = imodeljs_common_1.ImageBuffer.create(new Uint8Array([
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 255, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 104, 10, 0, 104, 10, 0, 104, 10, 0, 104, 10,
                0, 104, 10, 0, 104, 10, 0, 104, 10, 0, 104, 10,
                0, 104, 10, 0, 104, 10, 0, 104, 10, 0, 104, 10,
                0, 104, 10, 0, 104, 10, 0, 104, 10, 0, 104, 10
            ]), 2 /* Rgb */, 4);
            skyImage = imodeljs_common_1.ImageBuffer.create(new Uint8Array([
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 255, 255, 0, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 255, 255, 0, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255,
                0, 255, 255, 0, 255, 255, 0, 255, 255, 0, 255, 255
            ]), 2 /* Rgb */, 4);
        }
        const horizon = system.createTextureFromImageBuffer(horizonImage, this.iModel, params);
        const sky = system.createTextureFromImageBuffer(skyImage, this.iModel, params);
        const ground = system.createTextureFromImageBuffer(imodeljs_common_1.ImageBuffer.create(new Uint8Array([0, 104, 10]), 2 /* Rgb */, 1), this.iModel, params);
        const front = horizon;
        const back = horizon;
        const left = horizon;
        const right = horizon;
        const top = sky;
        const bottom = ground;
        this.skyBoxParams = System_1.SkyBoxCreateParams.createForTexturedCube(front, back, top, bottom, left, right);
        // ###TODO - if any image buffer or texture fails to load, bail out.
        return true;
    }
    loadImageSkyBoxParams(system) {
        if (this._loadingImages)
            return true;
        this._loadingImages = true;
        const promises = [];
        const prefix = this._skyBoxImagePrefix; // "mp_plains/plains-of-abraham_"; // "sor_sea/sea_";
        const ext = this._skyBoxImageSuffix; // ".png"; // ".JPG";
        const suffixes = ["ft", "bk", "up", "dn", "lf", "rt"];
        for (let i = 0; i < suffixes.length; i++) {
            const suffix = suffixes[i];
            const url = "./skyboxes/" + prefix + suffix + "." + ext;
            const promise = new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
                image.faceIndex = i;
            });
            promises.push(promise);
        }
        Promise.all(promises).then((images) => {
            const textures = [];
            const params = new imodeljs_common_1.RenderTexture.Params(undefined, 3 /* SkyBox */);
            for (const image of images) {
                const texture = system.createTextureFromImage(image, false, this.iModel, params);
                textures[image.faceIndex] = texture;
            }
            this.skyBoxParams = System_1.SkyBoxCreateParams.createForTexturedCube(textures[0], textures[1], textures[2], textures[3], textures[4], textures[5]);
            this._loadingImages = false;
        });
        return true;
    }
    /** Attempts to create a texture and material for the sky of the environment, and load it into the sky. Returns true on success, and false otherwise. */
    loadSkyBoxMaterial(system) {
        if (this.skyboxMaterial !== undefined)
            return true; // material has already been loaded
        const env = this.getEnvironment();
        let texture;
        // ### TODO
        // if (env.sky.jpegFile.length !== 0)
        // Read jpeg data from file
        // we didn't get a jpeg sky, just create a gradient
        if (!texture) {
            const gradientPixelCount = 1024;
            const sizeOfColorDef = 4;
            const buffer = new Uint8Array(gradientPixelCount * sizeOfColorDef);
            let currentBufferIdx = 0;
            let color1;
            let color2;
            // set up the 4 color gradient
            for (let i = 0; i < gradientPixelCount; i++, currentBufferIdx += 4) {
                let frac = i / gradientPixelCount;
                if (env.sky.twoColor) {
                    color1 = env.sky.zenithColor;
                    color2 = env.sky.nadirColor;
                }
                else if (frac > 0.5) {
                    color1 = env.sky.nadirColor;
                    color2 = env.sky.groundColor;
                    frac = 1.0 - (2.0 * (frac - 0.5));
                    frac = Math.pow(frac, env.sky.groundExponent);
                }
                else {
                    color1 = env.sky.zenithColor;
                    color2 = env.sky.skyColor;
                    frac = 2.0 * frac;
                    frac = Math.pow(frac, env.sky.skyExponent);
                }
                color1.lerp(color2, frac, color1);
                color1.setAlpha(color1.getAlpha() + frac * (color2.getAlpha() - color1.getAlpha()));
                buffer[currentBufferIdx] = color1.colors.r;
                buffer[currentBufferIdx + 1] = color1.colors.g;
                buffer[currentBufferIdx + 2] = color1.colors.b;
                buffer[currentBufferIdx + 3] = color1.getAlpha();
            }
            const image = imodeljs_common_1.ImageBuffer.create(buffer, 0 /* Rgba */, 1);
            if (!image)
                return false;
            texture = system.createTextureFromImageBuffer(image, this.iModel, imodeljs_common_1.RenderTexture.Params.defaults);
            if (!texture)
                return false;
        }
        const matParams = new imodeljs_common_1.RenderMaterial.Params();
        matParams.diffuseColor = imodeljs_common_1.ColorDef.white;
        matParams.shadows = false;
        matParams.ambient = 1;
        matParams.diffuse = 0;
        const mapParams = new imodeljs_common_1.TextureMapping.Params();
        const transform = new imodeljs_common_1.TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0);
        mapParams.textureMatrix = transform;
        mapParams.textureMatrix.setTransform();
        matParams.textureMapping = new imodeljs_common_1.TextureMapping(texture, mapParams);
        this.skyboxMaterial = system.createMaterial(matParams, this.iModel);
        return true;
    }
}
exports.DisplayStyle3dState = DisplayStyle3dState;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const EntityState_1 = __webpack_require__(53);
/** The state of a [ModelSelector]($backend). It holds a set of ids of GeometricModels for a SpatialViewDefinition. */
class ModelSelectorState extends EntityState_1.ElementState {
    constructor(props, iModel) {
        super(props, iModel);
        /** the set of ModelIds of this ModelSelectorState */
        this.models = new Set();
        if (props.models)
            props.models.forEach((model) => this.models.add(model));
    }
    /** Get the name of this ModelSelector */
    get name() { return this.code.getValue(); }
    toJSON() {
        const val = super.toJSON();
        val.models = [];
        this.models.forEach((model) => val.models.push(model));
        return val;
    }
    equalState(other) {
        if (this.models.size !== other.models.size)
            return false;
        if (this.name !== other.name)
            return false;
        const otherIter = other.models.keys();
        let otherRes = otherIter.next();
        for (let thisIter = this.models.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {
            if (thisRes.value !== otherRes.value)
                return false;
        }
        return true;
    }
    /** Add one or more models to this ModelSelectorState */
    addModels(arg) { bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => this.models.add(id)); }
    /** Drop one or more models from this ModelSelectorState */
    dropModels(arg) { bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => this.models.delete(id)); }
    /** Determine whether this ModelSelectorState includes the specified modelId value */
    has(id) { return this.models.has(id); }
    /** Determine whether this ModelSelectorState includes the specified modelId */
    containsModel(modelId) { return this.has(modelId.value); }
    /** Make sure all models referenced by this ModelSelectorState are loaded. */
    load() { return this.iModel.models.load(this.models); }
}
exports.ModelSelectorState = ModelSelectorState;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
class StopEvents {
    constructor(keyStrokes = false, wheel = false, button = false, buttonUp = false, reset = false, resetUp = false, paint = false, focus = false, modifierKeyTransition = false, sensor = false, abortUpdateRequest = false, touchMotion = false, mouseMotion = false, anyEvent = false, touchLimit = 0, numTouches = 0, touches = []) {
        this.keyStrokes = keyStrokes;
        this.wheel = wheel;
        this.button = button;
        this.buttonUp = buttonUp;
        this.reset = reset;
        this.resetUp = resetUp;
        this.paint = paint;
        this.focus = focus;
        this.modifierKeyTransition = modifierKeyTransition;
        this.sensor = sensor;
        this.abortUpdateRequest = abortUpdateRequest;
        this.touchMotion = touchMotion;
        this.mouseMotion = mouseMotion;
        this.anyEvent = anyEvent;
        this.touchLimit = touchLimit;
        this.numTouches = numTouches;
        this.touches = touches;
    }
    clear() { this.keyStrokes = this.wheel = this.button = this.buttonUp = this.reset = this.resetUp = this.paint = this.focus = this.modifierKeyTransition = this.sensor = this.abortUpdateRequest = this.touchMotion = this.mouseMotion = this.anyEvent = false; this.touchLimit = 0; }
    setStopOnModifierKey(stop) { this.modifierKeyTransition = stop; }
    setTouchLimit(limit, numTouches, touches) {
        this.touchMotion = true;
        this.touchLimit = limit;
        this.numTouches = numTouches >= 3 ? 3 : numTouches;
        for (let i = 0; i < numTouches; i++)
            this.touches[i] = touches[i];
    }
    static fromStopMask(mask) {
        if (mask & 8192 /* AnyEvent */)
            mask = -1;
        return new StopEvents(0 !== (mask & 1 /* OnKeystrokes */), 0 !== (mask & 2 /* OnWheel */), 0 !== (mask & 4 /* OnButton */), 0 !== (mask & 8 /* OnButtonUp */), 0 !== (mask & 16 /* OnReset */), 0 !== (mask & 32 /* OnResetUp */), 0 !== (mask & 64 /* OnPaint */), 0 !== (mask & 128 /* OnFocus */), 0 !== (mask & 256 /* OnModifierKey */), 0 !== (mask & 2048 /* OnSensor */), 0 !== (mask & 1024 /* OnAbortUpdate */), 0 !== (mask & 512 /* OnTouch */), 0 !== (mask & 4096 /* OnMouseMotion */), 0 !== (mask & 8192 /* AnyEvent */));
    }
}
exports.StopEvents = StopEvents;
class Motion {
    constructor(cursorPos = new geometry_core_1.Point2d(), tolerance = 0, total = 0) {
        this.cursorPos = cursorPos;
        this.tolerance = tolerance;
        this.total = total;
    }
    clear() { this.cursorPos.x = this.cursorPos.y = this.total = 0; }
    addMotion(val) { this.total += val; }
}
exports.Motion = Motion;
class AbortFlags {
    constructor(stopEvents = StopEvents.fromStopMask(1042 /* ForFullUpdate */), motion = new Motion()) {
        this.stopEvents = stopEvents;
        this.motion = motion;
    }
    get wantMotionAbort() { return 0 !== this.motion.tolerance; }
    setTouchCheckStopLimit(enabled, range, numTouches, touches) {
        if (!enabled)
            this.stopEvents.touchMotion = false;
        else
            this.stopEvents.setTouchLimit(range, numTouches, touches);
    }
}
exports.AbortFlags = AbortFlags;
class TileOptions {
    constructor(deadline, scale = 1, minDepth = 0, maxDepth = 100) {
        this.deadline = deadline;
        this.scale = scale;
        this.minDepth = minDepth;
        this.maxDepth = maxDepth;
    }
    get hasDeadline() { return this.deadline !== undefined; }
    get isTimedOut() { return this.hasDeadline && this.deadline.isInPast(); }
    setDepthRange(minDepth, maxDepth) { this.minDepth = minDepth; this.maxDepth = maxDepth; }
    setFixedDepth(depth) { this.setDepthRange(depth, depth); }
    isWithinDepthRange(depth) { bentleyjs_core_1.assert(this.minDepth <= this.maxDepth); return depth >= this.minDepth && depth <= this.maxDepth; }
}
exports.TileOptions = TileOptions;
class UpdatePlan {
    constructor() {
        this.tileOptions = new TileOptions();
        this.abortFlags = new AbortFlags();
        this.frustumScale = 1;
        this.wantDecorators = true;
        this.wantWait = false;
    }
    get hasSubRect() { return !!this._subRect; }
    get subRect() { return this._subRect; }
    set subRect(rect) { this._subRect = rect; }
    get hasQuitTime() { return this.quitTime !== undefined; }
    get isTimedOut() { return this.hasQuitTime && this.quitTime.isInPast(); }
    clearAbortFlags() { this.abortFlags.stopEvents = StopEvents.fromStopMask(0 /* None */); }
}
exports.UpdatePlan = UpdatePlan;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const Tool_1 = __webpack_require__(15);
const ViewTool_1 = __webpack_require__(77);
const bentleyjs_core_1 = __webpack_require__(0);
const PrimitiveTool_1 = __webpack_require__(98);
const ViewContext_1 = __webpack_require__(96);
const AccuSnap_1 = __webpack_require__(79);
const LegacyMath_1 = __webpack_require__(75);
const imodeljs_common_1 = __webpack_require__(2);
const IModelApp_1 = __webpack_require__(5);
const Sprites_1 = __webpack_require__(97);
class ToolState {
    constructor() {
        this.coordLockOvr = 0 /* None */;
        this.locateCircleOn = true;
    }
    setFrom(other) { this.coordLockOvr = other.coordLockOvr; this.locateCircleOn = other.locateCircleOn; }
    clone() { const val = new ToolState(); val.setFrom(this); return val; }
}
exports.ToolState = ToolState;
class SuspendedToolState {
    constructor() {
        this.shuttingDown = false;
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        const viewManager = IModelApp_1.IModelApp.viewManager;
        toolAdmin.setIncompatibleViewportCursor(true); // Don't save this...
        this.toolState = toolAdmin.toolState.clone();
        this.accuSnapState = IModelApp_1.IModelApp.accuSnap.toolState.clone();
        this.viewCursor = viewManager.cursor;
        this.inDynamics = viewManager.inDynamicsMode;
        if (this.inDynamics)
            viewManager.endDynamicsMode();
    }
    stop() {
        if (this.shuttingDown)
            return;
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        const viewManager = IModelApp_1.IModelApp.viewManager;
        toolAdmin.setIncompatibleViewportCursor(true); // Don't restore this...
        toolAdmin.toolState.setFrom(this.toolState);
        IModelApp_1.IModelApp.accuSnap.toolState.setFrom(this.accuSnapState);
        viewManager.setViewCursor(this.viewCursor);
        if (this.inDynamics)
            viewManager.beginDynamicsMode();
    }
}
exports.SuspendedToolState = SuspendedToolState;
class CurrentInputState {
    constructor() {
        this._rawPoint = new geometry_core_1.Point3d();
        this._uorPoint = new geometry_core_1.Point3d();
        this._viewPoint = new geometry_core_1.Point3d();
        this.qualifiers = 0 /* None */;
        this.motionTime = 0;
        this.button = [new Tool_1.BeButtonState(), new Tool_1.BeButtonState(), new Tool_1.BeButtonState()];
        this.lastButton = 0 /* Data */;
        this.inputSource = 0 /* Unknown */;
        this.inputOffset = new geometry_core_1.Point2d();
        this.wantIgnoreTest = false;
        this.numberTouches = 0;
        this.touches = [new geometry_core_1.Point2d(), new geometry_core_1.Point2d(), new geometry_core_1.Point2d()];
        this.touchMotionTime = 0;
        this.buttonDownTool = undefined;
        this.lastMotion = new geometry_core_1.Point2d();
    }
    get rawPoint() { return this._rawPoint; }
    set rawPoint(pt) { this._rawPoint.setFrom(pt); }
    get uorPoint() { return this._uorPoint; }
    set uorPoint(pt) { this._uorPoint.setFrom(pt); }
    get viewPoint() { return this._viewPoint; }
    set viewPoint(pt) { this._viewPoint.setFrom(pt); }
    get wasMotion() { return 0 !== this.motionTime; }
    get wasTouchMotion() { return 0 !== this.touchMotionTime; }
    get isShiftDown() { return 0 !== (this.qualifiers & 4 /* Shift */); }
    get isControlDown() { return 0 !== (this.qualifiers & 1 /* Control */); }
    get isAltDown() { return 0 !== (this.qualifiers & 8 /* Alt */); }
    isDragging(button) { return this.button[button].isDragging; }
    onStartDrag(button) { this.button[button].isDragging = true; }
    setKeyQualifier(qual, down) { this.qualifiers = down ? (this.qualifiers | qual) : (this.qualifiers & (~qual)); }
    clearKeyQualifiers() { this.qualifiers = 0 /* None */; }
    clearViewport(vp) { if (vp === this.viewport)
        this.viewport = undefined; }
    disableIgnoreTouchMotionTest() { this.wantIgnoreTest = false; }
    clearTouch() {
        this.numberTouches = 0;
        this.touchMotionTime = 0;
        this.wantIgnoreTest = false;
    }
    onMotion(pt2d) {
        this.motionTime = Date.now();
        this.lastMotion.x = pt2d.x;
        this.lastMotion.y = pt2d.y;
    }
    get hasMotionStopped() {
        const result = this.hasEventInputStopped(this.motionTime, 3 * 16);
        if (result.stopped)
            this.motionTime = result.eventTimer;
        return result.stopped;
    }
    get hasTouchMotionPaused() {
        const result = this.hasEventInputStopped(this.touchMotionTime, 3 * 16);
        if (result.stopped)
            this.touchMotionTime = result.eventTimer;
        return result.stopped;
    }
    hasEventInputStopped(timer, eventTimeout) {
        let isStopped = false;
        if (0 !== timer && ((Date.now() - timer) >= eventTimeout)) {
            isStopped = true;
            timer = 0;
        }
        return { eventTimer: timer, stopped: isStopped };
    }
    changeButtonToDownPoint(ev) {
        ev.point = this.button[ev.button].downUorPt;
        ev.rawPoint = this.button[ev.button].downRawPt;
        if (ev.viewport)
            ev.viewPoint = ev.viewport.worldToView(ev.rawPoint);
    }
    updateDownPoint(ev) {
        this.button[ev.button].downUorPt = ev.point;
    }
    onButtonDown(button) {
        const viewPt = this.viewport.worldToView(this.button[button].downRawPt);
        const center = this.viewport.npcToView(imodeljs_common_1.NpcCenter);
        viewPt.z = center.z;
        const now = Date.now();
        const isDoubleClick = ((now - this.button[button].downTime) < CurrentInputState.doubleClickTimeout)
            && (viewPt.distance(this.viewPoint) < CurrentInputState.doubleClickTolerance);
        this.button[button].init(this.uorPoint, this.rawPoint, now, true, isDoubleClick, false, this.inputSource);
        this.lastButton = button;
    }
    onButtonUp(button) {
        this.button[button].isDown = false;
        this.button[button].isDragging = false;
        this.lastButton = button;
    }
    toEvent(ev, useSnap) {
        let from = 0 /* User */;
        const uorPt = this.uorPoint.clone();
        let vp = this.viewport;
        if (useSnap) {
            const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
            if (snap) {
                from = snap.isHot() ? 3 /* ElemSnap */ : 0 /* User */;
                uorPt.setFrom(snap.adjustedPoint); // NOTE: Updated by AdjustSnapPoint even when not hot...
                vp = snap.viewport;
            }
            else if (IModelApp_1.IModelApp.tentativePoint.isActive) {
                from = 2 /* TentativePoint */;
                uorPt.setFrom(IModelApp_1.IModelApp.tentativePoint.point);
                vp = IModelApp_1.IModelApp.tentativePoint.viewport;
            }
        }
        const buttonState = this.button[this.lastButton];
        ev.initEvent(uorPt, this.rawPoint, this.viewPoint, vp, from, this.qualifiers, this.lastButton, buttonState.isDown, buttonState.isDoubleClick, this.inputSource);
    }
    adjustLastDataPoint(ev) {
        const state = this.button[0 /* Data */];
        state.downUorPt = ev.point;
        state.downRawPt = ev.point;
        this.viewport = ev.viewport;
    }
    toEventFromLastDataPoint(ev) {
        const state = this.button[0 /* Data */];
        const uorPt = state.downUorPt;
        const rawPt = state.downRawPt;
        const viewPt = this.viewport.worldToView(rawPt);
        ev.initEvent(uorPt, rawPt, viewPt, this.viewport, 0 /* User */, this.qualifiers, 0 /* Data */, state.isDown, state.isDoubleClick, state.inputSource);
    }
    fromPoint(vp, pt, source) {
        this.viewport = vp;
        this._viewPoint.x = pt.x + this.inputOffset.x;
        this._viewPoint.y = pt.y + this.inputOffset.y;
        this._viewPoint.z = vp.npcToView(imodeljs_common_1.NpcCenter).z;
        vp.viewToWorld(this._viewPoint, this._rawPoint);
        this._uorPoint = this._rawPoint.clone();
        this.inputSource = source;
    }
    fromButton(vp, pt, source, applyLocks) {
        this.fromPoint(vp, pt, source);
        // NOTE: Using the hit point on the element is preferable to ignoring a snap that is not "hot" completely...
        if (AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false)) {
            if (applyLocks)
                IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
            return;
        }
        IModelApp_1.IModelApp.toolAdmin.adjustPoint(this._uorPoint, vp, true, applyLocks);
    }
    fromGesture(vp, gestureInfo, applyLocks) {
        this.disableIgnoreTouchMotionTest();
        this.fromButton(vp, gestureInfo.ptsLocation, 2 /* Touch */, applyLocks);
    }
    isAnyDragging() {
        for (const button of this.button)
            if (button.isDragging)
                return true;
        return false;
    }
    isStartDrag(button) {
        // First make sure we aren't already dragging any button...
        if (this.isAnyDragging())
            return false;
        const state = this.button[button];
        if (!state.isDown)
            return false;
        if ((Date.now() - state.downTime) <= (7 * 16))
            return false;
        const viewPt = this.viewport.worldToView(state.downRawPt);
        const deltaX = Math.abs(this._viewPoint.x - viewPt.x);
        const deltaY = Math.abs(this._viewPoint.y - viewPt.y);
        return ((deltaX + deltaY) > 15);
    }
    ignoreTouchMotion(numberTouches, touches) {
        if (!this.wantIgnoreTest)
            return false;
        numberTouches = Math.min(numberTouches, this.touches.length);
        if (numberTouches !== this.numberTouches)
            return false;
        // Treat anything less than 0.05 inches as noise
        // Note our definition of "inches" may or may not correspond to physical inches as the browser refuses to tell us the PPI of the device...
        const pixelLimit = this.viewport.pixelsFromInches(0.05);
        for (let i = 0; i < numberTouches; i++) {
            const deltaX = Math.abs(touches[i].x - this.touches[i].x);
            const deltaY = Math.abs(touches[i].y - this.touches[i].y);
            if (deltaX > pixelLimit || deltaY > pixelLimit)
                return false;
        }
        return true;
    }
    onTouchMotionChange(numberTouches, touches) {
        if (0 === numberTouches) {
            this.clearTouch();
            return;
        }
        this.wantIgnoreTest = true;
        this.touchMotionTime = Date.now();
        this.numberTouches = numberTouches;
        for (let i = 0; i < this.touches.length; i++) {
            this.touches[i].x = touches[i].x;
            this.touches[i].y = touches[i].y;
        }
    }
}
CurrentInputState.doubleClickTimeout = 500; // half-second
CurrentInputState.doubleClickTolerance = 4.0;
exports.CurrentInputState = CurrentInputState;
// tslint:disable-next-line:variable-name
exports.WheelSettings = {
    zoomRatio: 1.75,
    navigateDistPct: 3.0,
    navigateMouseDistPct: 10.0,
};
/** Default processor to handle wheel events. */
class WheelEventProcessor {
    static process(ev, doUpdate) {
        const vp = ev.viewport;
        if (!vp)
            return;
        this.doZoom(ev);
        if (doUpdate) {
            vp.synchWithView(true);
            // AccuSnap hit won't be invalidated without cursor motion (closes info window, etc.).
            IModelApp_1.IModelApp.accuSnap.clear();
        }
    }
    static doZoom(ev) {
        const vp = ev.viewport;
        if (!vp)
            return 15 /* InvalidViewport */;
        let zoomRatio = exports.WheelSettings.zoomRatio;
        if (zoomRatio < 1)
            zoomRatio = 1;
        if (ev.wheelDelta > 0)
            zoomRatio = 1 / zoomRatio;
        const target = geometry_core_1.Point3d.create();
        const isSnap = ev.getTargetPoint(target);
        let targetRoot = target.clone();
        let status;
        if (vp.view.is3d() && vp.isCameraOn()) {
            let lastEventWasValid = false;
            if (!isSnap) {
                vp.worldToNpc(targetRoot, targetRoot);
                let defaultTarget;
                const lastEvent = IModelApp_1.IModelApp.toolAdmin.lastWheelEvent;
                const path = ViewTool_1.ViewManip.getTargetHitDetail(vp, target);
                if (lastEvent && lastEvent.viewport && lastEvent.viewport.view.equals(vp.view) && lastEvent.viewPoint.distanceSquaredXY(ev.viewPoint) < .00001) {
                    defaultTarget = vp.worldToNpc(lastEvent.point);
                    targetRoot.z = defaultTarget.z;
                    lastEventWasValid = true;
                }
                else if (path !== undefined) {
                    defaultTarget = path.hitPoint.clone();
                    targetRoot = vp.worldToNpc(defaultTarget);
                }
                else {
                    defaultTarget = vp.determineDefaultRotatePoint();
                    vp.worldToNpc(defaultTarget, defaultTarget);
                    targetRoot.z = defaultTarget.z;
                }
                vp.npcToWorld(targetRoot, targetRoot);
            }
            const cameraView = vp.view;
            const transform = geometry_core_1.Transform.createFixedPointAndMatrix(targetRoot, geometry_core_1.RotMatrix.createScale(zoomRatio, zoomRatio, zoomRatio));
            const oldCameraPos = cameraView.getEyePoint();
            const newCameraPos = transform.multiplyPoint3d(oldCameraPos);
            const offset = geometry_core_1.Vector3d.createStartEnd(oldCameraPos, newCameraPos);
            if (!isSnap && offset.magnitude() < .01) {
                offset.scaleToLength(1 / 3);
                lastEventWasValid = false;
                targetRoot.addInPlace(offset);
            }
            const viewTarget = cameraView.getTargetPoint().clone();
            viewTarget.addInPlace(offset);
            newCameraPos.setFrom(oldCameraPos.plus(offset));
            if (!lastEventWasValid) {
                const thisEvent = ev.clone();
                thisEvent.point.setFrom(targetRoot);
                IModelApp_1.IModelApp.toolAdmin.lastWheelEvent = thisEvent;
            }
            status = cameraView.lookAt(newCameraPos, viewTarget, cameraView.getYVector());
            vp.synchWithView(false);
        }
        else {
            const targetNpc = vp.worldToNpc(targetRoot);
            const trans = geometry_core_1.Transform.createFixedPointAndMatrix(targetNpc, geometry_core_1.RotMatrix.createScale(zoomRatio, zoomRatio, 1));
            const viewCenter = geometry_core_1.Point3d.create(.5, .5, .5);
            trans.multiplyPoint3d(viewCenter, viewCenter);
            vp.npcToWorld(viewCenter, viewCenter);
            status = vp.zoom(viewCenter, zoomRatio);
        }
        // if we scrolled out, we may have invalidated the current AccuSnap path
        IModelApp_1.IModelApp.accuSnap.reEvaluate();
        return status;
    }
}
/** Controls the current view, primitive, and idle tools. Forwards events to the appropriate tool. */
class ToolAdmin {
    constructor() {
        this._toolEvents = new bentleyjs_core_1.BeEventList();
        this.currentInputState = new CurrentInputState();
        this.toolState = new ToolState();
        this.cursorInView = true;
        this.saveCursor = undefined;
        this.saveLocateCircle = false;
        this.defaultTool = "Select";
        this.gesturePending = false;
        this.modifierKeyWentDown = false;
        this.modifierKey = 0 /* None */;
        this.touchBridgeMode = false; // Flag indicating that touch events are being converted into mouse events for this tool
        /** Apply operations such as transform, copy or delete to all members of an assembly. */
        this.assemblyLock = false;
        /** If Grid Lock is on, project data points to grid. */
        this.gridLock = false;
        /** If ACS Snap Lock is on, project snap points to the ACS plane. */
        this.acsPlaneSnapLock = false;
        /** If ACS Plane Lock is on, standard view rotations are relative to the ACS instead of global. */
        this.acsContextLock = false;
        this._wantEventLoop = false;
    }
    onInitialized() {
        this._idleTool = IModelApp_1.IModelApp.tools.create("Idle");
    }
    startEventLoop() {
        if (!this._wantEventLoop) {
            this._wantEventLoop = true;
            requestAnimationFrame(() => this.animationFrame());
        }
    }
    onShutDown() {
        Sprites_1.IconSprites.emptyAll(); // clear cache of icon sprites
        this._wantEventLoop = false;
        this._idleTool = undefined;
    }
    animationFrame() {
        if (this._wantEventLoop) {
            this.onTimerEvent();
            IModelApp_1.IModelApp.viewManager.renderLoop();
            requestAnimationFrame(() => this.animationFrame());
        }
    }
    get idleTool() { return this._idleTool; }
    filterViewport(_vp) { return false; }
    isCurrentInputSourceMouse() { return this.currentInputState.inputSource === 1 /* Mouse */; }
    onInstallTool(tool) { this.currentInputState.clearKeyQualifiers(); return tool.onInstall(); }
    onPostInstallTool(tool) { tool.onPostInstall(); }
    get activeViewTool() { return this.viewTool; }
    get activePrimitiveTool() { return this.primitiveTool; }
    get activeTool() {
        return this.viewTool ? this.viewTool : (this.inputCollector ? this.inputCollector : this.primitiveTool); // NOTE: Viewing tools suspend input collectors as well as primitives...
    }
    getInfoString(hit, delimiter) {
        let tool = this.activeTool;
        if (!tool)
            tool = this.idleTool;
        return tool.getInfoString(hit, delimiter);
    }
    // public onToolStateIdChanged(_tool: InteractiveTool, _toolStateId?: string): boolean { return false; }
    /**
     * Event that is raised whenever the active tool changes. This includes both primitive and viewing tools.
     * @param newTool The newly activated tool
     */
    get activeToolChanged() { return this._toolEvents.get("activeTool"); }
    getCursorView() { return this.currentInputState.viewport; }
    onAccuSnapEnabled() { }
    onAccuSnapDisabled() { }
    onAccuSnapSyncUI() { }
    /** called when a viewport is closed */
    onViewportClosed(vp) {
        //  Closing the viewport may also delete the QueryModel so we have to prevent AccuSnap from trying to use it.
        IModelApp_1.IModelApp.accuSnap.clear();
        this.currentInputState.clearViewport(vp);
    }
    initGestureEvent(ev, vp, gestureInfo) {
        const current = this.currentInputState;
        current.fromGesture(vp, gestureInfo, true);
        current.toEvent(ev, false);
        if (gestureInfo.isFromMouse)
            ev.actualInputSource = 1 /* Mouse */;
    }
    onWheel(vp, wheelDelta, pt2d) {
        if (!this.cursorInView)
            return;
        vp.removeAnimator();
        this.currentInputState.fromButton(vp, pt2d, 1 /* Mouse */, true);
        const wheelEvent = new Tool_1.BeWheelEvent();
        wheelEvent.wheelDelta = wheelDelta;
        this.currentInputState.toEvent(wheelEvent, true);
        this.onWheelEvent(wheelEvent);
    }
    onWheelEvent(wheelEvent) {
        const activeTool = this.activeTool;
        if (undefined === activeTool || !activeTool.onMouseWheel(wheelEvent))
            this.idleTool.onMouseWheel(wheelEvent);
    }
    onMouseLeave(vp) {
        IModelApp_1.IModelApp.notifications.clearToolTip();
        this.cursorInView = false;
        vp.invalidateDecorations();
    }
    /** @hidden */
    updateDynamics(ev) {
        if (!IModelApp_1.IModelApp.viewManager.inDynamicsMode || undefined === this.activeTool)
            return;
        if (undefined === ev) {
            ev = new Tool_1.BeButtonEvent();
            this.fillEventFromCursorLocation(ev);
        }
        if (undefined === ev.viewport)
            return;
        const context = new ViewContext_1.DynamicsContext(ev.viewport);
        this.activeTool.onDynamicFrame(ev, context);
    }
    /**
     * This is invoked on each frame to update current input state and forward model motion events to tools.
     */
    onTimerEvent() {
        const tool = this.activeTool;
        const current = this.currentInputState;
        if (current.numberTouches !== 0 && !this.touchBridgeMode) {
            const touchMotionStopped = current.hasTouchMotionPaused;
            if (!touchMotionStopped)
                return true;
            if (tool)
                tool.onTouchMotionPaused();
            return true;
        }
        const ev = new Tool_1.BeButtonEvent();
        current.toEvent(ev, true);
        const wasMotion = current.wasMotion;
        if (!wasMotion) {
            if (tool)
                tool.onModelNoMotion(ev);
            if (1 /* Mouse */ === current.inputSource) {
                IModelApp_1.IModelApp.accuSnap.onNoMotion(ev);
                // Application.accuDraw.onNoMotion(ev);
            }
        }
        if (current.hasMotionStopped) {
            if (tool)
                tool.onModelMotionStopped(ev);
            if (1 /* Mouse */ === current.inputSource) {
                IModelApp_1.IModelApp.accuSnap.onMotionStopped(ev);
            }
        }
        this.updateDynamics(ev);
        return !wasMotion; // return value unused...
    }
    onMouseMotionEvent(ev) { return !this.filterButtonEvent(ev); }
    async onMouseMotion(vp, pt2d, inputSource) {
        const current = this.currentInputState;
        current.onMotion(pt2d);
        this.cursorInView = true;
        if (this.filterViewport(vp))
            return;
        const rawEvent = new Tool_1.BeButtonEvent();
        current.fromPoint(vp, pt2d, inputSource);
        current.toEvent(rawEvent, false);
        if (!this.onMouseMotionEvent(rawEvent)) {
            this.setIncompatibleViewportCursor(false);
            return;
        }
        await IModelApp_1.IModelApp.accuSnap.onMotion(rawEvent); // Must update AccuSnap before calling FromButton...
        const ev = new Tool_1.BeButtonEvent();
        current.fromButton(vp, pt2d, inputSource, true);
        current.toEvent(ev, true);
        // await IModelApp.accuDraw.onMotion(ev);
        const tool = this.activeTool;
        const isValidLocation = !tool ? true : tool.isValidLocation(ev, false);
        this.setIncompatibleViewportCursor(isValidLocation);
        if (undefined !== tool && isValidLocation) {
            if (current.isStartDrag(ev.button)) {
                current.onStartDrag(ev.button);
                current.changeButtonToDownPoint(ev);
                tool.onModelStartDrag(ev);
                return;
            }
            tool.onModelMotion(ev);
            this.updateDynamics(ev);
        }
        if (this.isLocateCircleOn)
            vp.invalidateDecorations();
    }
    adjustPointToACS(pointActive, vp, perpendicular) {
        // The "I don't want ACS lock" flag can be set by tools to override the default behavior...
        if (0 !== (this.toolState.coordLockOvr & 2 /* ACS */))
            return;
        let viewZRoot;
        // Lock to the construction plane
        if (vp.view.is3d() && vp.view.isCameraOn())
            viewZRoot = vp.view.camera.eye.vectorTo(pointActive);
        else
            viewZRoot = vp.rotMatrix.getRow(2);
        const auxOriginRoot = vp.getAuxCoordOrigin();
        const auxRMatrixRoot = vp.getAuxCoordRotation();
        let auxNormalRoot = auxRMatrixRoot.getRow(2);
        // If ACS xy plane is perpendicular to view and not snapping, project to closest xz or yz plane instead...
        if (auxNormalRoot.isPerpendicularTo(viewZRoot) && !AccuSnap_1.TentativeOrAccuSnap.isHot()) {
            const auxXRoot = auxRMatrixRoot.getRow(0);
            const auxYRoot = auxRMatrixRoot.getRow(1);
            auxNormalRoot = (Math.abs(auxXRoot.dotProduct(viewZRoot)) > Math.abs(auxYRoot.dotProduct(viewZRoot))) ? auxXRoot : auxYRoot;
        }
        LegacyMath_1.LegacyMath.linePlaneIntersect(pointActive, pointActive, viewZRoot, auxOriginRoot, auxNormalRoot, perpendicular);
    }
    adjustPointToGrid(pointActive, vp) {
        // The "I don't want grid lock" flag can be set by tools to override the default behavior...
        if (!this.gridLock || 0 !== (this.toolState.coordLockOvr & 4 /* Grid */))
            return;
        vp.pointToGrid(pointActive);
    }
    adjustPoint(pointActive, vp, projectToACS = true, applyLocks = true) {
        if (Math.abs(pointActive.z) < 1.0e-7)
            pointActive.z = 0.0; // remove Z fuzz introduced by active depth when near 0...
        let handled = false;
        if (applyLocks && !(IModelApp_1.IModelApp.tentativePoint.isActive || IModelApp_1.IModelApp.accuSnap.isHot()))
            handled = IModelApp_1.IModelApp.accuDraw.adjustPoint(pointActive, vp, false);
        // NOTE: We don't need to support axis lock, it is worthless if you have AccuDraw...
        if (!handled && vp.isPointAdjustmentRequired()) {
            if (applyLocks)
                this.adjustPointToGrid(pointActive, vp);
            if (projectToACS)
                this.adjustPointToACS(pointActive, vp, false);
        }
        else if (applyLocks) {
            const savePoint = pointActive.clone();
            this.adjustPointToGrid(pointActive, vp);
            // if grid lock changes point, resend point to accudraw
            if (handled && !pointActive.isExactEqual(savePoint))
                IModelApp_1.IModelApp.accuDraw.adjustPoint(pointActive, vp, false);
        }
        if (Math.abs(pointActive.z) < 1.0e-7)
            pointActive.z = 0.0;
    }
    adjustSnapPoint(perpendicular = true) {
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
        if (!snap)
            return;
        const vp = snap.viewport;
        const isHot = snap.isHot();
        const point = snap.getPoint().clone();
        const savePt = point.clone();
        if (!isHot)
            this.adjustPointToGrid(point, vp);
        if (!IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, isHot)) {
            if (vp.isSnapAdjustmentRequired())
                this.adjustPointToACS(point, vp, perpendicular || IModelApp_1.IModelApp.accuDraw.isActive());
        }
        if (!point.isExactEqual(savePt))
            snap.adjustedPoint.setFrom(point);
    }
    sendDataPoint(ev) {
        const tool = this.activeTool;
        const current = this.currentInputState;
        if (!ev.isDown) {
            if (tool !== current.buttonDownTool)
                return; // Don't send tool UP event if it didn't get the DOWN event...
            if (tool)
                tool.onDataButtonUp(ev);
            return;
        }
        current.buttonDownTool = tool;
        IModelApp_1.IModelApp.accuDraw.onPreDataButton(ev);
        if (tool)
            tool.onDataButtonDown(ev);
        IModelApp_1.IModelApp.tentativePoint.onButtonEvent();
        IModelApp_1.IModelApp.accuDraw.onPostDataButton(ev);
        if (tool instanceof PrimitiveTool_1.PrimitiveTool)
            tool.autoLockTarget(); // lock tool to target model of this view...
        // Don't use input event, need to account for point location adjusted to hit point on element by tools...
        const scratchEv = new Tool_1.BeButtonEvent();
        current.toEventFromLastDataPoint(scratchEv);
        this.updateDynamics(scratchEv);
    }
    /** return true to filter (ignore) the given button event */
    filterButtonEvent(ev) {
        const vp = ev.viewport;
        if (undefined === vp)
            return false;
        const tool = this.activeTool;
        return tool ? !tool.isCompatibleViewport(vp, false) : false;
    }
    onButtonEvent(ev) {
        if (this.filterButtonEvent(ev))
            return false;
        if (0 /* Data */ !== ev.button)
            return true;
        const tool = this.activeTool;
        return (!tool ? true : tool.isValidLocation(ev, true));
    }
    onDataButtonDown(vp, pt2d, inputSource) {
        vp.removeAnimator();
        if (this.filterViewport(vp))
            return;
        const ev = new Tool_1.BeButtonEvent();
        const current = this.currentInputState;
        current.fromButton(vp, pt2d, inputSource, true);
        current.onButtonDown(0 /* Data */);
        current.toEvent(ev, false);
        current.updateDownPoint(ev);
        this.sendDataPoint(ev);
    }
    onDataButtonUp(vp, pt2d, inputSource) {
        if (this.filterViewport(vp))
            return;
        const current = this.currentInputState;
        const wasDragging = current.isDragging(0 /* Data */);
        const ev = new Tool_1.BeButtonEvent();
        current.fromButton(vp, pt2d, inputSource, true);
        current.onButtonUp(0 /* Data */);
        current.toEvent(ev, true);
        if (!this.onButtonEvent(ev))
            return;
        const tool = this.activeTool;
        if (tool !== current.buttonDownTool)
            return; // tool didn't receive the DOWN event...
        if (wasDragging) {
            if (tool)
                tool.onModelEndDrag(ev);
            return;
        }
        current.changeButtonToDownPoint(ev);
        this.sendDataPoint(ev);
    }
    onMiddleButtonDown(vp, pt2d) {
        if (this.filterViewport(vp))
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeButtonEvent();
        const current = this.currentInputState;
        current.fromButton(vp, pt2d, 1 /* Mouse */, true);
        current.onButtonDown(2 /* Middle */);
        current.toEvent(ev, true);
        current.updateDownPoint(ev);
        if (!this.onButtonEvent(ev))
            return;
        const tool = this.activeTool;
        current.buttonDownTool = tool;
        if (!tool || !tool.onMiddleButtonDown(ev)) {
            if (this.idleTool.onMiddleButtonDown(ev)) {
                // The active tool might have changed since the idle tool installs viewing tools.
                const activeTool = this.activeTool;
                if (activeTool !== tool)
                    current.buttonDownTool = activeTool;
            }
        }
    }
    onMiddleButtonUp(vp, pt2d) {
        if (this.filterViewport(vp))
            return;
        const current = this.currentInputState;
        const wasDragging = current.isDragging(2 /* Middle */);
        const ev = new Tool_1.BeButtonEvent();
        current.fromButton(vp, pt2d, 1 /* Mouse */, true);
        current.onButtonUp(2 /* Middle */);
        current.toEvent(ev, true);
        if (!this.onButtonEvent(ev))
            return;
        const tool = this.activeTool;
        if (tool !== current.buttonDownTool)
            return;
        if (wasDragging) {
            if (tool)
                tool.onModelEndDrag(ev);
            return;
        }
        current.changeButtonToDownPoint(ev);
        if (!tool || !tool.onMiddleButtonUp(ev)) {
            this.idleTool.onMiddleButtonUp(ev);
        }
    }
    onResetButtonDown(vp, pt2d) {
        if (this.filterViewport(vp))
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeButtonEvent();
        const current = this.currentInputState;
        current.fromButton(vp, pt2d, 1 /* Mouse */, true);
        current.onButtonDown(1 /* Reset */);
        current.toEvent(ev, true);
        current.updateDownPoint(ev);
        if (!this.onButtonEvent(ev))
            return;
        const tool = this.activeTool;
        current.buttonDownTool = tool;
        if (tool)
            tool.onResetButtonDown(ev);
    }
    onResetButtonUp(vp, pt2d) {
        if (this.filterViewport(vp))
            return;
        const current = this.currentInputState;
        const wasDragging = current.isDragging(1 /* Reset */);
        const ev = new Tool_1.BeButtonEvent();
        current.fromButton(vp, pt2d, 1 /* Mouse */, true);
        current.onButtonUp(1 /* Reset */);
        current.toEvent(ev, true);
        if (!this.onButtonEvent(ev))
            return;
        const tool = this.activeTool;
        if (tool !== current.buttonDownTool)
            return;
        if (wasDragging) {
            if (tool)
                tool.onModelEndDrag(ev);
            return;
        }
        current.changeButtonToDownPoint(ev);
        if (tool)
            tool.onResetButtonUp(ev);
        IModelApp_1.IModelApp.tentativePoint.onButtonEvent();
    }
    onGestureEvent(ev) { return (!this.filterButtonEvent(ev)); }
    onEndGesture(vp, gestureInfo) {
        vp.removeAnimator();
        this.gesturePending = false;
        const ev = new Tool_1.BeButtonEvent();
        this.initGestureEvent(ev, vp, gestureInfo);
        if (this.onGestureEvent(ev)) {
            const activeTool = this.activeTool;
            if (!activeTool || !activeTool.onEndGesture(ev))
                this.idleTool.onEndGesture(ev);
            this.currentInputState.clearTouch();
        }
        IModelApp_1.IModelApp.accuSnap.clear();
    }
    onSingleFingerMove(vp, gestureInfo) {
        this.gesturePending = false;
        const current = this.currentInputState;
        if (current.ignoreTouchMotion(gestureInfo.numberTouches, gestureInfo.touches))
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeGestureEvent();
        this.initGestureEvent(ev, vp, gestureInfo);
        if (this.onGestureEvent(ev)) {
            const activeTool = this.activeTool;
            if (!activeTool || !activeTool.onSingleFingerMove(ev))
                this.idleTool.onSingleFingerMove(ev);
            current.onTouchMotionChange(gestureInfo.numberTouches, gestureInfo.touches);
        }
    }
    onMultiFingerMove(vp, gestureInfo) {
        this.gesturePending = false;
        const current = this.currentInputState;
        if (current.ignoreTouchMotion(gestureInfo.numberTouches, gestureInfo.touches))
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeGestureEvent();
        this.initGestureEvent(ev, vp, gestureInfo);
        if (this.onGestureEvent(ev)) {
            const activeTool = this.activeTool;
            if (!activeTool || !activeTool.onMultiFingerMove(ev))
                this.idleTool.onMultiFingerMove(ev);
            current.onTouchMotionChange(gestureInfo.numberTouches, gestureInfo.touches);
        }
    }
    processGestureInfo(vp, info, funcName) {
        vp.removeAnimator();
        this.gesturePending = false;
        const ev = new Tool_1.BeGestureEvent();
        this.initGestureEvent(ev, vp, info);
        const activeTool = this.activeTool;
        const activeToolFunc = activeTool[funcName];
        if (!activeToolFunc || !activeToolFunc.call(activeTool, ev))
            this._idleTool[funcName].call(this._idleTool, ev);
    }
    onTwoFingerTap(vp, gestureInfo) { this.processGestureInfo(vp, gestureInfo, "onTwoFingerTap"); }
    onPressAndTap(vp, gestureInfo) { this.processGestureInfo(vp, gestureInfo, "onPressAndTap"); }
    onSingleTap(vp, gestureInfo) { this.processGestureInfo(vp, gestureInfo, "onSingleTap"); }
    onDoubleTap(vp, gestureInfo) { this.processGestureInfo(vp, gestureInfo, "onDoubleTap"); }
    onLongPress(vp, gestureInfo) { this.processGestureInfo(vp, gestureInfo, "onLongPress"); }
    onModifierKeyTransition(wentDown, key) {
        if (wentDown === this.modifierKeyWentDown && key === this.modifierKey)
            return;
        const activeTool = this.activeTool;
        const changed = activeTool ? activeTool.onModifierKeyTransition(wentDown, key) : false;
        this.modifierKey = key;
        this.modifierKeyWentDown = wentDown;
        if (!changed)
            return;
        this.updateDynamics();
    }
    static getModifierKeyFromVirtualKey(key) {
        switch (key) {
            case 2 /* Alt */: return 8 /* Alt */;
            case 0 /* Shift */: return 4 /* Shift */;
            case 1 /* Control */: return 1 /* Control */;
        }
        return 0 /* None */;
    }
    onKeyTransition(wentDown, key) {
        const activeTool = this.activeTool;
        if (!activeTool)
            return false;
        if (0 /* Shift */ === key || 1 /* Control */ === key || 2 /* Alt */ === key) {
            this.onModifierKeyTransition(wentDown, ToolAdmin.getModifierKeyFromVirtualKey(key));
            return true;
        }
        const current = this.currentInputState;
        return activeTool.onKeyTransition(wentDown, key, current.isShiftDown, current.isControlDown);
    }
    /** @hidden */
    setInputCollector(newTool) {
        if (undefined !== this.inputCollector) {
            this.inputCollector.onCleanup();
            this.inputCollector = undefined;
        }
        if (undefined !== this.lastWheelEvent)
            this.lastWheelEvent.invalidate();
        this.inputCollector = newTool;
    }
    /** @hidden */
    exitInputCollector() {
        if (undefined === this.inputCollector)
            return;
        let unsuspend = false;
        if (this.suspendedByInputCollector) {
            this.suspendedByInputCollector.stop();
            this.suspendedByInputCollector = undefined;
            unsuspend = true;
        }
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.setInputCollector(undefined);
        if (unsuspend) {
            const tool = this.activeTool;
            if (tool)
                tool.onUnsuspend();
        }
    }
    startInputCollector(_newTool) {
        if (undefined !== this.inputCollector) {
            this.setInputCollector(undefined);
        }
        else {
            const tool = this.activeTool;
            if (tool)
                tool.onSuspend();
            this.suspendedByInputCollector = new SuspendedToolState();
        }
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
    }
    /** @hidden */
    setViewTool(newTool) {
        if (undefined !== this.viewTool) {
            this.viewTool.onCleanup();
            this.viewTool = undefined;
        }
        if (undefined !== this.lastWheelEvent)
            this.lastWheelEvent.invalidate();
        this.viewTool = newTool;
    }
    /** @hidden */
    exitViewTool() {
        if (undefined === this.viewTool)
            return;
        let unsuspend = false;
        if (undefined !== this.suspendedByViewTool) {
            this.suspendedByViewTool.stop(); // Restore state of suspended tool...
            this.suspendedByViewTool = undefined;
            unsuspend = true;
        }
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.setViewTool(undefined);
        if (unsuspend) {
            const tool = this.activeTool;
            if (tool)
                tool.onUnsuspend();
        }
        IModelApp_1.IModelApp.accuDraw.onViewToolExit();
        this.updateDynamics();
    }
    startViewTool() {
        const { accuDraw, accuSnap, viewManager } = IModelApp_1.IModelApp;
        accuDraw.onViewToolInstall();
        if (undefined !== this.viewTool) {
            this.setViewTool(undefined);
        }
        else {
            const tool = this.activeTool;
            if (tool)
                tool.onSuspend();
            this.suspendedByViewTool = new SuspendedToolState();
        }
        viewManager.invalidateDecorationsAllViews();
        this.toolState.coordLockOvr = 65535 /* All */;
        this.toolState.locateCircleOn = false;
        accuSnap.onStartTool();
        this.setCursor(Tool_1.BeCursor.CrossHair);
    }
    /** @hidden */
    setPrimitiveTool(primitiveTool) {
        const newTool = primitiveTool; // in case we're restarting the same tool
        if (undefined !== this.primitiveTool) {
            IModelApp_1.IModelApp.viewManager.endDynamicsMode();
            this.primitiveTool.onCleanup();
            this.primitiveTool = undefined;
        }
        if (undefined !== this.lastWheelEvent)
            this.lastWheelEvent.invalidate();
        this.primitiveTool = newTool;
    }
    startPrimitiveTool(newTool) {
        this.exitViewTool();
        if (undefined !== this.primitiveTool)
            this.setPrimitiveTool(undefined);
        // clear the primitive tool first so following call does not trigger the refreshing of the ToolSetting for the previous primitive tool
        this.exitInputCollector();
        // send message that will clear state specific UI
        this.activeToolChanged.raiseEvent(newTool);
        this.setIncompatibleViewportCursor(true); // Don't restore this...
        this.toolState.coordLockOvr = 0 /* None */;
        this.toolState.locateCircleOn = false;
        IModelApp_1.IModelApp.accuDraw.onPrimitiveToolInstall();
        IModelApp_1.IModelApp.accuSnap.onStartTool();
        this.setCursor(newTool.getCursor());
    }
    /**
     * Starts the default tool, if any. Generally invoked automatically when other tools exit, so
     * shouldn't be called directly.
     */
    startDefaultTool() {
        IModelApp_1.IModelApp.tools.run(this.defaultTool);
    }
    setCursor(cursor) {
        if (undefined === this.saveCursor)
            IModelApp_1.IModelApp.viewManager.setViewCursor(cursor);
        else
            this.saveCursor = cursor;
    }
    decorate(context) {
        const tool = this.activeTool;
        if (undefined !== tool) {
            tool.decorate(context);
            if (undefined !== this.viewTool && tool !== this.viewTool)
                this.viewTool.decorateSuspended(context); // NOTE: A DgnViewTool currently can't be suspended...
            if (undefined !== this.inputCollector && tool !== this.inputCollector)
                this.inputCollector.decorateSuspended(context);
            if (undefined !== this.primitiveTool && tool !== this.primitiveTool)
                this.primitiveTool.decorateSuspended(context);
        }
        if (!this.cursorInView)
            return;
        const viewport = context.viewport;
        const ev = new Tool_1.BeButtonEvent();
        this.fillEventFromCursorLocation(ev);
        if (ev.viewport !== viewport)
            return;
        const hit = IModelApp_1.IModelApp.accuDraw.isActive() ? undefined : IModelApp_1.IModelApp.accuSnap.currHit; // NOTE: Show surface normal until AccuDraw becomes active...
        viewport.drawLocateCursor(context, ev.point, viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.getApertureInches()), this.isLocateCircleOn(), hit);
    }
    isLocateCircleOn() {
        return this.toolState.locateCircleOn && this.currentInputState.inputSource === 1 /* Mouse */;
    }
    beginDynamics() {
        IModelApp_1.IModelApp.accuDraw.onBeginDynamics();
        IModelApp_1.IModelApp.viewManager.beginDynamicsMode();
        this.setLocateCursor(false);
    }
    endDynamics() {
        IModelApp_1.IModelApp.accuDraw.onEndDynamics();
        IModelApp_1.IModelApp.viewManager.endDynamicsMode();
        this.setLocateCursor(true);
    }
    fillEventFromCursorLocation(ev) { this.currentInputState.toEvent(ev, true); }
    fillEventFromDataButton(ev) { this.currentInputState.toEventFromLastDataPoint(ev); }
    fillEventFromLastDataButton(ev) { this.currentInputState.toEventFromLastDataPoint(ev); }
    setAdjustedDataPoint(ev) { this.currentInputState.adjustLastDataPoint(ev); }
    convertGestureSingleTapToButtonDownAndUp(ev) {
        this.touchBridgeMode = true;
        const displayPoint = ev.getDisplayPoint();
        const vp = ev.viewport;
        this.onDataButtonDown(vp, displayPoint, 2 /* Touch */);
        this.onDataButtonUp(vp, displayPoint, 2 /* Touch */);
        this.touchBridgeMode = false;
    }
    convertGestureToResetButtonDownAndUp(ev) {
        this.touchBridgeMode = true;
        const displayPoint = ev.getDisplayPoint();
        const vp = ev.viewport;
        this.onResetButtonDown(vp, displayPoint);
        this.onResetButtonUp(vp, displayPoint);
        this.touchBridgeMode = false;
    }
    convertGestureMoveToButtonDownAndMotion(ev) {
        this.touchBridgeMode = true;
        const vp = ev.viewport;
        if (0 === ev.gestureInfo.previousNumberTouches)
            this.onDataButtonDown(vp, ev.getDisplayPoint(), 2 /* Touch */);
        else
            this.onMouseMotion(vp, ev.getDisplayPoint(), 2 /* Touch */);
    }
    convertGestureEndToButtonUp(ev) {
        this.onDataButtonUp(ev.viewport, ev.getDisplayPoint(), 2 /* Touch */);
        this.touchBridgeMode = false;
    }
    setIncompatibleViewportCursor(restore) {
        if (restore) {
            if (undefined === this.saveCursor)
                return;
            this.toolState.locateCircleOn = this.saveLocateCircle;
            IModelApp_1.IModelApp.viewManager.setViewCursor(this.saveCursor);
            this.saveCursor = undefined;
            return;
        }
        if (undefined !== this.saveCursor)
            return;
        this.saveLocateCircle = this.toolState.locateCircleOn;
        this.saveCursor = IModelApp_1.IModelApp.viewManager.cursor;
        this.toolState.locateCircleOn = false;
        IModelApp_1.IModelApp.viewManager.setViewCursor(Tool_1.BeCursor.NotAllowed);
    }
    /** Performs default handling of mouse wheel event (zoom in/out) */
    processWheelEvent(ev, doUpdate) {
        WheelEventProcessor.process(ev, doUpdate);
        this.updateDynamics(ev);
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        return true;
    }
    onSelectedViewportChanged(previous, current) {
        IModelApp_1.IModelApp.accuDraw.onSelectedViewportChanged(previous, current);
        if (undefined === current)
            this.callOnCleanup();
        else if (undefined !== this.primitiveTool)
            this.primitiveTool.onSelectedViewportChanged(previous, current);
        else if (undefined !== this.viewTool)
            this.viewTool.onSelectedViewportChanged(previous, current);
    }
    setLocateCircleOn(locateOn) {
        if (undefined === this.saveCursor)
            this.toolState.locateCircleOn = locateOn;
        else
            this.saveLocateCircle = locateOn;
    }
    setLocateCursor(enableLocate) {
        const { viewManager } = IModelApp_1.IModelApp;
        this.setCursor(viewManager.inDynamicsMode ? Tool_1.BeCursor.Dynamics : Tool_1.BeCursor.CrossHair);
        this.setLocateCircleOn(enableLocate);
        viewManager.invalidateDecorationsAllViews();
    }
    callOnCleanup() {
        this.exitViewTool();
        this.exitInputCollector();
        if (undefined !== this.primitiveTool)
            this.primitiveTool.onCleanup();
    }
}
exports.ToolAdmin = ToolAdmin;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const HitDetail_1 = __webpack_require__(63);
const imodeljs_common_1 = __webpack_require__(2);
const IModelApp_1 = __webpack_require__(5);
class TentativePoint {
    constructor() {
        this.isActive = false;
        this.qualifierMask = 0; // button qualifiers
        this.candidateSnapMode = 1 /* Nearest */; // during snap creation: the snap to try
        this.snapList = new HitDetail_1.HitList();
        this.hotDistanceInches = 0.21;
        this.rawPoint = new geometry_core_1.Point3d(); // world coordinates
        this.point = new geometry_core_1.Point3d(); // world coords (adjusted for locks)
        this.viewPt = new geometry_core_1.Point3d(); // view coordinate system
    }
    onInitialized() { }
    isSnappedToIntersectionCandidate() { return undefined !== this.currSnap && 64 /* Intersection */ === this.currSnap.snapMode && 3 /* Intersection */ !== this.currSnap.getHitType(); }
    setHitList(list) { this.tpHits = list; }
    /** @return true if the tentative point is currently active and snapped to an element. */
    isSnapped() { return !!this.currSnap; }
    /** @return The current snap path when TentativePoint.isSnapped or undefined. */
    getCurrSnap() { return this.currSnap; }
    getPoint() {
        const snap = this.currSnap;
        return !snap ? this.point : snap.adjustedPoint;
    }
    clear(doErase) {
        if (doErase) {
            this.removeTentative();
            IModelApp_1.IModelApp.accuSnap.synchSnapMode();
        }
        IModelApp_1.IModelApp.accuSnap.destroy();
        this.isActive = false;
        this.snapList.empty();
        this.setCurrSnap(undefined);
        this.tpHits = undefined;
    }
    removeTentative() {
        if (!this.isActive)
            return;
        IModelApp_1.IModelApp.accuSnap.erase();
        if (this.getCurrSnap())
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        else
            this.viewport.invalidateDecorations();
        this.isActive = false;
    }
    getTPSnapMode() { return (64 /* Intersection */ === this.activeSnapMode()) ? 1 /* Nearest */ : this.activeSnapMode(); }
    activeSnapMode() { return this.candidateSnapMode; }
    setCurrSnap(newSnap) {
        if (newSnap) {
            newSnap.heat = 2 /* InRange */;
        }
        this.currSnap = newSnap;
    }
    showTentative() {
        if (this.isSnapped()) {
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            IModelApp_1.IModelApp.accuSnap.displayInfoBalloon(this.viewPt, this.viewport, undefined);
        }
        else {
            this.viewport.invalidateDecorations();
        }
        this.isActive = true;
    }
    clearElementFromHitList(element) {
        this.snapList.removeHitsFrom(element);
    }
    getHitAndList(holder) {
        const hit = this.currSnap;
        if (hit) {
            holder.setHitList(this.tpHits);
            this.tpHits = undefined;
        }
        return hit;
    }
    onButtonEvent() {
        this.removeTentative();
        IModelApp_1.IModelApp.accuSnap.synchSnapMode();
        this.snapList.empty();
        this.setCurrSnap(undefined);
        this.tpHits = undefined;
    }
    isView3d() { return this.viewport.view.is3d(); }
    /** draw the cross as 4 lines rather than 2, so that there's no hole in the middle when drawn in dashed symbology */
    drawTpCross(graphic, tpSize, x, y) {
        const tpCross = [new geometry_core_1.Point2d(x, y), new geometry_core_1.Point2d(x + tpSize, y)];
        graphic.addLineString2d(tpCross, 0.0);
        tpCross[1].x = x - tpSize;
        graphic.addLineString2d(tpCross, 0.0);
        tpCross[1].x = x;
        tpCross[1].y = y + tpSize;
        graphic.addLineString2d(tpCross, 0.0);
        tpCross[1].y = y - tpSize;
        graphic.addLineString2d(tpCross, 0.0);
    }
    decorate(context) {
        const viewport = context.viewport;
        if (!this.isActive || !viewport)
            return;
        const tpSize = viewport.pixelsPerInch / 2.0; // about a 1/2 inch
        const center = viewport.worldToView(this.point);
        // draw a "background shadow" line: wide, black, mostly transparent
        const graphic = context.createViewOverlay();
        const color = imodeljs_common_1.ColorDef.from(0, 0, 0, 225);
        graphic.setSymbology(color, color, 7);
        this.drawTpCross(graphic, tpSize + 2, center.x + 1, center.y + 1);
        // draw a background line: narrow, black, slightly transparent (this is in case we're not snapped and showing a dotted line)
        imodeljs_common_1.ColorDef.from(0, 0, 0, 10, color);
        graphic.setSymbology(color, color, 3);
        this.drawTpCross(graphic, tpSize + 1, center.x, center.y);
        // off-white (don't want white/black reversal), slightly transparent
        imodeljs_common_1.ColorDef.from(0xfe, 0xff, 0xff, 10, color);
        graphic.setSymbology(color, color, 1, this.isSnapped ? 0 /* Solid */ : 4177066232 /* Code2 */);
        this.drawTpCross(graphic, tpSize, center.x, center.y);
        context.addViewOverlay(graphic.finish());
        // Draw snapped segment...
        if (this.currSnap)
            this.currSnap.draw(context);
    }
    getNextSnap() {
        const snap = this.snapList.getNextHit();
        if (!snap || !snap.isSnapDetail())
            return undefined;
        return snap;
    }
    /** find an intersection between the current snap path and one of the other paths in the current hitList. */
    doTPIntersectSnap(_inHit, changeFirst) {
        // use the current snapped path as the first path for the intersection
        const currSnap = this.getCurrSnap();
        const firstHit = currSnap;
        // // if we're already showing an intersection, use the "second" path as the new first path
        // if (changeFirst && (HitDetailType.Intersection === firstHit.getHitType()))
        //   firstHit = ((IntersectDetail *) firstHit) -> GetSecondHit();
        // // keep searching hits for an acceptable intersection
        // HitList intsctList;
        // for (secondHit = inHit; secondHit; secondHit = ElementLocateManager:: GetManager().GetElementPicker().GetNextHit())
        // {
        //   SnapDetailP thisIntsct = nullptr;
        //   if (SnapStatus:: Success == intsctCtx.IntersectDetails(& thisIntsct, firstHit, secondHit, & point, true))
        //   {
        //     intsctList.AddHit(thisIntsct, false, false);
        //     thisIntsct -> Release(); // ref count was incremented when we added to list
        //   }
        // }
        // intsctSnap = (SnapDetail *) intsctList.GetHit(0);
        // if (nullptr != intsctSnap) {
        //   intsctSnap -> AddRef();
        //   intsctSnap -> SetSnapMode(SnapMode.Intersection);
        //   ElementLocateManager:: GetManager()._SetChosenSnapMode(SnapType:: Points, SnapMode.Intersection);
        //   return intsctSnap;
        // }
        // We couldn't find an intersection, so now we have to decide what to show. If we were previously
        // showing an intersection, and the mouse moved to a new location (that's what "changeFirst" means), then
        // that probably means that s/he was trying to find a new element, but missed. In that case, we re-activate the
        // previous hit as the new snap, but of course we don't show it as an intersection. If we were not previously
        // snapped to an intersection, then s/he just missed, start the TP over and return a nullptr.
        return (changeFirst && (currSnap !== firstHit)) ? firstHit : undefined;
    }
    /*  We're looking for the second path for an intersection.
    *   currHit already points to the first path.
    *   nextHit is the next snap after currHit in snapList.
    * Multiple snaps:
    *   Because snapList can contain snaps of different types and because
    *   this list is sorted by proximity to the cursor, the
    *   SnapMode::Intersection candidate snaps may not be contiguous in the list.
    * This function returns the next snap in the snap list that is
    *   a SnapMode::Intersection candidate snap. This might be nextHit, or
    *   it might be a snap farther along.
    */
    findNextIntersectionCandidate(nextHit) {
        if (!nextHit)
            return undefined;
        if (64 /* Intersection */ === nextHit.snapMode && 3 /* Intersection */ !== nextHit.getHitType())
            return nextHit;
        if (this.snapList.currHit === -1)
            return undefined; // There is no current hit?! This happens when we TP twice to the same element.
        // Now search for the NEXT intersection target
        // currHit already points to the item in the list that follows nextHit
        for (let iSnapDetail = this.snapList.currHit; iSnapDetail < this.snapList.length; ++iSnapDetail) {
            const snap = this.snapList.hits[iSnapDetail];
            if (64 /* Intersection */ === snap.snapMode && 3 /* Intersection */ !== snap.getHitType())
                return snap;
        }
        return undefined;
    }
    optimizeHitList() {
        // Remove snaps that refer to same point on same element
        // (This makes it less frustrating to the user when stepping through alt. points!)
        for (let iSnapDetail = 0; iSnapDetail < this.snapList.length; ++iSnapDetail) {
            const snap = this.snapList.getHit(iSnapDetail);
            const sourceId = snap.sourceId;
            if (!sourceId)
                continue;
            let foundAny = false;
            for (let jSnapDetail = iSnapDetail + 1; jSnapDetail < this.snapList.length; ++jSnapDetail) {
                const otherSnap = this.snapList.getHit(jSnapDetail);
                if (otherSnap.adjustedPoint.isExactEqual(snap.adjustedPoint)) {
                    if (sourceId === otherSnap.sourceId) {
                        this.snapList.setHit(jSnapDetail, undefined);
                        foundAny = true;
                    }
                }
            }
            if (foundAny)
                this.snapList.dropNulls();
        }
    }
    async testHitsForSnapMode(snapMode) {
        this.tpHits.resetCurrentHit();
        this.candidateSnapMode = snapMode;
        let thisHit;
        while (thisHit = this.tpHits.getNextHit()) {
            const snap = await IModelApp_1.IModelApp.accuSnap.requestSnap(thisHit, this.getTPSnapMode(), this.hotDistanceInches);
            if (snap) {
                // Original hit list is already sorted...preserve order...
                this.snapList.insertHit(-1, snap);
                // Annotate the SnapDetail with the snap mode that was used to generate it
                if (64 /* Intersection */ === snapMode)
                    snap.snapMode = 64 /* Intersection */; // A SnapDetail (not IntersectionDetail) with SnapMode.Intersection denotes an intersection candidate...
            }
        }
        this.candidateSnapMode = 1 /* Nearest */;
        return 0 /* SUCCESS */;
    }
    async getSnaps() {
        // clear any current snaps
        this.snapList.empty();
        // make sure we don't have any hits.
        this.tpHits = undefined;
        const currHit = IModelApp_1.IModelApp.accuSnap.getHitAndList(this);
        // use existing AccuSnap hit list if one exists...
        if (!currHit) {
            // search for elements around the current raw point (search should not be affected by locks!)
            const aperture = (2.0 * this.viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.getApertureInches()) / 2.0) + 1.5;
            const options = IModelApp_1.IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...
            const picker = IModelApp_1.IModelApp.locateManager.getElementPicker();
            picker.empty();
            options.hitSource = 4 /* TentativeSnap */;
            if (0 === picker.doPick(this.viewport, this.rawPoint, aperture, options))
                return undefined;
            this.tpHits = picker.getHitList(true);
        }
        // Construct each active point snap mode
        const snaps = IModelApp_1.IModelApp.accuSnap.getActiveSnapModes();
        for (const snap of snaps) {
            await this.testHitsForSnapMode(snap);
        }
        this.optimizeHitList();
        // if something is AccuSnapped, make that the current tp snap
        if (currHit && currHit.isSnapDetail() && currHit.sourceId && 2 /* Snap */ <= currHit.getHitType()) {
            // now we have to remove that path from the tp list.
            this.snapList.removeHitsFrom(currHit.sourceId);
            this.snapList.resetCurrentHit();
            return currHit;
        }
        return this.getNextSnap();
    }
    static arePointsCloseEnough(pt1, pt2, pixelDistance) {
        const aperture = pixelDistance + 1.5;
        return pt1.distance(pt2) < aperture;
    }
    async process(ev) {
        // remove the TP cross if it is already on the screen
        this.removeTentative();
        const lastPtView = this.viewPt;
        this.viewport = ev.viewport;
        this.point.setFrom(ev.point);
        this.rawPoint.setFrom(ev.rawPoint);
        this.viewPt.setFrom(ev.viewPoint);
        this.qualifierMask = ev.keyModifiers;
        let snap;
        const snapAgain = (this.isSnapped() && TentativePoint.arePointsCloseEnough(lastPtView, this.viewPt, this.viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.getApertureInches())));
        snap = snapAgain ? this.getNextSnap() : await this.getSnaps();
        // If the the previous snap was done in intersection mode,
        // we now want to try to find intersections with the previous snap.
        if (this.isSnappedToIntersectionCandidate()) {
            // (If the mouse didn't move, then keep the previous "first" path and try to find more intersections with it.)
            const intersectSnap = this.doTPIntersectSnap(this.findNextIntersectionCandidate(snap), !snapAgain);
            //  If we can't create an intersection, then move on to the next active snap
            if (intersectSnap)
                snap = intersectSnap;
        }
        this.setCurrSnap(snap); //  Adopt the snap as current
        IModelApp_1.IModelApp.accuSnap.clear(); // make sure there's no AccuSnap active after a tentative point (otherwise we continually snap to it).
        if (this.isSnapped())
            this.point.setFrom(this.currSnap.snapPoint);
        this.showTentative(); // show the TP cross
    }
}
exports.TentativePoint = TentativePoint;


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({

  processors: {},

  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });

    return value;
  }
});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
const System_1 = __webpack_require__(17);
const imodeljs_common_1 = __webpack_require__(2);
const System_2 = __webpack_require__(7);
const BranchState_1 = __webpack_require__(218);
const Graphic_1 = __webpack_require__(64);
const EdgeOverrides_1 = __webpack_require__(55);
const Viewport_1 = __webpack_require__(44);
const DrawCommand_1 = __webpack_require__(56);
const ColorInfo_1 = __webpack_require__(101);
const RenderState_1 = __webpack_require__(82);
const GL_1 = __webpack_require__(8);
const SceneCompositor_1 = __webpack_require__(368);
const FrameBuffer_1 = __webpack_require__(83);
const Texture_1 = __webpack_require__(19);
const CachedGeometry_1 = __webpack_require__(29);
/** Represents the frustum for use in glsl as a pair of uniforms. */
class FrustumUniforms {
    constructor() {
        const pData = [];
        pData[0 /* kTop */] = 0.0;
        pData[1 /* kBottom */] = 0.0;
        pData[2 /* kLeft */] = 0.0;
        pData[3 /* kRight */] = 0.0;
        const fData = [];
        fData[0 /* kNear */] = 0.0;
        fData[1 /* kFar */] = 0.0;
        fData[2 /* kType */] = 0.0;
        this._planeData = new Float32Array(pData);
        this._frustumData = new Float32Array(fData);
    }
    get frustumPlanes() { return this._planeData; } // uniform vec4 u_frustumPlanes; // { top, bottom, left, right }
    get frustum() { return this._frustumData; } // uniform vec3 u_frustum; // { near, far, type }
    get nearPlane() { return this._frustumData[0 /* kNear */]; }
    get farPlane() { return this._frustumData[1 /* kFar */]; }
    get type() { return this.frustum[2 /* kType */]; }
    get is2d() { return 0 /* TwoDee */ === this.type; }
    setPlanes(top, bottom, left, right) {
        this._planeData[0 /* kTop */] = top;
        this._planeData[1 /* kBottom */] = bottom;
        this._planeData[2 /* kLeft */] = left;
        this._planeData[3 /* kRight */] = right;
    }
    setFrustum(nearPlane, farPlane, type) {
        this._frustumData[0 /* kNear */] = nearPlane;
        this._frustumData[1 /* kFar */] = farPlane;
        this._frustumData[2 /* kType */] = type;
    }
}
exports.FrustumUniforms = FrustumUniforms;
/** Interface for GPU clipping. Max of 6 planes of clipping; no nesting */
class Clips {
    constructor() {
        this._clipCount = 0;
        this._clipActive = 0;
        const data = [];
        for (let i = 0; i < 6 * 4; i++) {
            data[i] = 0.0;
        }
        this._clips = new Float32Array(data);
    }
    setFrom(planes, viewMatrix) {
        this._clipActive++;
        if (1 === this._clipActive) {
            const count = planes.length;
            this._clipCount = count;
            for (let i = 0; i < count; ++i) {
                // Transform direction of clip plane
                const norm = planes[i].inwardNormalRef;
                const dir = viewMatrix.multiplyVector(norm);
                dir.normalizeInPlace();
                this._clips[i * 4] = dir.x;
                this._clips[i * 4 + 1] = dir.y;
                this._clips[i * 4 + 2] = dir.z;
                // Transform distance of clip plane
                const pos = norm.scale(planes[i].distance).cloneAsPoint3d();
                const xFormPos = viewMatrix.multiplyPoint3d(pos);
                this._clips[i * 4 + 3] = -dir.dotProductXYZ(xFormPos.x, xFormPos.y, xFormPos.z);
            }
        }
    }
    clear() {
        if (this._clipActive === 1) {
            this._clipCount = 0;
        }
        if (this._clipActive > 0) {
            this._clipActive--;
        }
    }
    get clips() { return this._clips; }
    get length() { return this._clipCount; }
    get isValid() { return this.length > 0; }
}
exports.Clips = Clips;
class PerformanceMetrics {
    constructor() {
        this.frameTimes = [];
        this.curFrameTimeIndex = 0;
        this.gatherFrameTimings = true;
        this.curSpfTimeIndex = 0;
        this.spfTimes = [];
        this.spfSum = 0;
        this.renderSpfTimes = [];
        this.renderSpfSum = 0;
        this.loadTileTimes = [];
        this.loadTileSum = 0;
        this.fpsTimer = new bentleyjs_core_1.StopWatch(undefined, true);
        this.fpsTimerStart = 0;
    }
}
exports.PerformanceMetrics = PerformanceMetrics;
class Target extends System_1.RenderTarget {
    constructor() {
        super();
        this._stack = new BranchState_1.BranchStack();
        this._scene = [];
        this._overridesUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._hiliteUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._flashedElemId = bentleyjs_core_1.Id64.invalidId;
        this._flashedUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._flashIntensity = 0;
        this._transparencyThreshold = 0;
        this._fStop = 0;
        this._ambientLight = new Float32Array(3);
        this._performanceMetrics = new PerformanceMetrics();
        this._dcAssigned = false;
        this.clips = new Clips();
        this.decorationState = BranchState_1.BranchState.createForDecorations(); // Used when rendering view background and view/world overlays.
        this.frustumUniforms = new FrustumUniforms();
        this.bgColor = imodeljs_common_1.ColorDef.red.clone();
        this.monoColor = imodeljs_common_1.ColorDef.white.clone();
        this.hiliteSettings = new imodeljs_common_1.Hilite.Settings();
        this.planFrustum = new imodeljs_common_1.Frustum();
        this.nearPlaneCenter = new geometry_core_1.Point3d();
        this.viewMatrix = geometry_core_1.Transform.createIdentity();
        this.projectionMatrix = geometry_core_1.Matrix4d.createIdentity();
        this._visibleEdgeOverrides = new EdgeOverrides_1.EdgeOverrides();
        this._hiddenEdgeOverrides = new EdgeOverrides_1.EdgeOverrides();
        this._batches = [];
        this._doDebugPaint = false;
        this._scratchTmpFrustum = new imodeljs_common_1.Frustum();
        this._scratchRectFrustum = new imodeljs_common_1.Frustum();
        this._scratchViewFlags = new imodeljs_common_1.ViewFlags();
        this._renderCommands = new DrawCommand_1.RenderCommands(this, this._stack);
        this._overlayRenderState = new RenderState_1.RenderState();
        this._overlayRenderState.flags.depthMask = false;
        this._overlayRenderState.flags.blend = true;
        this._overlayRenderState.blend.setBlendFunc(GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.OneMinusSrcAlpha);
        this.compositor = new SceneCompositor_1.SceneCompositor(this); // compositor is created but not yet initialized... we are still undisposed
    }
    get currentOverrides() { return this._currentOverrides; }
    // public get currentOverrides(): FeatureOverrides | undefined { return this._currentOverrides ? undefined : undefined; } // ###TODO remove this - for testing purposes only (forces overrides off)
    set currentOverrides(ovr) {
        // Don't bother setting up overrides if they don't actually override anything - wastes time doing texture lookups in shaders.
        this._currentOverrides = (undefined !== ovr && ovr.anyOverridden) ? ovr : undefined;
    }
    get transparencyThreshold() { return this._transparencyThreshold; }
    get techniques() { return System_2.System.instance.techniques; }
    get hilite() { return this._hilite; }
    get hiliteUpdateTime() { return this._hiliteUpdateTime; }
    get flashedElemId() { return this._flashedElemId; }
    get flashedUpdateTime() { return this._flashedUpdateTime; }
    get flashIntensity() { return this._flashIntensity; }
    get overridesUpdateTime() { return this._overridesUpdateTime; }
    get areDecorationOverridesActive() { return false; } // ###TODO
    get fStop() { return this._fStop; }
    get ambientLight() { return this._ambientLight; }
    get shaderLights() { return this._shaderLights; }
    get scene() { return this._scene; }
    get dynamics() { return this._dynamics; }
    getWorldDecorations(decs) {
        if (undefined === this._worldDecorations) {
            bentleyjs_core_1.assert(0 < decs.list.length);
            // Don't allow flags like monochrome etc to affect world decorations. Allow lighting in 3d only.
            const vf = new imodeljs_common_1.ViewFlags();
            vf.setRenderMode(6 /* SmoothShade */);
            vf.setShowClipVolume(false);
            if (this.is2d) {
                vf.setShowSourceLights(false);
                vf.setShowCameraLights(false);
                vf.setShowSolarLight(false);
            }
            this._worldDecorations = new Graphic_1.WorldDecorations(vf);
        }
        this._worldDecorations.init(decs);
        return this._worldDecorations;
    }
    get currentViewFlags() { return this._stack.top.viewFlags; }
    get currentTransform() { return this._stack.top.transform; }
    get currentShaderFlags() { return this.currentViewFlags.isMonochrome() ? 1 /* Monochrome */ : 0 /* None */; }
    get currentFeatureSymbologyOverrides() { return this._stack.top.symbologyOverrides; }
    get hasClipVolume() { return this.clips.isValid && this._stack.top.showClipVolume; }
    get hasClipMask() { return undefined !== this.clipMask; }
    get clipMask() { return this._clipMask; }
    set clipMask(mask) {
        bentleyjs_core_1.assert(!this.hasClipMask);
        bentleyjs_core_1.assert(this.is2d);
        bentleyjs_core_1.dispose(this._clipMask);
        this._clipMask = mask;
    }
    get environmentMap() { return this._environmentMap; }
    get diffuseMap() { return this._diffuseMap; }
    get is2d() { return this.frustumUniforms.is2d; }
    get is3d() { return !this.is2d; }
    dispose() {
        bentleyjs_core_1.dispose(this._decorations);
        bentleyjs_core_1.dispose(this.compositor);
        this._dynamics = bentleyjs_core_1.dispose(this._dynamics);
        this._worldDecorations = bentleyjs_core_1.dispose(this._worldDecorations);
        this._clipMask = bentleyjs_core_1.dispose(this._clipMask);
        this._environmentMap = bentleyjs_core_1.dispose(this._environmentMap);
        this._diffuseMap = bentleyjs_core_1.dispose(this._diffuseMap);
        for (const batch of this._batches)
            batch.onTargetDisposed(this);
        this._batches = [];
        this._dcAssigned = false; // necessary to reassign to OnScreenTarget fbo member when re-validating render plan
        this._renderCommands.clear();
    }
    pushBranch(exec, branch) {
        this._stack.pushBranch(branch);
        const clip = this._stack.top.clipVolume;
        if (undefined !== clip) {
            clip.push(exec);
        }
    }
    pushState(state) {
        bentleyjs_core_1.assert(undefined === state.clipVolume);
        this._stack.pushState(state);
    }
    popBranch() {
        const clip = this._stack.top.clipVolume;
        if (undefined !== clip) {
            clip.pop(this);
        }
        this._stack.pop();
    }
    pushActiveVolume() { } // ###TODO
    popActiveVolume() { } // ###TODO
    addBatch(batch) {
        bentleyjs_core_1.assert(this._batches.indexOf(batch) < 0);
        this._batches.push(batch);
    }
    onBatchDisposed(batch) {
        const index = this._batches.indexOf(batch);
        bentleyjs_core_1.assert(index > -1);
        this._batches.splice(index, 1);
    }
    setFrameTime(sceneTime = 0.0) {
        if (this._performanceMetrics.gatherFrameTimings) {
            if (sceneTime > 0.0) {
                this._performanceMetrics.frameTimes[0] = bentleyjs_core_1.BeTimePoint.beforeNow(bentleyjs_core_1.BeDuration.fromSeconds(sceneTime));
                this._performanceMetrics.frameTimes[1] = bentleyjs_core_1.BeTimePoint.now();
                this._performanceMetrics.curFrameTimeIndex = 2;
            }
            else if (this._performanceMetrics.curFrameTimeIndex < 12)
                this._performanceMetrics.frameTimes[this._performanceMetrics.curFrameTimeIndex++] = bentleyjs_core_1.BeTimePoint.now();
        }
    }
    get frameTimings() {
        const timings = [];
        for (let i = 0; i < 11; ++i)
            timings[i] = (this._performanceMetrics.frameTimes[i + 1].milliseconds - this._performanceMetrics.frameTimes[i].milliseconds);
        return timings;
    }
    get performanceMetrics() { return this._performanceMetrics; }
    // ---- Implementation of RenderTarget interface ---- //
    get renderSystem() { return System_2.System.instance; }
    get cameraFrustumNearScaleLimit() {
        return 0; // ###TODO
    }
    changeDecorations(decs) {
        this._decorations = bentleyjs_core_1.dispose(this._decorations);
        this._decorations = decs;
        for (let i = 0; i < 16; i++) {
            System_2.System.instance.context.disableVertexAttribArray(i);
        }
    }
    changeScene(scene, _activeVolume) {
        this._scene = scene;
        // ###TODO active volume
    }
    changeDynamics(dynamics) {
        // ###TODO: set feature IDs into each graphic so that edge display works correctly...
        // See IModelConnection.transientIds
        bentleyjs_core_1.dispose(this._dynamics);
        this._dynamics = dynamics;
    }
    overrideFeatureSymbology(ovr) {
        this._stack.setSymbologyOverrides(ovr);
        this._overridesUpdateTime = bentleyjs_core_1.BeTimePoint.now();
    }
    setHiliteSet(hilite) {
        this._hilite = hilite;
        this._hiliteUpdateTime = bentleyjs_core_1.BeTimePoint.now();
    }
    setFlashed(id, intensity) {
        if (!id.equals(this._flashedElemId)) {
            this._flashedElemId = id;
            this._flashedUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        }
        this._flashIntensity = intensity;
    }
    changeRenderPlan(plan) {
        if (this._dcAssigned && plan.is3d !== this.is3d) {
            // changed the dimensionality of the Target. World decorations no longer valid.
            // (lighting is enabled or disabled based on 2d vs 3d).
            bentleyjs_core_1.dispose(this._worldDecorations);
            this._worldDecorations = undefined;
        }
        if (!this.assignDC()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this.bgColor.setFrom(plan.bgColor);
        this.monoColor.setFrom(plan.monoColor);
        this.hiliteSettings.copyFrom(plan.hiliteSettings);
        this._transparencyThreshold = 0.0;
        // ##TODO active volume...
        const scratch = Target._scratch;
        const visEdgeOvrs = undefined !== plan.hline ? plan.hline.visible.clone(scratch.visibleEdges) : undefined;
        const hidEdgeOvrs = undefined !== plan.hline ? plan.hline.hidden.clone(scratch.hiddenEdges) : undefined;
        const vf = imodeljs_common_1.ViewFlags.createFrom(plan.viewFlags, scratch.viewFlags);
        let forceEdgesOpaque = true; // most render modes want edges to be opaque so don't allow overrides to their alpha
        switch (vf.renderMode) {
            case 0 /* Wireframe */: {
                // Edge overrides never apply in wireframe mode
                vf.setShowVisibleEdges(false);
                vf.setShowHiddenEdges(false);
                forceEdgesOpaque = false;
                break;
            }
            case 6 /* SmoothShade */: {
                // Hidden edges require visible edges
                if (!vf.showVisibleEdges()) {
                    vf.setShowHiddenEdges(false);
                }
                break;
            }
            case 4 /* SolidFill */: {
                // In solid fill, if the edge color is not overridden, the edges do not use the element's line color
                if (undefined !== visEdgeOvrs && !visEdgeOvrs.ovrColor) {
                    // ###TODO? Probably supposed to be contrast with fill and/or background color...
                    bentleyjs_core_1.assert(undefined !== hidEdgeOvrs);
                    visEdgeOvrs.color.setFrom(imodeljs_common_1.ColorDef.white);
                    hidEdgeOvrs.color.setFrom(imodeljs_common_1.ColorDef.white);
                    visEdgeOvrs.ovrColor = hidEdgeOvrs.ovrColor = true;
                }
            }
            /* falls through */
            case 3 /* HiddenLine */: {
                // In solid fill and hidden line mode, visible edges always rendered and edge overrides always apply
                vf.setShowVisibleEdges(true);
                bentleyjs_core_1.assert(undefined !== plan.hline); // these render modes only supported in 3d, in which case hline always initialized
                if (undefined !== plan.hline) {
                    // The threshold in HiddenLineParams ranges from 0.0 (hide anything that's not 100% opaque)
                    // to 1.0 (don't hide anything regardless of transparency). Convert it to an alpha value.
                    let threshold = plan.hline.transparencyThreshold;
                    threshold = Math.min(1.0, Math.max(0.0, threshold));
                    this._transparencyThreshold = 1.0 - threshold;
                }
                break;
            }
        }
        this._visibleEdgeOverrides.init(forceEdgesOpaque, visEdgeOvrs);
        this._hiddenEdgeOverrides.init(forceEdgesOpaque, hidEdgeOvrs);
        this._stack.setViewFlags(vf);
        plan.frustum.clone(this.planFrustum);
        const farLowerLeft = plan.frustum.getCorner(0 /* LeftBottomRear */);
        const farLowerRight = plan.frustum.getCorner(1 /* RightBottomRear */);
        const farUpperLeft = plan.frustum.getCorner(2 /* LeftTopRear */);
        const farUpperRight = plan.frustum.getCorner(3 /* RightTopRear */);
        const nearLowerLeft = plan.frustum.getCorner(4 /* LeftBottomFront */);
        const nearLowerRight = plan.frustum.getCorner(5 /* RightBottomFront */);
        const nearUpperLeft = plan.frustum.getCorner(6 /* LeftTopFront */);
        const nearUpperRight = plan.frustum.getCorner(7 /* RightTopFront */);
        const nearCenter = nearLowerLeft.interpolate(0.5, nearUpperRight, scratch.nearCenter);
        const viewX = normalizedDifference(nearLowerRight, nearLowerLeft, scratch.viewX);
        const viewY = normalizedDifference(nearUpperLeft, nearLowerLeft, scratch.viewY);
        const viewZ = viewX.crossProduct(viewY, scratch.viewZ).normalize();
        if (!plan.is3d) {
            const halfWidth = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;
            const halfHeight = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;
            const depth = 2 * System_1.RenderTarget.frustumDepth2d;
            this.nearPlaneCenter.set(nearCenter.x, nearCenter.y, System_1.RenderTarget.frustumDepth2d);
            lookIn(this.nearPlaneCenter, viewX, viewY, viewZ, this.viewMatrix);
            ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);
            this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);
            this.frustumUniforms.setFrustum(0, depth, 0 /* TwoDee */);
        }
        else if (plan.fraction > 0.999) {
            const halfWidth = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;
            const halfHeight = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;
            const depth = geometry_core_1.Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3).magnitude();
            lookIn(nearCenter, viewX, viewY, viewZ, this.viewMatrix);
            ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);
            this.nearPlaneCenter.setFrom(nearLowerLeft);
            this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);
            this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);
            this.frustumUniforms.setFrustum(0, depth, 1 /* Orthographic */);
        }
        else {
            const scale = 1.0 / (1.0 - plan.fraction);
            const zVec = geometry_core_1.Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3);
            const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, scratch.point3);
            const frustumLeft = dotDifference(farLowerLeft, cameraPosition, viewX) * plan.fraction;
            const frustumRight = dotDifference(farLowerRight, cameraPosition, viewX) * plan.fraction;
            const frustumBottom = dotDifference(farLowerLeft, cameraPosition, viewY) * plan.fraction;
            const frustumTop = dotDifference(farUpperLeft, cameraPosition, viewY) * plan.fraction;
            const frustumFront = -dotDifference(nearLowerLeft, cameraPosition, viewZ);
            const frustumBack = -dotDifference(farLowerLeft, cameraPosition, viewZ);
            lookIn(cameraPosition, viewX, viewY, viewZ, this.viewMatrix);
            frustum(frustumLeft, frustumRight, frustumBottom, frustumTop, frustumFront, frustumBack, this.projectionMatrix);
            this.nearPlaneCenter.setFrom(nearLowerLeft);
            this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);
            this.frustumUniforms.setPlanes(frustumTop, frustumBottom, frustumLeft, frustumRight);
            this.frustumUniforms.setFrustum(frustumFront, frustumBack, 2 /* Perspective */);
        }
        // this.shaderlights.clear // ###TODO : Lighting
        this._fStop = 0.0;
        this._ambientLight[0] = 0.2;
        this._ambientLight[1] = 0.2;
        this._ambientLight[2] = 0.2;
        if (plan.is3d && undefined !== plan.lights) {
            // convertLights(...); // TODO: Lighting
            this._fStop = plan.lights.fstop;
        }
    }
    drawFrame(sceneMilSecElapsed) {
        bentleyjs_core_1.assert(System_2.System.instance.frameBufferStack.isEmpty);
        if (undefined === this._scene) {
            return;
        }
        this.paintScene(sceneMilSecElapsed);
        bentleyjs_core_1.assert(System_2.System.instance.frameBufferStack.isEmpty);
    }
    queueReset() {
        this.reset();
    }
    reset() {
        this.dispose();
        this._scene.length = 0;
        this._dynamics = undefined;
        // ###TODO this._activeVolume = undefined;
    }
    get wantInvertBlackBackground() { return false; }
    get visibleEdgeOverrides() { return this.getEdgeOverrides(1 /* OpaqueLinear */); }
    get hiddenEdgeOverrides() { return this.getEdgeOverrides(5 /* HiddenEdge */); }
    get isEdgeColorOverridden() {
        const ovrs = this.visibleEdgeOverrides;
        return undefined !== ovrs && ovrs.overridesColor;
    }
    get isEdgeWeightOverridden() {
        const ovrs = this.visibleEdgeOverrides;
        return undefined !== ovrs && ovrs.overridesWeight;
    }
    getEdgeOverrides(pass) {
        let ovrs;
        let enabled = false;
        if (5 /* HiddenEdge */ === pass) {
            ovrs = this._hiddenEdgeOverrides;
            enabled = this.currentViewFlags.showHiddenEdges();
        }
        else {
            ovrs = this._visibleEdgeOverrides;
            enabled = this.currentViewFlags.showVisibleEdges();
        }
        return enabled ? ovrs : undefined;
    }
    getEdgeWeight(params, baseWeight) {
        const ovrs = this.getEdgeOverrides(params.renderPass);
        return undefined !== ovrs && undefined !== ovrs.weight ? ovrs.weight : baseWeight;
    }
    getEdgeLineCode(params, baseCode) {
        const ovrs = this.getEdgeOverrides(params.renderPass);
        return undefined !== ovrs && undefined !== ovrs.lineCode ? ovrs.lineCode : baseCode;
    }
    get edgeColor() {
        bentleyjs_core_1.assert(this.isEdgeColorOverridden);
        return new ColorInfo_1.ColorInfo(this._visibleEdgeOverrides.color);
    }
    debugPaint() { }
    paintScene(sceneMilSecElapsed) {
        if (this._doDebugPaint) {
            this.debugPaint();
            return;
        }
        if (!this._dcAssigned) {
            return;
        }
        this.setFrameTime(sceneMilSecElapsed);
        this._beginPaint();
        const gl = System_2.System.instance.context;
        const rect = this.viewRect;
        gl.viewport(0, 0, rect.width, rect.height);
        this.setFrameTime();
        this._renderCommands.init(this._scene, this._decorations, this._dynamics);
        this.setFrameTime();
        this.compositor.draw(this._renderCommands); // scene compositor gets disposed and then re-initialized... target remains undisposed
        this.setFrameTime();
        this._stack.pushState(this.decorationState);
        this.drawPass(7 /* WorldOverlay */);
        this.drawPass(8 /* ViewOverlay */);
        this._stack.pop();
        this._endPaint();
        this.setFrameTime();
        if (sceneMilSecElapsed !== undefined) {
            const perfMet = this._performanceMetrics;
            const fpsTimerElapsed = perfMet.fpsTimer.currentSeconds - perfMet.fpsTimerStart;
            if (perfMet.spfTimes[perfMet.curSpfTimeIndex])
                perfMet.spfSum -= perfMet.spfTimes[perfMet.curSpfTimeIndex];
            perfMet.spfSum += fpsTimerElapsed;
            perfMet.spfTimes[perfMet.curSpfTimeIndex] = fpsTimerElapsed;
            const renderTimeElapsed = (perfMet.frameTimes[10].milliseconds - perfMet.frameTimes[1].milliseconds);
            if (perfMet.renderSpfTimes[perfMet.curSpfTimeIndex])
                perfMet.renderSpfSum -= perfMet.renderSpfTimes[perfMet.curSpfTimeIndex];
            perfMet.renderSpfSum += renderTimeElapsed;
            perfMet.renderSpfTimes[perfMet.curSpfTimeIndex++] = renderTimeElapsed;
            if (sceneMilSecElapsed !== undefined) {
                if (perfMet.loadTileTimes[perfMet.curSpfTimeIndex])
                    perfMet.loadTileSum -= perfMet.loadTileTimes[perfMet.curSpfTimeIndex];
                perfMet.loadTileSum += sceneMilSecElapsed;
                perfMet.loadTileTimes[perfMet.curSpfTimeIndex++] = sceneMilSecElapsed;
                if (perfMet.curSpfTimeIndex >= 50)
                    perfMet.curSpfTimeIndex = 0;
            }
            perfMet.fpsTimerStart = perfMet.fpsTimer.currentSeconds;
        }
        if (this._performanceMetrics.gatherFrameTimings) {
            gl.finish();
            this.setFrameTime();
        }
    }
    drawPass(pass) {
        System_2.System.instance.applyRenderState(this.getRenderState(pass));
        this.techniques.execute(this, this._renderCommands.getCommands(pass), pass);
    }
    getRenderState(pass) {
        // the other passes are handled by SceneCompositor
        bentleyjs_core_1.assert(8 /* ViewOverlay */ === pass || 7 /* WorldOverlay */ === pass);
        return this._overlayRenderState;
    }
    assignDC() {
        if (!this._dcAssigned) {
            this._dcAssigned = this._assignDC();
        }
        bentleyjs_core_1.assert(this._dcAssigned);
        return this._dcAssigned;
    }
    readPixels(rect, selector) {
        // We can't reuse the previous frame's data for a variety of reasons, chief among them that some types of geometry (surfaces, translucent stuff) don't write
        // to the pick buffers and others we don't want - such as non-pickable decorations - do.
        // Render to an offscreen buffer so that we don't destroy the current color buffer.
        const texture = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        if (undefined === texture)
            return undefined;
        let result;
        const fbo = FrameBuffer_1.FrameBuffer.create([texture]);
        if (undefined !== fbo) {
            System_2.System.instance.frameBufferStack.execute(fbo, true, () => {
                result = this.readPixelsFromFbo(rect, selector);
            });
            bentleyjs_core_1.dispose(fbo);
        }
        bentleyjs_core_1.dispose(texture);
        return result;
    }
    readPixelsFromFbo(rect, selector) {
        // Temporarily turn off textures and lighting. We don't need them and it will speed things up not to use them.
        const vf = this.currentViewFlags.clone(this._scratchViewFlags);
        vf.setShowTransparency(false);
        vf.setShowTextures(false);
        vf.setShowSourceLights(false);
        vf.setShowCameraLights(false);
        vf.setShowSolarLight(false);
        vf.setShowShadows(false);
        vf.setIgnoreGeometryMap(true);
        vf.setShowAcsTriad(false);
        vf.setShowGrid(false);
        vf.setMonochrome(false);
        vf.setShowMaterials(false);
        const state = BranchState_1.BranchState.create(this._stack.top.symbologyOverrides, vf);
        this.pushState(state);
        // Create a culling frustum based on the input rect.
        // NB: C++ BSIRect => TypeScript ViewRect...
        const viewRect = this.viewRect;
        const leftScale = (rect.left - viewRect.left) / (viewRect.right - viewRect.left);
        const rightScale = (viewRect.right - rect.right) / (viewRect.right - viewRect.left);
        const topScale = (rect.top - viewRect.top) / (viewRect.bottom - viewRect.top);
        const bottomScale = (viewRect.bottom - rect.bottom) / (viewRect.bottom - viewRect.top);
        const tmpFrust = this._scratchTmpFrustum;
        const planFrust = this.planFrustum;
        interpolateFrustumPoint(tmpFrust, planFrust, 0 /* _000 */, leftScale, 1 /* _100 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 1 /* _100 */, rightScale, 0 /* _000 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 2 /* _010 */, leftScale, 3 /* _110 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 3 /* _110 */, rightScale, 2 /* _010 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 4 /* _001 */, leftScale, 5 /* _101 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 5 /* _101 */, rightScale, 4 /* _001 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 6 /* _011 */, leftScale, 7 /* _111 */);
        interpolateFrustumPoint(tmpFrust, planFrust, 7 /* _111 */, rightScale, 6 /* _011 */);
        const rectFrust = this._scratchRectFrustum;
        interpolateFrustumPoint(rectFrust, tmpFrust, 0 /* _000 */, bottomScale, 2 /* _010 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 1 /* _100 */, bottomScale, 3 /* _110 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 2 /* _010 */, topScale, 0 /* _000 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 3 /* _110 */, topScale, 1 /* _100 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 4 /* _001 */, bottomScale, 6 /* _011 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 5 /* _101 */, bottomScale, 7 /* _111 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 6 /* _011 */, topScale, 4 /* _001 */);
        interpolateFrustumPoint(rectFrust, tmpFrust, 7 /* _111 */, topScale, 5 /* _101 */);
        // Repopulate the command list, omitting non-pickable decorations and putting transparent stuff into the opaque passes.
        // ###TODO: Handle pickable decorations.
        this._renderCommands.clear();
        this._renderCommands.setCheckRange(rectFrust);
        this._renderCommands.init(this._scene, this._decorations, this._dynamics, true);
        this._renderCommands.clearCheckRange();
        // Don't bother rendering + reading if we know there's nothing to draw.
        if (this._renderCommands.isEmpty) {
            this._stack.pop(); // ensure state is restored!
            return undefined;
        }
        // Draw the scene
        this.compositor.drawForReadPixels(this._renderCommands); // compositor gets disposed and re-initialized... target remains undisposed
        // Restore the state
        this._stack.pop();
        return this.compositor.readPixels(rect, selector);
    }
}
Target._scratch = {
    viewFlags: new imodeljs_common_1.ViewFlags(),
    nearCenter: new geometry_core_1.Point3d(),
    viewX: new geometry_core_1.Vector3d(),
    viewY: new geometry_core_1.Vector3d(),
    viewZ: new geometry_core_1.Vector3d(),
    vec3: new geometry_core_1.Vector3d(),
    point3: new geometry_core_1.Point3d(),
    visibleEdges: new imodeljs_common_1.HiddenLine.Style({}),
    hiddenEdges: new imodeljs_common_1.HiddenLine.Style({ ovrColor: false, color: new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.white), width: 1, pattern: 3435973836 /* HiddenLine */ }),
};
exports.Target = Target;
/** A Target which renders to a canvas on the screen */
class OnScreenTarget extends Target {
    constructor(canvas) {
        super();
        this._viewRect = new Viewport_1.ViewRect();
        this._prevViewRect = new Viewport_1.ViewRect();
        this._canvas = canvas;
    }
    dispose() {
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
        this._blitGeom = bentleyjs_core_1.dispose(this._blitGeom);
        super.dispose();
    }
    get viewRect() {
        this._viewRect.init(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);
        bentleyjs_core_1.assert(Math.floor(this._viewRect.width) === this._viewRect.width && Math.floor(this._viewRect.height) === this._viewRect.height, "fractional view rect dimensions");
        return this._viewRect;
    }
    setViewRect(_rect, _temporary) { bentleyjs_core_1.assert(false); }
    _assignDC() {
        bentleyjs_core_1.assert(undefined === this._fbo);
        const rect = this.viewRect;
        const color = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        if (undefined === color) {
            return false;
        }
        this._fbo = FrameBuffer_1.FrameBuffer.create([color]);
        // color.dispose();  // dispose of the texture (it is not used anymore)...?
        if (undefined === this._fbo) {
            return false;
        }
        const tx = this._fbo.getColor(0);
        bentleyjs_core_1.assert(undefined !== tx.getHandle());
        this._blitGeom = CachedGeometry_1.SingleTexturedViewportQuadGeometry.createGeometry(tx.getHandle(), 12 /* CopyColorNoAlpha */);
        return undefined !== this._blitGeom;
    }
    debugPaint() {
        const rect = this.viewRect;
        const canvas = System_2.System.instance.canvas;
        canvas.width = rect.width;
        canvas.height = rect.height;
        const gl = System_2.System.instance.context;
        gl.viewport(0, 0, rect.width, rect.height);
        gl.clearColor(1, 0, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        const context = this._canvas.getContext("2d");
        bentleyjs_core_1.assert(null !== context);
        context.drawImage(canvas, 0, 0);
    }
    updateViewRect() {
        const viewRect = this.viewRect;
        if (this._prevViewRect.width !== viewRect.width || this._prevViewRect.height !== viewRect.height) {
            // Must ensure internal bitmap grid dimensions of on-screen canvas match its own on-screen appearance
            this._canvas.width = viewRect.width;
            this._canvas.height = viewRect.height;
            this._prevViewRect = new Viewport_1.ViewRect(0, 0, viewRect.width, viewRect.height);
            return true;
        }
        return false;
    }
    _beginPaint() {
        bentleyjs_core_1.assert(undefined !== this._fbo);
        // Render to our framebuffer
        const system = System_2.System.instance;
        system.frameBufferStack.push(this._fbo, true);
        const viewRect = this.viewRect;
        // Ensure off-screen canvas dimensions match on-screen canvas dimensions
        if (system.canvas.width !== viewRect.width)
            system.canvas.width = viewRect.width;
        if (system.canvas.height !== viewRect.height)
            system.canvas.height = viewRect.height;
        bentleyjs_core_1.assert(system.context.drawingBufferWidth === viewRect.width, "offscreen context dimensions don't match onscreen");
        bentleyjs_core_1.assert(system.context.drawingBufferHeight === viewRect.height, "offscreen context dimensions don't match onscreen");
    }
    _endPaint() {
        const onscreenContext = this._canvas.getContext("2d");
        bentleyjs_core_1.assert(null !== onscreenContext);
        bentleyjs_core_1.assert(undefined !== this._blitGeom);
        if (undefined === this._blitGeom || null === onscreenContext) {
            return;
        }
        const system = System_2.System.instance;
        system.frameBufferStack.pop();
        // Copy framebuffer contents to off-screen canvas
        system.applyRenderState(RenderState_1.RenderState.defaults);
        const params = new DrawCommand_1.DrawParams(this, this._blitGeom);
        system.techniques.draw(params);
        // Copy off-screen canvas contents to on-screen canvas
        // ###TODO: Determine if clearRect() actually required...seems to leave some leftovers from prev image if not...
        onscreenContext.clearRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);
        onscreenContext.drawImage(system.canvas, 0, 0);
    }
    onResized() {
        this._dcAssigned = false;
        bentleyjs_core_1.dispose(this._fbo);
        this._fbo = undefined;
    }
}
exports.OnScreenTarget = OnScreenTarget;
class OffScreenTarget extends Target {
    constructor(rect) {
        super();
        this._viewRect = new Viewport_1.ViewRect(rect.left, rect.bottom, rect.right, rect.top);
    }
    get viewRect() { return this._viewRect; }
    setViewRect(rect, temporary) {
        if (this._viewRect.equals(rect))
            return;
        this._viewRect.copyFrom(rect);
        if (temporary) {
            // Temporarily adjust view rect in order to create scene for a view attachment.
            // Will be reset before attachment is rendered - so don't blow away our framebuffers + textures
            return;
        }
        this._dcAssigned = false;
        // ###TODO this._fbo = undefined;
        bentleyjs_core_1.dispose(this.compositor);
    }
    // ###TODO...
    _assignDC() { return false; }
    _makeCurrent() { }
    _beginPaint() { }
    _endPaint() { }
    onResized() { bentleyjs_core_1.assert(false); } // offscreen viewport's dimensions are set once, in constructor.
    updateViewRect() {
        return false;
    }
}
exports.OffScreenTarget = OffScreenTarget;
function normalizedDifference(p0, p1, out) {
    const result = undefined !== out ? out : new geometry_core_1.Vector3d();
    result.x = p0.x - p1.x;
    result.y = p0.y - p1.y;
    result.z = p0.z - p1.z;
    result.normalizeInPlace();
    return result;
}
function fromSumOf(p, v, scale, out) {
    const result = undefined !== out ? out : new geometry_core_1.Point3d();
    result.x = p.x + v.x * scale;
    result.y = p.y + v.y * scale;
    result.z = p.z + v.z * scale;
    return result;
}
function dotDifference(pt, origin, vec) {
    return (pt.x - origin.x) * vec.x + (pt.y - origin.y) * vec.y + (pt.z - origin.z) * vec.z;
}
function lookIn(eye, viewX, viewY, viewZ, result) {
    const rot = result.matrix.coffs;
    rot[0] = viewX.x;
    rot[1] = viewX.y;
    rot[2] = viewX.z;
    rot[3] = viewY.x;
    rot[4] = viewY.y;
    rot[5] = viewY.z;
    rot[6] = viewZ.x;
    rot[7] = viewZ.y;
    rot[8] = viewZ.z;
    result.origin.x = -viewX.dotProduct(eye);
    result.origin.y = -viewY.dotProduct(eye);
    result.origin.z = -viewZ.dotProduct(eye);
}
function ortho(left, right, bottom, top, near, far, result) {
    geometry_core_1.Matrix4d.createRowValues(2.0 / (right - left), 0.0, 0.0, -(right + left) / (right - left), 0.0, 2.0 / (top - bottom), 0.0, -(top + bottom) / (top - bottom), 0.0, 0.0, -2.0 / (far - near), -(far + near) / (far - near), 0.0, 0.0, 0.0, 1.0, result);
}
function frustum(left, right, bottom, top, near, far, result) {
    geometry_core_1.Matrix4d.createRowValues((2.0 * near) / (right - left), 0.0, (right + left) / (right - left), 0.0, 0.0, (2.0 * near) / (top - bottom), (top + bottom) / (top - bottom), 0.0, 0.0, 0.0, -(far + near) / (far - near), -(2.0 * far * near) / (far - near), 0.0, 0.0, -1.0, 0.0, result);
}
function interpolatePoint(p0, fraction, p1, out) {
    let x;
    let y;
    let z;
    if (fraction <= 0.5) {
        x = p0.x + fraction * (p1.x - p0.x);
        y = p0.y + fraction * (p1.y - p0.y);
        z = p0.z + fraction * (p1.z - p0.z);
    }
    else {
        const t = fraction - 1.0;
        x = p1.x + t * (p1.x - p0.x);
        y = p1.y + t * (p1.y - p0.y);
        z = p1.z + t * (p1.z - p0.z);
    }
    return geometry_core_1.Point3d.create(x, y, z, out);
}
function interpolateFrustumPoint(destFrust, srcFrust, destPoint, scale, srcPoint) {
    interpolatePoint(srcFrust.getCorner(destPoint), scale, srcFrust.getCorner(srcPoint), destFrust.points[destPoint]);
}


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const FeatureSymbology_1 = __webpack_require__(73);
/**
 * Represents a branch node in the scene graph, with associated view flags and transform to be applied to
 * all sub-nodes of the branch.
 */
class BranchState {
    static fromBranch(prev, branch) {
        const vf = branch.branch.getViewFlags(prev.viewFlags);
        const transform = prev.transform.multiplyTransformTransform(branch.localToWorldTransform);
        const ovrs = undefined !== branch.branch.symbologyOverrides ? branch.branch.symbologyOverrides : prev.symbologyOverrides;
        return new BranchState(vf, transform, ovrs, branch.clips);
    }
    static create(ovrs, flags, transform, clip) {
        return new BranchState(imodeljs_common_1.ViewFlags.createFrom(flags), undefined !== transform ? transform.clone() : geometry_core_1.Transform.createIdentity(), ovrs, clip);
    }
    static createForDecorations() {
        const vf = new imodeljs_common_1.ViewFlags();
        vf.setRenderMode(6 /* SmoothShade */);
        vf.setShowSourceLights(false);
        vf.setShowCameraLights(false);
        vf.setShowSolarLight(false);
        return new BranchState(vf, geometry_core_1.Transform.createIdentity(), new FeatureSymbology_1.FeatureSymbology.Overrides());
    }
    get viewFlags() { return this._viewFlags; }
    set viewFlags(vf) { vf.clone(this._viewFlags); }
    get showClipVolume() { return this.viewFlags.showClipVolume(); }
    constructor(flags, transform, ovrs, clip) {
        this._viewFlags = flags;
        this.transform = transform;
        this.symbologyOverrides = ovrs;
        this.clipVolume = clip;
    }
}
exports.BranchState = BranchState;
/**
 * Represents the current state of the scene graph. As the scene graph is traversed,
 * branch states are pushed and popped. Pushing a branch state replaces the current view flags
 * and multiplies the current transform with the branch's transform. Popping it inverts this
 * operation. The state at the top of the stack applies to the rendering of all primitives.
 * The stack does not store the scene graph itself.
 */
class BranchStack {
    constructor(flags, transform) {
        this._stack = [];
        this.pushState(BranchState.create(new FeatureSymbology_1.FeatureSymbology.Overrides(), flags, transform));
    }
    get top() {
        bentleyjs_core_1.assert(!this.empty);
        return this._stack[this._stack.length - 1];
    }
    get bottom() {
        bentleyjs_core_1.assert(!this.empty);
        return this._stack[0];
    }
    get length() { return this._stack.length; }
    get empty() { return 0 === this.length; }
    pushBranch(branch) {
        bentleyjs_core_1.assert(this.length > 0);
        this.pushState(BranchState.fromBranch(this.top, branch));
    }
    pushState(state) {
        this._stack.push(state);
    }
    pop() {
        bentleyjs_core_1.assert(!this.empty);
        if (!this.empty) {
            this._stack.pop();
        }
    }
    setViewFlags(vf) { bentleyjs_core_1.assert(1 === this.length); this.top.viewFlags = vf; }
    setSymbologyOverrides(ovrs) {
        bentleyjs_core_1.assert(1 === this.length);
        this.top.symbologyOverrides = ovrs;
    }
}
exports.BranchStack = BranchStack;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/** This function is intended to be used only when explicit debugging options are enabled;
 * never in production builds. Avoids having to duplicate the tslint:disable-line all over the place.
 * @hidden
 */
function debugPrint(str) {
    console.log(str); // tslint:disable-line:no-console
}
exports.debugPrint = debugPrint;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
const GraphicBuilder_1 = __webpack_require__(122);
const ViewContext_1 = __webpack_require__(96);
const Primitives_1 = __webpack_require__(61);
const DisplayParams_1 = __webpack_require__(60);
const GeometryAccumulator_1 = __webpack_require__(221);
function copy2dTo3d(pts2d, depth) {
    const pts3d = [];
    for (const point of pts2d)
        pts3d.push(geometry_core_1.Point3d.create(point.x, point.y, depth));
    return pts3d;
}
class GeometryListBuilder extends GraphicBuilder_1.GraphicBuilder {
    constructor(system, params, accumulatorTf = geometry_core_1.Transform.createIdentity()) {
        super(params);
        this.graphicParams = new imodeljs_common_1.GraphicParams();
        this.accum = new GeometryAccumulator_1.GeometryAccumulator(params.iModel, system, undefined, accumulatorTf);
    }
    _finish() {
        const graphic = this.finishGraphic(this.accum);
        this.accum.clear();
        return graphic;
    }
    activateGraphicParams(graphicParams) {
        this.graphicParams = graphicParams;
    }
    addArc2d(ellipse, isEllipse, filled, zDepth) {
        if (0.0 === zDepth) {
            this.addArc(ellipse, isEllipse, filled);
        }
        else {
            const ell = ellipse;
            ell.center.z = zDepth;
            this.addArc(ell, isEllipse, filled);
        }
    }
    addArc(ellipse, isEllipse, filled) {
        let curve;
        let isLoop = false;
        if (isEllipse || filled) {
            curve = geometry_core_1.Loop.create(ellipse);
            isLoop = true;
        }
        else {
            curve = geometry_core_1.Path.create(ellipse);
        }
        if (filled && !isEllipse && !ellipse.sweep.isFullCircle()) {
            const gapSegment = geometry_core_1.LineSegment3d.create(ellipse.startPoint(), ellipse.endPoint());
            gapSegment.markerBits = 0x00010000; // Set the CURVE_PRIMITIVE_BIT_GapCurve marker bit
            curve.children.push(gapSegment);
        }
        const displayParams = curve.isAnyRegionType() ? this.getMeshDisplayParams() : this.getLinearDisplayParams();
        if (isLoop)
            this.accum.addLoop(curve, displayParams, this.localToWorldTransform, false);
        else
            this.accum.addPath(curve, displayParams, this.localToWorldTransform, false);
    }
    /** take ownership of input points and add as a line string to this builder */
    addLineString(points) {
        if (2 === points.length && points[0].isAlmostEqual(points[1]))
            this.accum.addPointString(points, this.getLinearDisplayParams(), this.localToWorldTransform);
        else
            this.accum.addLineString(points, this.getLinearDisplayParams(), this.localToWorldTransform);
    }
    addLineString2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addLineString(pts3d);
    }
    /** take ownership of input points and add as a point string to this builder */
    addPointString(points) {
        this.accum.addPointString(points, this.getLinearDisplayParams(), this.localToWorldTransform);
    }
    addPointString2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addPointString(pts3d);
    }
    addShape(points) {
        const loop = geometry_core_1.Loop.create(geometry_core_1.LineString3d.create(points));
        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.localToWorldTransform, false);
    }
    addShape2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addShape(pts3d);
    }
    addPath(path) {
        this.accum.addPath(path, this.getLinearDisplayParams(), this.localToWorldTransform, false);
    }
    addLoop(loop) {
        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.localToWorldTransform, false);
    }
    addPolyface(meshData) {
        this.accum.addPolyface(meshData, this.getMeshDisplayParams(), this.localToWorldTransform);
    }
    getGraphicParams() { return this.graphicParams; }
    getDisplayParams(type) { return DisplayParams_1.DisplayParams.createForType(type, this.graphicParams); }
    getMeshDisplayParams() { return DisplayParams_1.DisplayParams.createForMesh(this.graphicParams, (grad) => this.resolveGradient(grad)); }
    getLinearDisplayParams() { return DisplayParams_1.DisplayParams.createForLinear(this.graphicParams); }
    get textDisplayParams() { return DisplayParams_1.DisplayParams.createForText(this.graphicParams); }
    get system() { return this.accum.system; }
    add(geom) { this.accum.addGeometry(geom); }
    reInitialize(localToWorld, accumTf = geometry_core_1.Transform.createIdentity()) {
        this.accum.reset(accumTf);
        this.activateGraphicParams(this.graphicParams);
        this.createParams.placement = localToWorld;
        this.reset();
    }
    resolveGradient(gradient) {
        return this.system.getGradientTexture(gradient, this.iModel);
    }
}
exports.GeometryListBuilder = GeometryListBuilder;
class PrimitiveBuilder extends GeometryListBuilder {
    constructor(system, params) {
        super(system, params);
        this.primitives = [];
        this.params = params;
    }
    finishGraphic(accum) {
        if (!accum.isEmpty) {
            // Overlay decorations don't test Z. Tools like to layer multiple primitives on top of one another; they rely on the primitives rendering
            // in that same order to produce correct results (e.g., a thin line rendered atop a thick line of another color).
            // No point generating edges for graphics that are always rendered in smooth shade mode.
            const options = Primitives_1.GeometryOptions.createForGraphicBuilder(this.params);
            // const context = PrimitiveBuilderContext.fromPrimitiveBuilder(this);
            const tolerance = this.computeTolerance(accum);
            accum.saveToGraphicList(this.primitives, options, tolerance);
        }
        return (this.primitives.length !== 1) ? this.accum.system.createGraphicList(this.primitives) : this.primitives.pop();
    }
    computeTolerance(accum) {
        const toleranceMult = 0.25;
        if (this.params.isViewCoordinates)
            return toleranceMult;
        if (!this.params.viewport)
            return 20;
        const range = accum.geometries.computeRange(); // NB: Already multiplied by transform...
        // NB: Geometry::CreateFacetOptions() will apply any scale factors from transform...no need to do it here.
        const pt = range.low.interpolate(0.5, range.high);
        return this.params.viewport.getPixelSizeAtPoint(pt) * toleranceMult;
    }
    reset() { this.primitives = []; }
}
exports.PrimitiveBuilder = PrimitiveBuilder;
class PrimitiveBuilderContext extends ViewContext_1.ViewContext {
    constructor(viewport, imodel, system) {
        super(viewport);
        this.viewport = viewport;
        this.imodel = imodel;
        this.system = system;
    }
    static fromPrimitiveBuilder(builder) { return new PrimitiveBuilderContext(builder.viewport, builder.iModel, builder.system); }
}
exports.PrimitiveBuilderContext = PrimitiveBuilderContext;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const MeshPrimitives_1 = __webpack_require__(43);
const MeshBuilderMap_1 = __webpack_require__(222);
const GeometryPrimitives_1 = __webpack_require__(225);
const GeometryList_1 = __webpack_require__(228);
class GeometryAccumulator {
    constructor(iModel, system, surfacesOnly = false, transform = geometry_core_1.Transform.createIdentity(), tileRange = geometry_core_1.Range3d.createNull()) {
        this.geometries = new GeometryList_1.GeometryList();
        this.checkGlyphBoxes = false; // #TODO: obviously update when checkGlyphBoxes needs to be mutable
        this._surfacesOnly = surfacesOnly;
        this._transform = transform;
        this.iModel = iModel;
        this.system = system;
        this.tileRange = tileRange;
    }
    get surfacesOnly() { return this._surfacesOnly; }
    get transform() { return this._transform; }
    get isEmpty() { return this.geometries.isEmpty; }
    get haveTransform() { return !this._transform.isIdentity(); }
    getPrimitiveRange(pGeom) {
        const pRange = new geometry_core_1.Range3d();
        pGeom.range(undefined, pRange);
        if (pRange.isNull())
            return undefined;
        return pRange;
    }
    calculateTransform(transform, range) {
        if (this.haveTransform)
            this._transform.multiplyTransformTransform(transform, transform);
        transform.multiplyRange(range, range);
    }
    addLoop(loop, displayParams, transform, disjoint) {
        const range = this.getPrimitiveRange(loop);
        if (!range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromLoop(loop, transform, range, displayParams, disjoint));
    }
    addLineString(pts, displayParams, transform) {
        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range
        const range = geometry_core_1.Range3d.createNull();
        range.extendArray(pts, undefined);
        if (range.isNull())
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromLineString(pts, transform, range, displayParams));
    }
    addPointString(pts, displayParams, transform) {
        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range
        const range = geometry_core_1.Range3d.createNull();
        range.extendArray(pts, undefined);
        if (range.isNull())
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPointString(pts, transform, range, displayParams));
    }
    addPath(path, displayParams, transform, disjoint) {
        const range = this.getPrimitiveRange(path);
        if (!range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPath(path, transform, range, displayParams, disjoint));
    }
    addPolyface(ipf, displayParams, transform) {
        const range = this.getPrimitiveRange(ipf);
        if (undefined === range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPolyface(ipf, transform, range, displayParams));
    }
    addGeometry(geom) { this.geometries.push(geom); return true; }
    clear() { this.geometries.clear(); }
    reset(transform = geometry_core_1.Transform.createIdentity(), surfacesOnly = false) {
        this.clear();
        this._transform = transform;
        this._surfacesOnly = surfacesOnly;
    }
    /**
     * Generates a MeshBuilderMap
     * native: GeometryAccumulator::ToMeshBuilderMap(GeometryOptionsCR options, double tolerance, FeatureTableP featureTable, ViewContextR context) const
     * note  : removed featureTable, ViewContext
     * @param tolerance should derive from Viewport.getPixelSizeAtPoint
     */
    toMeshBuilderMap(options, tolerance) {
        const { geometries } = this; // declare internal dependencies
        const { wantSurfacesOnly, wantPreserveOrder } = options;
        const range = geometries.computeRange();
        const is2d = !range.isNull() && range.isAlmostZeroZ();
        return MeshBuilderMap_1.MeshBuilderMap.createFromGeometries(geometries, tolerance, range, is2d, wantSurfacesOnly, wantPreserveOrder);
    }
    /** removed ViewContext */
    toMeshes(options, tolerance) {
        if (this.geometries.isEmpty)
            return new MeshPrimitives_1.MeshList();
        const builderMap = this.toMeshBuilderMap(options, tolerance);
        return builderMap.toMeshes();
    }
    /**
     * Populate a list of Graphic objects from the accumulated Geometry objects.
     * removed ViewContext
     */
    saveToGraphicList(graphics, options, tolerance) {
        const meshes = this.toMeshes(options, tolerance);
        const args = new MeshPrimitives_1.MeshGraphicArgs();
        for (const mesh of meshes) {
            const graphic = mesh.getGraphics(args, this.system);
            if (undefined !== graphic)
                graphics.push(graphic);
        }
    }
}
exports.GeometryAccumulator = GeometryAccumulator;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const Primitives_1 = __webpack_require__(61);
const MeshBuilder_1 = __webpack_require__(223);
const MeshPrimitives_1 = __webpack_require__(43);
class MeshBuilderMap extends bentleyjs_core_1.Dictionary {
    constructor(tolerance, range, is2d, preserveKeyOrder = false) {
        super((lhs, rhs) => lhs.compare(rhs));
        this.keyOrder = 0;
        this.tolerance = tolerance;
        this.vertexTolerance = tolerance * Primitives_1.ToleranceRatio.vertex;
        this.facetAreaTolerance = tolerance * Primitives_1.ToleranceRatio.facetArea;
        this.range = range;
        this.is2d = is2d;
        this.preserveKeyOrder = preserveKeyOrder;
    }
    static createFromGeometries(geometries, tolerance, range, is2d, wantSurfacesOnly, wantPreserveOrder) {
        const map = new MeshBuilderMap(tolerance, range, is2d, wantPreserveOrder);
        if (geometries.isEmpty)
            return map;
        for (const geom of geometries)
            map.loadGeometry(geom, wantSurfacesOnly);
        return map;
    }
    toMeshes() {
        const meshes = new MeshPrimitives_1.MeshList();
        for (const builder of this._values) {
            meshes.push(builder.mesh);
        }
        return meshes;
    }
    /**
     * extract polyfaces and strokes from geometry into MeshBuilder stored in builderMap
     * @param geom Geometry instance to extract polyfaces and strokes from
     * @param wantSurfacesOnly if true prevent strokes from being loaded into builders
     */
    loadGeometry(geom, wantSurfacesOnly) {
        this.loadPolyfacePrimitiveList(geom);
        if (!wantSurfacesOnly)
            this.loadStrokePrimitiveList(geom);
    }
    /**
     * extract polyface primitives from geometry in meshBuilder stored in builderMap
     * @param geom Geometry instance to extract polyfaces from
     */
    loadPolyfacePrimitiveList(geom) {
        const polyfaces = geom.getPolyfaces(this.tolerance);
        if (polyfaces !== undefined)
            for (const polyface of polyfaces)
                this.loadIndexedPolyface(polyface);
    }
    /**
     * extract indexed polyfaces into meshBuilder stored in builderMap
     * @param polyface PolyfacePrimitive to extract indexed polyfaces from
     */
    loadIndexedPolyface(polyface) {
        const { indexedPolyface, displayParams, isPlanar } = polyface;
        const { pointCount, normalCount } = indexedPolyface;
        const { fillColor, isTextured } = displayParams;
        const textureMapping = displayParams.textureMapping;
        if (pointCount === 0)
            return;
        const builder = this.getBuilder(displayParams, 0 /* Mesh */, normalCount > 0, isPlanar);
        builder.addFromPolyface(indexedPolyface, { includeParams: isTextured, fillColor: fillColor.tbgr, mappedTexture: textureMapping });
    }
    /**
     * extract stroke primitives from geometry in meshBuilder stored in builderMap
     * @param geom Geometry instance to extract strokes from
     */
    loadStrokePrimitiveList(geom) {
        const strokes = geom.getStrokes(this.tolerance);
        if (undefined !== strokes)
            for (const stroke of strokes)
                this.loadStrokesPrimitive(stroke);
    }
    /**
     * extract strokes primitive into meshBuilder stored in builderMap
     * @param strokePrimitive StrokesPrimitive instance to extractfrom
     */
    loadStrokesPrimitive(strokePrimitive) {
        const { displayParams, isDisjoint, isPlanar, strokes } = strokePrimitive;
        const type = isDisjoint ? 2 /* Point */ : 1 /* Polyline */;
        const builder = this.getBuilder(displayParams, type, false, isPlanar);
        builder.addStrokePointLists(strokes, isDisjoint, displayParams.fillColor.tbgr);
    }
    getBuilder(displayParams, type, hasNormals, isPlanar) {
        const { facetAreaTolerance, tolerance, is2d, range } = this;
        const key = this.getKey(displayParams, type, hasNormals, isPlanar);
        return this.getBuilderFromKey(key, { displayParams, type, range, is2d, isPlanar, tolerance, areaTolerance: facetAreaTolerance });
    }
    getKey(displayParams, type, hasNormals, isPlanar) {
        const key = new MeshBuilderMap.Key(displayParams, type, hasNormals, isPlanar);
        if (this.preserveKeyOrder)
            key.order = ++this.keyOrder;
        return key;
    }
    /**
     * gets builder associated with key if defined, otherwise creates a new builder and sets that with key
     * @param key MeshBuilderMap.Key to associate with builder
     * @param props MeshBuilder.Props required to create builder if it does not already exist
     * @returns builder reference, changes will update instance stored in builderMap
     */
    getBuilderFromKey(key, props) {
        let builder = this.get(key);
        if (undefined === builder) {
            builder = MeshBuilder_1.MeshBuilder.create(props);
            this.set(key, builder);
        }
        return builder;
    }
}
exports.MeshBuilderMap = MeshBuilderMap;
(function (MeshBuilderMap) {
    class Key {
        constructor(params, type, hasNormals, isPlanar) {
            this.order = 0;
            this.params = params;
            this.type = type;
            this.hasNormals = hasNormals;
            this.isPlanar = isPlanar;
        }
        static createFromMesh(mesh) {
            return new Key(mesh.displayParams, mesh.type, mesh.normals.length !== 0, mesh.isPlanar);
        }
        compare(rhs) {
            let diff = bentleyjs_core_1.compareNumbers(this.order, rhs.order);
            if (0 === diff) {
                diff = bentleyjs_core_1.compareNumbers(this.type, rhs.type);
                if (0 === diff) {
                    diff = bentleyjs_core_1.compareBooleans(this.isPlanar, rhs.isPlanar);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareBooleans(this.hasNormals, rhs.hasNormals);
                        if (0 === diff) {
                            diff = this.params.compareForMerge(rhs.params);
                        }
                    }
                }
            }
            return diff;
        }
        equals(rhs) { return 0 === this.compare(rhs); }
    }
    MeshBuilderMap.Key = Key;
})(MeshBuilderMap = exports.MeshBuilderMap || (exports.MeshBuilderMap = {}));


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const VertexKey_1 = __webpack_require__(224);
const imodeljs_common_1 = __webpack_require__(2);
const Primitives_1 = __webpack_require__(61);
const MeshPrimitives_1 = __webpack_require__(43);
class MeshBuilder {
    get currentPolyface() { return this._currentPolyface; }
    set displayParams(params) { this.mesh.displayParams = params; }
    /** create reference for vertexMap on demand */
    get vertexMap() {
        if (undefined === this._vertexMap)
            this._vertexMap = new VertexKey_1.VertexMap();
        return this._vertexMap;
    }
    /** create reference for triangleSet on demand */
    get triangleSet() {
        if (undefined === this._triangleSet)
            this._triangleSet = new Primitives_1.TriangleSet();
        return this._triangleSet;
    }
    constructor(mesh, tolerance, areaTolerance, tileRange) {
        this.mesh = mesh;
        this.tolerance = tolerance;
        this.areaTolerance = areaTolerance;
        this.tileRange = tileRange;
    }
    /**
     * create instance of MeshBuilder without a predefined mesh instance
     * @param props
     * props to create mesh:
     *    props.displayParams : DisplayParams
     *    props.features? : Mesh.Features | undefined
     *    props.type : Mesh.PrimitiveType
     *    props.range : Range3d
     *    props.is2d : boolean
     *    props.isPlanar : boolean
     * additional props:
     *    props.tolerance : number
     *    props.areaTolerance : number
     */
    static create(props) {
        const mesh = MeshPrimitives_1.Mesh.create(props);
        const { tolerance, areaTolerance, range } = props;
        return new MeshBuilder(mesh, tolerance, areaTolerance, range);
    }
    /**
     * iterate through each point list of the strokes primitive and either load the point string or polyline into builder
     * @param strokes lists of stroke primitive point lists to iterate
     * @param isDisjoint if true add point string, else add polyline
     * @param fillColor
     */
    addStrokePointLists(strokes, isDisjoint, fillColor) {
        for (const strokePoints of strokes) {
            const { startDistance, points } = strokePoints;
            if (isDisjoint)
                this.addPointString(points, fillColor, startDistance);
            else
                this.addPolyline(points, fillColor, startDistance);
        }
    }
    /**
     * add data from polyface into mesh builder
     * @param polyface the indexed polyface to iterate the facets of in order to load each facet's triangles' vertices
     * @param props the properties required for this operation
     *    props.includeParams: boolean
     *    props.fillColor: number
     *    props.mappedTexture?: TextureMapping
     */
    addFromPolyface(polyface, props) {
        const visitor = polyface.createVisitor();
        while (visitor.moveToNextFacet()) {
            this.addFromPolyfaceVisitor(visitor, props);
        }
        this.endPolyface();
    }
    /**
     *
     * @param visitor
     * @param props the properties required for this operation:
     *    props.includeParams: boolean
     *    props.fillColor: number
     *    props.mappedTexture?: TextureMapping
     */
    addFromPolyfaceVisitor(visitor, options) {
        const { pointCount, normalCount, paramCount, requireNormals } = visitor;
        const { includeParams, mappedTexture } = options;
        const isDegenerate = requireNormals && normalCount < pointCount; // TFS#790263: Degenerate triangle - no normals.
        // a triangle must have at least 3 points
        if (pointCount < 3 || isDegenerate)
            return;
        const haveParam = includeParams && paramCount > 0;
        const triangleCount = pointCount - 2;
        bentleyjs_core_1.assert(!includeParams || paramCount > 0);
        bentleyjs_core_1.assert(!haveParam || undefined !== mappedTexture);
        const polyfaceVisitorOptions = Object.assign({}, options, { triangleCount, haveParam });
        // The face represented by this visitor should be convex (we request that in facet options) - so we do a simple fan triangulation.
        for (let triangleIndex = 0; triangleIndex < triangleCount; triangleIndex++) {
            const triangle = this.createTriangle(triangleIndex, visitor, polyfaceVisitorOptions);
            if (undefined !== triangle)
                this.addTriangle(triangle);
        }
    }
    createTriangleVertices(triangleIndex, visitor, options) {
        const { point, requireNormals } = visitor;
        const { fillColor, haveParam } = options;
        const qPointParams = this.mesh.points.params;
        // If we do not have UVParams stored on the IndexedPolyface, compute them now
        let params;
        if (haveParam && options.mappedTexture) {
            bentleyjs_core_1.assert(this.mesh.points.length === 0 || this.mesh.uvParams.length !== 0);
            const mappedTexture = options.mappedTexture;
            const transformToImodel = mappedTexture.params.textureMatrix.transform;
            if (transformToImodel)
                params = mappedTexture.computeUVParams(visitor, transformToImodel);
            bentleyjs_core_1.assert(params !== undefined);
        }
        const vertices = [];
        for (let i = 0; i < 3; ++i) {
            const vertexIndex = 0 === i ? 0 : triangleIndex + i;
            const position = imodeljs_common_1.QPoint3d.create(point.getPoint3dAt(vertexIndex), qPointParams);
            const normal = requireNormals ? new imodeljs_common_1.OctEncodedNormal(visitor.getNormal(vertexIndex)) : undefined;
            const uvParam = params ? params[vertexIndex] : undefined;
            vertices[i] = { position, fillColor, normal, uvParam };
        }
        // Previously we would add all 3 vertices to our map, then detect degenerate triangles in AddTriangle().
        // This led to unused vertex data, and caused mismatch in # of vertices when recreating the MeshBuilder from the data in the tile cache.
        // Detect beforehand instead.
        if (vertices[0].position.equals(vertices[1].position) || vertices[0].position.equals(vertices[2].position) || vertices[1].position.equals(vertices[2].position))
            return undefined;
        return vertices;
    }
    createTriangle(triangleIndex, visitor, options) {
        // generate vertex key properties for each of the three sides of the triangle
        const vertices = this.createTriangleVertices(triangleIndex, visitor, options);
        // avoid creating degenerate triangles
        if (undefined === vertices)
            return undefined;
        const { edgeVisible } = visitor;
        const triangle = new Primitives_1.Triangle();
        triangle.setEdgeVisibility(0 === triangleIndex ? edgeVisible[0] : false, edgeVisible[triangleIndex + 1], triangleIndex === options.triangleCount - 1 ? edgeVisible[triangleIndex + 2] : false);
        // set each triangle index to the index associated with the vertex key location in the vertex map
        vertices.forEach((vertexProps, i) => {
            const vertexKeyIndex = this.addVertex(vertexProps);
            triangle.indices[i] = vertexKeyIndex;
            // if the current polyface exists, map the vertex key index to the visitor's client point index
            if (this.currentPolyface !== undefined)
                this.currentPolyface.vertexIndexMap.set(vertexKeyIndex, visitor.clientPointIndex(i));
        });
        return triangle;
    }
    /** removed Feature for now */
    addPolyline(pts, fillColor, startDistance) {
        const { mesh } = this;
        const poly = new imodeljs_common_1.MeshPolyline(startDistance);
        const points = pts instanceof imodeljs_common_1.QPoint3dList ? pts : imodeljs_common_1.QPoint3dList.createFrom(pts, mesh.points.params);
        for (const position of points)
            poly.addIndex(this.addVertex({ position, fillColor }));
        mesh.addPolyline(poly);
    }
    /** removed Feature for now */
    addPointString(pts, fillColor, startDistance) {
        const { mesh } = this;
        // Assume no duplicate points in point strings (or, too few to matter).
        // Why? Because drawGridDots() potentially sends us tens of thousands of points (up to 83000 on my large monitor in top view), and wants to do so every frame.
        // The resultant map lookups/inserts/rebalancing kill performance in non-optimized builds.
        // NB: startDistance currently unused - Ray claims they will be used in future for non-cosmetic line styles? If not let's jettison them...
        const poly = new imodeljs_common_1.MeshPolyline(startDistance);
        const points = imodeljs_common_1.QPoint3dList.createFrom(pts, mesh.points.params);
        for (const position of points) {
            mesh.addVertex({ position, fillColor });
            poly.addIndex(this.addVertex({ position, fillColor }, false));
        }
        mesh.addPolyline(poly);
    }
    beginPolyface(polyface, options) {
        // ###TODO generateNoEdges no edges case
        // maybe this --> (options.generateNoEdges && 0 === polyface.data.edgeVisible.length)
        const triangles = this.mesh.triangles;
        this._currentPolyface = new MeshBuilderPolyface(polyface, options, triangles === undefined ? 0 : triangles.length);
    }
    endPolyface() {
        const { currentPolyface, mesh } = this;
        if (undefined === currentPolyface)
            return;
        if (mesh.edges === undefined)
            mesh.edges = new imodeljs_common_1.MeshEdges();
        // ###TODO
        // MeshEdgesBuilder(m_tileRange, *m_mesh, *m_currentPolyface).BuildEdges(*m_mesh->m_edges, m_currentPolyface.get());
    }
    addVertex(vertex, addToMeshOnInsert = true) {
        // if vertex key isn't duplicate, then also insert properties into mesh
        const onInsert = (vk) => this.mesh.addVertex(vk);
        return this.vertexMap.insertKey(vertex, addToMeshOnInsert ? onInsert : undefined);
    }
    addTriangle(triangle) {
        // Prefer to avoid adding vertices originating from degenerate triangles before we get here...
        bentleyjs_core_1.assert(!triangle.isDegenerate);
        const onInsert = (_vk) => this.mesh.addTriangle(triangle);
        this.triangleSet.insertKey(triangle, onInsert);
    }
}
exports.MeshBuilder = MeshBuilder;
class MeshEdgeCreationOptions {
    constructor(type = 0 /* NoEdges */) {
        this.minCreaseAngle = 20.0 * geometry_core_1.Angle.radiansPerDegree;
        this.type = type;
    }
    get generateAllEdges() { return this.type === 7 /* AllEdges */; }
    get generateNoEdges() { return this.type === 0 /* NoEdges */; }
    get generateSheetEdges() { return 0 !== (this.type & 1 /* SheetEdges */); }
    get generateCreaseEdges() { return 0 !== (this.type & 2 /* CreaseEdges */); }
    /** Create edge chains for polyfaces that do not already have them. */
    get createEdgeChains() { return 0 !== (this.type & 8 /* CreateChains */); }
}
exports.MeshEdgeCreationOptions = MeshEdgeCreationOptions;
class MeshBuilderPolyface {
    constructor(polyface, edgeOptions, baseTriangleIndex) {
        this.vertexIndexMap = new Map();
        this.polyface = polyface;
        this.edgeOptions = edgeOptions;
        this.baseTriangleIndex = baseTriangleIndex;
    }
}
exports.MeshBuilderPolyface = MeshBuilderPolyface;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
class VertexKey {
    constructor(position, fillColor, normal, uvParam) {
        this.octEncodedNormal = 0;
        this.normalValid = false;
        this.position = position.clone();
        this.fillColor = fillColor;
        if (undefined !== normal) {
            this.normalValid = true;
            this.octEncodedNormal = normal.value;
        }
        if (undefined !== uvParam)
            this.uvParam = uvParam.clone();
    }
    static create(props) { return new VertexKey(props.position, props.fillColor, props.normal, props.uvParam); }
    equals(rhs) {
        bentleyjs_core_1.assert(this.normalValid === rhs.normalValid);
        if (!this.position.equals(rhs.position) || this.octEncodedNormal !== rhs.octEncodedNormal || this.fillColor !== rhs.fillColor)
            return false;
        if (undefined === this.uvParam) {
            bentleyjs_core_1.assert(undefined === rhs.uvParam);
            return true;
        }
        else {
            bentleyjs_core_1.assert(undefined !== rhs.uvParam);
            return this.uvParam.isAlmostEqual(rhs.uvParam, 0.1);
        }
    }
    compare(rhs) {
        if (this === rhs)
            return 0;
        let diff = this.position.compare(rhs.position);
        if (0 === diff) {
            diff = this.octEncodedNormal - rhs.octEncodedNormal;
            if (0 === diff) {
                diff = this.fillColor - rhs.fillColor;
                if (0 === diff && undefined !== this.uvParam) {
                    bentleyjs_core_1.assert(undefined !== rhs.uvParam);
                    diff = bentleyjs_core_1.compareWithTolerance(this.uvParam.x, rhs.uvParam.x);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareWithTolerance(this.uvParam.x, rhs.uvParam.y);
                    }
                }
            }
        }
        return diff;
    }
}
exports.VertexKey = VertexKey;
class VertexMap extends bentleyjs_core_1.IndexMap {
    constructor() { super(bentleyjs_core_1.compare); }
    insertKey(props, onInsert) {
        return this.insert(VertexKey.create(props), onInsert);
    }
}
exports.VertexMap = VertexMap;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const DisplayParams_1 = __webpack_require__(60);
const Strokes_1 = __webpack_require__(226);
const Polyface_1 = __webpack_require__(227);
class Geometry {
    constructor(transform, tileRange, displayParams) {
        this.transform = transform;
        this.tileRange = tileRange;
        this.displayParams = displayParams;
    }
    static createFromPointString(pts, tf, tileRange, params) {
        return new PrimitivePointStringGeometry(pts, tf, tileRange, params);
    }
    static createFromLineString(pts, tf, tileRange, params) {
        return new PrimitiveLineStringGeometry(pts, tf, tileRange, params);
    }
    static createFromLoop(loop, tf, tileRange, params, disjoint) {
        return new PrimitiveLoopGeometry(loop, tf, tileRange, params, disjoint);
    }
    static createFromPath(path, tf, tileRange, params, disjoint) {
        return new PrimitivePathGeometry(path, tf, tileRange, params, disjoint);
    }
    static createFromPolyface(ipf, tf, tileRange, params) {
        return new PrimitivePolyfaceGeometry(ipf, tf, tileRange, params);
    }
    getPolyfaces(tolerance) {
        const facetOptions = geometry_core_1.StrokeOptions.createForFacets();
        facetOptions.chordTol = tolerance;
        if (this.displayParams.isTextured)
            facetOptions.needParams = true;
        // if (!this.displayParams.ignoreLighting) // ###TODO And not 2D...
        //   facetOptions.needNormals = true;
        return this._getPolyfaces(facetOptions);
    }
    getStrokes(tolerance) {
        const strokeOptions = geometry_core_1.StrokeOptions.createForCurves();
        strokeOptions.chordTol = tolerance;
        return this._getStrokes(strokeOptions);
    }
    get hasTexture() { return this.displayParams.isTextured; }
    doDecimate() { return false; }
    doVertexCluster() { return true; }
    part() { return undefined; }
}
exports.Geometry = Geometry;
class PrimitivePathGeometry extends Geometry {
    constructor(path, tf, range, params, isDisjoint) {
        super(tf, range, params);
        this.path = path;
        this.isDisjoint = isDisjoint;
    }
    _getPolyfaces(_facetOptions) { return undefined; }
    _getStrokes(facetOptions) {
        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.path, facetOptions, this.displayParams, this.isDisjoint, this.transform);
    }
    static getStrokesForLoopOrPath(loopOrPath, facetOptions, params, isDisjoint, transform) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        if (!loopOrPath.isAnyRegionType() || params.wantRegionOutline) {
            const strksPts = new Strokes_1.StrokesPrimitivePointLists();
            PrimitivePathGeometry.collectCurveStrokes(strksPts, loopOrPath, facetOptions, transform);
            if (strksPts.length > 0) {
                const isPlanar = loopOrPath.isAnyRegionType();
                bentleyjs_core_1.assert(isPlanar === params.wantRegionOutline);
                const strksPrim = Strokes_1.StrokesPrimitive.create(params, isDisjoint, isPlanar);
                strksPrim.strokes = strksPts;
                strksList.push(strksPrim);
            }
        }
        return strksList;
    }
    static collectCurveStrokes(strksPts, loopOrPath, facetOptions, trans) {
        const strokes = loopOrPath.getPackedStrokes(facetOptions);
        if (undefined !== strokes) {
            const pts = strokes.getPoint3dArray();
            trans.multiplyPoint3dArrayInPlace(pts);
            strksPts.push(new Strokes_1.StrokesPrimitivePointList(0, pts));
        }
    }
}
exports.PrimitivePathGeometry = PrimitivePathGeometry;
class PrimitivePointStringGeometry extends Geometry {
    constructor(pts, tf, range, params) {
        super(tf, range, params);
        this.pts = pts;
    }
    _getPolyfaces(_facetOptions) {
        return undefined;
    }
    _getStrokes(_facetOptions) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        const strksPts = new Strokes_1.StrokesPrimitivePointLists(new Strokes_1.StrokesPrimitivePointList(0, this.pts));
        const strksPrim = Strokes_1.StrokesPrimitive.create(this.displayParams, true, false);
        strksPrim.strokes = strksPts;
        strksPrim.transform(this.transform);
        strksList.push(strksPrim);
        return strksList;
    }
}
exports.PrimitivePointStringGeometry = PrimitivePointStringGeometry;
class PrimitiveLineStringGeometry extends Geometry {
    constructor(pts, tf, range, params) {
        super(tf, range, params);
        this.pts = pts;
    }
    _getPolyfaces(_facetOptions) {
        return undefined;
    }
    _getStrokes(_facetOptions) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        const strksPts = new Strokes_1.StrokesPrimitivePointLists(new Strokes_1.StrokesPrimitivePointList(0, this.pts));
        const strksPrim = Strokes_1.StrokesPrimitive.create(this.displayParams, false, false);
        strksPrim.strokes = strksPts;
        strksPrim.transform(this.transform);
        strksList.push(strksPrim);
        return strksList;
    }
}
exports.PrimitiveLineStringGeometry = PrimitiveLineStringGeometry;
class PrimitiveLoopGeometry extends Geometry {
    constructor(loop, tf, range, params, isDisjoint) {
        super(tf, range, params);
        this.loop = loop;
        this.isDisjoint = isDisjoint;
    }
    _getPolyfaces(facetOptions) {
        if (!this.loop.isAnyRegionType()) {
            return undefined;
        }
        // The following is good for single loop things according to Earlin.
        const contour = geometry_core_1.SweepContour.createForLinearSweep(this.loop);
        if (contour !== undefined) {
            const pfBuilder = geometry_core_1.PolyfaceBuilder.create(facetOptions);
            contour.emitFacets(pfBuilder, false, this.transform); // build facets and emit them to the builder
            const polyface = pfBuilder.claimPolyface();
            const wantEdges = DisplayParams_1.DisplayParams.RegionEdgeType.Default === this.displayParams.regionEdgeType;
            const isPlanar = true;
            return new Polyface_1.PolyfacePrimitiveList(Polyface_1.PolyfacePrimitive.create(this.displayParams, polyface, wantEdges, isPlanar));
        } // ###TODO: this approach might not work with holes
        return undefined;
    }
    _getStrokes(facetOptions) {
        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.loop, facetOptions, this.displayParams, this.isDisjoint, this.transform);
    }
}
exports.PrimitiveLoopGeometry = PrimitiveLoopGeometry;
class PrimitivePolyfaceGeometry extends Geometry {
    constructor(polyface, tf, range, params) {
        super(tf, range, params);
        this.polyface = polyface;
    }
    _getPolyfaces(_facetOptions) {
        if (!this.hasTexture) {
            if (this.polyface.data.param) {
                this.polyface.data.param = [];
            }
            if (this.polyface.data.paramIndex) {
                this.polyface.data.paramIndex = [];
            }
        }
        bentleyjs_core_1.assert(this.transform.isIdentity());
        return new Polyface_1.PolyfacePrimitiveList(Polyface_1.PolyfacePrimitive.create(this.displayParams, this.polyface));
    }
    _getStrokes(_facetOptions) { return undefined; }
}
exports.PrimitivePolyfaceGeometry = PrimitivePolyfaceGeometry;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
class StrokesPrimitivePointList {
    constructor(startDistance, points = []) { this.startDistance = startDistance; this.points = [...points]; }
}
exports.StrokesPrimitivePointList = StrokesPrimitivePointList;
class StrokesPrimitivePointLists extends Array {
    constructor(...args) { super(...args); }
}
exports.StrokesPrimitivePointLists = StrokesPrimitivePointLists;
class StrokesPrimitive {
    static create(params, isDisjoint, isPlanar) {
        return new StrokesPrimitive(params, isDisjoint, isPlanar);
    }
    constructor(params, isDisjoint, isPlanar) {
        this.displayParams = params;
        this.strokes = new StrokesPrimitivePointLists();
        this.isDisjoint = isDisjoint;
        this.isPlanar = isPlanar;
    }
    transform(trans) {
        for (const strk of this.strokes) {
            trans.multiplyPoint3dArrayInPlace(strk.points);
        }
    }
}
exports.StrokesPrimitive = StrokesPrimitive;
class StrokesPrimitiveList extends Array {
    constructor(...args) { super(...args); }
}
exports.StrokesPrimitiveList = StrokesPrimitiveList;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
class PolyfacePrimitive {
    get indexedPolyface() { return this._polyface; }
    static create(params, pf, displayEdges = true, isPlanar = false) {
        return new PolyfacePrimitive(params, pf, displayEdges, isPlanar);
    }
    constructor(params, pf, displayEdges, isPlanar) {
        this.displayParams = params;
        this._polyface = pf;
        this.displayEdges = displayEdges;
        this.isPlanar = isPlanar;
    }
    clone() { return new PolyfacePrimitive(this.displayParams, this._polyface.clone(), this.displayEdges, this.isPlanar); }
    transform(trans) { return this._polyface.tryTransformInPlace(trans); }
}
exports.PolyfacePrimitive = PolyfacePrimitive;
class PolyfacePrimitiveList extends Array {
    constructor(...args) { super(...args); }
}
exports.PolyfacePrimitiveList = PolyfacePrimitiveList;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
class GeometryList extends bentleyjs_core_1.Iterable {
    get first() { return this._list[0]; }
    get isEmpty() { return this._list.length === 0; }
    get length() { return this._list.length; }
    push(geom) {
        return this._list.push(geom);
    }
    append(src) {
        this._list.push(...src._list);
        return this;
    }
    clear() { this._list.length = 0; }
    computeRange() {
        const range = geometry_core_1.Range3d.createNull();
        const extendRange = (geom) => range.extendRange(geom.tileRange);
        this._list.forEach(extendRange);
        return range;
    }
    computeQuantizationParams() { return imodeljs_common_1.QParams3d.fromRange(this.computeRange()); }
}
exports.GeometryList = GeometryList;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ShaderProgram_1 = __webpack_require__(125);
const TechniqueFlags_1 = __webpack_require__(126);
const ClearTranslucent_1 = __webpack_require__(369);
const ClearPickAndColor_1 = __webpack_require__(370);
const CopyColor_1 = __webpack_require__(371);
const CopyPickBuffers_1 = __webpack_require__(372);
const Composite_1 = __webpack_require__(373);
const ClipMask_1 = __webpack_require__(374);
const Translucency_1 = __webpack_require__(375);
const Monochrome_1 = __webpack_require__(376);
const Surface_1 = __webpack_require__(231);
const PointString_1 = __webpack_require__(378);
const PointCloud_1 = __webpack_require__(379);
const FeatureSymbology_1 = __webpack_require__(86);
const Fragment_1 = __webpack_require__(25);
const Decode_1 = __webpack_require__(85);
const Common_1 = __webpack_require__(45);
const Vertex_1 = __webpack_require__(20);
const Polyline_1 = __webpack_require__(232);
const Edge_1 = __webpack_require__(380);
const SkyBox_1 = __webpack_require__(381);
// A rendering technique implemented using a single shader program, typically for some specialized purpose.
class SingularTechnique {
    // Note: Technique assumes ownership of a program
    constructor(program) { this.program = program; }
    getShader(_flags) { return this.program; }
    compileShaders() { return this.program.compile(); }
    dispose() {
        bentleyjs_core_1.dispose(this.program);
    }
}
exports.SingularTechnique = SingularTechnique;
function numFeatureVariants(numBaseShaders) { return numBaseShaders * 3; }
const numHiliteVariants = 1;
const clips = [0 /* No */, 1 /* Yes */];
const featureModes = [0 /* None */, 1 /* Pick */, 2 /* Overrides */];
const scratchTechniqueFlags = new TechniqueFlags_1.TechniqueFlags();
// A rendering technique implemented using multiple shader programs, selected based on TechniqueFlags.
class VariedTechnique {
    constructor(numPrograms) {
        this._programs = [];
        this._programs.length = numPrograms;
    }
    getShader(flags) { return this._programs[this.getShaderIndex(flags)]; }
    compileShaders() {
        let allCompiled = true;
        for (const program of this._programs) {
            if (!program.compile())
                allCompiled = false;
        }
        return allCompiled;
    }
    dispose() {
        for (const program of this._programs)
            bentleyjs_core_1.dispose(program);
        this._programs.length = 0;
    }
    addShader(builder, flags, gl) {
        this.addProgram(flags, builder.buildProgram(gl));
    }
    addProgram(flags, program) {
        const index = this.getShaderIndex(flags);
        bentleyjs_core_1.assert(undefined === this._programs[index], "program already exists");
        this._programs[index] = program;
    }
    addHiliteShader(clip, gl, create) {
        const builder = create(clip);
        scratchTechniqueFlags.initForHilite(clip);
        this.addShader(builder, scratchTechniqueFlags, gl);
    }
    addTranslucentShader(builder, flags, gl) {
        flags.isTranslucent = true;
        Translucency_1.addTranslucency(builder.frag);
        this.addShader(builder, flags, gl);
    }
    addElementId(builder, feat) {
        const frag = builder.frag;
        if (0 /* None */ === feat)
            frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
        else {
            const vert = builder.vert;
            vert.set(5 /* AddComputeElementId */, FeatureSymbology_1.computeElementId);
            Common_1.addFrustum(builder);
            builder.addInlineComputedVarying("v_eyeSpace", 5 /* Vec3 */, FeatureSymbology_1.computeEyeSpace);
            Vertex_1.addModelViewMatrix(vert);
            FeatureSymbology_1.addRenderOrder(frag);
            FeatureSymbology_1.addElementId(builder);
            frag.addExtension("GL_EXT_draw_buffers");
            frag.addFunction(Decode_1.GLSLDecode.encodeDepthRgb);
            frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
            frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragData);
        }
    }
    getShaderIndex(flags) {
        bentleyjs_core_1.assert(!flags.isHilite || (!flags.isTranslucent && flags.hasFeatures), "invalid technique flags");
        const index = this.computeShaderIndex(flags);
        bentleyjs_core_1.assert(index < this._programs.length, "shader index out of bounds");
        return index;
    }
}
exports.VariedTechnique = VariedTechnique;
class SurfaceTechnique extends VariedTechnique {
    constructor(gl) {
        super((numFeatureVariants(2) + numHiliteVariants) * 2);
        const flags = scratchTechniqueFlags;
        for (const clip of clips) {
            this.addHiliteShader(clip, gl, Surface_1.createSurfaceHiliter);
            for (const featureMode of featureModes) {
                flags.reset(featureMode, clip);
                const builder = Surface_1.createSurfaceBuilder(featureMode, clip);
                Monochrome_1.addMonochrome(builder.frag);
                Surface_1.addMaterial(builder.frag);
                this.addShader(builder, flags, gl);
                this.addTranslucentShader(builder, flags, gl);
            }
        }
    }
    computeShaderIndex(flags) {
        if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            let hIndex = SurfaceTechnique.kHilite;
            if (flags.hasClipVolume) {
                hIndex += SurfaceTechnique.kClip;
            }
            return hIndex;
        }
        let index = flags.isTranslucent ? SurfaceTechnique.kTranslucent : SurfaceTechnique.kOpaque;
        index += SurfaceTechnique.kFeature * flags.featureMode;
        if (flags.hasClipVolume) {
            index += SurfaceTechnique.kClip;
        }
        return index;
    }
}
SurfaceTechnique.kOpaque = 0;
SurfaceTechnique.kTranslucent = 1;
SurfaceTechnique.kFeature = 2;
SurfaceTechnique.kHilite = numFeatureVariants(SurfaceTechnique.kFeature);
SurfaceTechnique.kClip = SurfaceTechnique.kHilite + 1;
class PolylineTechnique extends VariedTechnique {
    constructor(gl) {
        super((numFeatureVariants(2) + numHiliteVariants) * 2);
        const flags = scratchTechniqueFlags;
        for (const clip of clips) {
            this.addHiliteShader(clip, gl, Polyline_1.createPolylineHiliter);
            for (const featureMode of featureModes) {
                flags.reset(featureMode, clip);
                const builder = Polyline_1.createPolylineBuilder(clip);
                Monochrome_1.addMonochrome(builder.frag);
                // The translucent shaders do not need the element IDs.
                const builderTrans = Polyline_1.createPolylineBuilder(clip);
                Monochrome_1.addMonochrome(builderTrans.frag);
                if (2 /* Overrides */ === featureMode) {
                    FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 15 /* Linear */);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 15 /* Linear */);
                    this.addTranslucentShader(builderTrans, flags, gl);
                }
                else {
                    this.addTranslucentShader(builderTrans, flags, gl);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                }
                this.addElementId(builder, featureMode);
                flags.reset(featureMode, clip);
                this.addShader(builder, flags, gl);
            }
        }
    }
    computeShaderIndex(flags) {
        if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            let hIndex = PolylineTechnique.kHilite;
            if (flags.hasClipVolume) {
                hIndex += PolylineTechnique.kClip;
            }
            return hIndex;
        }
        let index = flags.isTranslucent ? PolylineTechnique.kTranslucent : PolylineTechnique.kOpaque;
        index += PolylineTechnique.kFeature * flags.featureMode;
        if (flags.hasClipVolume) {
            index += PolylineTechnique.kClip;
        }
        return index;
    }
}
PolylineTechnique.kOpaque = 0;
PolylineTechnique.kTranslucent = 1;
PolylineTechnique.kFeature = 2;
PolylineTechnique.kHilite = numFeatureVariants(PolylineTechnique.kFeature);
PolylineTechnique.kClip = PolylineTechnique.kHilite + 1;
class EdgeTechnique extends VariedTechnique {
    constructor(gl, isSilhouette = false) {
        super(numFeatureVariants(2) * 2);
        const flags = scratchTechniqueFlags;
        for (const clip of clips) {
            for (const featureMode of featureModes) {
                flags.reset(featureMode, clip);
                const builder = Edge_1.createEdgeBuilder(isSilhouette, clip);
                Monochrome_1.addMonochrome(builder.frag);
                // The translucent shaders do not need the element IDs.
                const builderTrans = Edge_1.createEdgeBuilder(isSilhouette, clip);
                Monochrome_1.addMonochrome(builderTrans.frag);
                if (2 /* Overrides */ === featureMode) {
                    FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 15 /* Linear */);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 15 /* Linear */);
                    this.addTranslucentShader(builderTrans, flags, gl);
                }
                else {
                    this.addTranslucentShader(builderTrans, flags, gl);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                }
                this.addElementId(builder, featureMode);
                flags.reset(featureMode, clip);
                this.addShader(builder, flags, gl);
            }
        }
    }
    computeShaderIndex(flags) {
        let index = flags.isTranslucent ? EdgeTechnique.kTranslucent : EdgeTechnique.kOpaque;
        index += EdgeTechnique.kFeature * flags.featureMode;
        if (flags.hasClipVolume) {
            index += EdgeTechnique.kClip;
        }
        return index;
    }
}
EdgeTechnique.kOpaque = 0;
EdgeTechnique.kTranslucent = 1;
EdgeTechnique.kFeature = 2;
EdgeTechnique.kClip = numFeatureVariants(EdgeTechnique.kFeature);
class PointStringTechnique extends VariedTechnique {
    constructor(gl) {
        super((numFeatureVariants(2) + numHiliteVariants) * 2);
        const flags = scratchTechniqueFlags;
        for (const clip of clips) {
            this.addHiliteShader(clip, gl, PointString_1.createPointStringHiliter);
            for (const featureMode of featureModes) {
                flags.reset(featureMode, clip);
                const builder = PointString_1.createPointStringBuilder(clip);
                Monochrome_1.addMonochrome(builder.frag);
                // The translucent shaders do not need the element IDs.
                const builderTrans = PointString_1.createPointStringBuilder(clip);
                Monochrome_1.addMonochrome(builderTrans.frag);
                if (2 /* Overrides */ === featureMode) {
                    FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 13 /* Point */);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 13 /* Point */);
                    this.addTranslucentShader(builderTrans, flags, gl);
                }
                else {
                    this.addTranslucentShader(builderTrans, flags, gl);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                }
                this.addElementId(builder, featureMode);
                flags.reset(featureMode, clip);
                this.addShader(builder, flags, gl);
            }
        }
    }
    computeShaderIndex(flags) {
        if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            let hIndex = PointStringTechnique.kHilite;
            if (flags.hasClipVolume) {
                hIndex += PointStringTechnique.kClip;
            }
            return hIndex;
        }
        let index = flags.isTranslucent ? PointStringTechnique.kTranslucent : PointStringTechnique.kOpaque;
        index += PointStringTechnique.kFeature * flags.featureMode;
        if (flags.hasClipVolume) {
            index += PointStringTechnique.kClip;
        }
        return index;
    }
}
PointStringTechnique.kOpaque = 0;
PointStringTechnique.kTranslucent = 1;
PointStringTechnique.kFeature = 2;
PointStringTechnique.kHilite = numFeatureVariants(PointStringTechnique.kFeature);
PointStringTechnique.kClip = PointStringTechnique.kHilite + 1;
class PointCloudTechnique extends VariedTechnique {
    constructor(gl) {
        super(2);
        const flags = scratchTechniqueFlags;
        for (const clip of clips) {
            flags.reset(0 /* None */, clip);
            const builder = PointCloud_1.createPointCloudBuilder(clip);
            builder.frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
            this.addShader(builder, flags, gl);
        }
    }
    computeShaderIndex(flags) {
        let index = PointCloudTechnique.kOpaque;
        if (flags.hasClipVolume) {
            index += PointCloudTechnique.kClip;
        }
        return index;
    }
}
PointCloudTechnique.kOpaque = 0;
PointCloudTechnique.kClip = PointCloudTechnique.kOpaque + 1;
// A collection of rendering techniques accessed by ID.
class Techniques {
    constructor() {
        this._list = new Array(); // indexed by TechniqueId, which may exceed TechniqueId.NumBuiltIn for dynamic techniques.
        this._dynamicTechniqueIds = new Array(); // technique ID = (index in this array) + TechniqueId.NumBuiltIn
        this._scratchTechniqueFlags = new TechniqueFlags_1.TechniqueFlags();
    }
    static create(gl) {
        const techs = new Techniques();
        return techs.initializeBuiltIns(gl) ? techs : undefined;
    }
    getTechnique(id) {
        bentleyjs_core_1.assert(id < this._list.length, "technique index out of bounds");
        return this._list[id];
    }
    addDynamicTechnique(technique, name) {
        for (let i = 0; i < this._dynamicTechniqueIds.length; i++) {
            if (this._dynamicTechniqueIds[i] === name) {
                return 16 /* NumBuiltIn */ + i;
            }
        }
        this._dynamicTechniqueIds.push(name);
        this._list.push(technique);
        return 16 /* NumBuiltIn */ + this._dynamicTechniqueIds.length - 1;
    }
    /** Execute each command in the list */
    execute(target, commands, renderPass) {
        bentleyjs_core_1.assert(255 /* None */ !== renderPass, "invalid render pass");
        const flags = this._scratchTechniqueFlags;
        bentleyjs_core_1.using(new ShaderProgram_1.ShaderProgramExecutor(target, renderPass), (executor) => {
            for (const command of commands) {
                command.preExecute(executor);
                const techniqueId = command.getTechniqueId(target);
                if (-1 /* Invalid */ !== techniqueId) {
                    // A primitive command.
                    bentleyjs_core_1.assert(command.isPrimitiveCommand, "expected primitive command");
                    flags.init(target, renderPass);
                    const tech = this.getTechnique(techniqueId);
                    const program = tech.getShader(flags);
                    if (executor.setProgram(program)) {
                        command.execute(executor);
                    }
                }
                else {
                    // A branch command.
                    bentleyjs_core_1.assert(!command.isPrimitiveCommand, "expected non-primitive command");
                    command.execute(executor);
                }
                command.postExecute(executor);
            }
        });
    }
    /** Draw a single primitive. Usually used for special-purpose rendering techniques. */
    draw(params) {
        const tech = this.getTechnique(params.geometry.getTechniqueId(params.target));
        const program = tech.getShader(TechniqueFlags_1.TechniqueFlags.defaults);
        bentleyjs_core_1.using(new ShaderProgram_1.ShaderProgramExecutor(params.target, params.renderPass, program), (executor) => {
            bentleyjs_core_1.assert(executor.isValid);
            if (executor.isValid) {
                executor.draw(params);
            }
        });
    }
    dispose() {
        for (const tech of this._list)
            bentleyjs_core_1.dispose(tech);
        this._list.length = 0;
    }
    // Chiefly for tests - compiles all shader programs - more generally programs are compiled on demand.
    compileShaders() {
        let allCompiled = true;
        for (const tech of this._list) {
            if (!tech.compileShaders()) {
                allCompiled = false;
            }
        }
        return allCompiled;
    }
    initializeBuiltIns(gl) {
        this._list[9 /* OITClearTranslucent */] = new SingularTechnique(ClearTranslucent_1.createClearTranslucentProgram(gl));
        this._list[13 /* ClearPickAndColor */] = new SingularTechnique(ClearPickAndColor_1.createClearPickAndColorProgram(gl));
        this._list[11 /* CopyColor */] = new SingularTechnique(CopyColor_1.createCopyColorProgram(gl));
        this._list[12 /* CopyColorNoAlpha */] = new SingularTechnique(CopyColor_1.createCopyColorProgram(gl, false));
        this._list[10 /* CopyPickBuffers */] = new SingularTechnique(CopyPickBuffers_1.createCopyPickBuffersProgram(gl));
        this._list[6 /* CompositeHilite */] = new SingularTechnique(Composite_1.createCompositeProgram(2 /* Hilite */, gl));
        this._list[7 /* CompositeTranslucent */] = new SingularTechnique(Composite_1.createCompositeProgram(1 /* Translucent */, gl));
        this._list[8 /* CompositeHiliteAndTranslucent */] = new SingularTechnique(Composite_1.createCompositeProgram(2 /* Hilite */ | 1 /* Translucent */, gl));
        this._list[14 /* ClipMask */] = new SingularTechnique(ClipMask_1.createClipMaskProgram(gl));
        this._list[0 /* Surface */] = new SurfaceTechnique(gl);
        this._list[4 /* Edge */] = new EdgeTechnique(gl, false);
        this._list[5 /* SilhouetteEdge */] = new EdgeTechnique(gl, true);
        this._list[1 /* Polyline */] = new PolylineTechnique(gl);
        this._list[3 /* PointString */] = new PointStringTechnique(gl);
        this._list[2 /* PointCloud */] = new PointCloudTechnique(gl);
        this._list[15 /* SkyBox */] = new SingularTechnique(SkyBox_1.createSkyBoxProgram(gl));
        bentleyjs_core_1.assert(this._list.length === 16 /* NumBuiltIn */, "unexpected number of built-in techniques");
        return true;
    }
}
exports.Techniques = Techniques;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(30);
const computeLUTCoords = `
vec2 computeLUTCoords(float index, vec2 dimensions, vec2 center, float mult) {
  float baseIndex = index*mult;

  // Fix precision issues wherein mod(x,y) => y instead of 0 when x is multiple of y...
  float epsilon = 0.5 / dimensions.x;
  float yId = floor(baseIndex / dimensions.x + epsilon);
  float xId = baseIndex - dimensions.x * yId; // replaces mod()...

  return center + vec2(xId/dimensions.x, yId/dimensions.y);
}
`;
const computeCoordsTemplate = `
vec2 compute_{LUTNAME}_coords(float index) {
  return computeLUTCoords(index, u_{LUTNAME}Params.xy, g_{LUTNAME}_center, {MULT});
}
`;
const initializerTemplate = `
  {LUTSTEPX} = 1.0 / {LUTPARAMS}.x;
  {LUTSTEPY} = 1.0 / {LUTPARAMS}.y;
  {LUTCENTER} = vec2(0.5*{LUTSTEPX}, 0.5*{LUTSTEPY});
`;
function addLookupTable(sb, lutName, mult = "1.0") {
    sb.addFunction(computeLUTCoords);
    if (sb instanceof ShaderBuilder_1.VertexShaderBuilder) {
        const lutStepX = "g_" + lutName + "_stepX";
        const lutStepY = "g_" + lutName + "_stepY";
        const lutCenter = "g_" + lutName + "_center";
        const lutParams = "u_" + lutName + "Params";
        sb.addGlobal(lutStepX, 3 /* Float */);
        sb.addGlobal(lutStepY, 3 /* Float */);
        sb.addGlobal(lutCenter, 4 /* Vec2 */);
        let initializerSpecific = initializerTemplate;
        initializerSpecific = initializerSpecific.replace(/{LUTSTEPX}/g, lutStepX);
        initializerSpecific = initializerSpecific.replace(/{LUTSTEPY}/g, lutStepY);
        initializerSpecific = initializerSpecific.replace(/{LUTCENTER}/g, lutCenter);
        initializerSpecific = initializerSpecific.replace(/{LUTPARAMS}/g, lutParams);
        sb.addInitializer(initializerSpecific);
        let computeCoordsSpecific = computeCoordsTemplate;
        computeCoordsSpecific = computeCoordsSpecific.replace(/{LUTNAME}/g, lutName);
        computeCoordsSpecific = computeCoordsSpecific.replace(/{MULT}/g, mult);
        sb.addFunction(computeCoordsSpecific);
    }
}
exports.addLookupTable = addLookupTable;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(30);
const Fragment_1 = __webpack_require__(25);
const Vertex_1 = __webpack_require__(20);
const Decode_1 = __webpack_require__(85);
const Color_1 = __webpack_require__(103);
const Lighting_1 = __webpack_require__(377);
const Clipping_1 = __webpack_require__(89);
const FloatRGBA_1 = __webpack_require__(35);
const FeatureSymbology_1 = __webpack_require__(86);
const Common_1 = __webpack_require__(45);
const Surface_1 = __webpack_require__(127);
const RenderFlags_1 = __webpack_require__(24);
const bentleyjs_core_1 = __webpack_require__(0);
const Material_1 = __webpack_require__(130);
const System_1 = __webpack_require__(7);
const applyMaterialOverrides = `
  bool isTextured = isSurfaceBitSet(kSurfaceBit_HasTexture);
  bool useTextureWeight = isTextured && u_textureWeight < 1.0;
  bool useMatColor = !isSurfaceBitSet(kSurfaceBit_IgnoreMaterial) && (!isTextured || useTextureWeight);

  if (useMatColor) {
    // u_matRgb.a = 1.0 if color overridden by material, 0.0 otherwise.
    if (u_matRgb.a > 0.5)
      baseColor.rgb = u_matRgb.rgb * baseColor.a;

    // u_matAlpha.y = 1.0 if alpha overridden by material.
    if (u_matAlpha.y > 0.5)
      baseColor = adjustPreMultipliedAlpha(baseColor, u_matAlpha.x);
  }

  if (useTextureWeight) {
    vec4 texColor = TEXTURE(s_texture, v_texCoord);
    baseColor = mix(baseColor, texColor, u_textureWeight);

    // Textures do NOT contain premultiplied alpha. Multiply here.
    // ###TODO: This won't produce correct results if u_textureWeight < 1.0 and baseColor.a < 1.0 - handle.
    return applyPreMultipliedAlpha(baseColor);
  }

  return baseColor;
`;
function addMaterial(frag) {
    // ###TODO: We could pack rgb, alpha, and override flags into two floats.
    frag.addFunction(Fragment_1.GLSLFragment.revertPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.applyPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    frag.set(2 /* ApplyMaterialOverrides */, applyMaterialOverrides);
    frag.addUniform("u_matRgb", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_matRgb", (uniform, params) => {
            const mat = params.target.currentViewFlags.showMaterials() && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform4fv(mat.diffuseUniform);
        });
    });
    frag.addUniform("u_matAlpha", 4 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_matAlpha", (uniform, params) => {
            const mat = params.target.currentViewFlags.showMaterials() && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform2fv(mat.alphaUniform);
        });
    });
    frag.addUniform("u_textureWeight", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_textureWeight", (uniform, params) => {
            const mat = params.target.currentViewFlags.showMaterials() && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform1f(mat.textureWeight);
        });
    });
}
exports.addMaterial = addMaterial;
const computePosition = `
  // ###TODO if (u_animParams.z > 0.0)
  // ###TODO   rawPos.xyz += computeAnimatedDisplacement(u_animValue * u_animParams.z).xyz;
  vec4 pos = u_mv * rawPos;
  v_pos = pos.xyz;
  return u_proj * pos;
`;
function createCommon(clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(true);
    const vert = builder.vert;
    // ###TODO Animation.AddCommon(vert);
    if (1 /* Yes */ === clip)
        Clipping_1.addClipping(builder);
    Vertex_1.addProjectionMatrix(vert);
    Vertex_1.addModelViewMatrix(vert);
    builder.addVarying("v_pos", 5 /* Vec3 */);
    vert.set(3 /* ComputePosition */, computePosition);
    return builder;
}
function createSurfaceHiliter(clip) {
    const builder = createCommon(clip);
    FeatureSymbology_1.addHiliter(builder);
    return builder;
}
exports.createSurfaceHiliter = createSurfaceHiliter;
// nvidia hardware incorrectly interpolates varying floats when we send the same exact value for every vertex...
const isSurfaceBitSet = `
bool isSurfaceBitSet(float flag) { return 0.0 != extractNthBit(floor(v_surfaceFlags + 0.5), flag); }
`;
function addSurfaceFlagsLookup(builder) {
    builder.addConstant("kSurfaceBit_HasTexture", 3 /* Float */, "0.0");
    builder.addConstant("kSurfaceBit_ApplyLighting", 3 /* Float */, "1.0");
    builder.addConstant("kSurfaceBit_HasNormals", 3 /* Float */, "2.0");
    builder.addConstant("kSurfaceBit_IgnoreMaterial", 3 /* Float */, "3.0");
    builder.addConstant("kSurfaceBit_TransparencyThreshold", 3 /* Float */, "4.0");
    builder.addConstant("kSurfaceBit_BackgroundFill", 3 /* Float */, "5.0");
    builder.addConstant("kSurfaceBit_HasColorAndNormal", 3 /* Float */, "6.0");
    builder.addConstant("kSurfaceBit_EnvironmentMap", 3 /* Float */, "7.0");
    builder.addConstant("kSurfaceMask_None", 3 /* Float */, "0.0");
    builder.addConstant("kSurfaceMask_HasTexture", 3 /* Float */, "1.0");
    builder.addConstant("kSurfaceMask_ApplyLighting", 3 /* Float */, "2.0");
    builder.addConstant("kSurfaceMask_HasNormals", 3 /* Float */, "4.0");
    builder.addConstant("kSurfaceMask_IgnoreMaterial", 3 /* Float */, "8.0");
    builder.addConstant("kSurfaceMask_TransparencyThreshold", 3 /* Float */, "16.0");
    builder.addConstant("kSurfaceMask_BackgroundFill", 3 /* Float */, "32.0");
    builder.addConstant("kSurfaceMask_HasColorAndNormal", 3 /* Float */, "64.0");
    builder.addConstant("kSurfaceMask_EnvironmentMap", 3 /* Float */, "128.0");
    builder.addFunction(Common_1.GLSLCommon.extractNthBit);
    builder.addFunction(isSurfaceBitSet);
}
const getSurfaceFlags = "return u_surfaceFlags;";
const computeSurfaceFlags = `
  float flags = u_surfaceFlags;
  if (feature_ignore_material) {
    bool hasTexture = 0.0 != fract(flags / 2.0); // kSurfaceMask_HasTexture = 1.0...
    if (hasTexture)
      flags -= kSurfaceMask_HasTexture;

    flags += kSurfaceMask_IgnoreMaterial;
  }

  return flags;
`;
exports.octDecodeNormal = `
vec3 octDecodeNormal(vec2 e) {
  e = e / 255.0 * 2.0 - 1.0;
  vec3 n = vec3(e.x, e.y, 1.0 - abs(e.x) - abs(e.y));
  if (n.z < 0.0) {
    vec2 signNotZero = vec2(n.x >= 0.0 ? 1.0 : -1.0, n.y >= 0.0 ? 1.0 : -1.0);
    n.xy = (1.0 - abs(n.yx)) * signNotZero;
  }

  return normalize(n);
}
`;
const computeNormal = `
  if (!isSurfaceBitSet(kSurfaceBit_HasNormals))
    return vec3(0.0);

  vec2 normal = g_vertexData2;
  if (isSurfaceBitSet(kSurfaceBit_HasColorAndNormal)) {
    vec2 tc = g_vertexBaseCoords;
    tc.x += 3.0 * g_vert_stepX;
    vec4 enc = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
    normal = enc.xy;
  }

  return normalize(u_nmx * octDecodeNormal(normal));
`;
const isBelowTransparencyThreshold = `
  return alpha < u_transparencyThreshold && isSurfaceBitSet(kSurfaceBit_TransparencyThreshold);
`;
const applyBackgroundColor = `
  if (isSurfaceBitSet(kSurfaceBit_BackgroundFill))
    baseColor.rgb = u_bgColor.rgb;

  return baseColor;
`;
const computeTexCoord = `
  if (!isSurfaceBitSet(kSurfaceBit_HasTexture))
    return vec2(0.0);

  // ###TODO if (u_animParams.w > 0.0)
  // ###TODO   return computeAnimatedTextureParam(u_animValue * u_animParams.w);

  vec2 tc = g_vertexBaseCoords;
  tc.x += 3.0 * g_vert_stepX;
  vec4 rgba = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec2 qcoords = vec2(decodeUInt16(rgba.xy), decodeUInt16(rgba.zw));
  return unquantize2d(qcoords, u_qTexCoordParams);
`;
const getSurfaceColor = `
vec4 getSurfaceColor() { return v_color; }
`;
const computeBaseColor = `
  if (isSurfaceBitSet(kSurfaceBit_HasTexture) && u_textureWeight >= 1.0) {
    // if a glyph texture, must mix getSurfaceColor() with texCol so texCol.a is applied 100% and
    // surfCol.rgb is scaled by texCol.rgb (texCol.rgb = full white originally but stretched via mipMapping)
    if (u_applyGlyphTex > 0) {
      vec4 surfCol = getSurfaceColor();
      const vec3 white = vec3(1.0);
      const vec3 epsilon = vec3(0.0001);
      vec3 color = surfCol.a > 0.0 ? surfCol.rgb / surfCol.a : surfCol.rgb; // revert premultiplied alpha
      vec3 delta = (color + epsilon) - white;
      if (u_reverseWhiteOnWhite > 0.5 && delta.x > 0.0 && delta.y > 0.0 && delta.z > 0.0)
        surfCol.rgb = vec3(0.0);

      vec4 texCol = TEXTURE(s_texture, v_texCoord);
      return vec4(surfCol.rgb * texCol.rgb, texCol.a);
    } else {
      return TEXTURE(s_texture, v_texCoord);
    }
  } else {
    return getSurfaceColor(); // if textured, compute surface/material color first then mix with texture in applyMaterialOverrides...
  }
`;
function addSurfaceFlags(builder, withFeatureOverrides) {
    builder.addFunctionComputedVarying("v_surfaceFlags", 3 /* Float */, "computeSurfaceFlags", withFeatureOverrides ? computeSurfaceFlags : getSurfaceFlags);
    addSurfaceFlagsLookup(builder.vert);
    addSurfaceFlagsLookup(builder.frag);
    builder.addUniform("u_surfaceFlags", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_surfaceFlags", (uniform, params) => {
            bentleyjs_core_1.assert(params.geometry instanceof Surface_1.SurfaceGeometry);
            const mesh = params.geometry;
            const surfFlags = mesh.computeSurfaceFlags(params);
            uniform.setUniform1f(surfFlags);
        });
    });
}
function addNormal(builder) {
    Vertex_1.addNormalMatrix(builder.vert);
    builder.vert.addFunction(exports.octDecodeNormal);
    builder.addFunctionComputedVarying("v_n", 5 /* Vec3 */, "computeLightingNormal", computeNormal);
}
function addTransparencyThreshold(frag) {
    frag.addUniform("u_transparencyThreshold", 3 /* Float */, (prog) => {
        prog.addProgramUniform("u_transparencyThreshold", (uniform, params) => {
            uniform.setUniform1f(params.target.transparencyThreshold);
        });
    });
    frag.set(6 /* DiscardByAlpha */, isBelowTransparencyThreshold);
}
function createSurfaceBuilder(feat, clip) {
    const builder = createCommon(clip);
    Common_1.addShaderFlags(builder);
    FeatureSymbology_1.addFeatureSymbology(builder, feat, 2 /* Overrides */ === feat ? 12 /* Surface */ : 0 /* None */);
    addSurfaceFlags(builder, 2 /* Overrides */ === feat);
    FeatureSymbology_1.addSurfaceDiscard(builder, feat);
    addNormal(builder);
    // NB: We need the transparency threshold in translucent *and* opaque passes.
    // Opaque because we must compute the alpha in order to decide whether to discard or render opaque.
    addTransparencyThreshold(builder.frag);
    // In HiddenLine mode, we must compute the base color (plus feature overrides etc) in order to get the alpha, then replace with background color (preserving alpha for the transparency threshold test).
    builder.frag.set(4 /* FinalizeBaseColor */, applyBackgroundColor);
    builder.frag.addUniform("u_bgColor", 5 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_bgColor", (uniform, params) => {
            const bgColor = params.target.bgColor;
            const rgbColor = FloatRGBA_1.FloatPreMulRgba.fromColorDef(bgColor);
            uniform.setUniform3fv(new Float32Array([rgbColor.red, rgbColor.green, rgbColor.blue]));
        });
    });
    // Vertex
    builder.vert.addFunction(Decode_1.GLSLDecode.unquantize2d);
    // ###TODO: Animation.addTextureParam(builder.vert);
    builder.addFunctionComputedVarying("v_texCoord", 4 /* Vec2 */, "computeTexCoord", computeTexCoord);
    builder.vert.addUniform("u_qTexCoordParams", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_qTexCoordParams", (uniform, params) => {
            const surfGeom = params.geometry;
            const surfFlags = surfGeom.computeSurfaceFlags(params);
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags)) {
                const uvQParams = surfGeom.lut.uvQParams;
                if (undefined !== uvQParams) {
                    uniform.setUniform4fv(uvQParams);
                }
            }
        });
    });
    builder.frag.addUniform("s_texture", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_texture", (uniform, params) => {
            const surfGeom = params.geometry;
            const surfFlags = surfGeom.computeSurfaceFlags(params);
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags)) {
                bentleyjs_core_1.assert(undefined !== surfGeom.texture);
                const texture = surfGeom.texture;
                texture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Zero);
            }
            else if (undefined !== System_1.System.instance && undefined !== System_1.System.instance.lineCodeTexture) {
                // Bind the linecode texture just so that we have something bound to this texture unit for the shader.
                System_1.System.instance.lineCodeTexture.bindSampler(uniform, RenderFlags_1.TextureUnit.Zero);
            }
        });
    });
    builder.frag.addUniform("u_applyGlyphTex", 1 /* Int */, (prog) => {
        prog.addGraphicUniform("u_applyGlyphTex", (uniform, params) => {
            const surfGeom = params.geometry;
            const surfFlags = surfGeom.computeSurfaceFlags(params);
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags)) {
                uniform.setUniform1i(surfGeom.isGlyph ? 1 : 0);
            }
        });
    });
    // Fragment and Vertex
    Color_1.addColor(builder);
    // Fragment
    builder.frag.addFunction(getSurfaceColor);
    Lighting_1.addLighting(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    if (0 /* None */ === feat) {
        builder.frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    }
    else {
        builder.frag.addExtension("GL_EXT_draw_buffers");
        builder.frag.addFunction(Decode_1.GLSLDecode.depthRgb);
        builder.frag.addFunction(Decode_1.GLSLDecode.encodeDepthRgb);
        builder.frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
        builder.frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragData);
    }
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    return builder;
}
exports.createSurfaceBuilder = createSurfaceBuilder;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ShaderBuilder_1 = __webpack_require__(30);
const Vertex_1 = __webpack_require__(20);
const Common_1 = __webpack_require__(45);
const Viewport_1 = __webpack_require__(233);
const GL_1 = __webpack_require__(8);
const Decode_1 = __webpack_require__(85);
const Clipping_1 = __webpack_require__(89);
const Color_1 = __webpack_require__(103);
const Fragment_1 = __webpack_require__(25);
const Common_2 = __webpack_require__(45);
const System_1 = __webpack_require__(7);
const RenderFlags_1 = __webpack_require__(24);
const FeatureSymbology_1 = __webpack_require__(86);
const checkForDiscard = "return discardByLineCode;";
const applyLineCode = `
  if (v_texc.x >= 0.0) { // v_texc = (-1,-1) for solid lines - don't bother with any of this
    vec4 texColor = TEXTURE(u_lineCodeTexture, v_texc);
    discardByLineCode = (0.0 == texColor.r);
  }

  if (v_lnInfo.w > 0.5) { // line needs pixel trimming
    // calculate pixel distance from pixel center to expected line center, opposite dir from major
    vec2 dxy = gl_FragCoord.xy - v_lnInfo.xy;
    if (v_lnInfo.w < 1.5)  // not x-major
      dxy = dxy.yx;

    float dist = v_lnInfo.z * dxy.x - dxy.y;
    float distA = abs(dist);
    if (distA > 0.5 || (distA == 0.5 && dist < 0.0))
      discardByLineCode = true;  // borrow this flag to force discard
  }

  return baseColor;
`;
const computeTextureCoord = `
vec2 computeLineCodeTextureCoords(vec2 windowDir, vec4 projPos, float adjust) {
  vec2 texc;
  float lineCode = ComputeLineCode();
  if (0.0 == lineCode) {
    // Solid line - tell frag shader not to bother.
    texc = vec2(-1.0, -1.0);
  } else {
    const float imagesPerPixel = 1.0/32.0;
    const float textureCoordinateBase = 8192.0; // Temp workardound for clipping problem in perspective views (negative values don't seem to interpolate correctly).

    if (abs(windowDir.x) > abs(windowDir.y))
      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.x + adjust * windowDir.x);
    else
      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.y + adjust * windowDir.y);

    const float numLineCodes = 16.0; // NB: Actually only 10, but texture is 16px tall because it needs to be a power of 2.
    const float rowsPerCode = 1.0;
    const float numRows = numLineCodes*rowsPerCode;
    const float centerY = 0.5/numRows;
    const float stepY = rowsPerCode/numRows;
    texc.y = stepY * lineCode + centerY;
  }

  return texc;
}
`;
exports.adjustWidth = `
void adjustWidth(inout float width, vec2 d2, vec2 org) {
  // calculate slope based width adjustment for non-AA lines, widths 1 to 4
  vec2 d2A = abs(d2);
  const float s_myFltEpsilon = 0.0001;  // limit test resolution to 4 digits in case 24 bit (s16e7) is used in hardware
  if (d2A.y > s_myFltEpsilon && width < 4.5) {
    float len = length(d2A);
    float tan = d2A.x / d2A.y;

    if (width < 1.5) { // width 1
      if (tan <= 1.0)
        width = d2A.y / len;
      else
        width = d2A.x / len;
      // width 1 requires additional adjustment plus trimming in frag shader using v_lnInfo
      width *= 1.01;
      v_lnInfo.xy = org;
      v_lnInfo.w = 1.0; // set flag to do trimming
      // set slope in v_lnInfo.z
      if (d2A.x - d2A.y > s_myFltEpsilon) {
        v_lnInfo.z = d2.y / d2.x;
        v_lnInfo.w += 2.0; // add in x-major flag
      } else
        v_lnInfo.z = d2.x / d2.y;

    } else if (width < 2.5) { // width 2
      if (tan <= 0.5)
        width = 2.0 * d2A.y / len;
      else
        width = (d2A.y + 2.0 * d2A.x) / len;

    } else if (width < 3.5) { // width 3
        if (tan <= 1.0)
            width = (3.0 * d2A.y + d2A.x) / len;
        else
            width = (d2A.y + 3.0 * d2A.x) / len;

    } else { // if (width < 4.5) // width 4
      if (tan <= 0.5)
        width = (4.0 * d2A.y + d2A.x) / len;
      else if (tan <= 2.0)
        width = (3.0 * d2A.y + 3.0 * d2A.x) / len;
      else
        width = (d2A.y + 4.0 * d2A.x) / len;
    }
  }
}
`;
function addLineCodeTexture(frag) {
    frag.addUniform("u_lineCodeTexture", 9 /* Sampler2D */, (prog) => {
        prog.addProgramUniform("u_lineCodeTexture", (uniform) => {
            const lct = System_1.System.instance.lineCodeTexture;
            bentleyjs_core_1.assert(undefined !== lct);
            if (undefined !== lct)
                lct.bindSampler(uniform, RenderFlags_1.TextureUnit.LineCode);
        });
    });
}
exports.addLineCodeTexture = addLineCodeTexture;
function addLineCode(prog, args) {
    const vert = prog.vert;
    const frag = prog.frag;
    vert.addUniform("u_lineCode", 3 /* Float */, (shaderProg) => {
        shaderProg.addGraphicUniform("u_lineCode", (uniform, params) => {
            uniform.setUniform1f(params.geometry.getLineCode(params));
        });
    });
    vert.addFunction(Vertex_1.GLSLVertex.computeLineCode);
    const funcCall = "computeLineCodeTextureCoords(" + args + ")";
    prog.addFunctionComputedVaryingWithArgs("v_texc", 4 /* Vec2 */, funcCall, computeTextureCoord);
    Common_1.addFrustum(prog);
    addLineCodeTexture(prog.frag);
    frag.set(4 /* FinalizeBaseColor */, applyLineCode);
    frag.set(5 /* CheckForDiscard */, checkForDiscard);
    frag.addGlobal("discardByLineCode", 0 /* Boolean */, "false");
}
exports.addLineCode = addLineCode;
function polylineAddLineCode(prog) {
    addLineCode(prog, lineCodeArgs);
    Vertex_1.addModelViewMatrix(prog.vert);
    /* NOTNOW_NO_LONGER_REQUIRED
    // ###TODO: Ray claims these currently-unused distances will be useful later on for non-cosmetic line styles?
    // If not, jettison.
    prog.vert.addAttribute("a_distance", VariableType.Float, (prog) => {
      prog.addGraphicAttribute("a_distance", (that, params) => {}
        that.getAttribute().enableArray(params.m_geometry.getPolylineBuffers()->m_distances, 1, GL_FLOAT, GL_FALSE, 0, 0);
      });
    });
    */
}
function addCommon(prog, clip) {
    const vert = prog.vert;
    Viewport_1.addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation
    Vertex_1.addProjectionMatrix(vert);
    Vertex_1.addModelViewMatrix(vert);
    vert.addFunction(Vertex_1.GLSLVertex.computeLineWeight);
    Viewport_1.addViewport(vert);
    vert.addGlobal("g_windowPos", 6 /* Vec4 */);
    vert.addGlobal("g_prevPos", 6 /* Vec4 */);
    vert.addGlobal("g_nextPos", 6 /* Vec4 */);
    vert.addGlobal("g_windowDir", 4 /* Vec2 */);
    vert.addInitializer(decodeAdjacentPositions);
    vert.addAttribute("a_prevIndex", 5 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_prevIndex", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.prevIndices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
        });
    });
    vert.addAttribute("a_nextIndex", 5 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_nextIndex", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.nextIndicesAndParams, 3, GL_1.GL.DataType.UnsignedByte, false, 4, 0);
        });
    });
    vert.addFunction(Decode_1.GLSLDecode.unquantize2d);
    vert.addAttribute("a_param", 3 /* Float */, (shaderProg) => {
        shaderProg.addAttribute("a_param", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.nextIndicesAndParams, 1, GL_1.GL.DataType.UnsignedByte, false, 4, 3);
        });
    });
    vert.addUniform("u_lineWeight", 3 /* Float */, (shaderProg) => {
        shaderProg.addGraphicUniform("u_lineWeight", (attr, params) => {
            attr.setUniform1f(params.geometry.getLineWeight(params));
        });
    });
    vert.addGlobal("miterAdjust", 3 /* Float */, "0.0");
    vert.set(3 /* ComputePosition */, computePosition);
    prog.addVarying("v_lnInfo", 6 /* Vec4 */);
    vert.addFunction(exports.adjustWidth);
    if (1 /* Yes */ === clip)
        Clipping_1.addClipping(prog);
}
const decodeAdjacentPositions = `
  float index;
  vec2 tc;
  vec4 e0, e1;
  vec3 qpos;

  index = decodeUInt32(a_prevIndex);
  tc = computeLUTCoords(index, u_vertParams.xy, g_vert_center, u_vertParams.z);
  e0 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc += g_vert_stepX;
  e1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  qpos = vec3(decodeUInt16(e0.xy), decodeUInt16(e0.zw), decodeUInt16(e1.xy));
  g_prevPos = unquantizePosition(qpos, u_qOrigin, u_qScale);

  index = decodeUInt32(a_nextIndex);
  tc = computeLUTCoords(index, u_vertParams.xy, g_vert_center, u_vertParams.z);
  e0 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc += g_vert_stepX;
  e1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  qpos = vec3(decodeUInt16(e0.xy), decodeUInt16(e0.zw), decodeUInt16(e1.xy));
  g_nextPos = unquantizePosition(qpos, u_qOrigin, u_qScale);
`;
const computePosition = `
  const float kNone = 0.0,
              kSquare = 1.0*3.0,
              kMiter = 2.0*3.0,
              kMiterInsideOnly = 3.0*3.0,
              kJointBase = 4.0*3.0,
              kNegatePerp = 8.0*3.0,
              kNegateAlong = 16.0*3.0,
              kNoneAdjWt = 32.0*3.0;

  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false

  vec4 pos = u_mvp * rawPos;

  vec4 next = g_nextPos;
  g_windowPos = modelToWindowCoordinates(rawPos, next);

  if (g_windowPos.w == 0.0)
    return g_windowPos;

  float param = a_param;
  float weight = ComputeLineWeight();
  float scale = 1.0, directionScale = 1.0;

  if (param >= kNoneAdjWt)
    param -= kNoneAdjWt;

  if (param >= kNegateAlong) {
    directionScale = -directionScale;
    param -= kNegateAlong;
  }

  if (param >= kNegatePerp) {
    scale = -1.0;
    param -= kNegatePerp;
  }

  vec4 projNext = modelToWindowCoordinates(next, rawPos);
  g_windowDir = projNext.xy - g_windowPos.xy;

  if (param < kJointBase) {
    vec2 dir = (directionScale > 0.0) ? g_windowDir : -g_windowDir;
    vec2 pos = (directionScale > 0.0) ? g_windowPos.xy : projNext.xy;
    adjustWidth(weight, dir, pos);
  }

  if (kNone != param) {
    vec2 delta = vec2(0.0);
    vec4 prev   = g_prevPos;
    vec4 projPrev = modelToWindowCoordinates(prev, rawPos);
    vec2 prevDir   = g_windowPos.xy - projPrev.xy;
    float thisLength = sqrt(g_windowDir.x * g_windowDir.x + g_windowDir.y * g_windowDir.y);
    const float s_minNormalizeLength = 1.0E-5;  // avoid normalizing zero length vectors.
    float dist = weight / 2.0;

    if (thisLength > s_minNormalizeLength) {
      g_windowDir /= thisLength;

      float prevLength = sqrt(prevDir.x * prevDir.x + prevDir.y * prevDir.y);

      if (prevLength > s_minNormalizeLength) {
        prevDir /= prevLength;
        const float     s_minParallelDot= -.9999, s_maxParallelDot = .9999;
        float           prevNextDot  = dot(prevDir, g_windowDir);

        if (prevNextDot < s_minParallelDot || prevNextDot > s_maxParallelDot)    // No miter if parallel or antiparallel.
          param = kSquare;
      } else
        param = kSquare;
    } else {
      g_windowDir = -normalize(prevDir);
      param = kSquare;
    }

    vec2 perp = scale * vec2(-g_windowDir.y, g_windowDir.x);

    if (param == kSquare) {
      delta = perp;
    } else {
      vec2 bisector = normalize(prevDir - g_windowDir);
      float dotP = dot (bisector, perp);

      if (dotP != 0.0) { // Should never occur - but avoid divide by zero.
        const float maxMiter = 3.0;
        float miterDistance = 1.0/dotP;

        if (param == kMiter) { // Straight miter.
          delta = (abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;

        } else if (param == kMiterInsideOnly) { // Miter at inside, square at outside (to make room for joint).
          delta = (dotP  > 0.0 || abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;

        } else {
          const float jointTriangleCount = 3.0;
          float ratio = (param - kJointBase) / jointTriangleCount; // 3 triangles per half-joint as defined in Graphics.cpp
          delta = normalize((1.0 - ratio) * bisector + (dotP < 0.0 ? -ratio : ratio) * perp); // Miter/Straight combination.
        }
      }
    }

    miterAdjust = dot(g_windowDir, delta) * dist; // Not actually used for hilite shader but meh.
    pos.x += dist * delta.x * 2.0 * pos.w / u_viewport.z;
    pos.y += dist * delta.y * 2.0 * pos.w / u_viewport.w;
  }

  return pos;
`;
const lineCodeArgs = "g_windowDir, g_windowPos, miterAdjust";
function createPolylineBuilder(clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(true);
    Common_2.addShaderFlags(builder);
    addCommon(builder, clip);
    polylineAddLineCode(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createPolylineBuilder = createPolylineBuilder;
function createPolylineHiliter(clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(true);
    addCommon(builder, clip);
    Common_1.addFrustum(builder);
    FeatureSymbology_1.addHiliter(builder);
    return builder;
}
exports.createPolylineHiliter = createPolylineHiliter;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(81);
const Vertex_1 = __webpack_require__(20);
const RenderPass_1 = __webpack_require__(129);
function addViewport(shader) {
    shader.addUniform("u_viewport", 6 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_viewport", (uniform, params) => {
            const rect = params.target.viewRect;
            const vp = [rect.left, rect.bottom, rect.width, rect.height];
            uniform.setUniform4fv(vp);
        });
    });
}
exports.addViewport = addViewport;
function computeViewportTransformation(viewRect, nearDepthRange, farDepthRange) {
    const x = viewRect.left;
    const y = viewRect.top;
    const width = viewRect.width;
    const height = viewRect.height;
    const halfWidth = width * 0.5;
    const halfHeight = height * 0.5;
    const halfDepth = (farDepthRange - nearDepthRange) * 0.5;
    const column0Row0 = halfWidth;
    const column1Row1 = halfHeight;
    const column2Row2 = halfDepth;
    const column3Row0 = x + halfWidth;
    const column3Row1 = y + halfHeight;
    const column3Row2 = nearDepthRange + halfDepth;
    const column3Row3 = 1.0;
    const mat = Matrix_1.Matrix4.fromValues(column0Row0, 0.0, 0.0, column3Row0, 0.0, column1Row1, 0.0, column3Row1, 0.0, 0.0, column2Row2, column3Row2, 0.0, 0.0, 0.0, column3Row3);
    return mat;
}
function addViewportTransformation(shader) {
    shader.addUniform("u_viewportTransformation", 8 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_viewportTransformation", (uniform, params) => {
            uniform.setMatrix4(computeViewportTransformation(params.target.viewRect, 0.0, 1.0));
        });
    });
}
exports.addViewportTransformation = addViewportTransformation;
const modelToWindowCoordinates = `
vec4 modelToWindowCoordinates(vec4 position, vec4 next) {
  if (kRenderPass_ViewOverlay == u_renderPass || kRenderPass_Background == u_renderPass) {
    vec4 q = u_mvp * position;
    q.xyz /= q.w;
    q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
    return q;
  }

  // Negative values are in front of the camera (visible).
  float s_maxZ = -u_frustum.x;            // use -near (front) plane for segment drop test since u_frustum's near & far are pos.
  vec4  q = u_mv * position;              // eye coordinates.
  vec4  n = u_mv * next;

  if (q.z > s_maxZ) {
    if (n.z > s_maxZ)
      return vec4(0.0, 0.0,  1.0, 0.0);   // Entire segment behind eye.

    float t = (s_maxZ - q.z) / (n.z - q.z);

    q.x += t * (n.x - q.x);
    q.y += t * (n.y - q.y);
    q.z = s_maxZ;                       // q.z + (s_maxZ - q.z) * (s_maxZ - q.z) / n.z - q.z
  }
  q = u_proj * q;
  q.xyz /= q.w;                           // normalized device coords
  q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coords
  return q;
  }
`;
function addModelToWindowCoordinates(vert) {
    Vertex_1.addModelViewProjectionMatrix(vert);
    addViewportTransformation(vert);
    RenderPass_1.addRenderPass(vert);
    vert.addFunction(modelToWindowCoordinates);
}
exports.addModelToWindowCoordinates = addModelToWindowCoordinates;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const Primitive_1 = __webpack_require__(65);
const CachedGeometry_1 = __webpack_require__(29);
const VertexLUT_1 = __webpack_require__(88);
const FeaturesInfo_1 = __webpack_require__(87);
const Handle_1 = __webpack_require__(36);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
class PointStringInfo {
    constructor(args) {
        this.vertexParams = args.pointParams;
        this.features = FeaturesInfo_1.FeaturesInfo.create(args.features);
        this.weight = args.width;
    }
}
exports.PointStringInfo = PointStringInfo;
class PointStringGeometry extends CachedGeometry_1.LUTGeometry {
    constructor(indices, numIndices, lut, info) {
        super();
        this.numIndices = numIndices;
        this.indices = indices;
        this.lut = lut;
        this.pointString = info;
    }
    _wantWoWReversal(_target) { return true; }
    getTechniqueId(_target) { return 3 /* PointString */; }
    getRenderPass(_target) { return 1 /* OpaqueLinear */; }
    get featuresInfo() { return this.pointString.features; }
    get renderOrder() { return 11 /* PlanarLinear */; }
    bindVertexArray(attr) {
        attr.enableArray(this.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _getLineWeight(_params) { return this.pointString.weight; }
    draw() {
        const gl = System_1.System.instance.context;
        this.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Points, 0, this.numIndices);
    }
    static create(args) {
        if (0 === args.polylines.length)
            return undefined;
        let vertIndices = args.polylines[0].vertIndices;
        if (1 < args.polylines.length) {
            // ###TODO: This shouldn't happen, and similar assertion in C++ is not triggered...
            // assert(args.polylines.length === 1);
            vertIndices = [];
            for (const polyline of args.polylines) {
                for (const vertIndex of polyline.vertIndices) {
                    vertIndices.push(vertIndex);
                }
            }
        }
        const vertexIndices = VertexLUT_1.VertexLUT.convertIndicesToTriplets(vertIndices);
        const indices = Handle_1.BufferHandle.createArrayBuffer(vertexIndices);
        if (undefined !== indices) {
            const lutParams = new VertexLUT_1.VertexLUT.Params(new VertexLUT_1.VertexLUT.SimpleBuilder(args), args.colors);
            const info = new PointStringInfo(args);
            const lut = lutParams.toData(info.vertexParams);
            if (undefined !== lut) {
                return new PointStringGeometry(indices, vertIndices.length, lut, info);
            }
        }
        return undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        bentleyjs_core_1.dispose(this.indices);
    }
}
exports.PointStringGeometry = PointStringGeometry;
class PointStringPrimitive extends Primitive_1.Primitive {
    static create(args) {
        const geom = PointStringGeometry.create(args);
        return undefined !== geom ? new PointStringPrimitive(geom) : undefined;
    }
    constructor(cachedGeom) { super(cachedGeom); }
    get renderOrder() { return 3 /* Linear */; }
}
exports.PointStringPrimitive = PointStringPrimitive;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(17);
const common_1 = __webpack_require__(2);
const CachedGeometry_1 = __webpack_require__(29);
const Viewport_1 = __webpack_require__(44);
const FrameBuffer_1 = __webpack_require__(83);
const Disposable_1 = __webpack_require__(161);
const Assert_1 = __webpack_require__(93);
const Texture_1 = __webpack_require__(19);
const GL_1 = __webpack_require__(8);
const System_2 = __webpack_require__(7);
const RenderState_1 = __webpack_require__(82);
const DrawCommand_1 = __webpack_require__(56);
/** A 3D clip volume defined by up to 6 planes. */
class ClipVolumePlanes extends System_1.RenderClipVolume {
    static create(clipVec) {
        if (1 !== clipVec.clips.length) {
            return undefined;
        }
        const clipPrim = clipVec.clips[0];
        const clipPlanesRef = clipPrim.fetchClipPlanesRef();
        const convexClipPlaneSets = clipPlanesRef.convexSets;
        if (undefined === convexClipPlaneSets || 1 !== convexClipPlaneSets.length) {
            return undefined;
        }
        const planes = convexClipPlaneSets[0].planes;
        const clipCount = planes.length;
        if (0 === clipCount || clipCount > 6) {
            return undefined;
        }
        const result = [];
        for (const plane of planes) {
            result.push(plane.clone());
        }
        return new ClipVolumePlanes(result);
    }
    get length() { return undefined !== this._planes ? this._planes.length : 0; }
    get isEmpty() { return 0 === this.length; }
    dispose() { }
    push(exec) { this.apply(exec.target.clips, exec.target.viewMatrix); }
    pop(target) { target.clips.clear(); }
    apply(clips, viewMatrix) { clips.setFrom(this._planes, viewMatrix); }
    constructor(planes) { super(); this._planes = planes; }
}
exports.ClipVolumePlanes = ClipVolumePlanes;
/** A 2D clip volume defined by any number of planes. */
class ClipMaskVolume {
    constructor(geometry) {
        this.geometry = geometry;
        this.frustum = new common_1.Frustum();
        this.rect = new Viewport_1.ViewRect(0, 0, 0, 0);
    }
    /** Create a new ClipVolume from a clip vector. */
    static create(clipVec) {
        const range = clipVec.boundingRange;
        if (range.isNull())
            return undefined;
        const pts = [
            geometry_core_1.Point3d.create(range.low.x, range.low.y, 0),
            geometry_core_1.Point3d.create(range.high.x, range.low.y, 0),
            geometry_core_1.Point3d.create(range.high.x, range.high.y, 0),
            geometry_core_1.Point3d.create(range.low.x, range.high.y, 0),
        ];
        const clippedPolygonInsides = geometry_core_1.ClipUtilities.clipPolygonToClipVector(pts, clipVec);
        const indices = [];
        const vertices = common_1.QPoint3dList.createFrom([], common_1.QParams3d.fromRange(range));
        let indexOffset = 0;
        for (const clippedPolygon of clippedPolygonInsides) {
            const triangulatedPolygonGraph = geometry_core_1.Triangulator.earcutFromPoints(clippedPolygon);
            geometry_core_1.Triangulator.cleanupTriangulation(triangulatedPolygonGraph);
            const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create();
            polyfaceBuilder.addGraph(triangulatedPolygonGraph, false);
            const polyface = polyfaceBuilder.claimPolyface();
            const nPoints = polyface.pointCount;
            const pPoints = polyface.data.point;
            const pIndices = polyface.data.pointIndex;
            Assert_1.assert(nPoints !== 0);
            for (let i = 0; i < nPoints; i++)
                vertices.add(pPoints.getPoint3dAt(i));
            const visitor = geometry_core_1.IndexedPolyfaceVisitor.create(polyface, 0);
            while (visitor.moveToNextFacet())
                for (let i = 0; i < 3; i++)
                    pIndices.push(indexOffset + visitor.clientPointIndex(i));
            Assert_1.assert(pIndices.length > 0);
            indexOffset += pIndices.length;
        }
        if (indices.length === 0 || vertices.length === 0)
            return undefined;
        return new ClipMaskVolume(new CachedGeometry_1.ClipMaskGeometry(new Uint32Array(indices), vertices));
    }
    get texture() { return this._texture; }
    get fbo() { return this._fbo; }
    dispose() {
        this._texture = Disposable_1.dispose(this._texture);
        this._fbo = Disposable_1.dispose(this._fbo);
    }
    /** Push this clip mask texture onto the target of a program executor. */
    push(shader) {
        if (this._texture !== undefined)
            shader.target.clipMask = this._texture;
    }
    /** Clear a target's clip mask, provided that this ClipMaskVolume's texture is not undefined. */
    pop(target) {
        if (target.is2d && this._texture !== undefined)
            target.clipMask = undefined;
    }
    /** Update the clip mask using the shader executor's target and return the resulting texture. */
    getTexture(exec) {
        const target = exec.target;
        if (!target.is2d)
            return undefined;
        const frust = target.planFrustum;
        const rect = target.viewRect;
        const frustumChanged = !this.frustum.equals(frust);
        const textureChanged = this._texture === undefined || this.rect.width !== rect.width || this.rect.height !== rect.height;
        if (textureChanged) {
            this.dispose();
            this._texture = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
            if (this._texture !== undefined)
                this._fbo = FrameBuffer_1.FrameBuffer.create([this._texture]);
        }
        this.rect.init(rect.left, rect.top, rect.right, rect.bottom);
        if (textureChanged || frustumChanged) {
            this.frustum.setFrom(frust);
            this.render(exec);
        }
        return this._texture;
    }
    render(exec) {
        if (this._fbo === undefined)
            return;
        const state = new RenderState_1.RenderState();
        state.flags.depthMask = false;
        state.flags.blend = false;
        state.flags.depthTest = false;
        // Render clip geometry as a mask
        System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
            const prevState = System_2.System.instance.currentRenderState;
            const target = exec.target;
            System_2.System.instance.applyRenderState(state);
            const context = System_2.System.instance.context;
            context.clearColor(0, 0, 0, 0);
            context.clear(context.COLOR_BUFFER_BIT);
            const params = new DrawCommand_1.DrawParams(target, this.geometry, target.currentTransform, 3 /* OpaqueGeneral */);
            exec.drawInterrupt(params);
            // Restore previous render state
            System_2.System.instance.applyRenderState(prevState);
        });
    }
}
exports.ClipMaskVolume = ClipMaskVolume;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module SelectionSet */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const PrimitiveTool_1 = __webpack_require__(98);
const IModelApp_1 = __webpack_require__(5);
const Tool_1 = __webpack_require__(15);
const ElementLocateManager_1 = __webpack_require__(78);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const Viewport_1 = __webpack_require__(44);
/** Tool for picking a set of elements of interest, selected by the user. */
class SelectionTool extends PrimitiveTool_1.PrimitiveTool {
    constructor() {
        super(...arguments);
        this.isSelectByPoints = false;
        this.points = [];
    }
    requireWriteableTarget() { return false; }
    autoLockTarget() { } // NOTE: For selecting elements we only care about iModel, so don't lock target model automatically.
    // protected getManipulator(): EditManipulator.Provider | undefined { return new TestEditManipulatorProvider(this.iModel); } // NEEDSWORK: Testing...
    getManipulator() { return undefined; } // Override to create sub-class of EditManipulator.Provider...
    wantSelectionClearOnMiss(_ev) { return 0 /* Replace */ === this.getSelectionMode(); }
    getSelectionMethod() { return 0 /* Pick */; } // NEEDSWORK: Setting...
    getSelectionMode() { return 0 /* Replace */; } // NEEDSWORK: Settings...
    wantToolSettings() { return true; } // NEEDSWORK: Settings...
    initSelectTool() {
        this.isSelectByPoints = false;
        this.points.length = 0;
        const enableLocate = 0 /* Pick */ === this.getSelectionMethod();
        IModelApp_1.IModelApp.toolAdmin.setCursor(enableLocate ? Tool_1.BeCursor.Arrow : Tool_1.BeCursor.CrossHair);
        IModelApp_1.IModelApp.toolAdmin.setLocateCircleOn(true);
        IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr = 65535 /* All */;
        IModelApp_1.IModelApp.locateManager.initToolLocate();
        IModelApp_1.IModelApp.locateManager.options.allowDecorations = (undefined !== this.manipulator && this.manipulator.allowTransientControls());
        IModelApp_1.IModelApp.accuSnap.enableLocate(enableLocate);
        IModelApp_1.IModelApp.accuSnap.enableSnap(false);
        IModelApp_1.IModelApp.notifications.outputPromptByKey("CoreTools:tools.ElementSet.Prompt.IdentifyElement");
    }
    processSelection(elementId, process) {
        // NEEDSWORK...SelectionScope
        switch (process) {
            case 0 /* AddElementToSelection */:
                return this.iModel.selectionSet.add(elementId);
            case 1 /* RemoveElementFromSelection */:
                return this.iModel.selectionSet.remove(elementId);
            case 2 /* InvertElementInSelection */:// (if element is in selection remove it else add it.)
                return this.iModel.selectionSet.invert(elementId);
            case 3 /* ReplaceSelectionWithElement */:
                this.iModel.selectionSet.replace(elementId);
                return true;
            default:
                return false;
        }
    }
    useOverlapSelection(ev) {
        let overlapMode = false;
        const vp = ev.viewport;
        const pt1 = vp.worldToView(this.points[0]);
        const pt2 = vp.worldToView(ev.point);
        overlapMode = (pt1.x > pt2.x);
        return (ev.isShiftKey ? !overlapMode : overlapMode); // Shift inverts inside/overlap selection...
    }
    selectByPointsDecorate(context) {
        if (!this.isSelectByPoints)
            return;
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        const graphic = context.createViewOverlay();
        const vp = context.viewport;
        const origin = vp.worldToView(this.points[0]);
        const corner = vp.worldToView(ev.point);
        origin.z = corner.z = 0.0;
        const viewPts = [];
        if (1 /* Line */ === this.getSelectionMethod() || (0 /* Pick */ === this.getSelectionMethod() && 1 /* Reset */ === ev.button)) {
            viewPts[0] = origin;
            viewPts[1] = corner;
            graphic.setSymbology(vp.getContrastToBackgroundColor(), imodeljs_common_1.ColorDef.black, 1, 4177066232 /* Code2 */);
            graphic.addLineString(viewPts);
        }
        else {
            viewPts[0] = viewPts[4] = origin;
            viewPts[1] = new geometry_core_1.Point3d(corner.x, origin.y, corner.z);
            viewPts[2] = corner;
            viewPts[3] = new geometry_core_1.Point3d(origin.x, corner.y, origin.z);
            graphic.setSymbology(vp.getContrastToBackgroundColor(), imodeljs_common_1.ColorDef.black, 1, this.useOverlapSelection(ev) ? 4177066232 /* Code2 */ : 0 /* Solid */);
            graphic.addLineString(viewPts);
        }
        context.addViewOverlay(graphic.finish());
    }
    selectByPointsProcess(origin, corner, ev, method, overlap) {
        const vp = ev.viewport;
        if (!vp)
            return;
        const pts = [];
        pts[0] = new geometry_core_1.Point2d(Math.floor(origin.x + 0.5), Math.floor(origin.y + 0.5));
        pts[1] = new geometry_core_1.Point2d(Math.floor(corner.x + 0.5), Math.floor(corner.y + 0.5));
        const range = geometry_core_1.Range2d.createArray(pts);
        const rect = new Viewport_1.ViewRect();
        rect.initFromRange(range);
        const pixels = vp.readPixels(rect, 1 /* ElementId */);
        if (undefined === pixels)
            return;
        let contents = new Set();
        const testPoint = geometry_core_1.Point2d.createZero();
        if (2 /* Box */ === method) {
            const outline = overlap ? undefined : new Set();
            const offset = range.clone();
            offset.expandInPlace(-2); // NEEDWORK: Why doesn't -1 work?!?
            for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {
                for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {
                    const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                    if (undefined === pixel || undefined === pixel.elementId || !pixel.elementId.isValid())
                        continue; // no geometry at this location...
                    if (undefined !== outline && !offset.containsPoint(testPoint))
                        outline.add(pixel.elementId.toString());
                    else
                        contents.add(pixel.elementId.toString());
                }
            }
            if (undefined !== outline && 0 !== outline.size) {
                const inside = new Set();
                bentleyjs_core_1.Id64.toIdSet(contents).forEach((id) => { if (!outline.has(id))
                    inside.add(id); });
                contents = inside;
            }
        }
        else {
            const closePoint = geometry_core_1.Point2d.createZero();
            for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {
                for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {
                    const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                    if (undefined === pixel || undefined === pixel.elementId || !pixel.elementId.isValid())
                        continue; // no geometry at this location...
                    const fraction = testPoint.fractionOfProjectionToLine(pts[0], pts[1], 0.0);
                    pts[0].interpolate(fraction, pts[1], closePoint);
                    if (closePoint.distance(testPoint) < 1.5)
                        contents.add(pixel.elementId.toString());
                }
            }
        }
        if (0 === contents.size) {
            if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev))
                this.iModel.selectionSet.emptyAll();
            return;
        }
        switch (this.getSelectionMode()) {
            case 0 /* Replace */:
                if (!ev.isControlKey)
                    this.processSelection(contents, 3 /* ReplaceSelectionWithElement */);
                else
                    this.processSelection(contents, 2 /* InvertElementInSelection */);
                break;
            case 1 /* Add */:
                this.processSelection(contents, 0 /* AddElementToSelection */);
                break;
            case 2 /* Remove */:
                this.processSelection(contents, 1 /* RemoveElementFromSelection */);
                break;
        }
    }
    selectByPointsStart(ev) {
        if (0 /* Data */ !== ev.button && 1 /* Reset */ !== ev.button)
            return false;
        this.points.length = 0;
        this.points.push(ev.point.clone());
        this.isSelectByPoints = true;
        IModelApp_1.IModelApp.accuSnap.enableLocate(false);
        IModelApp_1.IModelApp.toolAdmin.setLocateCircleOn(false);
        return true;
    }
    selectByPointsEnd(ev) {
        if (!this.isSelectByPoints)
            return false;
        const vp = ev.viewport;
        if (!vp) {
            this.initSelectTool();
            return false;
        }
        const origin = vp.worldToView(this.points[0]);
        const corner = vp.worldToView(ev.point);
        if (1 /* Line */ === this.getSelectionMethod() || (0 /* Pick */ === this.getSelectionMethod() && 1 /* Reset */ === ev.button))
            this.selectByPointsProcess(origin, corner, ev, 1 /* Line */, true);
        else
            this.selectByPointsProcess(origin, corner, ev, 2 /* Box */, this.useOverlapSelection(ev));
        this.initSelectTool();
        vp.invalidateDecorations();
        return true;
    }
    onModelStartDrag(ev) {
        if (this.manipulator && this.manipulator.onButtonEvent(ev))
            return false;
        this.selectByPointsStart(ev);
        return false;
    }
    onModelEndDrag(ev) {
        // NOTE: If manipulator installed an input collector, it would get the end drag event directly...
        this.selectByPointsEnd(ev);
        return false;
    }
    onDataButtonUp(ev) {
        if (!ev.viewport)
            return false;
        if (this.manipulator && this.manipulator.onButtonEvent(ev))
            return false;
        if (0 /* Pick */ !== this.getSelectionMethod()) {
            if (!this.selectByPointsEnd(ev)) {
                if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev))
                    this.iModel.selectionSet.emptyAll();
                this.selectByPointsStart(ev);
            }
            return false;
        }
        // NOTE: Non-element hits are only handled by a manipulator that specificially requested them, can be ignored here...
        const hit = IModelApp_1.IModelApp.locateManager.doLocate(new ElementLocateManager_1.LocateResponse(), true, ev.point, ev.viewport);
        if (hit && hit.isElementHit()) {
            switch (this.getSelectionMode()) {
                case 0 /* Replace */:
                    this.processSelection(hit.sourceId, ev.isControlKey ? 2 /* InvertElementInSelection */ : 3 /* ReplaceSelectionWithElement */);
                    break;
                case 1 /* Add */:
                    this.processSelection(hit.sourceId, 0 /* AddElementToSelection */);
                    break;
                case 2 /* Remove */:
                    this.processSelection(hit.sourceId, 1 /* RemoveElementFromSelection */);
                    break;
            }
            return false;
        }
        if (!ev.isControlKey && 0 !== this.iModel.selectionSet.size && this.wantSelectionClearOnMiss(ev))
            this.iModel.selectionSet.emptyAll();
        return false;
    }
    onResetButtonUp(ev) {
        if (this.isSelectByPoints) {
            this.initSelectTool();
            return false;
        }
        if (this.manipulator && this.manipulator.onButtonEvent(ev))
            return false;
        // Check for overlapping hits...
        const lastHit = 2 /* Remove */ === this.getSelectionMode() ? undefined : IModelApp_1.IModelApp.locateManager.currHit;
        if (lastHit && this.iModel.selectionSet.has(lastHit.sourceId)) {
            const autoHit = IModelApp_1.IModelApp.accuSnap.currHit;
            // Play nice w/auto-locate, only remove previous hit if not currently auto-locating or over previous hit...
            if (undefined === autoHit || autoHit.isSameHit(lastHit)) {
                const response = new ElementLocateManager_1.LocateResponse();
                const nextHit = IModelApp_1.IModelApp.locateManager.doLocate(response, false, ev.point, ev.viewport);
                // remove element(s) previously selected if in replace mode, or if we have a next element in add mode...
                if (0 /* Replace */ === this.getSelectionMode() || undefined !== nextHit)
                    this.processSelection(lastHit.sourceId, 1 /* RemoveElementFromSelection */);
                // add element(s) located via reset button
                if (undefined !== nextHit)
                    this.processSelection(nextHit.sourceId, 0 /* AddElementToSelection */);
                return false;
            }
        }
        IModelApp_1.IModelApp.accuSnap.resetButton();
        return false;
    }
    onSingleTap(ev) {
        return (undefined !== this.manipulator && this.manipulator.onGestureEvent(ev)); // Let idle tool send data button down/up events if not handled by manipulator...
    }
    onSingleFingerMove(ev) {
        if (this.isSelectByPoints) {
            IModelApp_1.IModelApp.toolAdmin.convertGestureMoveToButtonDownAndMotion(ev);
            return true;
        }
        if (0 !== ev.gestureInfo.previousNumberTouches)
            return false; // Decide on first touch notification if we'll start handling this gesture instead of passing it on to the idle tool...
        return (undefined !== this.manipulator && this.manipulator.onGestureEvent(ev)); // Let idle tool handle event if not handled by manipulator...
    }
    onEndGesture(ev) {
        if (2 /* SingleFingerMove */ !== ev.gestureInfo.gestureId)
            return false;
        if (this.isSelectByPoints)
            return this.selectByPointsEnd(ev);
        return (undefined !== this.manipulator && this.manipulator.onGestureEvent(ev)); // Let idle tool handle event if not handled by manipulator...
    }
    decorate(context) {
        this.selectByPointsDecorate(context);
    }
    onModifierKeyTransition(_wentDown, key) {
        return key === 4 /* Shift */ && this.isSelectByPoints;
    }
    onPostLocate(hit, _out) {
        const mode = this.getSelectionMode();
        if (0 /* Replace */ === mode)
            return true;
        const elementId = (hit.isElementHit() ? hit.sourceId : undefined);
        if (!elementId)
            return true; // Don't reject transients...
        const isSelected = this.iModel.selectionSet.has(elementId);
        return (1 /* Add */ === mode ? !isSelected : isSelected);
    }
    onRestartTool() {
        this.exitTool();
    }
    onCleanup() {
        super.onCleanup();
        if (this.manipulator) {
            this.manipulator.clear();
            this.manipulator = undefined;
        }
    }
    onPostInstall() {
        super.onPostInstall();
        if (!this.targetView)
            return;
        this.manipulator = this.getManipulator();
        if (this.manipulator)
            this.manipulator.init(); // create controls for an existing selection set...
        this.initSelectTool();
    }
    static startTool() {
        const tool = new SelectionTool();
        return tool.run();
    }
}
SelectionTool.hidden = false;
SelectionTool.toolId = "Select";
exports.SelectionTool = SelectionTool;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(15);
const ViewTool_1 = __webpack_require__(77);
const HitDetail_1 = __webpack_require__(63);
const IModelApp_1 = __webpack_require__(5);
/**
 * The default "idle" tool. If no tool is active, or the active tool does not respond to a given
 * event, input events are forwarded to the idle tool. The default idle tool converts middle mouse button events
 * and touch gestures into view navigation operations like pan, zoom, rotate, and fit.
 */
/* Controls are as follows:
*  Mouse/keyboard:
*      mmb: pan
*      shift-mmb: rotate
*      wheel: zoom in/out
*      double-mmb: fit view
*  Touch:
*      single-finger drag: rotate
*      two-finger drag: pan
*      pinch: zoom in/out
*      double-tap: fit view
*  Touch inputs can be combined e.g. drag two fingers while moving them closer together => pan + zoom in
*/
class IdleTool extends Tool_1.InteractiveTool {
    onMiddleButtonDown(ev) {
        const vp = ev.viewport;
        if (!vp)
            return true;
        const cur = IModelApp_1.IModelApp.toolAdmin.currentInputState;
        if (cur.isDragging(0 /* Data */) || cur.isDragging(1 /* Reset */))
            return false;
        let viewTool;
        if (ev.isDoubleClick) {
            viewTool = new ViewTool_1.FitViewTool(vp, true);
        }
        else if (ev.isControlKey) {
            viewTool = IModelApp_1.IModelApp.tools.create( true ? "Look" : "Scroll", vp);
        }
        else if (ev.isShiftKey) {
            viewTool = IModelApp_1.IModelApp.tools.create("View.Rotate", vp, true, false, true);
        }
        else if (false) {
            /* ###TODO: Other view tools if needed... */
        }
        else {
            const currTool = IModelApp_1.IModelApp.toolAdmin.activeViewTool;
            if (currTool && currTool instanceof ViewTool_1.ViewManip) {
                if (!currTool.isDragging && currTool.viewHandles.hasHandle(4 /* ViewPan */))
                    currTool.forcedHandle = 4 /* ViewPan */;
                return true;
            }
            viewTool = IModelApp_1.IModelApp.tools.create("View.Pan", vp, true, false, true);
        }
        return !!viewTool && viewTool.run();
    }
    onMiddleButtonUp(ev) {
        if (ev.isDoubleClick || ev.isControlKey || ev.isShiftKey)
            return false;
        const currTool = IModelApp_1.IModelApp.toolAdmin.activeViewTool;
        if (currTool && currTool instanceof ViewTool_1.ViewManip) {
            if (currTool.viewHandles.hasHandle(4 /* ViewPan */))
                currTool.forcedHandle = 0 /* None */; // Didn't get start drag, don't leave ViewPan active...
            if (currTool.viewHandles.hasHandle(2 /* TargetCenter */))
                currTool.invalidateTargetCenter();
        }
        const tp = IModelApp_1.IModelApp.tentativePoint;
        tp.process(ev);
        if (tp.isSnapped) {
            IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
        }
        else {
            if (IModelApp_1.IModelApp.accuDraw.isActive) {
                const point = tp.point;
                const vp = ev.viewport;
                if (vp.isSnapAdjustmentRequired()) {
                    IModelApp_1.IModelApp.toolAdmin.adjustPointToACS(point, vp, false);
                    const hit = new HitDetail_1.HitDetail(point, vp, 4 /* TentativeSnap */, point, "", 6 /* Unknown */, 0, 0);
                    const snap = new HitDetail_1.SnapDetail(hit);
                    tp.setCurrSnap(snap);
                    IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
                    tp.point.setFrom(tp.point);
                    tp.setCurrSnap(undefined);
                }
                else {
                    IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, false);
                    const savePoint = point.clone();
                    IModelApp_1.IModelApp.toolAdmin.adjustPointToGrid(point, vp);
                    if (!point.isExactEqual(savePoint))
                        IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, false);
                    tp.point.setFrom(point);
                }
            }
            else {
                IModelApp_1.IModelApp.toolAdmin.adjustPoint(tp.point, ev.viewport);
            }
            IModelApp_1.IModelApp.accuDraw.onTentative();
        }
        // NOTE: Need to synch tool dynamics because of updateDynamics call in _ExitViewTool before point was adjusted.
        IModelApp_1.IModelApp.toolAdmin.updateDynamics();
        return true;
    }
    onMouseWheel(ev) { return IModelApp_1.IModelApp.toolAdmin.processWheelEvent(ev, true); }
    onMultiFingerMove(ev) { const tool = new ViewTool_1.RotatePanZoomGestureTool(ev, true); tool.run(); return true; }
    onSingleFingerMove(ev) { return this.onMultiFingerMove(ev); }
    onSingleTap(ev) { IModelApp_1.IModelApp.toolAdmin.convertGestureSingleTapToButtonDownAndUp(ev); return true; }
    onDoubleTap(ev) { if (ev.viewport) {
        const tool = new ViewTool_1.FitViewTool(ev.viewport, true);
        tool.run();
    } return true; }
    onTwoFingerTap(ev) { IModelApp_1.IModelApp.toolAdmin.convertGestureToResetButtonDownAndUp(ev); return true; }
    exitTool() { }
    run() { return true; }
}
IdleTool.toolId = "Idle";
IdleTool.hidden = true;
exports.IdleTool = IdleTool;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(225));
__export(__webpack_require__(228));
__export(__webpack_require__(220));
__export(__webpack_require__(221));
__export(__webpack_require__(223));
__export(__webpack_require__(222));
__export(__webpack_require__(43));
__export(__webpack_require__(208));
__export(__webpack_require__(60));
__export(__webpack_require__(61));
__export(__webpack_require__(226));
__export(__webpack_require__(227));
__export(__webpack_require__(224));
__export(__webpack_require__(218));
__export(__webpack_require__(29));
__export(__webpack_require__(235));
__export(__webpack_require__(101));
__export(__webpack_require__(56));
__export(__webpack_require__(55));
__export(__webpack_require__(100));
__export(__webpack_require__(87));
__export(__webpack_require__(35));
__export(__webpack_require__(83));
__export(__webpack_require__(8));
__export(__webpack_require__(64));
__export(__webpack_require__(36));
__export(__webpack_require__(81));
__export(__webpack_require__(102));
__export(__webpack_require__(234));
__export(__webpack_require__(128));
__export(__webpack_require__(65));
__export(__webpack_require__(124));
__export(__webpack_require__(24));
__export(__webpack_require__(82));
__export(__webpack_require__(30));
__export(__webpack_require__(125));
__export(__webpack_require__(7));
__export(__webpack_require__(217));
__export(__webpack_require__(229));
__export(__webpack_require__(126));
__export(__webpack_require__(387));
__export(__webpack_require__(19));
__export(__webpack_require__(88));
__export(__webpack_require__(73));
__export(__webpack_require__(122));
__export(__webpack_require__(17));
__export(__webpack_require__(213));


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** The base class for an environment-specific Project/user/IModelServer management system. */
class ProjectAbstraction {
}
exports.ProjectAbstraction = ProjectAbstraction;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const frontend_1 = __webpack_require__(104);
const rendering_1 = __webpack_require__(238);
const lib_1 = __webpack_require__(18);
const common_1 = __webpack_require__(2);
const geometry_core_1 = __webpack_require__(1);
const Utils_1 = __webpack_require__(131);
const SimpleViewState_1 = __webpack_require__(388);
const ConnectProject_1 = __webpack_require__(389);
const NonConnectProject_1 = __webpack_require__(390);
// Only want the following imports if we are using electron and not a browser -----
// tslint:disable-next-line:variable-name
let remote;
if (common_1.ElectronRpcConfiguration.isElectron) {
    // tslint:disable-next-line:no-var-requires
    remote = __webpack_require__(391).remote;
}
const renderModeOptions = {
    flags: new Map(),
    mode: 6 /* SmoothShade */,
};
let activeViewState = new SimpleViewState_1.SimpleViewState();
const viewMap = new Map();
let theViewport;
let curModelProps = [];
let curModelPropIndices = [];
let curNumModels = 0;
const curCategories = new Set();
const configuration = {};
let curFPSIntervalId;
let overrideColor;
function addFeatureOverrides(ovrs, viewport) {
    if (undefined === overrideColor)
        return;
    const color = common_1.RgbColor.fromColorDef(overrideColor);
    const app = rendering_1.FeatureSymbology.Appearance.fromJSON({ rgb: color, weight: 4, linePixels: 2155905152 /* Code1 */ });
    for (const elemId of viewport.iModel.selectionSet.elements)
        ovrs.overrideElement(elemId, app);
}
// Entry point - run the main function
setTimeout(() => main(), 1000);
// Retrieves the configuration for starting SVT from configuration.json file located in the built public folder
function retrieveConfiguration() {
    return new Promise((resolve, _reject) => {
        const request = new XMLHttpRequest();
        request.open("GET", "configuration.json", false);
        request.setRequestHeader("Cache-Control", "no-cache");
        request.onreadystatechange = ((_event) => {
            if (request.readyState === XMLHttpRequest.DONE) {
                if (request.status === 200) {
                    const newConfigurationInfo = JSON.parse(request.responseText);
                    Object.assign(configuration, newConfigurationInfo);
                    resolve();
                }
                // Everything is good, the response was received.
            }
            else {
                // Not ready yet.
            }
        });
        request.send();
    });
}
// opens the configured iModel from disk
async function openStandaloneIModel(state, filename) {
    configuration.standalone = true;
    state.iModelConnection = await frontend_1.IModelConnection.openStandalone(filename);
    configuration.iModelName = state.iModelConnection.name;
}
// selects the configured view.
async function buildViewList(state, configurations) {
    const config = undefined !== configurations ? configurations : {};
    const viewList = document.getElementById("viewList");
    const viewQueryParams = { wantPrivate: false };
    const viewSpecs = await state.iModelConnection.views.getViewList(viewQueryParams);
    for (const viewSpec of viewSpecs) {
        const option = document.createElement("option");
        option.text = viewSpec.name;
        viewList.add(option);
        viewMap.set(viewSpec.name, viewSpec);
        if (undefined === config.viewName)
            config.viewName = viewSpec.name;
        if (viewSpec.name === config.viewName) {
            viewList.value = viewSpec.name;
            const viewState = await state.iModelConnection.views.load(viewSpec.id);
            viewMap.set(viewSpec.name, viewState);
            state.viewState = viewState;
        }
    }
}
// open up the model toggle menu
function startToggleModel(_event) {
    const menu = document.getElementById("toggleModelMenu");
    menu.style.display = menu.style.display === "none" || menu.style.display === "" ? "block" : "none";
}
// open up the category selection model
function startCategorySelection(_event) {
    const menu = document.getElementById("categorySelectionMenu");
    menu.style.display = menu.style.display === "none" || menu.style.display === "" ? "block" : "none";
}
// build list of models; enables those defined in model selector
async function buildModelMenu(state) {
    const modelMenu = document.getElementById("toggleModelMenu");
    const modelButton = document.getElementById("startToggleModel");
    const spatialView = undefined !== state.viewState && state.viewState instanceof frontend_1.SpatialViewState ? state.viewState : undefined;
    if (undefined === spatialView) {
        modelMenu.style.display = modelButton.style.display = "none";
        return;
    }
    modelButton.style.display = "inline";
    const modelQueryParams = { from: frontend_1.SpatialModelState.getClassFullName(), wantPrivate: false };
    curModelProps = await state.iModelConnection.models.queryProps(modelQueryParams);
    curModelPropIndices = [];
    modelMenu.innerHTML = "";
    // ###TODO: Load models on demand when they are enabled in the dialog - not all up front like this...super-inefficient...
    let i = 0;
    for (const modelProp of curModelProps) {
        const model = spatialView.iModel.models.getLoaded(modelProp.id.toString());
        if (undefined === model)
            await spatialView.iModel.models.load(modelProp.id.toString());
        modelMenu.innerHTML += '<input id="cbxModel' + i + '" type="checkbox"> ' + modelProp.name + "\n<br>\n";
        curModelPropIndices.push(i);
        i++;
    }
    curNumModels = i;
    for (let c = 0; c < curNumModels; c++) {
        const cbxName = "cbxModel" + c;
        const enabled = spatialView.modelSelector.has(curModelProps[c].id.toString());
        updateCheckboxToggleState(cbxName, enabled);
        addModelToggleHandler(cbxName);
    }
    applyModelToggleChange("cbxModel0"); // force view to update based on all being enabled
}
// build list of categories; enable those defined in category selector
async function buildCategoryMenu(state) {
    curCategories.clear();
    let html = '<input id="cbxCatToggleAll" type="checkbox"> Toggle All\n<br>\n';
    const view = state.viewState;
    const ecsql = "SELECT ECInstanceId as id, CodeValue as code, UserLabel as label FROM " + (view.is3d() ? "BisCore.SpatialCategory" : "BisCore.DrawingCategory");
    const rows = await view.iModel.executeQuery(ecsql);
    for (const row of rows) {
        let label = row.label;
        if (undefined === label)
            label = row.code;
        const id = row.id;
        curCategories.add(id);
        html += '<input id="cbxCat' + id + '" type="checkbox"> ' + label + "\n<br>\n";
    }
    const categoryMenu = document.getElementById("categorySelectionMenu");
    categoryMenu.innerHTML = html;
    updateCheckboxToggleState("cbxCatToggleAll", curCategories.size === view.categorySelector.categories.size);
    addCategoryToggleAllHandler();
    for (const cat of curCategories) {
        const cbxName = "cbxCat" + cat;
        updateCheckboxToggleState(cbxName, view.categorySelector.has(cat));
        addCategoryToggleHandler(cbxName);
    }
}
// set checkbox state to checked or unchecked
function updateCheckboxToggleState(id, enabled) {
    document.getElementById(id).checked = enabled;
}
// query checkbox state (checked or unchecked)
function getCheckboxToggleState(id) {
    return document.getElementById(id).checked;
}
// apply a model checkbox state being changed (actually change list of viewed models)
function applyModelToggleChange(_cbxModel) {
    if (!(theViewport.view instanceof frontend_1.SpatialViewState))
        return;
    const view = theViewport.view;
    view.clearViewedModels();
    for (let c = 0; c < curNumModels; c++) {
        const cbxName = "cbxModel" + c;
        const isChecked = getCheckboxToggleState(cbxName);
        if (isChecked)
            view.addViewedModel(curModelProps[curModelPropIndices[c]].id);
    }
    theViewport.sync.invalidateScene();
    const menu = document.getElementById("toggleModelMenu");
    menu.style.display = "none"; // menu.style.display === "none" || menu.style.display === "" ? "none" : "block";
}
function toggleCategoryState(invis, catId, view) {
    view.changeCategoryDisplay(catId, !invis);
}
// apply a category checkbox state being changed
function applyCategoryToggleChange(_cbxCategory) {
    const view = theViewport.view;
    let allToggledOn = true;
    for (const cat of curCategories) {
        const cbxName = "cbxCat" + cat;
        const isChecked = getCheckboxToggleState(cbxName);
        const invis = isChecked ? false : true;
        toggleCategoryState(invis, cat, view);
        if (invis)
            allToggledOn = false;
    }
    updateCheckboxToggleState("cbxCatToggleAll", allToggledOn);
    const menu = document.getElementById("categorySelectionMenu");
    menu.style.display = "none"; // menu.style.display === "none" || menu.style.display === "" ? "none" : "block";
}
// toggle all checkboxes being toggled
function applyCategoryToggleAllChange() {
    const view = theViewport.view;
    const isChecked = getCheckboxToggleState("cbxCatToggleAll");
    for (const cat of curCategories) {
        const cbxName = "cbxCat" + cat;
        updateCheckboxToggleState(cbxName, isChecked);
        const invis = isChecked ? false : true;
        toggleCategoryState(invis, cat, view);
    }
    const menu = document.getElementById("categorySelectionMenu");
    menu.style.display = "none"; // menu.style.display === "none" || menu.style.display === "" ? "none" : "block";
}
// add a click handler to model checkbox
function addModelToggleHandler(id) {
    document.getElementById(id).addEventListener("click", () => applyModelToggleChange(id));
}
// add a click handler to category checkbox
function addCategoryToggleHandler(id) {
    document.getElementById(id).addEventListener("click", () => applyCategoryToggleChange(id));
}
// add a click handler to the category 'toggle all' checkbox
function addCategoryToggleAllHandler() {
    document.getElementById("cbxCatToggleAll").addEventListener("click", () => applyCategoryToggleAllChange());
}
function toggleStandardViewMenu(_event) {
    const menu = document.getElementById("standardRotationMenu");
    menu.style.display = menu.style.display === "none" || menu.style.display === "" ? "block" : "none";
}
function toggleRenderModeMenu(_event) {
    const menu = document.getElementById("changeRenderModeMenu");
    menu.style.display = menu.style.display === "none" || menu.style.display === "" ? "block" : "none";
}
function toggleSnapModeMenu(_event) {
    const menu = document.getElementById("changeSnapModeMenu");
    menu.style.display = menu.style.display === "none" || menu.style.display === "" ? "block" : "none";
}
function applyStandardViewRotation(rotationId, label) {
    if (undefined === theViewport)
        return;
    const startFrustum = theViewport.getFrustum();
    const newFrustum = startFrustum.clone();
    const rotatePoint = theViewport.determineDefaultRotatePoint();
    const rMatrix = frontend_1.AccuDraw.getStandardRotation(rotationId, theViewport, theViewport.isContextRotationRequired());
    const viewTransform = geometry_core_1.Transform.createFixedPointAndMatrix(rotatePoint, theViewport.rotMatrix);
    newFrustum.multiply(viewTransform);
    let rotateTransform = geometry_core_1.Transform.createFixedPointAndMatrix(rotatePoint, rMatrix);
    rotateTransform = rotateTransform.inverse();
    if (!rotateTransform)
        return;
    newFrustum.multiply(rotateTransform);
    theViewport.animateFrustumChange(startFrustum, newFrustum);
    theViewport.synchWithView(true);
    Utils_1.showStatus(label, "view");
}
function applyRenderModeChange(mode) {
    const menuDialog = document.getElementById("changeRenderModeMenu");
    const newValue = document.getElementById(mode).checked;
    renderModeOptions.flags.set(mode, newValue);
    frontend_1.IModelApp.tools.run("View.ChangeRenderMode", theViewport, renderModeOptions.flags, menuDialog, renderModeOptions.mode);
}
function stringToRenderMode(name) {
    switch (name) {
        case "Smooth Shade": return 6 /* SmoothShade */;
        case "Solid Fill": return 4 /* SolidFill */;
        case "Hidden Line": return 3 /* HiddenLine */;
        default: return 0 /* Wireframe */;
    }
}
function renderModeToString(mode) {
    switch (mode) {
        case 6 /* SmoothShade */: return "Smooth Shade";
        case 4 /* SolidFill */: return "Solid Fill";
        case 3 /* HiddenLine */: return "Hidden Line";
        default: return "Wireframe";
    }
}
function changeRenderMode() {
    const select = document.getElementById("renderModeList");
    renderModeOptions.mode = stringToRenderMode(select.value);
    frontend_1.IModelApp.tools.run("View.ChangeRenderMode", theViewport, renderModeOptions.flags, document.getElementById("changeRenderModeMenu"), renderModeOptions.mode);
}
function updateRenderModeOption(id, enabled, options) {
    document.getElementById(id).checked = enabled;
    options.set(id, enabled);
}
// updates the checkboxes and the map for turning off and on rendering options to match what the current view is showing
function updateRenderModeOptionsMap() {
    let skybox = false;
    let groundplane = false;
    if (theViewport.view.is3d()) {
        const view = theViewport.view;
        const env = view.getDisplayStyle3d().getEnvironment();
        skybox = env.sky.display;
        groundplane = env.ground.display;
    }
    const viewflags = theViewport.view.viewFlags;
    const lights = viewflags.showSourceLights() || viewflags.showSolarLight() || viewflags.showCameraLights();
    updateRenderModeOption("skybox", skybox, renderModeOptions.flags);
    updateRenderModeOption("groundplane", groundplane, renderModeOptions.flags);
    updateRenderModeOption("ACSTriad", viewflags.showAcsTriad(), renderModeOptions.flags);
    updateRenderModeOption("fill", viewflags.showFill(), renderModeOptions.flags);
    updateRenderModeOption("grid", viewflags.showGrid(), renderModeOptions.flags);
    updateRenderModeOption("textures", viewflags.showTextures(), renderModeOptions.flags);
    updateRenderModeOption("visibleEdges", viewflags.showVisibleEdges(), renderModeOptions.flags);
    updateRenderModeOption("hiddenEdges", viewflags.showHiddenEdges(), renderModeOptions.flags);
    updateRenderModeOption("materials", viewflags.showMaterials(), renderModeOptions.flags);
    updateRenderModeOption("lights", lights, renderModeOptions.flags);
    updateRenderModeOption("monochrome", viewflags.isMonochrome(), renderModeOptions.flags);
    updateRenderModeOption("constructions", viewflags.showConstructions(), renderModeOptions.flags);
    updateRenderModeOption("weights", viewflags.showWeights(), renderModeOptions.flags);
    updateRenderModeOption("styles", viewflags.showStyles(), renderModeOptions.flags);
    updateRenderModeOption("transparency", viewflags.showTransparency(), renderModeOptions.flags);
    renderModeOptions.mode = viewflags.getRenderMode();
    document.getElementById("renderModeList").value = renderModeToString(viewflags.getRenderMode());
}
// opens the view and connects it to the HTML canvas element.
async function openView(state) {
    // find the canvas.
    const htmlCanvas = document.getElementById("imodelview");
    if (htmlCanvas) {
        theViewport = new frontend_1.Viewport(htmlCanvas, state.viewState);
        await _changeView(state.viewState);
        theViewport.addFeatureOverrides = addFeatureOverrides;
        theViewport.continuousRendering = document.getElementById("continuousRendering").checked;
        frontend_1.IModelApp.viewManager.addViewport(theViewport);
    }
}
async function _changeView(view) {
    await theViewport.changeView(view);
    activeViewState.viewState = view;
    await buildModelMenu(activeViewState);
    await buildCategoryMenu(activeViewState);
    updateRenderModeOptionsMap();
}
class MeasurePointsTool extends frontend_1.PrimitiveTool {
    constructor() {
        super(...arguments);
        this.points = [];
    }
    requireWriteableTarget() { return false; }
    onPostInstall() { super.onPostInstall(); frontend_1.IModelApp.accuSnap.enableSnap(true); }
    onRestartTool() {
        this.exitTool();
    }
}
MeasurePointsTool.toolId = "Measure.Points";
exports.MeasurePointsTool = MeasurePointsTool;
// starts Mesure between points tool
function startMeasurePoints(_event) {
    frontend_1.IModelApp.tools.run("Measure.Points", theViewport);
}
// functions that start viewing commands, associated with icons in wireIconsToFunctions
function startToggleCamera(_event) {
    frontend_1.IModelApp.tools.run("View.ToggleCamera", theViewport);
}
function startFit(_event) {
    frontend_1.IModelApp.tools.run("View.Fit", theViewport, true);
}
// starts Window Area
function startWindowArea(_event) {
    frontend_1.IModelApp.tools.run("View.WindowArea", theViewport);
}
// starts element selection tool
function startSelect(_event) {
    frontend_1.IModelApp.tools.run("Select");
}
// starts walk command
function startWalk(_event) {
    frontend_1.IModelApp.tools.run("View.Walk", theViewport);
}
// start rotate view.
function startRotateView(_event) {
    frontend_1.IModelApp.tools.run("View.Rotate", theViewport);
}
// override symbology for selected elements
function changeOverrideColor() {
    const select = document.getElementById("colorList");
    overrideColor = new common_1.ColorDef(select.value);
    theViewport.view.setFeatureOverridesDirty();
}
// change active view.
async function changeView(event) {
    const spinner = document.getElementById("spinner");
    spinner.style.display = "block";
    const viewName = event.target.selectedOptions["0"].label;
    let view = viewMap.get(viewName);
    if (!(view instanceof frontend_1.ViewState)) {
        view = await activeViewState.iModelConnection.views.load(view.id);
        viewMap.set(viewName, view);
    }
    await _changeView(view.clone());
    spinner.style.display = "none";
}
async function clearViews() {
    if (activeViewState.iModelConnection !== undefined)
        if (configuration.standalone)
            await activeViewState.iModelConnection.closeStandalone();
        else
            await activeViewState.iModelConnection.close(activeViewState.accessToken);
    activeViewState = new SimpleViewState_1.SimpleViewState();
    viewMap.clear();
    document.getElementById("viewList").innerHTML = "";
}
async function resetStandaloneIModel(filename) {
    const spinner = document.getElementById("spinner");
    spinner.style.display = "block";
    frontend_1.IModelApp.viewManager.dropViewport(theViewport);
    await clearViews();
    await openStandaloneIModel(activeViewState, filename);
    await buildViewList(activeViewState);
    await openView(activeViewState);
    spinner.style.display = "none";
}
async function selectIModel() {
    if (common_1.ElectronRpcConfiguration.isElectron) {
        const options = {
            properties: ["openFile"],
            filters: [{ name: "IModels", extensions: ["ibim", "bim"] }],
        };
        remote.dialog.showOpenDialog(options, async (filePaths) => {
            if (undefined !== filePaths)
                await resetStandaloneIModel(filePaths[0]);
        });
    }
    else {
        if (configuration.standalonePath === undefined || !document.createEvent) {
            const filePath = prompt("Enter the full local path of the iModel you wish to open:");
            if (filePath !== null) {
                try {
                    await resetStandaloneIModel(filePath);
                }
                catch (_a) {
                    alert("Error - The file path given is invalid.");
                    const spinner = document.getElementById("spinner");
                    spinner.style.display = "none";
                }
            }
        }
        else {
            const selector = document.getElementById("browserFileSelector");
            const evt = document.createEvent("MouseEvents");
            evt.initEvent("click", true, false);
            selector.dispatchEvent(evt);
        }
    }
}
// undo prev view manipulation
function doUndo(_event) {
    frontend_1.IModelApp.tools.run("View.Undo", theViewport);
}
// redo view manipulation
function doRedo(_event) {
    frontend_1.IModelApp.tools.run("View.Redo", theViewport);
}
// do iModel synchronization
function doSyncIModel(_event) {
    console.log("IModel Synchronization");
}
function setFpsInfo() {
    const perfMet = theViewport.target.performanceMetrics;
    if (document.getElementById("showfps"))
        document.getElementById("showfps").innerHTML =
            "Avg. FPS (ms): " + (perfMet.spfTimes.length / perfMet.spfSum).toFixed(2)
                + " Render Time (ms): " + (perfMet.renderSpfSum / perfMet.renderSpfTimes.length).toFixed(2)
                + "<br />Scene Time (ms): " + (perfMet.loadTileSum / perfMet.loadTileTimes.length).toFixed(2);
}
function addRenderModeHandler(id) {
    document.getElementById(id).addEventListener("click", () => applyRenderModeChange(id));
}
// associate viewing commands to icons. I couldn't get assigning these in the HTML to work.
function wireIconsToFunctions() {
    document.getElementById("selectIModel").addEventListener("click", selectIModel);
    document.getElementById("viewList").addEventListener("change", changeView);
    document.getElementById("startToggleModel").addEventListener("click", startToggleModel);
    document.getElementById("startCategorySelection").addEventListener("click", startCategorySelection);
    document.getElementById("startToggleCamera").addEventListener("click", startToggleCamera);
    document.getElementById("startFit").addEventListener("click", startFit);
    document.getElementById("startWindowArea").addEventListener("click", startWindowArea);
    document.getElementById("startSelect").addEventListener("click", startSelect);
    document.getElementById("startMeasurePoints").addEventListener("click", startMeasurePoints);
    document.getElementById("startWalk").addEventListener("click", startWalk);
    document.getElementById("startRotateView").addEventListener("click", startRotateView);
    document.getElementById("switchStandardRotation").addEventListener("click", toggleStandardViewMenu);
    document.getElementById("renderModeToggle").addEventListener("click", toggleRenderModeMenu);
    document.getElementById("snapModeToggle").addEventListener("click", toggleSnapModeMenu);
    document.getElementById("doUndo").addEventListener("click", doUndo);
    document.getElementById("doRedo").addEventListener("click", doRedo);
    document.getElementById("doSync").addEventListener("click", doSyncIModel);
    // standard view rotation handlers
    document.getElementById("top").addEventListener("click", () => applyStandardViewRotation(0 /* Top */, "Top"));
    document.getElementById("bottom").addEventListener("click", () => applyStandardViewRotation(1 /* Bottom */, "Bottom"));
    document.getElementById("left").addEventListener("click", () => applyStandardViewRotation(2 /* Left */, "Left"));
    document.getElementById("right").addEventListener("click", () => applyStandardViewRotation(3 /* Right */, "Right"));
    document.getElementById("front").addEventListener("click", () => applyStandardViewRotation(4 /* Front */, "Front"));
    document.getElementById("back").addEventListener("click", () => applyStandardViewRotation(5 /* Back */, "Back"));
    document.getElementById("iso").addEventListener("click", () => applyStandardViewRotation(6 /* Iso */, "Iso"));
    document.getElementById("rightIso").addEventListener("click", () => applyStandardViewRotation(7 /* RightIso */, "RightIso"));
    // render mode handlers
    addRenderModeHandler("skybox");
    addRenderModeHandler("groundplane");
    addRenderModeHandler("ACSTriad");
    addRenderModeHandler("fill");
    addRenderModeHandler("grid");
    addRenderModeHandler("textures");
    addRenderModeHandler("visibleEdges");
    addRenderModeHandler("hiddenEdges");
    addRenderModeHandler("materials");
    addRenderModeHandler("lights");
    addRenderModeHandler("monochrome");
    addRenderModeHandler("constructions");
    addRenderModeHandler("weights");
    addRenderModeHandler("styles");
    addRenderModeHandler("transparency");
    document.getElementById("continuousRendering").addEventListener("click", () => {
        const checked = document.getElementById("continuousRendering").checked;
        if (theViewport)
            theViewport.continuousRendering = checked;
        if (checked) {
            curFPSIntervalId = setInterval(setFpsInfo, 500);
            document.getElementById("showfps").style.display = "inline";
        }
        else {
            document.getElementById("showfps").style.display = "none";
            clearInterval(curFPSIntervalId);
        }
    });
    document.getElementById("renderModeList").addEventListener("change", () => changeRenderMode());
    document.getElementById("colorList").addEventListener("change", () => changeOverrideColor());
    // File Selector for the browser (a change represents a file selection)... only used when in browser and given base path for local files
    document.getElementById("browserFileSelector").addEventListener("change", async function onChange() {
        const files = this.files;
        if (files !== undefined && files.length > 0) {
            try {
                await resetStandaloneIModel(configuration.standalonePath + "/" + files[0].name);
            }
            catch (_a) {
                alert("Error Opening iModel - Make sure you are selecting files from the following directory: " + configuration.standalonePath);
                const spinner = document.getElementById("spinner");
                spinner.style.display = "none";
            }
        }
    });
}
// If we are using a browser, close the current iModel before leaving
window.onbeforeunload = () => {
    if (activeViewState.iModelConnection !== undefined)
        if (configuration.standalone)
            activeViewState.iModelConnection.closeStandalone();
        else
            activeViewState.iModelConnection.close(activeViewState.accessToken);
};
function stringToSnapMode(name) {
    switch (name) {
        case "Keypoint": return 2 /* NearestKeypoint */;
        case "Nearest": return 1 /* Nearest */;
        case "Center": return 8 /* Center */;
        case "Origin": return 16 /* Origin */;
        case "Intersection": return 64 /* Intersection */;
        default: return 2 /* NearestKeypoint */;
    }
}
class SVTAccuSnap extends frontend_1.AccuSnap {
    getActiveSnapModes() {
        const select = document.getElementById("snapModeList");
        const snapMode = stringToSnapMode(select.value);
        const snaps = [];
        snaps.push(snapMode);
        return snaps;
    }
}
class SVTIModelApp extends frontend_1.IModelApp {
    static onStartup() {
        frontend_1.IModelApp.accuSnap = new SVTAccuSnap();
        const svtToolNamespace = frontend_1.IModelApp.i18n.registerNamespace("SVTTools");
        MeasurePointsTool.register(svtToolNamespace);
    }
}
// main entry point.
async function main() {
    // retrieve, set, and output the global configuration variable
    await retrieveConfiguration();
    console.log("Configuration", JSON.stringify(configuration));
    // start the app.
    SVTIModelApp.startup();
    // Choose RpcConfiguration based on whether we are in electron or browser
    let rpcConfiguration;
    if (common_1.ElectronRpcConfiguration.isElectron) {
        rpcConfiguration = common_1.ElectronRpcManager.initializeClient({}, [common_1.IModelTileRpcInterface, common_1.StandaloneIModelRpcInterface, common_1.IModelReadRpcInterface]);
    }
    else {
        rpcConfiguration = common_1.BentleyCloudRpcManager.initializeClient({ info: { title: "SimpleViewApp", version: "v1.0" } }, [common_1.IModelTileRpcInterface, common_1.StandaloneIModelRpcInterface, common_1.IModelReadRpcInterface]);
        lib_1.Config.devCorsProxyServer = "https://localhost:3001";
    }
    // WIP: WebAppRpcProtocol seems to require an IModelToken for every RPC request. ECPresentation initialization tries to set active locale using
    // RPC without any imodel and fails...
    for (const definition of rpcConfiguration.interfaces())
        common_1.RpcOperation.forEach(definition, (operation) => operation.policy.token = (_request) => new common_1.IModelToken("test", "test", "test", "test"));
    const spinner = document.getElementById("spinner");
    spinner.style.display = "block";
    try {
        if (configuration.standalone) {
            await openStandaloneIModel(activeViewState, configuration.iModelName);
        }
        else {
            frontend_1.IModelApp.hubDeploymentEnv = configuration.environment || "QA";
            const projectMgr = configuration.useIModelBank ? new NonConnectProject_1.NonConnectProject() : new ConnectProject_1.ConnectProject();
            await projectMgr.loginAndOpenImodel(activeViewState);
        }
        // open the specified view
        Utils_1.showStatus("opening View", configuration.viewName);
        await buildViewList(activeViewState, configuration);
        // now connect the view to the canvas
        await openView(activeViewState);
        Utils_1.showStatus("View Ready");
    }
    catch (reason) {
        alert(reason);
        return;
    }
    spinner.style.display = "none";
    debugger;
    wireIconsToFunctions();
    console.log("This is from frontend/main");
}


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/** Commonly used constant values. */
class Constant {
}
Constant.oneMillimeter = 0.001;
Constant.oneCentimeter = 0.01;
Constant.oneMeter = 1.0;
Constant.oneKilometer = 1000.0;
Constant.diameterOfEarth = 12742.0 * Constant.oneKilometer;
Constant.circumferenceOfEarth = 40075.0 * Constant.oneKilometer;
Constant.radiansPerDegree = 0.0174532925;
exports.Constant = Constant;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPrimitive_1 = __webpack_require__(136);
const Range_1 = __webpack_require__(21);
const Transform_1 = __webpack_require__(6);
const Geometry_1 = __webpack_require__(3);
const LineSegment3d_1 = __webpack_require__(38);
/** Class holding an array structure of shapes defined by clip plane sets */
class ClipVector {
    constructor(clips) {
        this.boundingRange = Range_1.Range3d.createNull();
        this._clips = clips ? clips : [];
    }
    /** Returns a reference to the array of ClipShapes. */
    get clips() { return this._clips; }
    /** Returns true if this ClipVector contains a ClipShape. */
    isValid() { return this._clips.length > 0; }
    /** Create a ClipVector with an empty set of ClipShapes. */
    static createEmpty(result) {
        if (result) {
            result._clips.length = 0;
            return result;
        }
        return new ClipVector();
    }
    /** Create a ClipVector from an array of ClipShapes */
    static createClipShapeRefs(clips, result) {
        if (result) {
            result._clips = clips;
            return result;
        }
        return new ClipVector(clips);
    }
    /** Create a ClipVector from an array of ClipShapes, each one becoming a deep copy. */
    static createClipShapeClones(clips, result) {
        const clipClones = [];
        for (const clip of clips)
            clipClones.push(clip.clone());
        return ClipVector.createClipShapeRefs(clipClones, result);
    }
    /** Create a deep copy of another ClipVector */
    static createFrom(donor, result) {
        const retVal = result ? result : new ClipVector();
        retVal._clips.length = 0;
        for (const clip of donor._clips) {
            retVal._clips.push(clip.clone());
        }
        retVal.boundingRange.setFrom(donor.boundingRange);
        return retVal;
    }
    /** Parse this ClipVector into a JSON object. */
    toJSON() {
        if (!this.isValid())
            return [];
        const val = [];
        for (const clipShape of this.clips)
            val.push(clipShape.toJSON());
        return val;
    }
    /** Parse a JSON object into a new ClipVector. */
    static fromJSON(json, result) {
        result = result ? result : new ClipVector();
        result.clear();
        try {
            for (const clip of json) {
                const clipPrim = ClipPrimitive_1.ClipShape.fromJSON(clip);
                if (clipPrim)
                    result._clips.push(clipPrim);
            }
        }
        catch (e) {
            result.clear();
        }
        return result;
    }
    /** Returns a deep copy of this ClipVector (optionally stores it in the result param rather than create using new()) */
    clone(result) {
        return ClipVector.createFrom(this, result);
    }
    /** Empties out the array of ClipShapes. */
    clear() {
        this._clips.length = 0;
    }
    /** Append a deep copy of the given ClipShape to this ClipVector. */
    appendClone(clip) {
        this._clips.push(clip.clone());
    }
    /** Append a reference of the given ClipShape to this ClipVector. */
    appendReference(clip) {
        this._clips.push(clip);
    }
    /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */
    appendShape(shape, zLow, zHigh, transform, isMask = false, invisible = false) {
        const clip = ClipPrimitive_1.ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);
        if (!clip)
            return false;
        this._clips.push(clip);
        return true;
    }
    /** Returns the three-dimensional range that this ClipVector spans, which may be null. */
    getRange(transform, result) {
        const range = Range_1.Range3d.createNull(result);
        for (const shape of this._clips) {
            const thisRange = shape.getRange(false, transform);
            if (thisRange !== undefined) {
                if (range.isNull())
                    range.setFrom(thisRange);
                else
                    range.intersect(thisRange, range);
            }
        }
        if (!this.boundingRange.isNull())
            range.intersect(this.boundingRange, range);
        return range;
    }
    /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection). */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        if (!this.boundingRange.isNull() && !this.boundingRange.containsPoint(point))
            return false;
        for (const clip of this._clips)
            if (!clip.pointInside(point, onTolerance))
                return false;
        return true;
    }
    /** Transforms this ClipVector to a new coordinate-system. Returns true if successful. */
    transformInPlace(transform) {
        for (const clip of this._clips)
            if (clip.transformInPlace(transform) === false)
                return false;
        if (!this.boundingRange.isNull())
            transform.multiplyRange(this.boundingRange, this.boundingRange);
        return true;
    }
    /**
     * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also
     * taking into account each ClipShape's individual transforms.
     *
     * Information out:
     *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure)
     *  - If given a transform, will be set from the transformFromClip of the first ClipShape
     *  - The ClipMask of the final ClipShape is stored in the returned array at index 0
     *  - The last valid zLow found is stored in the returned array at index 1
     *  - The last valid zHigh found is stored in the returned array at index 2
     */
    extractBoundaryLoops(loopPoints, transform) {
        let clipM = 0 /* None */;
        let zBack = -Number.MAX_VALUE;
        let zFront = Number.MAX_VALUE;
        const retVal = [];
        let nLoops = 0;
        if (this._clips.length === 0)
            return retVal;
        const deltaTrans = Transform_1.Transform.createIdentity();
        for (const clip of this._clips) {
            if (clip !== this._clips[0]) {
                let fwdTrans = Transform_1.Transform.createIdentity();
                let invTrans = Transform_1.Transform.createIdentity();
                if (this._clips[0].transformValid && clip.transformValid) {
                    fwdTrans = clip.transformFromClip.clone();
                    invTrans = this._clips[0].transformToClip.clone();
                }
                deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));
            }
            loopPoints[nLoops] = [];
            if (clip.polygon !== undefined) {
                clipM = 15 /* XAndY */;
                if (clip.zHighValid) {
                    clipM = clipM | 32 /* ZHigh */;
                    zFront = clip.zHigh;
                }
                if (clip.zLowValid) {
                    clipM = clipM | 16 /* ZLow */;
                    zBack = clip.zLow;
                }
                for (const point of clip.polygon)
                    loopPoints[nLoops].push(point.clone());
                deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);
                nLoops++;
            }
        }
        retVal.push(clipM);
        retVal.push(zBack);
        retVal.push(zFront);
        if (transform)
            transform.setFrom(this._clips[0].transformFromClip);
        return retVal;
    }
    /** Sets this ClipVector and all of its members to the visibility specified. */
    setInvisible(invisible) {
        for (const clip of this._clips)
            clip.setInvisible(invisible);
    }
    /** For every clip, parse the member point array into the member clip plane object (only for clipPlanes member, not the mask) */
    parseClipPlanes() {
        for (const clip of this._clips)
            clip.fetchClipPlanesRef();
    }
    /** Returns true if able to successfully multiply all member ClipShape planes by the matrix given. */
    multiplyPlanesTimesMatrix(matrix) {
        let numErrors = 0;
        for (const clip of this._clips)
            if (clip.multiplyPlanesTimesMatrix(matrix) === false)
                numErrors++;
        return numErrors === 0 ? true : false;
    }
    /**
     * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyPointContainment(points, ignoreMasks = false) {
        let currentContainment = 2 /* Ambiguous */;
        for (const primitive of this._clips) {
            const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);
            if (2 /* Ambiguous */ === thisContainment)
                return 2 /* Ambiguous */;
            if (2 /* Ambiguous */ === currentContainment)
                currentContainment = thisContainment;
            else if (currentContainment !== thisContainment)
                return 2 /* Ambiguous */;
        }
        return currentContainment;
    }
    /**
     * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyRangeContainment(range, ignoreMasks) {
        const corners = range.corners();
        return this.classifyPointContainment(corners, ignoreMasks);
    }
    /**
     * For an array of points (making up a LineString), tests whether the segment between each point lies inside the ClipVector.
     * If true, returns true immediately.
     */
    isAnyLineStringPointInside(points) {
        for (const clip of this._clips) {
            const clipPlaneSet = clip.fetchClipPlanesRef();
            for (let i = 0; i + 1 < points.length; i++) {
                const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
                if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))
                    return true;
            }
        }
        return false;
    }
    /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */
    sumSizes(intervals, begin, end) {
        let s = 0.0;
        for (let i = begin; i < end; i++)
            s += (intervals[i].x1 - intervals[i].x0);
        return s;
    }
    /**
     * For an array of points that make up a LineString, develops a line segment between each point pair,
     * and returns true if all segments lie inside this ClipVector.
     */
    isLineStringCompletelyContained(points) {
        const clipIntervals = [];
        for (let i = 0; i + 1 < points.length; i++) {
            const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
            let fractionSum = 0.0;
            let index0 = 0;
            for (const clip of this._clips) {
                const clipPlaneSet = clip.fetchClipPlanesRef();
                clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);
                const index1 = clipIntervals.length;
                fractionSum += this.sumSizes(clipIntervals, index0, index1);
                index0 = index1;
                // ASSUME primitives are non-overlapping...
                if (fractionSum >= ClipVector.TARGET_FRACTION_SUM)
                    break;
            }
            if (fractionSum < ClipVector.TARGET_FRACTION_SUM)
                return false;
        }
        return true;
    }
}
ClipVector.TARGET_FRACTION_SUM = 0.99999999;
exports.ClipVector = ClipVector;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/**
 * PascalCoeffients class has static methods which return rows of the PascalTriangle.
 *
 */
class PascalCoefficients {
    /**
     * * return a row of the pascal table.
     * * The contents must not be altered by the user !!!
     * * Hypothetically the request row can be any integer.
     * * BUT in practice, values 60 create integer entries that are too big for IEEE double.
     */
    static getRow(row) {
        const allRows = PascalCoefficients.allRows;
        if (allRows.length === 0) {
            // seed the table . . .
            allRows.push(new Float64Array([1]));
            allRows.push(new Float64Array([1, 1]));
            allRows.push(new Float64Array([1, 2, 1]));
            allRows.push(new Float64Array([1, 3, 3, 1]));
            allRows.push(new Float64Array([1, 4, 6, 4, 1]));
            allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));
            allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));
            allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));
        }
        while (allRows.length <= row) {
            const k = allRows.length;
            const oldRow = allRows[k - 1];
            const newRow = new Float64Array(k + 1);
            newRow[0] = 1.0;
            for (let i = 1; i < k; i++)
                newRow[i] = oldRow[i - 1] + oldRow[i];
            newRow[k] = 1.0;
            allRows.push(newRow);
        }
        return allRows[row];
    }
    /** Return an array with Bezier weighted pascal coefficients
     * @param row row index in the pascal triangle.  (`row+1` entries)
     * @param u parameter value
     * @param result optional destination array.
     * @note if the destination array is undefined or too small, a new Float64Array is allocated.
     * @note if the destination array is larger than needed, its leading `row+1` values are filled,
     *     and the array is returned.
     */
    static getBezierBasisValues(order, u, result) {
        const row = order - 1;
        const pascalRow = PascalCoefficients.getRow(row);
        if (result === undefined || result.length < order)
            result = new Float64Array(order);
        for (let i = 0; i < order; i++)
            result[i] = pascalRow[i];
        // multiply by increasing powers of u ...
        let p = u;
        for (let i = 1; i < order; i++, p *= u) {
            result[i] *= p;
        }
        // multiply by powers of (1-u), working from right
        const v = 1.0 - u;
        p = v;
        for (let i = order - 2; i >= 0; i--, p *= v) {
            result[i] *= p;
        }
        return result;
    }
}
PascalCoefficients.allRows = [];
exports.PascalCoefficients = PascalCoefficients;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const PointVector_1 = __webpack_require__(4);
const Range_1 = __webpack_require__(21);
const Geometry_1 = __webpack_require__(3);
class Ray2d {
    constructor(origin, direction) {
        this._origin = origin;
        this._direction = direction;
    }
    static createOriginAndTarget(origin, target) {
        return new Ray2d(origin.clone(), origin.vectorTo(target));
    }
    static createOriginAndDirection(origin, direction) {
        return new Ray2d(origin.clone(), direction.clone());
    }
    static createOriginAndDirectionCapture(origin, direction) {
        return new Ray2d(origin, direction);
    }
    get origin() { return this._origin; }
    get direction() { return this._direction; }
    /**
     *  Return a ray that is parallel at distance to the left, specified as fraction of the ray's direction vector.
     */
    parallelRay(leftFraction) {
        return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction);
    }
    CCWPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CCWXY());
    }
    CWPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CWXY());
    }
    normalizeDirectionInPlace() {
        if (this._direction.normalize(this._direction)) {
            return true;
        }
        else {
            this._direction.x = 1.0;
            this._direction.y = 0.0;
            // magnitude = 0.0;
            return false;
        }
    }
    /**
     * Intersect this ray (ASSUMED NORMALIZED) with unbounded line defined by points.
     *  (The normalization assumption affects test for parallel vectors.)
     *  Fraction and dhds passed as number[] to use by reference... Sticking to return of true and false in the case fraction is zero after
     *  a true safe divide
     */
    intersectUnboundedLine(linePointA, linePointB, fraction, dhds) {
        const lineDirection = linePointA.vectorTo(linePointB);
        const vector0 = linePointA.vectorTo(this._origin);
        const h0 = vector0.crossProduct(lineDirection);
        dhds[0] = this._direction.crossProduct(lineDirection);
        // h = h0 + s * dh
        const ff = Geometry_1.Geometry.conditionalDivideFraction(-h0, dhds[0]);
        if (ff !== undefined) {
            fraction[0] = ff;
            return true;
        }
        else {
            fraction[0] = 0.0;
            return false;
        }
    }
    /** return the ray fraction where point projects to the ray */
    projectionFraction(point) {
        return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);
    }
    /** return the fraction of projection to the perpendicular ray */
    perpendicularProjectionFraction(point) {
        const uv = this._direction.crossProduct(this._origin.vectorTo(point));
        const uu = this._direction.magnitudeSquared();
        // Want zero returned if failure case, not undefined
        return Geometry_1.Geometry.safeDivideFraction(uv, uu, 0.0);
    }
    /** Return point from origin plus a scaled vector */
    fractionToPoint(f) {
        return this._origin.plusScaled(this._direction, f);
    }
}
exports.Ray2d = Ray2d;
class ConvexPolygon2d {
    constructor(points) {
        this.hullPoints = [];
        // Deep copy of points array given
        for (const point of points) {
            this.hullPoints.push(point);
        }
    }
    /** Create the hull */
    static createHull(points) {
        return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Create the hull. First try to use the points as given. */
    static createHullIsValidCheck(points) {
        if (ConvexPolygon2d.isValidConvexHull(points))
            return new ConvexPolygon2d(points);
        else
            return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Return a reference of the hull points. */
    get points() {
        return this.hullPoints;
    }
    /** Test if hull points are a convex, CCW polygon */
    static isValidConvexHull(points) {
        if (points.length < 3)
            return false;
        const n = points.length;
        for (let i = 0; i < n; i++) {
            const i1 = (i + 1) % n;
            const i2 = (i + 2) % n;
            if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)
                return false;
        }
        return true;
    }
    /** Return true if the convex hull (to the left of the edges) contains the test point */
    containsPoint(point) {
        let xy0 = this.hullPoints[this.hullPoints.length - 1];
        // double tol = -1.0e-20;  negative tol!!
        for (const i of this.hullPoints) {
            const xy1 = i;
            const c = xy0.crossProductToPoints(xy1, point);
            if (c < 0.0)
                return false;
            xy0 = i;
        }
        return true;
    }
    /** Return the largest outside. (return 0 if in or on) */
    distanceOutside(xy) {
        let maxDistance = 0.0;
        const n = this.hullPoints.length;
        let xy0 = this.hullPoints[n - 1];
        // double tol = -1.0e-20;  // negative tol!!
        for (let i = 0; i < n; i++) {
            const xy1 = this.hullPoints[i];
            const c = xy0.crossProductToPoints(xy1, xy);
            if (c < 0.0) {
                const ray = Ray2d.createOriginAndTarget(xy0, xy1);
                const s = ray.projectionFraction(xy);
                let d = 0.0;
                if (s < 0.0)
                    d = xy0.distance(xy);
                else if (s > 1.0)
                    d = xy1.distance(xy);
                else
                    d = xy.distance(ray.fractionToPoint(s));
                if (d > maxDistance)
                    maxDistance = d;
            }
            xy0 = this.hullPoints[i];
        }
        return maxDistance;
    }
    /** Offset the entire hull (in place) by distance.
     * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)
     */
    offsetInPlace(distance) {
        const n = this.hullPoints.length;
        if (n >= 3) {
            const hullPoint0 = this.hullPoints[0];
            let edgeA = this.hullPoints[n - 1].vectorTo(hullPoint0);
            edgeA = edgeA.normalize();
            if (edgeA === undefined) {
                return false;
            }
            let perpA = edgeA.rotate90CWXY();
            let edgeB;
            let perpB;
            for (let i = 0; i < n; i++) {
                const j = i + 1;
                edgeB = this.hullPoints[i].vectorTo(j < n ? this.hullPoints[j] : hullPoint0);
                edgeB = edgeB.normalize();
                if (edgeB === undefined) {
                    return false;
                }
                perpB = edgeB.rotate90CWXY();
                const offsetBisector = PointVector_1.Vector2d.createOffsetBisector(perpA, perpB, distance);
                if (offsetBisector === undefined) {
                    return false;
                }
                this.hullPoints[i] = this.hullPoints[i].plus(offsetBisector);
                // PerpA takes up reference to perpB, as perpB will die in new iteration
                perpA = perpB;
            }
        }
        return true;
    }
    /**
     * Return 2 distances bounding the intersection of the ray with a convex hull.
     * ASSUME (for tolerancing) the ray has normalized direction vector.
     * Both negative and positive distances along the ray are possible.
     * Returns range with extremities if less than 3 points, distanceA > distanceB, or if cross product < 0
     */
    clipRay(ray) {
        let distanceA = -Number.MAX_VALUE;
        let distanceB = Number.MAX_VALUE;
        const n = this.hullPoints.length;
        if (n < 3)
            return Range_1.Range1d.createNull();
        let xy0 = this.hullPoints[n - 1];
        for (const xy1 of this.hullPoints) {
            const distance = [];
            const dhds = [];
            if (ray.intersectUnboundedLine(xy0, xy1, distance, dhds)) {
                if (dhds[0] > 0.0) {
                    if (distance[0] < distanceB)
                        distanceB = distance[0];
                }
                else {
                    if (distance[0] > distanceA)
                        distanceA = distance[0];
                }
                if (distanceA > distanceB)
                    return Range_1.Range1d.createNull();
            }
            else {
                // ray is parallel to the edge.
                // Any single point out classifies it all . ..
                if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)
                    return Range_1.Range1d.createNull();
            }
            // xy1 is reassigned with each new loop
            xy0 = xy1;
        }
        const range = Range_1.Range1d.createNull();
        range.extendX(distanceA);
        range.extendX(distanceB);
        return range;
    }
    /** Return the range of (fractional) ray postions for projections of all points from the arrays. */
    rangeAlongRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this.hullPoints)
            range.extendX(ray.projectionFraction(xy1));
        return range;
    }
    /** Return the range of (fractional) ray postions for projections of all points from the arrays. */
    rangePerpendicularToRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this.hullPoints)
            range.extendX(ray.perpendicularProjectionFraction(xy1));
        return range;
    }
    /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.
     *  Returns an empty hull if less than 3 points are given.
     */
    static computeConvexHull(points) {
        const hull = [];
        const n = points.length;
        if (n < 3)
            return hull;
        // Get deep copy
        const xy1 = points.slice(0, n);
        xy1.sort(Geometry_1.Geometry.lexicalXYLessThan);
        hull.push(xy1[0]); // This is sure to stay
        hull.push(xy1[1]); // This one can be removed in loop.
        // First sweep creates upper hull
        for (let i = 2; i < n; i++) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            hull.push(candidate);
        }
        // Second sweep creates lower hull right to left
        const i0 = hull.length - 1;
        // xy1.back () is already on stack.
        hull.push(xy1[n - 2]);
        for (let i = n - 2; i-- > 0;) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            if (i > 0)
                hull.push(candidate);
        }
        return hull;
    }
}
exports.ConvexPolygon2d = ConvexPolygon2d;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Numerics */
const Geometry_1 = __webpack_require__(3);
class Complex {
    set x(value) { this.myX = value; }
    get x() { return this.myX; }
    set y(value) { this.myY = value; }
    get y() { return this.myY; }
    constructor(x = 0, y = 0) { this.myX = x; this.myY = y; }
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    setFrom(other) { this.x = other.x; this.y = other.y; }
    clone() { return new Complex(this.x, this.y); }
    isAlmostEqual(other) { return Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x); }
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Complex(x, y);
    }
    plus(other, result) { return Complex.create(this.x + other.x, this.y + other.y, result); }
    minus(other, result) { return Complex.create(this.x - other.x, this.y - other.y, result); }
    times(other, result) {
        return Complex.create(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x, result);
    }
    /** multiply {this * x+i*y}. That is, the second Complex value exists via the args without being formally created as an instance. */
    timesXY(x, y, result) {
        return Complex.create(this.x * x - this.y * y, this.x * y + this.y * x, result);
    }
    magnitude() { return Math.hypot(this.x, this.y); }
    angle() { return Geometry_1.Angle.createAtan2(this.y, this.x); }
    distance(other) {
        return Math.hypot(this.x - other.x, this.y - other.y);
    }
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    divide(other, result) {
        const bb = other.magnitudeSquared();
        if (bb === 0.0)
            return undefined;
        const divbb = 1.0 / bb;
        return Complex.create((this.x * other.x + this.y * other.y) * divbb, (this.y * other.x - this.x * other.y) * divbb, result);
    }
    sqrt(result) {
        if ((this.x === 0.0) && (this.y === 0.0))
            return Complex.create(0, 0, result);
        const x = Math.abs(this.x);
        const y = Math.abs(this.y);
        let r = 0;
        let w = 0;
        if (x >= y) {
            r = y / x;
            w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));
        }
        else {
            r = x / y;
            w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));
        }
        if (this.x >= 0.0) {
            return Complex.create(w, this.y / (2.0 * w), result);
        }
        else {
            const y1 = (this.y >= 0) ? w : -w;
            return Complex.create(this.y / (2.0 * y1), y1, result);
        }
    }
    setFromJSON(json) {
        if (Array.isArray(json) && json.length > 1) {
            this.set(json[0], json[1]);
        }
        else if (json && json.x && json.y) {
            this.set(json.x, json.y);
        }
        else {
            this.set(0, 0);
        }
    }
    static fromJSON(json) { const result = new Complex(); result.setFromJSON(json); return result; }
    /**
     * Convert an Complex to a JSON object.
     * @return {*} [x,y]
     */
    toJSON() { return [this.x, this.y]; }
}
exports.Complex = Complex;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Range_1 = __webpack_require__(21);
const GrowableArray_1 = __webpack_require__(37);
class Range1dArray {
    /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}
     *  ib = lowest possible index of overlapping interval of {B}
     *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}
     *  iB is advanced to the first interval whose high is to the right of {rangeA.high}
     */
    static advanceIntervalDifference(rangeA, dataB, iB, retVal) {
        const nB = dataB.length;
        let low = rangeA.low;
        let high = rangeA.high;
        while (iB < nB) {
            const rangeB = dataB[iB];
            if (rangeB.high < low) {
                iB++;
            }
            else if (rangeB.high <= high) {
                if (rangeB.low > low)
                    retVal.push(Range_1.Range1d.createXX(low, rangeB.low));
                low = rangeB.high;
                iB++;
            }
            else {
                // B ends beyond rangeA...
                if (rangeB.low < high)
                    high = rangeB.low;
                break;
            }
        }
        if (low < high)
            retVal.push(Range_1.Range1d.createXX(low, high));
        return retVal;
    }
    /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */
    static differenceSorted(dataA, dataB) {
        const nA = dataA.length;
        const iB = 0;
        const retVal = [];
        for (let iA = 0; iA < nA; iA++) {
            Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);
        }
        return retVal;
    }
    /** Internal step: Caller ensures rangeA is the "lower" interval.
     *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.
     *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns
     */
    static advanceIntervalIntersection(rangeA, rangeB, retVal) {
        if (rangeB.low > rangeA.high) {
            return true;
        }
        else if (rangeB.high >= rangeA.high) {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeA.high));
            return true;
        }
        else {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeB.high));
            return false;
        }
    }
    static intersectSorted(dataA, dataB) {
        let iA = 0;
        let iB = 0;
        const nA = dataA.length;
        const nB = dataB.length;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            if (rangeA.low <= rangeB.low) {
                if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))
                    iA++;
                else
                    iB++;
            }
            else {
                if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))
                    iB++;
                else
                    iA++;
            }
        }
        return retVal;
    }
    /** Internal step: Read an interval from the array.
     *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment readindex.
     */
    static advanceIntervalUnion(workRange, source, readIndex) {
        if (readIndex >= source.length)
            return false;
        const candidate = source[readIndex];
        if (candidate.low > workRange.high)
            return false;
        if (candidate.high > workRange.high)
            workRange.high = candidate.high;
        return true;
    }
    static unionSorted(dataA, dataB) {
        const nA = dataA.length;
        const nB = dataB.length;
        let iA = 0;
        let iB = 0;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            let workRange;
            // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.
            if (rangeA.low <= rangeB.low) {
                workRange = rangeA.clone();
                iA++;
            }
            else {
                workRange = rangeB.clone();
                iB++;
            }
            let toLoop = true;
            do {
                const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);
                const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);
                if (resultA)
                    iA++;
                if (resultB)
                    iB++;
                if (!(resultA || resultB))
                    toLoop = false;
            } while (toLoop);
            retVal.push(workRange);
        }
        while (iA < nA)
            retVal.push(dataA[iA++]);
        while (iB < nB)
            retVal.push(dataB[iB++]);
        return retVal;
    }
    static paritySorted(dataA, dataB) {
        // Combine the two arrays, and then perform a simplification using simplifySortParity function
        const retVal = [];
        for (const range of dataA)
            retVal.push(range.clone());
        for (const range of dataB)
            retVal.push(range.clone());
        // Sort the array
        retVal.sort(compareRange1d);
        Range1dArray.simplifySortParity(retVal, true);
        return retVal;
    }
    /** Uses the Range1d specific compare function for sorting the array of ranges */
    static sort(data) {
        data.sort(compareRange1d);
    }
    /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */
    static simplifySortUnion(data, removeZeroLengthRanges = false) {
        if (data.length < 2)
            return;
        data.sort(compareRange1d);
        let currIdx = 0;
        let toInsert = false;
        for (let i = 0; i < data.length; i++) {
            if (i === data.length - 1) {
                if (toInsert) {
                    if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                        data[currIdx++] = data[i];
                }
                break;
            }
            if (data[i + 1].low > data[i].high) {
                if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                    data[currIdx++] = data[i];
                continue;
            }
            else {
                data[i + 1].low = data[i].low;
                data[i + 1].high = Math.max(data[i].high, data[i + 1].high);
                toInsert = true;
            }
        }
        data.length = currIdx;
    }
    static simplifySortParity(data, removeZeroLengthRanges = false) {
        const numData = [];
        for (const range of data) {
            if (range.low !== range.high) {
                numData.push(range.low);
                numData.push(range.high);
            }
        }
        const n = numData.length;
        numData.sort((a, b) => {
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        });
        let currIdx = 0;
        let x0;
        let x1;
        for (let i = 0; i < n; i += 2) {
            x0 = numData[i];
            x1 = numData[i + 1];
            if (!removeZeroLengthRanges) {
                Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
            else {
                // coalesce intervals that share end and start:
                while (i + 2 < n && numData[i + 2] === x1) {
                    i += 2;
                    x1 = numData[i + 1];
                }
                if (x1 > x0)
                    Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
        }
        data.length = currIdx;
    }
    /** test if value is "in" by union rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testUnion(data, value) {
        for (const range of data) {
            if (range.containsX(value))
                return true;
        }
        return false;
    }
    /** test if value is "in" by parity rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testParity(data, value) {
        let inside = false;
        for (const range of data) {
            if (range.containsX(value))
                inside = !inside;
        }
        return inside;
    }
    /** return an array with all the low and high values of all the ranges.
     * * the coordinates are not sorted.
     */
    static getBreaks(data, result) {
        if (!result)
            result = new GrowableArray_1.GrowableFloat64Array(2 * data.length);
        for (const range of data) {
            result.push(range.low);
            result.push(range.high);
        }
        return result;
    }
    /** sum the lengths of all ranges */
    static sumLengths(data) {
        let sum = 0.0;
        for (const range of data) {
            sum += range.length();
        }
        return sum;
    }
    /**
     * Test if the low,high values are sorted with no overlap.
     * @param data array of ranges.
     * @param strict if true, consider exact high-to-low match as overlap.
     */
    static isSorted(data, strict = true) {
        const n = data.length;
        if (strict) {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high >= data[i + 1].low)
                    return false;
            }
        }
        else {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high > data[i + 1].low)
                    return false;
            }
        }
        return true;
    }
}
exports.Range1dArray = Range1dArray;
/** Checks low's first, then high's */
function compareRange1d(a, b) {
    if (a.low < b.low)
        return -1;
    if (a.low > b.low)
        return 1;
    if (a.high < b.high)
        return -1;
    if (a.high > b.high)
        return 1;
    return 0;
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class
var DataState;
(function (DataState) {
    DataState[DataState["RawMatrix"] = 0] = "RawMatrix";
    DataState[DataState["FactorOK"] = 1] = "FactorOK";
    DataState[DataState["FactorFailed"] = 2] = "FactorFailed";
})(DataState || (DataState = {}));
class TriDiagonalSystem {
    constructor(n) {
        this.aLeft = new Float64Array(n);
        this.aDiag = new Float64Array(n);
        this.aRight = new Float64Array(n);
        this.b = new Float64Array(n);
        this.x = new Float64Array(n);
        this.Reset();
    }
    // Reset to RawMatrix state with all coefficients zero
    Reset() {
        this.dataState = DataState.RawMatrix;
        const n = this.aDiag.length;
        for (let i = 0; i < n; i++) {
            this.aLeft[i] = this.aRight[i] = this.aDiag[i] = this.b[i] = this.x[i] = 0.0;
        }
    }
    // Install data in a row of the matrix
    SetRow(row, left, diag, right) {
        this.aLeft[row] = left;
        this.aDiag[row] = diag;
        this.aRight[row] = right;
    }
    // Add to row of matrix
    AddToRow(row, left, diag, right) {
        this.aLeft[row] += left;
        this.aDiag[row] += diag;
        this.aRight[row] += right;
    }
    // Install data in the right side (B) vector
    SetB(row, bb) {
        this.b[row] = bb;
    }
    // Add to an entry in the right side (B) vector
    AddToB(row, bb) {
        this.b[row] += bb;
    }
    // Access data from the right side (B) vector
    GetB(row) {
        return this.b[row];
    }
    // Install data in the solution (X) vector
    SetX(row, xx) {
        this.x[row] = xx;
    }
    // Access data frin the solution (X) vector
    GetX(row) {
        return this.x[row];
    }
    // Get method for matrix and vector order
    Order() {
        return this.aDiag.length;
    }
    // Compute product of AX and save as B
    MultiplyAX() {
        if (this.dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this.dataState === DataState.FactorOK) {
            const n = this.aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                this.b[i] = this.aDiag[i] * this.x[i] + this.aRight[i] * this.x[i + 1];
            }
            this.b[nm1] = this.aDiag[nm1] * this.x[nm1];
            for (let i = nm1; i > 0; i--) {
                this.b[i] += this.aLeft[i] * this.b[i - 1];
            }
            return true;
        }
        else {
            const n = this.aDiag.length;
            const nm1 = n - 1;
            this.b[0] = this.aDiag[0] * this.x[0] + this.aRight[0] * this.x[1];
            let i;
            for (i = 1; i < nm1; i++) {
                this.b[i] = this.aLeft[i] * this.x[i - 1] + this.aDiag[i] * this.x[i] + this.aRight[i] * this.x[i + 1];
            }
            this.b[nm1] = this.aLeft[nm1] * this.x[n - 2] + this.aDiag[i] * this.x[nm1];
            return true;
        }
    }
    // Compute product of AX and save as B
    MultiplyAXPoints(pointX, pointB) {
        pointB.length = 0;
        while (pointB.length < pointX.length)
            pointB.push(PointVector_1.Point3d.create());
        pointB.length = pointX.length;
        if (this.dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this.dataState === DataState.FactorOK) {
            const n = this.aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                PointVector_1.Point3d.add2Scaled(pointX[i], this.aDiag[i], pointX[i + 1], this.aRight[i], pointB[i]);
            }
            PointVector_1.Point3d.createScale(pointX[nm1], this.aDiag[nm1], pointB[nm1]);
            for (let i = nm1; i > 0; i--) {
                pointB[i].plusScaled(pointB[i - 1], this.aLeft[i], pointB[i]);
            }
            return true;
        }
        else {
            const n = this.aDiag.length;
            const nm1 = n - 1;
            PointVector_1.Point3d.add2Scaled(pointX[0], this.aDiag[0], pointX[1], this.aRight[0], pointB[0]);
            let i;
            for (i = 1; i < nm1; i++) {
                PointVector_1.Point3d.add3Scaled(pointX[i - 1], this.aLeft[i], pointX[i], this.aDiag[i], pointX[i + 1], this.aRight[i], pointB[i]);
            }
            PointVector_1.Point3d.add2Scaled(pointX[n - 2], this.aLeft[nm1], pointX[nm1], this.aDiag[nm1], pointB[nm1]);
            return true;
        }
    }
    // Multiply the stored factors together to return to plain matrix form
    Defactor() {
        if (this.dataState === DataState.RawMatrix) {
            return true;
        }
        if (this.dataState === DataState.FactorFailed) {
            return false;
        }
        const n = this.aDiag.length;
        const nm1 = n - 1;
        for (let i = nm1; i > 0; i--) {
            this.aDiag[i] += this.aLeft[i] * this.aRight[i - 1];
            this.aLeft[i] *= this.aDiag[i - 1];
        }
        this.dataState = DataState.RawMatrix;
        return true;
    }
    // Factor the tridiagonal matrix to LU parts. b, x, not altered
    Factor() {
        if (this.dataState === DataState.FactorOK) {
            return true;
        }
        if (this.dataState !== DataState.RawMatrix) {
            return false;
        }
        this.dataState = DataState.FactorFailed;
        const n1 = this.aDiag.length - 1; // Last pivot index
        // Eliminate in subdiagonal.
        for (let i = 0; i < n1; i++) {
            const r = Geometry_1.Geometry.conditionalDivideFraction(this.aLeft[i + 1], this.aDiag[i]);
            if (!r)
                return false;
            this.aLeft[i + 1] = r;
            this.aDiag[i + 1] -= r * this.aRight[i];
        }
        this.dataState = DataState.FactorOK;
        return true;
    }
    // Solve AX=B. A is left in factored state. B unchanged.
    FactorAndBackSubstitute() {
        const n = this.aDiag.length;
        const n1 = n - 1;
        if (!this.Factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        for (let i = 0; i < n; i++) {
            this.x[i] = this.b[i];
        }
        for (let i = 1; i < n; i++) {
            this.x[i] -= this.aLeft[i] * this.x[i - 1];
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        this.x[n1] /= this.aDiag[n1];
        for (let i = n1 - 1; i >= 0; i--) {
            this.x[i] = (this.x[i] - this.aRight[i] * this.x[i + 1]) / this.aDiag[i];
        }
        return true;
    }
    // Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array
    FactorAndBackSubstitutePointArrays(vectorB, vectorX) {
        const n = this.aDiag.length;
        if (vectorB.length < n)
            return false;
        while (vectorX.length < n)
            vectorX.push(PointVector_1.Point3d.create(0, 0, 0));
        vectorX.length = n;
        const n1 = n - 1;
        if (!this.Factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        if (vectorB !== vectorX) {
            for (let i = 0; i < n; i++) {
                vectorX[i].setFrom(vectorB[i]);
            }
        }
        let a;
        let b;
        for (let i = 1; i < n; i++) {
            a = this.aLeft[i];
            vectorX[i].x -= a * vectorX[i - 1].x;
            vectorX[i].y -= a * vectorX[i - 1].y;
            vectorX[i].z -= a * vectorX[i - 1].z;
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        b = 1.0 / this.aDiag[n1];
        vectorX[n1].x *= b;
        vectorX[n1].y *= b;
        vectorX[n1].z *= b;
        for (let i = n1 - 1; i >= 0; i--) {
            a = this.aRight[i];
            b = 1.0 / this.aDiag[i];
            vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;
            vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;
            vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;
        }
        return true;
    }
    // Allocate a complete copy
    Copy() {
        const n = this.aDiag.length;
        const B = new TriDiagonalSystem(n);
        for (let i = 0; i < n; i++) {
            B.aLeft[i] = this.aLeft[i];
            B.aDiag[i] = this.aDiag[i];
            B.aRight[i] = this.aRight[i];
            B.x[i] = this.x[i];
            B.b[i] = this.b[i];
        }
        B.dataState = this.dataState;
        return B;
    }
    // return an array form that may be useful for display ...
    flatten() {
        const n = this.aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this.aLeft[i], this.aDiag[i], this.aRight[i]], this.x[i], this.b[i]]);
        }
        return data;
    }
    // return an array form that may be useful for display ...
    flattenWithPoints(xyzB) {
        const n = this.aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this.aLeft[i], this.aDiag[i], this.aRight[i]], this.x[i], xyzB[i].toJSON()]);
        }
        return data;
    }
}
exports.TriDiagonalSystem = TriDiagonalSystem;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveProcessor_1 = __webpack_require__(141);
const CurveChain_1 = __webpack_require__(14);
const LineString3d_1 = __webpack_require__(10);
const LineSegment3d_1 = __webpack_require__(38);
/** Algorithmic class: Accumulate maximum gap between adjacent primitives of CurveChain.
 */
class GapSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() { super(); this.maxGap = 0.0; }
    static maxGap(target) {
        const context = new GapSearchContext();
        target.announceToCurveProcessor(context);
        return context.maxGap;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (this.stack.length > 0) {
            const parent = this.stack[this.stack.length - 1];
            if (parent instanceof CurveChain_1.CurveChain) {
                const chain = parent;
                const nextCurve = chain.cyclicCurvePrimitive(_indexInParent + 1);
                if (curve !== undefined && nextCurve !== undefined) {
                    this.maxGap = Math.max(this.maxGap, curve.endPoint().distance(nextCurve.startPoint()));
                }
            }
        }
    }
}
exports.GapSearchContext = GapSearchContext;
/** Algorithmic class: Count LineSegment3d and LineString3d primitives.
 */
class CountLinearPartsSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() {
        super();
        this.numLineSegment = 0;
        this.numLineString = 0;
        this.numOther = 0;
    }
    static hasNonLinearPrimitives(target) {
        const context = new CountLinearPartsSearchContext();
        target.announceToCurveProcessor(context);
        return context.numOther > 0;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (curve instanceof LineSegment3d_1.LineSegment3d)
            this.numLineSegment++;
        else if (curve instanceof LineString3d_1.LineString3d)
            this.numLineString++;
        else
            this.numOther++;
    }
}
exports.CountLinearPartsSearchContext = CountLinearPartsSearchContext;
/** Algorithmic class: Transform curves in place.
 */
class TransformInPlaceContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor(transform) { super(); this.numFail = 0; this.numOK = 0; this.transform = transform; }
    static tryTransformInPlace(target, transform) {
        const context = new TransformInPlaceContext(transform);
        target.announceToCurveProcessor(context);
        return context.numFail === 0;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        if (!curvePrimitive.tryTransformInPlace(this.transform))
            this.numFail++;
        else
            this.numOK++;
    }
}
exports.TransformInPlaceContext = TransformInPlaceContext;
/** Algorithmic class: Sum lengths of curves */
class SumLengthsContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor() { super(); this.sum = 0.0; }
    static sumLengths(target) {
        const context = new SumLengthsContext();
        target.announceToCurveProcessor(context);
        return context.sum;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        this.sum += curvePrimitive.curveLength();
    }
}
exports.SumLengthsContext = SumLengthsContext;
/**
 * Algorithmic class for cloning curve collections.
 * * recurse through collection nodes, building image nodes as needed and inserting clones of children.
 * * for individual primitive, invoke doClone (protected) for direct clone; insert into parent
 */
class CloneCurvesContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor(transform) {
        super();
        this.transform = transform;
        this.result = undefined;
    }
    static clone(target, transform) {
        const context = new CloneCurvesContext(transform);
        target.announceToCurveProcessor(context);
        return context.result;
    }
    enter(c) {
        if (c instanceof CurveChain_1.CurveCollection)
            super.enter(c.cloneEmptyPeer());
    }
    leave() {
        const result = super.leave();
        if (result) {
            if (this.stack.length === 0)
                this.result = result;
            else
                this.stack[this.stack.length - 1].tryAddChild(result);
        }
        return result;
    }
    // specialized cloners override this (and allow announceCurvePrimitive to insert to parent)
    doClone(primitive) {
        if (this.transform)
            return primitive.cloneTransformed(this.transform);
        return primitive.clone();
    }
    announceCurvePrimitive(primitive, _indexInParent) {
        const c = this.doClone(primitive);
        if (c && this.stack.length > 0) {
            const parent = this.stack[this.stack.length - 1];
            if (parent instanceof CurveChain_1.CurveChain) {
                parent.tryAddChild(c);
            }
            else if (parent instanceof CurveChain_1.BagOfCurves) {
                parent.tryAddChild(c);
            }
        }
    }
}
exports.CloneCurvesContext = CloneCurvesContext;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryHandler_1 = __webpack_require__(90);
const CurvePrimitive_1 = __webpack_require__(12);
const Geometry_1 = __webpack_require__(3);
const LineSegment3d_1 = __webpack_require__(38);
const LineString3d_1 = __webpack_require__(10);
// import { Arc3d } from "./Arc3d";
const PointVector_1 = __webpack_require__(4);
// import { LineString3d } from "./LineString3d";
const Polynomials_1 = __webpack_require__(66);
/**
 * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by CurveCurve,IntersectXY and
 * CurveCurve.ClosestApproach
 */
class CurveLocationDetailArrayPair {
    constructor() {
        this.dataA = [];
        this.dataB = [];
    }
}
exports.CurveLocationDetailArrayPair = CurveLocationDetailArrayPair;
/*
 * * Handler class for XY intersections.
 * * This is local to the file (not exported)
 * * Instances are initialized and called from CurveCurve.
 */
class CurveCurveIntersectXY extends GeometryHandler_1.NullGeometryHandler {
    constructor(_geometryA, extendA, geometryB, extendB) {
        super();
        // this.geometryA = _geometryA;
        this.extendA = extendA;
        this.geometryB = geometryB;
        this.extendB = extendB;
        this.reinitialize();
    }
    reinitialize() {
        this.results = new CurveLocationDetailArrayPair();
    }
    /**
     * @param reinitialize if true, a new results structure is created for use by later calls.
     * @returns Return the results structure for the intersection calculation.
     *
     */
    grabResults(reinitialize = false) {
        const result = this.results;
        if (reinitialize)
            this.reinitialize();
        return result;
    }
    acceptFraction(extend0, fraction, extend1) {
        if (!extend0 && fraction < 0.0)
            return false;
        if (!extend1 && fraction > 1.0)
            return false;
        return true;
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    computeSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const uv = CurveCurveIntersectXY.workVector2dA;
        if (Polynomials_1.SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(pointA0, pointA1, pointB0, pointB1, uv)
            && this.acceptFraction(extendA0, uv.x, extendA1)
            && this.acceptFraction(extendB0, uv.y, extendB1)) {
            const detailA = CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(cpA, Geometry_1.Geometry.interpolate(fractionA0, uv.x, fractionA1), pointA0.interpolate(uv.x, pointA1));
            detailA.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.isolated);
            const detailB = CurvePrimitive_1.CurveLocationDetail.createCurveFractionPoint(cpB, Geometry_1.Geometry.interpolate(fractionB0, uv.y, fractionB1), pointB0.interpolate(uv.y, pointB1));
            detailB.setIntervalRole(CurvePrimitive_1.CurveIntervalRole.isolated);
            if (reversed) {
                this.results.dataA.push(detailB);
                this.results.dataB.push(detailA);
            }
            else {
                this.results.dataA.push(detailA);
                this.results.dataB.push(detailB);
            }
        }
    }
    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {
        const pointA0 = lsA.point0Ref;
        const pointA1 = lsA.point1Ref;
        const pointB0 = CurveCurveIntersectXY.workPointB0;
        const pointB1 = CurveCurveIntersectXY.workPointB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.computeSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);
            }
        }
        return undefined;
    }
    handleLineSegment3d(segmentA) {
        if (this.geometryB instanceof LineSegment3d_1.LineSegment3d) {
            const segmentB = this.geometryB;
            this.computeSegmentSegment(segmentA, this.extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this.extendA, segmentB, this.extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this.extendB, false);
        }
        else if (this.geometryB instanceof LineString3d_1.LineString3d) {
            this.computeSegmentLineString(segmentA, this.extendA, this.geometryB, this.extendB, false);
        }
    }
    handleLineString3d(lsA) {
        if (this.geometryB instanceof LineString3d_1.LineString3d) {
            const lsB = this.geometryB;
            const pointA0 = CurveCurveIntersectXY.workPointA0;
            const pointA1 = CurveCurveIntersectXY.workPointA1;
            const pointB0 = CurveCurveIntersectXY.workPointB0;
            const pointB1 = CurveCurveIntersectXY.workPointB1;
            const numA = lsA.numPoints();
            const numB = lsB.numPoints();
            if (numA > 1 && numB > 1) {
                lsA.pointAt(0, pointA0);
                const dfA = 1.0 / (numA - 1);
                const dfB = 1.0 / (numB - 1);
                let fA0 = 0.0;
                let fB0;
                let fA1;
                let fB1;
                const extendA = this.extendA;
                const extendB = this.extendB;
                lsA.pointAt(0, pointA0);
                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {
                    fA1 = ia * dfA;
                    fB0 = 0.0;
                    lsA.pointAt(ia, pointA1);
                    lsB.pointAt(0, pointB0);
                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                        lsB.pointAt(ib, pointB1);
                        fB1 = ib * dfB;
                        this.computeSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);
                    }
                }
            }
        }
        else if (this.geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.computeSegmentLineString(this.geometryB, this.extendB, lsA, this.extendA, true);
        }
        return undefined;
        /*  public handleArc3d(arc0: Arc3d): any {
            if (this.geometryB instanceof Arc3d) {
            }
            return undefined;
          }
          */
    }
}
CurveCurveIntersectXY.workVector2dA = PointVector_1.Vector2d.create();
CurveCurveIntersectXY.workPointA0 = PointVector_1.Point3d.create();
CurveCurveIntersectXY.workPointA1 = PointVector_1.Point3d.create();
CurveCurveIntersectXY.workPointB0 = PointVector_1.Point3d.create();
CurveCurveIntersectXY.workPointB1 = PointVector_1.Point3d.create();
class CurveCurve {
    static IntersectionXY(geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY(geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
}
exports.CurveCurve = CurveCurve;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const Transform_1 = __webpack_require__(6);
const CurvePrimitive_1 = __webpack_require__(12);
const CurveChain_1 = __webpack_require__(14);
const BSplineCurve_1 = __webpack_require__(107);
const Arc3d_1 = __webpack_require__(47);
const LineSegment3d_1 = __webpack_require__(38);
const LineString3d_1 = __webpack_require__(10);
const PointHelpers_1 = __webpack_require__(22);
/**
 * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.
 *
 * * For the common case of building a right handed frame:
 *
 * ** create the FrameBuilder and make calls to announcePoint and announceVector.
 * ** the frame will be fully determined by an origin and two vectors.
 * ** the first call to announcePoint will set the origin.
 * **  additional calls to announcePoint will produce announceVector call with the vector from the origin.
 * ** After each announcement, call getValidatedFrame(false)
 * ** getValidatedFrame will succeed when it has two independent vectors.
 * *  to build a left handed frame,
 *
 * **  an origin and 3 independent vectors are required.
 * **  annouce as above, but query wtih getValidatedFrame (true).
 * **  this will use the third vector to select right or left handed frame.
 */
class FrameBuilder {
    clear() { this.origin = undefined; this.vector0 = undefined; this.vector1 = undefined; this.vector2 = undefined; }
    constructor() { this.clear(); }
    /** Try to assemble the data into a nonsingular transform.
     *
     * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.
     * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.
     */
    getValidatedFrame(allowLeftHanded = false) {
        if (this.origin && this.vector0 && this.vector1) {
            if (!allowLeftHanded) {
                const matrix = Transform_1.RotMatrix.createRigidFromColumns(this.vector0, this.vector1, 0 /* XYZ */);
                if (matrix)
                    return Transform_1.Transform.createOriginAndMatrix(this.origin, matrix);
                // uh oh -- vector1 was not really independent.  clear everything after vector0.
                this.vector1 = this.vector2 = undefined;
            }
            else if (this.vector2) {
                const matrix = Transform_1.RotMatrix.createRigidFromColumns(this.vector0, this.vector1, 0 /* XYZ */);
                if (matrix) {
                    if (this.vector0.tripleProduct(this.vector1, this.vector2) < 0)
                        matrix.scaleColumns(1.0, 1.0, -1.0);
                    return Transform_1.Transform.createOriginAndMatrix(this.origin, matrix);
                }
                // uh oh again -- clear vector1 and vector2, reannounce vector2 as possible vector1??
                const vector2 = this.vector2;
                this.vector1 = this.vector2 = undefined;
                this.announceVector(vector2);
            }
        }
        return undefined;
    }
    // If vector0 is known but vector1 is not, make vector1 the cross of the upvector and vector0
    applyDefaultUpVector(vector) {
        if (vector && this.vector0 && !this.vector1 && !vector.isParallelTo(this.vector0)) {
            this.vector1 = vector.crossProduct(this.vector0);
        }
    }
    hasOrigin() { return this.origin !== undefined; }
    /** Return the number of vectors saved.   Because the save process checkes numerics, this should be the rank of the system.
     */
    savedVectorCount() {
        if (!this.vector0)
            return 0;
        if (!this.vector1)
            return 1;
        if (!this.vector2)
            return 2;
        return 3;
    }
    /** announce a new point.  If this point is different from the origin, also announce the vector from the origin.*/
    announcePoint(point) {
        if (!this.origin) {
            this.origin = point.clone();
            return this.savedVectorCount();
        }
        // the new point may provide an additional vector
        if (this.origin.isAlmostEqual(point))
            return this.savedVectorCount();
        return this.announceVector(this.origin.vectorTo(point));
    }
    announceVector(vector) {
        if (vector.isAlmostZero())
            return this.savedVectorCount();
        if (!this.vector0) {
            this.vector0 = vector;
            return 1;
        }
        if (!this.vector1) {
            if (!vector.isParallelTo(this.vector0)) {
                this.vector1 = vector;
                return 2;
            }
            return 1;
        }
        // vector0 and vector1 are independent.
        if (!this.vector2) {
            const unitPerpendicular = this.vector0.unitCrossProduct(this.vector1);
            if (unitPerpendicular && !Geometry_1.Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {
                this.vector2 = vector;
                return 3;
            }
        }
        // fall through if prior vectors are all there -- no need for the new one.
        return 3;
    }
    /** Inspect the content of the data.  Announce points and vectors.   Return when savedVectorCount becomes
     * sufficient for a coordinate system.
     */
    announce(data) {
        if (this.savedVectorCount() > 1)
            return;
        if (data instanceof PointVector_1.Point3d)
            this.announcePoint(data);
        else if (data instanceof PointVector_1.Vector3d)
            this.announceVector(data);
        else if (Array.isArray(data)) {
            for (const child of data) {
                if (this.savedVectorCount() > 1)
                    break;
                this.announce(child);
            }
        }
        else if (data instanceof CurvePrimitive_1.CurvePrimitive) {
            if (data instanceof LineSegment3d_1.LineSegment3d) {
                this.announcePoint(data.startPoint());
                this.announcePoint(data.endPoint());
            }
            else if (data instanceof Arc3d_1.Arc3d) {
                const ray = data.fractionToPointAndDerivative(0.0);
                this.announcePoint(ray.origin);
                this.announceVector(ray.direction);
                this.announceVector(data.matrix.columnZCrossVector(ray.direction));
            }
            else if (data instanceof LineString3d_1.LineString3d) {
                for (const point of data.points) {
                    this.announcePoint(point);
                    if (this.savedVectorCount() > 1)
                        break;
                }
            }
            else if (data instanceof BSplineCurve_1.BSplineCurve3d) {
                const point = PointVector_1.Point3d.create();
                for (let i = 0; this.savedVectorCount() < 2; i++) {
                    if (data.getPole(i, point) instanceof PointVector_1.Point3d)
                        this.announcePoint(point);
                    else
                        break;
                }
            }
            // TODO: unknown curve type.  Stroke? FrenetFrame?
        }
        else if (data instanceof CurveChain_1.CurveCollection) {
            if (data.children)
                for (const child of data.children) {
                    this.announce(child);
                    if (this.savedVectorCount() > 1)
                        break;
                }
        }
    }
    /** create a localToWorld frame for the given data.
     *
     * *  origin is at first point
     * *  x axis in direction of first nonzero vector present or implied by the input.
     * *  y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.
     */
    static createRightHandedFrame(defaultUpVector, ...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            builder.applyDefaultUpVector(defaultUpVector);
            const result = builder.getValidatedFrame(false);
            if (result !== undefined)
                return result;
        }
        // try direct evaluation of curve primitives?
        for (const data of params) {
            if (data instanceof CurveChain_1.CurveCollection) {
                const children = data.children;
                if (children) {
                    for (const curve of children) {
                        if (curve instanceof CurvePrimitive_1.CurvePrimitive) {
                            const frenetFrame = curve.fractionToFrenetFrame(0.0);
                            if (frenetFrame)
                                return frenetFrame;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** create a map with
     * *  transform0 = the local to world
     * *  transform1 = world to local
     * * ideally all points in local xy plane
     */
    static createRightHandedLocalToWorld(...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            const localToWorld = builder.getValidatedFrame(false);
            if (localToWorld !== undefined)
                return localToWorld;
        }
        return undefined;
    }
    /**
     * try to create a frame whose xy plane is through points.
     *
     * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the
     * point most distant from that line.
     * @param points array of points
     */
    static createFrameToDistantPoints(points) {
        if (points.length > 2) {
            const origin = points[0].clone();
            const vector01 = PointVector_1.Vector3d.create();
            PointHelpers_1.Point3dArray.vectorToMostDistantPoint(points, points[0], vector01);
            const vector02 = PointVector_1.Vector3d.create();
            PointHelpers_1.Point3dArray.vectorToPointWithMaxCrossProductMangitude(points, origin, vector01, vector02);
            const matrix = Transform_1.RotMatrix.createRigidFromColumns(vector01, vector02, 0 /* XYZ */);
            if (matrix)
                return Transform_1.Transform.createRefs(origin, matrix);
        }
        return undefined;
    }
    /**
     * Create the localToWorld transform from a range to axes of its parent coordinate system.
     * @param range [in] range to inpsect
     * @param fractionX  [in] fractonal coordinate of frame origin x
     * @param fractionY [in] fractional coordinate of frame origin y
     * @param fractionZ [in] fractgional coordinate of frame origin z
     * @param scaleSelect [in] selects size of localToWorld axes.
     * @param defaultAxisLength [in] if true and any axis length is 0, that axis vector takes this physical length.
     */
    static createLocalToWorldTransformInRange(range, scaleSelect = 2 /* NonUniformRangeContainment */, fractionX = 0, fractionY = 0, fractionZ = 0, defaultAxisLength = 1.0) {
        if (range.isNull())
            return Transform_1.Transform.createIdentity();
        let a = 1.0;
        let b = 1.0;
        let c = 1.0;
        if (scaleSelect === 1 /* LongestRangeDirection */) {
            a = b = c = Geometry_1.Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);
        }
        else if (scaleSelect === 2 /* NonUniformRangeContainment */) {
            a = Geometry_1.Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionX, 0, 1);
            b = Geometry_1.Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionY, 0, 1);
            c = Geometry_1.Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionZ, 0, 1);
        }
        return Transform_1.Transform.createRefs(range.fractionToPoint(fractionX, fractionY, fractionZ), Transform_1.RotMatrix.createScale(a, b, c));
    }
}
exports.FrameBuilder = FrameBuilder;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module Numerics */
Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(3);
const PointVector_1 = __webpack_require__(4);
const GrowableArray_1 = __webpack_require__(37);
class ClusterableArray extends GrowableArray_1.GrowableBlockedArray {
    /**
     * @param numCoordinatePerPoint number of coordinates per point
     * @param  numExtraDataPerPoint of extra data values per point.
     * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)
     */
    constructor(numCoordinatePerPoint, numExtraDataPerPoint, initialBlockCapacity) {
        super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);
        this.numExtraDataPerPoint = numExtraDataPerPoint;
        this.numCoordinatePerPoint = numCoordinatePerPoint;
    }
    static sortVectorComponent(index) {
        let c = 1.0;
        for (let i = 1; i < index; i++)
            c *= ClusterableArray.vectorFactor;
        return c;
    }
    /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.
     * @param data array of numDataPerBlock values.
     */
    addBlock(data) {
        const i0 = this.newBlockIndex() + 1;
        const n = Math.min(this.numPerBlock - 1, data.length);
        for (let i = 0; i < n; i++)
            this.data[i0 + i] = data[i];
    }
    /** add a block with directly 2 to 5 listed content parameters.
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addDirect(x0, x1, x2, x3, x4) {
        const i0 = this.newBlockIndex();
        this.data[i0 + 1] = x0;
        this.data[i0 + 2] = x1;
        if (x2 !== undefined)
            this.data[i0 + 3] = x2;
        if (x3 !== undefined)
            this.data[i0 + 4] = x3;
        if (x4 !== undefined)
            this.data[i0 + 5] = x4;
    }
    /** add a block with directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint2d(xy, a, b, c) {
        const i0 = this.newBlockIndex();
        this.data[i0 + 1] = xy.x;
        this.data[i0 + 2] = xy.y;
        if (a !== undefined)
            this.data[i0 + 3] = a;
        if (b !== undefined)
            this.data[i0 + 4] = b;
        if (c !== undefined)
            this.data[i0 + 5] = c;
    }
    /** add a block with directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint3d(xyz, a, b, c) {
        const i0 = this.newBlockIndex();
        this.data[i0 + 1] = xyz.x;
        this.data[i0 + 2] = xyz.y;
        this.data[i0 + 3] = xyz.z;
        if (a !== undefined)
            this.data[i0 + 4] = a;
        if (b !== undefined)
            this.data[i0 + 5] = b;
        if (c !== undefined)
            this.data[i0 + 6] = c;
    }
    getPoint2d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return PointVector_1.Point2d.create(this.data[i0 + 1], this.data[i0 + 2], result);
    }
    getPoint3d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return PointVector_1.Point3d.create(this.data[i0 + 1], this.data[i0 + 2], this.data[i0 + 3], result);
    }
    /** Return a single extra data value */
    getExtraData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this.data[i0 + 1 + this.numCoordinatePerPoint + i];
    }
    /** Return a single data value */
    getData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this.data[i0 + i];
    }
    /** Set a single extra data value */
    setExtraData(blockIndex, i, value) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        this.data[i0 + 1 + this.numCoordinatePerPoint + i] = value;
    }
    static isClusterTerminator(x) { return x === ClusterableArray.clusterTerminator; }
    /** Return an array giving clusters of blocks with similar coordinates.
     *
     * * The contents of each block is assumed to be set up so the primary sort coordinate is first.
     *
     * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of
     * candidates for clusters.
     * ** The usual solution is to u value which is a dot product along some skew direction and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.
     * ** apply setupPrimaryClusterSort to prepare that!!!
     * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component
     * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.
     * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)
     */
    clusterIndicesLexical(clusterTolerance = Geometry_1.Geometry.smallMetricDistance) {
        // install primary sort key
        this.setupPrimaryClusterSort();
        // presort by all coordinates ....
        const firstSort = this.sortIndicesLexical();
        const clusterIndices = new Uint32Array(2 * firstSort.length); // worst case: no duplicates, each index goes in followed by terminator.
        let m = 0; // number of cluster indices
        const n = this.numBlocks; // and this must match firstSort.length !!
        let clusterStartBlockIndex = 0;
        let candidateBlockIndex = 0;
        let barrierU = 0.0;
        let i = 0;
        let j = 0;
        const k0 = 1; // beginning of active column for distance
        const k1 = 1 + this.numCoordinatePerPoint;
        for (i = 0; i < n; i++) {
            clusterStartBlockIndex = firstSort[i];
            if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {
                // unused block, so it becomes a cluster...
                clusterIndices[m++] = clusterStartBlockIndex;
                barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;
                firstSort[i] = ClusterableArray.clusterTerminator;
                for (j = i + 1; j < n; j++) {
                    candidateBlockIndex = firstSort[j];
                    if (candidateBlockIndex === ClusterableArray.clusterTerminator)
                        continue; // nearby in sort direction but already in a cluster.
                    if (this.component(candidateBlockIndex, 0) >= barrierU)
                        break;
                    if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {
                        clusterIndices[m++] = candidateBlockIndex; // The candidate is in the block
                        firstSort[j] = ClusterableArray.clusterTerminator; // and it will not be reused as future block base
                    }
                }
                clusterIndices[m++] = ClusterableArray.clusterTerminator;
            }
        }
        // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.
        return clusterIndices.slice(0, m);
    }
    /** setup (overwrite!!) the "0" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.
     * This is normally called before clusterIndicesLexical.
     */
    setupPrimaryClusterSort() {
        const nb = this.numBlocks;
        const nc = this.numCoordinatePerPoint;
        const vector = new Float64Array(nc);
        vector[0] = 1.0;
        for (let c = 1; c < nc; c++)
            vector[c] = vector[c - 1] * ClusterableArray.vectorFactor;
        let k = 0;
        let dot = 0.0;
        const data = this.data;
        for (let b = 0; b < nb; b++) {
            k = this.blockIndexToDoubleIndex(b);
            dot = 0.0;
            for (let c = 0; c < nc; c++) {
                dot += vector[c] * data[k + 1 + c];
            }
            data[k] = dot;
        }
    }
    ToJSON() {
        const result = [];
        for (let b = 0; b < this.numBlocks; b++) {
            let i = this.blockIndexToDoubleIndex(b);
            const chunk = [b, this.data[i++]];
            const coordinates = [];
            for (let c = 0; c < this.numCoordinatePerPoint; c++)
                coordinates.push(this.data[i++]);
            chunk.push(coordinates);
            for (let c = 0; c < this.numExtraDataPerPoint; c++)
                chunk.push(this.data[i++]);
            result.push(chunk);
        }
        return result;
    }
    /**
     * @returns Return an array of indices from block index to cluster index.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndex_blockToClusterIndex(clusteredBlocks) {
        const numBlocks = this.numBlocks;
        const blockToCluster = new Uint32Array(numBlocks);
        blockToCluster.fill(ClusterableArray.clusterTerminator);
        let numCluster = 0;
        for (const b of clusteredBlocks) {
            if (b >= numBlocks) {
                numCluster++;
            }
            else {
                blockToCluster[b] = numCluster;
            }
        }
        return blockToCluster;
    }
    /**
     * @returns Return an array of indices from block index to index of its cluster's start in the cluster index array.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndex_blockToClusterStart(clusteredBlocks) {
        const n = clusteredBlocks.length;
        const numBlocks = this.numBlocks;
        const blockToClusterStart = new Uint32Array(numBlocks);
        const terminator = ClusterableArray.clusterTerminator;
        blockToClusterStart.fill(terminator);
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k > numBlocks) {
                clusterStart = i + 1;
            }
            else {
                blockToClusterStart[k] = clusterStart;
            }
        }
        return blockToClusterStart;
    }
    /** count the clusters in the clusteredBlocks array. */
    countClusters(clusteredBlocks) {
        let numClusters = 0;
        const terminator = ClusterableArray.clusterTerminator;
        for (const b of clusteredBlocks) {
            if (b === terminator)
                numClusters++;
        }
        return numClusters;
    }
    /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place
     * the cluster's block indices appear in clusterBlocks
     */
    createIndex_clusterToClusterStart(clusteredBlocks) {
        let numCluster = this.countClusters(clusteredBlocks);
        const clusterToClusterStart = new Uint32Array(numCluster);
        const terminator = ClusterableArray.clusterTerminator;
        clusterToClusterStart.fill(terminator);
        const n = clusteredBlocks.length;
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k === terminator) {
                clusterStart = i + 1;
            }
            else if (i === clusterStart) {
                clusterToClusterStart[numCluster++] = clusterStart;
            }
        }
        return clusterToClusterStart;
    }
    /**
     * Sort terminator-delimited subsets of an array of indices into the table, using a single extraData index as sort key.
     * @param blockedIndices [in] indices, organized as blocks of good indices terminated by the clusterTerminator.
     * @param extraDataIndex index of the extra data key.
     */
    sortSubsetsBySingleKey(blockedIndices, dataIndex) {
        const dataOffset = 1 + dataIndex;
        let kBegin = 0;
        let swap;
        let key0, key1;
        const numK = blockedIndices.length;
        for (let kEnd = 0; kEnd < numK; kEnd++) {
            if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {
                // sort blockedIndices[kBegin ,= k < kEnd].
                //  (search for minimum remaining, swap  . . )
                for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {
                    key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);
                    for (let k1 = k0 + 1; k1 < kEnd; k1++) {
                        key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);
                        if (key1 < key0) {
                            swap = blockedIndices[k0];
                            blockedIndices[k0] = blockedIndices[k1];
                            blockedIndices[k1] = swap;
                            key0 = key1;
                        }
                    }
                }
                kBegin = kEnd + 1;
            }
        }
    }
    /**
     * @returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterPoint3dArray(data, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, data.length);
        data.forEach((p) => {
            clusterArray.addDirect(p.x, p.y, p.z);
        });
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(data.length);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0)
                    result.packedPoints.push(data[k].clone());
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
    /**
     * @returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterGrowablePoint3dArray(source, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, source.length);
        const p = PointVector_1.Point3d.create();
        const numSourcePoint = source.length;
        for (let i = 0; i < numSourcePoint; i++) {
            source.getPoint3dAt(i, p);
            clusterArray.addDirect(p.x, p.y, p.z);
        }
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(source.length);
        const numPackedPoints = clusterArray.countClusters(order);
        result.growablePackedPoints = new GrowableArray_1.GrowableXYZArray(numPackedPoints);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0)
                    result.growablePackedPoints.pushFromGrowableXYZArray(source, k);
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
}
ClusterableArray.vectorFactor = 0.8732; // use 1.0 to rig easy tests.
/** this value is used as cluster terminator in the Uint232rray of indcies. */
ClusterableArray.clusterTerminator = 0xFFffFFff;
exports.ClusterableArray = ClusterableArray;
/**
 * Data carrier class for
 * * packedPoints = an array of Point3d
 * * oldToNew = array of indices from some prior Point3d[] to the packed points.
 */
class PackedPointsWithIndex {
    /** construct a PackedPoints object with
     * * empty packedPoints array
     * * oldToNew indices all initialized to PackedPoints.invalidIndex
     */
    constructor(numOldIndexEntry) {
        this.packedPoints = [];
        this.oldToNew = new Uint32Array(numOldIndexEntry);
        for (let i = 0; i < numOldIndexEntry; i++) {
            this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;
        }
    }
    /**
     * Use the oldToNew array to update an array of "old" indices.
     * @param indices array of indices into prepacked array.
     * @returns true if all input indices were valid for the oldToNew array.
     */
    updateIndices(indices) {
        let numErrors = 0;
        indices.forEach((value, i, data) => {
            if (value < this.oldToNew.length) {
                data[i] = this.oldToNew[value];
            }
            else
                numErrors++;
        });
        return numErrors === 0;
    }
}
PackedPointsWithIndex.invalidIndex = 0xFFFFffff;
exports.PackedPointsWithIndex = PackedPointsWithIndex;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Point3d, Vector3d, Point2d } from "./PointVector";
const PointVector_1 = __webpack_require__(4);
const Polyface_1 = __webpack_require__(92);
const Geometry4d_1 = __webpack_require__(46);
const CurveChain_1 = __webpack_require__(14);
const LineString3d_1 = __webpack_require__(10);
const PointHelpers_1 = __webpack_require__(22);
const Moments_1 = __webpack_require__(139);
/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each mtehod. */
class PolyfaceQuery {
    /** copy the points from a visitor into a Linestring3d in a Loop object */
    static VisitorToLoop(visitor) {
        const ls = LineString3d_1.LineString3d.createPoints(visitor.point.getPoint3dArray());
        return CurveChain_1.Loop.create(ls);
    }
    /** Create a linestring loop for each facet of the polyface. */
    static IndexedPolyfaceToLoops(polyface) {
        const result = CurveChain_1.BagOfCurves.create();
        const visitor = polyface.createVisitor(1);
        while (visitor.moveToNextFacet()) {
            const loop = PolyfaceQuery.VisitorToLoop(visitor);
            result.tryAddChild(loop);
        }
        return result;
    }
    /** @returns Return the sum of all facets areas. */
    static sumFacetAreas(source) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumFacetAreas(source.createVisitor(1));
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            s += PointHelpers_1.PolygonOps.sumTriangleAreas(visitor.point.getPoint3dArray());
        }
        return s;
    }
    /** sum volumes of tetrahedra from origin to all facets.
     * * if origin is omitted, the first point encountered (by the visitor) is used as origin.
     * * If the mesh is closed, this sum is the volume.
     * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets
     * from the origin to facets.
    */
    static sumTetrahedralVolumes(source, origin) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);
        let myOrigin = origin;
        const visitor = source;
        const facetOrigin = PointVector_1.Point3d.create();
        const targetA = PointVector_1.Point3d.create();
        const targetB = PointVector_1.Point3d.create();
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            if (myOrigin === undefined)
                myOrigin = visitor.point.getPoint3dAt(0);
            visitor.point.getPoint3dAt(0, facetOrigin);
            for (let i = 1; i + 1 < visitor.point.length; i++) {
                visitor.point.getPoint3dAt(i, targetA);
                visitor.point.getPoint3dAt(i + 1, targetB);
                s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);
            }
        }
        return s / 6.0;
    }
    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all facets. */
    static SumFacetSecondAreaMomentProducts(source, origin) {
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.SumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);
        const products = Geometry4d_1.Matrix4d.createZero();
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            PointHelpers_1.PolygonOps.addSecondMomentAreaProducts(visitor.point, origin, products);
        }
        return products;
    }
    /** Compute area moments for the mesh. In the returned MomentData:
     * * origin is the centroid.
     * * localToWorldMap has the origin and principal directions
     * * radiiOfGyration radii for rotation aroud the x,y,z axes.
     */
    static computePrincipalAreaMoments(source) {
        const origin = source.data.getPoint(0);
        if (!origin)
            return undefined;
        const inertiaProducts = PolyfaceQuery.SumFacetSecondAreaMomentProducts(source, origin);
        return Moments_1.MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);
    }
}
exports.PolyfaceQuery = PolyfaceQuery;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = __webpack_require__(255);
var RequestBase = __webpack_require__(256);
var isObject = __webpack_require__(158);
var ResponseBase = __webpack_require__(257);
var Agent = __webpack_require__(259);

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = __webpack_require__(158);

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var utils = __webpack_require__(258);

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};


/***/ }),
/* 259 */
/***/ (function(module, exports) {

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(261);
var parse = __webpack_require__(262);
var formats = __webpack_require__(160);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(159);
var formats = __webpack_require__(160);

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(159);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Events */
Object.defineProperty(exports, "__esModule", { value: true });
class EventContext {
    constructor(listener, scope, once) {
        this.listener = listener;
        this.scope = scope;
        this.once = once;
    }
}
/**
 * Manages a set of *listeners* for a particular event and notifies them when the event is raised.
 * This class is usually instantiated inside of a container class and
 * exposed as a property for others to *subscribe* via [[BeEvent.addListener]].
 */
class BeEvent {
    constructor() {
        this._listeners = [];
        this._insideRaiseEvent = false;
    }
    /** The number of listeners currently subscribed to the event. */
    get numberOfListeners() { return this._listeners.length; }
    /**
     * Registers a Listener to be executed whenever this event is raised.
     * @param listener The function to be executed when the event is raised.
     * @param scope An optional object scope to serve as the 'this' pointer when listener is invoked.
     * @returns A function that will remove this event listener.
     * @see [[BeEvent.raiseEvent]], [[BeEvent.removeListener]]
     */
    addListener(listener, scope) {
        this._listeners.push(new EventContext(listener, scope, false));
        const event = this;
        return () => { event.removeListener(listener, scope); };
    }
    /**
     * Registers a callback function to be executed *only once* when the event is raised.
     * @param listener The function to be executed once when the event is raised.
     * @param scope An optional object scope to serve as the `this` pointer in which the listener function will execute.
     * @returns A function that will remove this event listener.
     * @see [[BeEvent.raiseEvent]], [[BeEvent.removeListener]]
     */
    addOnce(listener, scope) {
        this._listeners.push(new EventContext(listener, scope, true));
        const event = this;
        return () => { event.removeListener(listener, scope); };
    }
    /**
     * Un-register a previously registered listener.
     * @param listener The listener to be unregistered.
     * @param  scope The scope that was originally passed to addListener.
     * @returns 'true' if the listener was removed; 'false' if the listener and scope are not registered with the event.
     * @see [[BeEvent.raiseEvent]], [[BeEvent.addListener]]
     */
    removeListener(listener, scope) {
        const listeners = this._listeners;
        for (let i = 0; i < listeners.length; ++i) {
            const context = listeners[i];
            if (context.listener === listener && context.scope === scope) {
                if (this._insideRaiseEvent) {
                    context.listener = undefined;
                }
                else {
                    listeners.splice(i, 1);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Raises the event by calling each registered listener with the supplied arguments.
     * @param args This method takes any number of parameters and passes them through to the listeners.
     * @see [[BeEvent.removeListener]], [[BeEvent.addListener]]
     */
    raiseEvent(..._args) {
        this._insideRaiseEvent = true;
        const listeners = this._listeners;
        let length = listeners.length;
        let dropped = false;
        for (let i = 0; i < length; ++i) {
            const context = listeners[i];
            if (!context.listener) {
                dropped = true;
            }
            else {
                context.listener.apply(context.scope, arguments);
                if (context.once) {
                    context.listener = undefined;
                    dropped = true;
                }
            }
            // if we had dropped listeners, remove them now
            if (dropped) {
                this._listeners.length = 0;
                listeners.forEach((ctx) => { if (ctx.listener)
                    this._listeners.push(ctx); });
                length = listeners.length;
            }
        }
        this._insideRaiseEvent = false;
    }
    /** Determine whether this BeEvent has a specified listener registered.
     * @param listener The listener to check.
     * @param scope optional scope argument to match call to addListener
     */
    has(listener, scope) {
        for (const ctx of this._listeners) {
            if (ctx.listener === listener && ctx.scope === scope) {
                return true;
            }
        }
        return false;
    }
    /** Clear all Listeners from this BeEvent. */
    clear() { this._listeners.length = 0; }
}
exports.BeEvent = BeEvent;
/**
 * A list of BeEvent objects, accessible by an event name.
 * This class may be used instead of explicitly declaring each BeEvent as a member of a containing class.
 */
class BeEventList {
    constructor() {
        this._events = {};
    }
    /**
     * Gets the BeEvent associated with a name.
     * @param name The name of the event.
     * @note the BeEvent will be created if none existed before this call.
     */
    get(name) {
        let event = this._events[name];
        if (event)
            return event;
        event = new BeEvent();
        this._events[name] = event;
        return event;
    }
    /**
     * Removes the BeEvent associated with a name.
     * @param name The name of the event.
     */
    remove(name) {
        this._events[name] = undefined;
    }
}
exports.BeEventList = BeEventList;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module BeSQLite */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Basic comparison routine for numbers
 * Uses a default tolerance of 0.1 that can be overridden by supplying a third parameter
 */
function compareWithTolerance(a, b, tolerance = 0.1) {
    if (a < b - tolerance)
        return -1;
    else if (a > b + tolerance)
        return 1;
    else
        return 0;
}
exports.compareWithTolerance = compareWithTolerance;
function compareNumbers(a, b) { return a - b; }
exports.compareNumbers = compareNumbers;
function compareBooleans(a, b) { return a !== b ? (a < b ? -1 : 1) : 0; }
exports.compareBooleans = compareBooleans;
function compareStrings(a, b) { return a === b ? 0 : (a < b ? -1 : 1); }
exports.compareStrings = compareStrings;
function compare(lhs, rhs) { return lhs.compare(rhs); }
exports.compare = compare;
function comparePossiblyUndefined(compareDefined, lhs, rhs) {
    if (undefined === lhs)
        return undefined === rhs ? 0 : -1;
    else if (undefined === rhs)
        return 1;
    else
        return compareDefined(lhs, rhs);
}
exports.comparePossiblyUndefined = comparePossiblyUndefined;
function compareStringsOrUndefined(lhs, rhs) { return comparePossiblyUndefined(compareStrings, lhs, rhs); }
exports.compareStringsOrUndefined = compareStringsOrUndefined;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
const SortedArray_1 = __webpack_require__(110);
/**
 * Maintains a mapping of keys to values.
 * Unlike the standard Map<K, V>, a Dictionary<K, V> supports custom comparison logic for keys of object type.
 * The user supplies a key comparison function to the constructor, which must meet the following criteria given 'lhs' and 'rhs' of type K:
 *  - If lhs is equal to rhs, returns 0
 *  - If lhs is less than rhs, returns a negative value
 *  - If lhs is greater than rhs, returns a positive value
 *  - If compare(lhs, rhs) returns 0, then compare(rhs, lhs) must also return 0
 *  - If compare(lhs, rhs) returns a negative value, then compare(rhs, lhs) must return a positive value, and vice versa.
 *
 * Modifying a key in a way that affects the comparison function will produce unpredictable results, the
 * most likely of which is that keys will cease to map to the values with which they were initially inserted.
 */
class Dictionary {
    /**
     * Construct a new Dictionary<K, V>.
     * @param compareKeys A function accepting two values of type K and returning a negative value if lhs < rhs,
     *        zero if lhs == rhs, and a positive value otherwise.
     * @param cloneKey A function that, given a value of type K, returns an equivalent value of type K.
     *        This function is invoked when a new key is inserted into the dictionary. The default implementation simply returns its input.
     * @param cloneValue A function that, given a value of type V, returns an equivalent value of type V.
     *        This function is invoked when a new value is inserted into the dictionary. The default implementation simply returns its input.
     */
    constructor(compareKeys, cloneKey = SortedArray_1.defaultClone, cloneValue = SortedArray_1.defaultClone) {
        this._keys = [];
        this._values = [];
        this._compareKeys = compareKeys;
        this._cloneKey = cloneKey;
        this._cloneValue = cloneValue;
    }
    /** The number of entries in the dictionary. */
    get length() { return this._keys.length; }
    /** Removes all entries from this dictionary */
    clear() {
        this._keys = [];
        this._values = [];
    }
    /**
     * Looks up a value by its key.
     * @param key The key to search for
     * @returns the value associated with the key, or undefined if the key is not present in the dictionary.
     */
    get(key) {
        const bound = this.lowerBound(key);
        return bound.equal ? this._values[bound.index] : undefined;
    }
    /**
     * Deletes a value using its key.
     * @param key The key to delete
     */
    delete(key) {
        const bound = this.lowerBound(key);
        if (bound.equal) {
            this._values.splice(bound.index, 1);
            this._keys.splice(bound.index, 1);
        }
    }
    /**
     * Attempts to insert a new entry into the dictionary. If an entry with an equivalent key exists, the dictionary is unmodified.
     * If the new entry is in fact inserted, both the key and value will be cloned using the functions supplied to the dictionary's constructor.
     * @param key The key to associate with the value
     * @param value The value to associate with the key
     * @returns true if the new entry was inserted, false if an entry with an equivalent key already exists.
     */
    insert(key, value) {
        const bound = this.lowerBound(key);
        if (!bound.equal) {
            this._keys.splice(bound.index, 0, this._cloneKey(key));
            this._values.splice(bound.index, 0, this._cloneValue(value));
        }
        return !bound.equal;
    }
    /**
     * Sets the value associated with the specified key in the dictionary.
     * If no such key already exists, this is equivalent to insert(key, value); otherwise, the existing value associated with the key is replaced.
     * In either case, the value will be cloned using the function supplied to the dictionary's constructor.
     */
    set(key, value) {
        value = this._cloneValue(value);
        const bound = this.lowerBound(key);
        if (bound.equal) {
            this._values[bound.index] = value;
        }
        else {
            this._keys.splice(bound.index, 0, this._cloneKey(key));
            this._values.splice(bound.index, 0, value);
        }
    }
    /**
     * Extracts the contents of this dictionary as an array of { key, value } pairs, and empties this dictionary.
     * @returns An array of { key, value } pairs sorted by key.
     */
    extractPairs() {
        const pairs = [];
        for (let i = 0; i < this.length; i++)
            pairs.push({ key: this._keys[i], value: this._values[i] });
        this.clear();
        return pairs;
    }
    /**
     * Extracts the contents of this dictionary as a pair of { keys, values } arrays, and empties this dictionary.
     * The array of keys is sorted according to the comparison criterion.
     * The position of each value in the array of values corresponds the the position of the corresponding key in the array of keys.
     * @returns a pair of { keys, values } arrays in which key[i] corresponds to value[i] in this dictionary and the keys are in sorted order.
     */
    extractArrays() {
        const result = { keys: this._keys, values: this._values };
        this.clear();
        return result;
    }
    /**
     * Computes the position at which the specified key should be inserted in order to maintain sorted order.
     * @param key The key whose position is to be computed.
     * @returns an object with 'index' corresponding to the computed position and 'equal' set to true if an equivalent key already exists at that index.
     */
    lowerBound(key) { return SortedArray_1.lowerBound(key, this._keys, this._compareKeys); }
}
exports.Dictionary = Dictionary;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
const SortedArray_1 = __webpack_require__(110);
/** Associates a value of type T with an index representing its insertion order in an IndexMap<T> */
class IndexedValue {
    constructor(value, index) {
        this.value = value;
        this.index = index;
    }
}
exports.IndexedValue = IndexedValue;
/**
 * Maintains a set of unique elements in sorted order and retains the insertion order of each.
 * The uniqueness of the elements is determined by a comparison routine supplied by the user.
 * The user may also supply a maximum size, beyond which insertions will fail.
 */
class IndexMap {
    /**
     * Construct a new IndexMap<T>.
     * @param compare A function accepting two values of type T and returning a negative value if lhs < rhs,
     *        zero if lhs == rhs, and a positive value otherwise.
     * @param maximumSize The maximum number of elements permitted in the IndexMap. The maximum index of an element is maximumSize-1.
     * @param clone A function that, given a value of type T, returns an equivalent value of type T.
     *        This function is invoked when a new element is inserted into the array.
     *        The default implementation simply returns its input.
     */
    constructor(compare, maximumSize = Number.MAX_SAFE_INTEGER, clone = SortedArray_1.defaultClone) {
        this.array = [];
        this.compareValues = compare;
        this.clone = clone;
        this.maximumSize = maximumSize;
    }
    /** The number of elements in the map. */
    get length() { return this.array.length; }
    /** Returns true if the maximum number of elements have been inserted. */
    get isFull() { return this.length >= this.maximumSize; }
    /** Returns true if the map contains no elements. */
    get isEmpty() { return 0 === this.length; }
    /** Removes all elements from the map. */
    clear() { this.array = []; }
    /** Attempt to insert a new value into the map.
     * If an equivalent element already exists in the map, the corresponding index is returned.
     * If the map is full, nothing is inserted and -1 is returned.
     * Otherwise:
     *  The new element is mapped to the next-available index (that is, the length of the map prior to insertion of this new element);
     *  the value is cloned using the function supplied to the IndexMap constructor;
     *  the cloned result is inserted into the map; and
     *  the index of the new element is returned.
     * @param value The value to insert
     * @param onInsert The optional callback method to call if insertion occurs with the inserted value
     * @returns the index of the equivalent element in the map, or -1 if the map is full and no equivalent element exists.
     */
    insert(value, onInsert) {
        const bound = this.lowerBound(value);
        if (bound.equal)
            return this.array[bound.index].index;
        else if (this.isFull)
            return -1;
        const entry = new IndexedValue(this.clone(value), this.array.length);
        if (undefined !== onInsert)
            onInsert(entry.value);
        this.array.splice(bound.index, 0, entry);
        return entry.index;
    }
    /**
     * Finds the index of an element equivalent to the supplied value.
     * @param value the value to find
     * @returns the index of an equivalent element in the map, or -1 if no such element exists.
     */
    indexOf(value) {
        const bound = this.lowerBound(value);
        return bound.equal ? this.array[bound.index].index : -1;
    }
    lowerBound(value) { return SortedArray_1.lowerBound(value, this.array, (lhs, rhs) => this.compareValues(lhs, rhs.value)); }
}
exports.IndexMap = IndexMap;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract class for custom data structures
 * @param list the wrapped array that this class support iteration over
 */
class Iterable {
    constructor(_list = []) {
        this._list = _list;
    }
    [Symbol.iterator]() {
        let key = 0;
        return { next: () => { const result = key < this._list.length ? { value: this._list[key], done: false } : { value: this._list[key - 1], done: true }; key++; return result; } };
    }
}
exports.Iterable = Iterable;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Derived from:
 * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>
 * See README.md at https://github.com/rsms/js-lru for details.
 */
/** An entry holds the key and value, and pointers to any older and newer entries. */
class Entry {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
exports.Entry = Entry;
class EntryIterator {
    constructor(oldestEntry) {
        this.entry = oldestEntry;
    }
    next() {
        const ent = this.entry;
        if (!ent)
            return { done: true, value: undefined };
        this.entry = ent.newer;
        const val = [ent.key, ent.value];
        return { done: false, value: val };
    }
}
class KeyIterator {
    constructor(oldestEntry) {
        this.entry = oldestEntry;
    }
    next() {
        const ent = this.entry;
        if (!ent)
            return { done: true, value: undefined };
        this.entry = ent.newer;
        return { done: false, value: ent.key };
    }
}
class ValueIterator {
    constructor(oldestEntry) {
        this.entry = oldestEntry;
    }
    next() {
        const ent = this.entry;
        if (!ent)
            return { done: true, value: undefined };
        this.entry = ent.newer;
        return { done: false, value: ent.value };
    }
}
/**
 * A Map of a key/value pairs, where the size of the map can be limited.
 *
 * When entries are inserted, if the map is "full", the
 * least-recently-used (LRU) value is dropped. When entries are retrieved, they are moved to the front of the LRU list.
 *
 * Illustration of the design:
 *
 * ```
 *
 *       entry             entry             entry             entry
 *       ______            ______            ______            ______
 *      | head |.newer => |      |.newer => |      |.newer => | tail |
 *      |  A   |          |  B   |          |  C   |          |  D   |
 *      |______| <= older.|______| <= older.|______| <= older.|______|
 *
 *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
 * ```
 */
class LRUMap {
    /**
     * Construct a new LRUMap to hold up to limit entries.
     */
    constructor(limit) {
        this.size = 0;
        this.limit = limit;
        this.oldest = this.newest = undefined;
        this._keymap = new Map();
    }
    markEntryAsUsed(entry) {
        if (entry === this.newest)
            return; // Already the most recently used entry, so no need to update the list
        // HEAD--------------TAIL
        //   <.older   .newer>
        //  <--- add direction --
        //   A  B  C  <D>  E
        if (entry.newer) {
            if (entry === this.oldest) {
                this.oldest = entry.newer;
            }
            entry.newer.older = entry.older; // C <-- E.
        }
        if (entry.older) {
            entry.older.newer = entry.newer; // C. --> E
        }
        entry.newer = undefined; // D --x
        entry.older = this.newest; // D. --> E
        if (this.newest) {
            this.newest.newer = entry; // E. <-- D
        }
        this.newest = entry;
    }
    /**  Replace all values in this map with key-value pairs (2-element Arrays) from provided iterable. */
    assign(entries) {
        let entry;
        let limit = this.limit || Number.MAX_VALUE;
        this._keymap.clear();
        const it = entries[Symbol.iterator]();
        for (let itv = it.next(); !itv.done; itv = it.next()) {
            const e = new Entry(itv.value[0], itv.value[1]);
            this._keymap.set(e.key, e);
            if (!entry) {
                this.oldest = e;
            }
            else {
                entry.newer = e;
                e.older = entry;
            }
            entry = e;
            if (limit-- === 0) {
                throw new Error("overflow");
            }
        }
        this.newest = entry;
        this.size = this._keymap.size;
    }
    /** Get and register recent use of <key>.
     *  Returns the value associated with <key> or undefined if not in cache.
     */
    get(key) {
        // First, find our cache entry
        const entry = this._keymap.get(key);
        if (!entry)
            return; // Not cached. Sorry.
        // As <key> was found in the cache, register it as being requested recently
        this.markEntryAsUsed(entry);
        return entry.value;
    }
    /** Put <value> into the cache associated with <key>. Replaces any existing entry with the same key.
     *  @returns `this`.
     */
    set(key, value) {
        let entry = this._keymap.get(key);
        if (entry) {
            // update existing
            entry.value = value;
            this.markEntryAsUsed(entry);
            return this;
        }
        // new entry
        this._keymap.set(key, (entry = new Entry(key, value)));
        if (this.newest) {
            // link previous tail to the new tail (entry)
            this.newest.newer = entry;
            entry.older = this.newest;
        }
        else {
            // we're first in
            this.oldest = entry;
        }
        // add new entry to the end of the linked list -- it is now the freshest entry.
        this.newest = entry;
        ++this.size;
        if (this.size > this.limit) {
            // we hit the limit -- remove the head
            this.shift();
        }
        return this;
    }
    /**  Purge the least recently used (oldest) entry from the cache.
     *  @returns The removed entry or undefined if the cache was empty.
     */
    shift() {
        const entry = this.oldest;
        if (entry) {
            if (entry.newer) {
                // advance the list
                this.oldest = entry.newer;
                this.oldest.older = undefined;
            }
            else {
                // the cache is exhausted
                this.oldest = undefined;
                this.newest = undefined;
            }
            // Remove last strong reference to <entry> and remove links from the purged
            // entry being returned:
            entry.newer = entry.older = undefined;
            this._keymap.delete(entry.key);
            --this.size;
            return [entry.key, entry.value];
        }
        return undefined;
    }
    /** Access value for `key` without registering recent use. Useful if you do not
     *  want to change the state of the map, but only "peek" at it.
     *  @returns The value associated with `key` if found, or undefined if not found.
     */
    find(key) {
        const e = this._keymap.get(key);
        return e ? e.value : undefined;
    }
    /** Check if there's a value for key in the cache without registering recent use. */
    has(key) {
        return this._keymap.has(key);
    }
    /**  Remove entry `key` from cache and return its value.
     *  @returns The removed value, or undefined if not found.
     */
    delete(key) {
        const entry = this._keymap.get(key);
        if (!entry)
            return;
        this._keymap.delete(entry.key);
        if (entry.newer && entry.older) {
            // re-link the older entry with the newer entry
            entry.older.newer = entry.newer;
            entry.newer.older = entry.older;
        }
        else if (entry.newer) {
            // remove the link to us
            entry.newer.older = undefined;
            // link the newer entry to head
            this.oldest = entry.newer;
        }
        else if (entry.older) {
            // remove the link to us
            entry.older.newer = undefined;
            // link the newer entry to head
            this.newest = entry.older;
        }
        else {
            this.oldest = this.newest = undefined;
        }
        this.size--;
        return entry.value;
    }
    /**  Removes all entries */
    clear() {
        // Note: clearing links should be safe, as we don't expose live links to user
        this.oldest = this.newest = undefined;
        this.size = 0;
        this._keymap.clear();
    }
    /** Returns an iterator over all keys, starting with the oldest. */
    keys() {
        return this.oldest ? new KeyIterator(this.oldest) : undefined;
    }
    /** Returns an iterator over all values, starting with the oldest. */
    values() {
        return this.oldest ? new ValueIterator(this.oldest) : undefined;
    }
    /** Returns an iterator over all entries, starting with the oldest. */
    entries() {
        return this.oldest ? new EntryIterator(this.oldest) : undefined;
    }
    /**  Call `fun` for each entry, starting with the oldest entry. */
    forEach(fun, thisObj) {
        if (typeof thisObj !== "object") {
            thisObj = this;
        }
        let entry = this.oldest;
        while (entry) {
            fun.call(thisObj, entry.value, entry.key, this);
            entry = entry.newer;
        }
    }
    /** Returns a JSON (array) representation */
    toJSON() {
        const s = new Array(this.size);
        let i = 0;
        let entry = this.oldest;
        while (entry) {
            s[i++] = { key: entry.key, value: entry.value };
            entry = entry.newer;
        }
        return s;
    }
    /** Returns a String representation */
    toString() {
        let s = "";
        let entry = this.oldest;
        while (entry) {
            s += String(entry.key) + ":" + entry.value;
            entry = entry.newer;
            if (entry) {
                s += " < ";
            }
        }
        return s;
    }
}
exports.LRUMap = LRUMap;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
// TextDecoder is not supported on all platforms - this is an alternative for utf-8.
// ###TODO use TextDecoder where available
// From https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/getStringFromTypedArray.js
// which is itself inspired by https://github.com/inexorabletash/text-encoding
var Utf8ToString;
(function (Utf8ToString) {
    function inRange(a, min, max) { return min <= a && a <= max; }
    function utf8Handler(bytes) {
        let codePoint = 0;
        let bytesSeen = 0;
        let bytesNeeded = 0;
        let lowerBoundary = 0x80;
        let upperBoundary = 0xbf;
        const codePoints = [];
        const length = bytes.length;
        for (let i = 0; i < length; i++) {
            const currentByte = bytes[i];
            // If bytesNeeded = 0, then we are starting a new character
            if (0 === bytesNeeded) {
                // 1 byte ascii character
                if (inRange(currentByte, 0x00, 0x7f)) {
                    // return a code point whose value is byte.
                    codePoints.push(currentByte);
                    continue;
                }
                // 2 byte character
                if (inRange(currentByte, 0xc2, 0xdf)) {
                    bytesNeeded = 1;
                    codePoint = currentByte & 0x1f;
                    continue;
                }
                // 3 byte character
                if (inRange(currentByte, 0xe0, 0xef)) {
                    if (0xe0 === currentByte)
                        lowerBoundary = 0xa0;
                    else if (0xed === currentByte)
                        upperBoundary = 0x9f;
                    bytesNeeded = 2;
                    codePoint = currentByte & 0xf;
                    continue;
                }
                // 4 byte character
                if (inRange(currentByte, 0xf0, 0xf4)) {
                    if (0xf0 === currentByte)
                        lowerBoundary = 0x90;
                    else if (0xf4 === currentByte)
                        upperBoundary = 0x8f;
                    bytesNeeded = 3;
                    codePoint = currentByte & 0x7;
                    continue;
                }
                // invalid utf-8
                return undefined;
            }
            // out of range so ignore the first part(s) of the character and continue with this byte on its own
            if (!inRange(currentByte, lowerBoundary, upperBoundary)) {
                codePoint = bytesNeeded = bytesSeen = 0;
                lowerBoundary = 0x80;
                upperBoundary = 0xbf;
                --i;
                continue;
            }
            // set appropriate boundaries since we've now checked byte 2 of a potential longer character
            lowerBoundary = 0x80;
            upperBoundary = 0xbf;
            // add byte to code point
            codePoint = (codePoint << 6) | (currentByte & 0x3f);
            // We have the correct number of bytes, so push and reset for next character
            ++bytesSeen;
            if (bytesSeen === bytesNeeded) {
                codePoints.push(codePoint);
                codePoint = bytesNeeded = bytesSeen = 0;
            }
        }
        return codePoints;
    }
    function decodeWithFromCharCode(view) {
        let result = "";
        const codePoints = utf8Handler(view);
        if (undefined === codePoints)
            return undefined;
        for (let cp of codePoints) {
            if (cp <= 0xffff) {
                result += String.fromCharCode(cp);
            }
            else {
                cp -= 0x10000;
                result += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);
            }
        }
        return result;
    }
    Utf8ToString.decodeWithFromCharCode = decodeWithFromCharCode;
})(Utf8ToString || (Utf8ToString = {}));
/** Utility functions for working with strings. */
var StringUtils;
(function (StringUtils) {
    /** Given an array of bytes containing a utf-8 string, convert to a string.
     * @param utf8: An array of utf-8 characters as a byte array
     * @returns An equivalent string, or undefined if the array does not contain a valid utf-8 string.
     */
    function utf8ToString(utf8) {
        // ###TODO: if available: const decoder = new TextDecoder("utf-8");
        // ###TODO: if available: return decoder.decode(utf8);
        return Utf8ToString.decodeWithFromCharCode(utf8);
    }
    StringUtils.utf8ToString = utf8ToString;
})(StringUtils = exports.StringUtils || (exports.StringUtils = {}));


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 272 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 273 */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: sax
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
     true
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    var _Base64 = global.Base64;
    var version = "2.4.8";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        if (typeof navigator != 'undefined' && navigator.product == 'ReactNative') {
        } else {
            try {
                buffer = __webpack_require__(40).Buffer;
            } catch (err) {}
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    // that's it!
    return {Base64: global.Base64}
}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** Profile of the authenticated user. */
class UserProfile {
    constructor(firstName, lastName, email, userId, organization) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
        this.userId = userId;
        this.organization = organization;
    }
}
exports.UserProfile = UserProfile;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const WsgClient_1 = __webpack_require__(32);
const Request_1 = __webpack_require__(23);
const ECJsonTypeMap_1 = __webpack_require__(9);
/** Connect project */
let Project = class Project extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Project.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Number")
], Project.prototype, "number", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UltimateRefId")
], Project.prototype, "ultimateRefId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AssetId")
], Project.prototype, "assetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataLocationId")
], Project.prototype, "dataLocationId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Industry")
], Project.prototype, "industry", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], Project.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Location")
], Project.prototype, "location", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Latitude")
], Project.prototype, "latitude", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Longitude")
], Project.prototype, "longitude", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CountryCode")
], Project.prototype, "countryCode", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.TimeZoneLocation")
], Project.prototype, "timeZoneLocation", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Status")
], Project.prototype, "status", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RegisteredDate")
], Project.prototype, "registeredDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LastModifiedDate")
], Project.prototype, "lastModifiedDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsRbacEnabled")
], Project.prototype, "isRbacEnabled", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AllowExternalTeamMembers")
], Project.prototype, "allowExternalTeamMembers", void 0);
Project = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "CONNECTEDContext.Project", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Project);
exports.Project = Project;
/** RBAC project */
let RbacProject = class RbacProject extends ECJsonTypeMap_1.WsgInstance {
};
RbacProject = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "RBAC.Project", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RbacProject);
exports.RbacProject = RbacProject;
/** RBAC permission */
let Permission = class Permission extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Permission.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], Permission.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ServiceGPRId")
], Permission.prototype, "serviceGprId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CategoryId")
], Permission.prototype, "categoryId", void 0);
Permission = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "RBAC.Permission", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Permission);
exports.Permission = Permission;
var IModelHubPermissions;
(function (IModelHubPermissions) {
    IModelHubPermissions[IModelHubPermissions["None"] = 0] = "None";
    IModelHubPermissions[IModelHubPermissions["CreateIModel"] = 1] = "CreateIModel";
    IModelHubPermissions[IModelHubPermissions["ReadIModel"] = 2] = "ReadIModel";
    IModelHubPermissions[IModelHubPermissions["ModifyIModel"] = 4] = "ModifyIModel";
    IModelHubPermissions[IModelHubPermissions["ManageResources"] = 8] = "ManageResources";
    IModelHubPermissions[IModelHubPermissions["ManageVersions"] = 16] = "ManageVersions";
})(IModelHubPermissions = exports.IModelHubPermissions || (exports.IModelHubPermissions = {}));
/** Client API to access the connect services. */
class RbacClient extends WsgClient_1.WsgClient {
    constructor(deploymentEnv) {
        super(deploymentEnv, "v2.4", "https://connect-wsg20.bentley.com");
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return RbacClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return RbacClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets connect projects accessible to the authorized user.
     * @param token Delegation token of the authorized user.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of projects.
     */
    async getProjects(token, queryOptions) {
        const userProfile = token.getUserProfile();
        if (!userProfile)
            return Promise.reject(new Error("Invalid access token"));
        const url = "/Repositories/BentleyCONNECT--Main/RBAC/User/" + userProfile.userId + "/Project";
        return this.getInstances(RbacProject, token, url, queryOptions);
    }
    /**
     * Get the permissions relevant to the iModelHubService for a specified project
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the specified project.
     */
    async getIModelHubPermissions(token, projectId) {
        const userProfile = token.getUserProfile();
        if (!userProfile)
            return Promise.reject(new Error("Invalid access token"));
        const relativeUrlPath = "/Repositories/BentleyCONNECT--Main/RBAC/User/" + userProfile.userId + "/Project";
        const url = await this.getUrl() + relativeUrlPath;
        const iModelHubServiceGPRId = 2485;
        const filterStr = `$id+eq+'${projectId}'+and+Permission.ServiceGPRId+eq+${iModelHubServiceGPRId}`;
        const options = {
            method: "GET",
            headers: { authorization: token.toTokenString() },
            qs: {
                $select: "Permission.$id",
                $filter: filterStr,
            },
        };
        await this.setupOptionDefaults(options);
        const res = await Request_1.request(url, options);
        if (!res.body || !res.body.hasOwnProperty("instances"))
            return Promise.reject(new Error("Expected an array of instances to be returned"));
        const instances = res.body.instances;
        if (!instances || instances.length !== 1)
            return Promise.reject(new Error("Project with specified id was not found"));
        let permissions = IModelHubPermissions.None;
        for (const relationshipInstance of instances[0].relationshipInstances) {
            switch (relationshipInstance.relatedInstance.instanceId) {
                case "IMHS_Create_iModel":
                    permissions = permissions | IModelHubPermissions.CreateIModel;
                    break;
                case "IMHS_Read_iModel":
                    permissions = permissions | IModelHubPermissions.ReadIModel;
                    break;
                case "IMHS_Modify_iModel":
                    permissions = permissions | IModelHubPermissions.ModifyIModel;
                    break;
                case "IMHS_ManageResources":
                    permissions = permissions | IModelHubPermissions.ManageResources;
                    break;
                case "IMHS_Manage_Versions":
                    permissions = permissions | IModelHubPermissions.ManageVersions;
                    break;
                default:
            }
        }
        return permissions;
    }
}
RbacClient.searchKey = "RBAC.URL";
RbacClient.defaultUrlDescriptor = {
    DEV: "https://dev-rbac-eus.cloudapp.net",
    QA: "https://qa-connect-rbac.bentley.com",
    PROD: "https://connect-rbac.bentley.com",
    PERF: "https://perf-rbac-eus.cloudapp.net",
};
exports.RbacClient = RbacClient;
/** Client API to access the connect services. */
class ConnectClient extends WsgClient_1.WsgClient {
    constructor(deploymentEnv) {
        super(deploymentEnv, "sv1.0", "https://connect-wsg20.bentley.com");
        this.deploymentEnv = deploymentEnv;
        this.rbacClient = new RbacClient(this.deploymentEnv);
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ConnectClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return ConnectClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets connect projects accessible to the authorized user.
     * @param token Delegation token of the authorized user.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of projects.
     */
    async getProjects(token, queryOptions) {
        return this.getInstances(Project, token, "/Repositories/BentleyCONNECT--Main/ConnectedContext/Project", queryOptions);
    }
    /**
     * Gets a connect project.
     * @param token Delegation token of the authorized user.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to the found project. Rejects if no projects, or more than one project is found.
     */
    async getProject(token, queryOptions) {
        return this.getProjects(token, queryOptions)
            .then((projects) => {
            if (projects.length !== 1) {
                return Promise.reject(new Error("Expected a single project to be returned by query"));
            }
            return Promise.resolve(projects[0]);
        });
    }
    /** Get the projects the user has been "invited" to. Note that this involves querying the RBAC and ConnectedContext services.
     * @param token Delegation token of the authorized user.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of invited projects.
     */
    async getInvitedProjects(token, queryOptions) {
        const rbacQueryOptions = {
            $top: queryOptions ? queryOptions.$top : undefined,
            $skip: queryOptions ? queryOptions.$skip : undefined,
            $filter: "rbaconly+eq+true",
        };
        const invitedProjectIds = await this.rbacClient.getProjects(token, rbacQueryOptions)
            .then((invitedProjects) => invitedProjects.map((val) => val.wsgId));
        const filterStr = "$id+in+[" + invitedProjectIds.reduce((sum, value) => {
            const quotedValue = "'" + value + "'";
            return sum ? sum + "," + quotedValue : quotedValue;
        }, "") + "]";
        const newQueryOptions = queryOptions || {};
        newQueryOptions.$filter = (queryOptions && queryOptions.$filter) ? queryOptions.$filter + "+and+" + filterStr : filterStr;
        return this.getProjects(token, newQueryOptions);
    }
}
ConnectClient.searchKey = "CONNECTEDContextService.URL";
ConnectClient.defaultUrlDescriptor = {
    DEV: "https://dev-wsg20-eus.cloudapp.net",
    QA: "https://qa-connect-wsg20.bentley.com",
    PROD: "https://connect-wsg20.bentley.com",
    PERF: "https://perf-wsg20-eus.cloudapp.net",
};
exports.ConnectClient = ConnectClient;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__(278)
var url = __webpack_require__(113)

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(279)
var response = __webpack_require__(171)
var extend = __webpack_require__(288)
var statusCodes = __webpack_require__(289)
var url = __webpack_require__(113)

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(170)
var inherits = __webpack_require__(50)
var response = __webpack_require__(171)
var stream = __webpack_require__(172)
var toArrayBuffer = __webpack_require__(287)

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(40).Buffer, __webpack_require__(13), __webpack_require__(26)))

/***/ }),
/* 280 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(95).Buffer;
var util = __webpack_require__(282);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 282 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(284);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(26)))

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(179);

/*<replacement>*/
var util = __webpack_require__(70);
util.inherits = __webpack_require__(50);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(40).Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}


/***/ }),
/* 288 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(291)(module), __webpack_require__(13)))

/***/ }),
/* 291 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(294);
exports.encode = exports.stringify = __webpack_require__(295);


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class that provides custom request options for all future requests
 */
class CustomRequestOptions {
    setCustomOptions(customOptions) {
        this._customOptions = customOptions;
    }
    insertCustomOptions(customOptions) {
        if (!this._customOptions) {
            return customOptions;
        }
        if (!customOptions) {
            customOptions = {};
        }
        customOptions = Object.assign({}, customOptions, this._customOptions);
        return customOptions;
    }
    isSet() {
        return null != this._customOptions;
    }
}
exports.CustomRequestOptions = CustomRequestOptions;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Errors_1 = __webpack_require__(49);
const bentleyjs_core_1 = __webpack_require__(0);
const Config_1 = __webpack_require__(31);
const Query_1 = __webpack_require__(41);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Controls whether the user has exclusive or shared access to a local briefcase */
var BriefcaseAccessMode;
(function (BriefcaseAccessMode) {
    BriefcaseAccessMode[BriefcaseAccessMode["Shared"] = 0] = "Shared";
    BriefcaseAccessMode[BriefcaseAccessMode["Exclusive"] = 1] = "Exclusive";
})(BriefcaseAccessMode = exports.BriefcaseAccessMode || (exports.BriefcaseAccessMode = {}));
/** Briefcase */
let Briefcase = class Briefcase extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], Briefcase.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
], Briefcase.prototype, "fileDescription", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], Briefcase.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
], Briefcase.prototype, "fileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "briefcaseId")
], Briefcase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserOwned"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "userId")
], Briefcase.prototype, "userId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MergedChangeSetId")
], Briefcase.prototype, "mergedChangeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AcquiredDate")
], Briefcase.prototype, "acquiredDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsReadOnly"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "isReadOnly")
], Briefcase.prototype, "isReadOnly", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], Briefcase.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "accessMode")
], Briefcase.prototype, "accessMode", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "localPathname")
], Briefcase.prototype, "localPathname", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "lastAccessedAt")
], Briefcase.prototype, "lastAccessedAt", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "iModelId")
], Briefcase.prototype, "iModelId", void 0);
Briefcase = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Briefcase", { schemaPropertyName: "schemaName", classPropertyName: "className" }),
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("ecdb", "ServiceStore.Briefcase", { classKeyPropertyName: "className" })
], Briefcase);
exports.Briefcase = Briefcase;
/**
 * Query object for getting Briefcases. You can use this to modify the query.
 * @see BriefcaseHandler.get()
 */
class BriefcaseQuery extends Query_1.Query {
    /**
     * Query single briefcase by its id.
     * If briefcase is not found, request will be rejected with a [[WsgError]].
     * @param id Id of the briefcase.
     * @returns This query.
     */
    byId(id) {
        this._byId = id;
        return this;
    }
    /**
     * Used by handler to get the id that is queried.
     * @returns Value that was set with byId method.
     */
    getId() {
        return this._byId;
    }
    /**
     * Query will additionally select Briefcase file download URL.
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
}
exports.BriefcaseQuery = BriefcaseQuery;
/** Check if Briefcase Id is valid. */
function isBriefcaseIdValid(briefcaseId) {
    return briefcaseId > 1 && briefcaseId < 16 * 1024 * 1024;
}
exports.isBriefcaseIdValid = isBriefcaseIdValid;
/**
 * Handler for all methods related to @see Briefcase instances.
 */
class BriefcaseHandler {
    /**
     * Constructor for BriefcaseHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /**
     * Gets relative url for Briefcase requests.
     * @param imodelId Id of the iModel.
     * @param briefcaseId Id of the briefcase.
     */
    getRelativeUrl(imodelId, briefcaseId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/Briefcase/${briefcaseId || ""}`;
    }
    /**
     * Acquires a briefcase for the specified iModel
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @returns Resolves to the acquired Briefcase instance.
     */
    async create(token, imodelId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Acquiring briefcase for iModel ${imodelId}`);
        let briefcase = new Briefcase();
        briefcase = await this._handler.postInstance(Briefcase, token, this.getRelativeUrl(imodelId), briefcase);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Acquired briefcase ${briefcase.briefcaseId} for iModel ${imodelId}`);
        return briefcase;
    }
    /**
     * Delete a Briefcase
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel.
     * @param briefcaseId Id of the briefcase to be deleted.
     * @returns Resolves if the Briefcase has been successfully deleted.
     */
    async delete(token, imodelId, briefcaseId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting briefcase ${briefcaseId} from iModel ${imodelId}`);
        if (!isBriefcaseIdValid(briefcaseId))
            return Promise.reject(Errors_1.IModelHubRequestError.invalidArgument("briefcaseId"));
        await this._handler.delete(token, this.getRelativeUrl(imodelId, briefcaseId));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted briefcase ${briefcaseId} from iModel ${imodelId}`);
    }
    /**
     * Gets the briefcases that have been acquired by the user.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Optional query object to filter the queried briefcases and select different data from them.
     * @returns Resolves to the briefcase.
     * @throws [[ResponseError]] if briefcases couldn't be queried.
     */
    async get(token, imodelId, query = new BriefcaseQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying briefcases for iModel ${imodelId}`);
        const id = query.getId();
        if (id && !isBriefcaseIdValid(id))
            return Promise.reject(Errors_1.IModelHubRequestError.invalidArgument("briefcaseId"));
        const briefcases = await this._handler.getInstances(Briefcase, token, this.getRelativeUrl(imodelId, id), query.getQueryOptions());
        for (const briefcase of briefcases) {
            briefcase.iModelId = imodelId;
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${briefcases.length} briefcases for iModel ${imodelId}`);
        return briefcases;
    }
    /**
     * Downloads the briefcase.
     * Creates the directory containing the briefcase if necessary.
     * If there is a error in the operation any incomplete briefcase is deleted from disk.
     * @param briefcase Briefcase to download. This needs to include a download link. @see BriefcaseQuery.selectDownloadUrl().
     * @param downloadToPathname Directory where the briefcase should be downloaded.
     * @param progressCallback Callback for tracking progress.
     * @throws [[ResponseError]] if the briefcase cannot be downloaded.
     * @throws [[IModelHubRequestError]] if this method is used incorrectly.
     */
    async download(briefcase, downloadToPathname, progressCallback) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Downloading briefcase ${briefcase.wsgId} for iModel ${briefcase.iModelId}`);
        if (Config_1.Config.isBrowser())
            return Promise.reject(Errors_1.IModelHubRequestError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubRequestError.fileHandler());
        if (!briefcase.downloadUrl)
            return Promise.reject(Errors_1.IModelHubRequestError.missingDownloadUrl("briefcase"));
        await this._fileHandler.downloadFile(briefcase.downloadUrl, downloadToPathname, parseInt(briefcase.fileSize, 10), progressCallback);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Downloading briefcase ${briefcase.wsgId} for iModel ${briefcase.iModelId}`);
    }
}
exports.BriefcaseHandler = BriefcaseHandler;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Errors_1 = __webpack_require__(49);
const bentleyjs_core_1 = __webpack_require__(0);
const Config_1 = __webpack_require__(31);
const Query_1 = __webpack_require__(41);
const loggingCategory = "imodeljs-clients.imodelhub";
/** ChangeSet */
let ChangeSet = class ChangeSet extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], ChangeSet.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], ChangeSet.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], ChangeSet.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], ChangeSet.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Index")
], ChangeSet.prototype, "index", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ParentId")
], ChangeSet.prototype, "parentId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SeedFileId")
], ChangeSet.prototype, "seedFileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], ChangeSet.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], ChangeSet.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.PushDate")
], ChangeSet.prototype, "pushDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContainingChanges")
], ChangeSet.prototype, "containsSchemaChanges", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsUploaded")
], ChangeSet.prototype, "isUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], ChangeSet.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl")
], ChangeSet.prototype, "uploadUrl", void 0);
ChangeSet = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.ChangeSet", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], ChangeSet);
exports.ChangeSet = ChangeSet;
/**
 * Query object for getting ChangeSets You can use this to modify the query.
 * @see ChangeSetHandler.get()
 */
class ChangeSetQuery extends Query_1.InstanceIdQuery {
    /**
     * Query will additionally select Briefcase file download URL.
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
    /**
     * Query all ChangeSets that are after given ChangeSet id (does not include the specified change set)
     * @param id Id of a ChangeSet.
     * @returns This query.
     */
    fromId(id) {
        this._query.$filter = `FollowingChangeSet-backward-ChangeSet.Id+eq+'${id}'`;
        return this;
    }
    /**
     * Change the order to latest changesets first in the query.
     * @returns This query.
     */
    latest() {
        this._query.$orderby = "Index+desc";
        return this;
    }
    /**
     * Query ChangeSets between changeSets.
     * @param firstChangeSetId Id of the first changeSet.
     * @param secondChangeSetId Id of the second changeSet.
     * @returns This query.
     */
    betweenChangeSets(firstChangeSetId, secondChangeSetId) {
        let query;
        if (!secondChangeSetId) {
            query = `CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;
        }
        else {
            query = `(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;
            query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}')`;
            query += `+or+(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}'`;
            query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}')`;
        }
        this.addFilter(query);
        return this;
    }
    /**
     * Query version changeSets.
     * @param versionId Id of the version.
     * @returns This query.
     */
    getVersionChangeSets(versionId) {
        this.addFilter(`CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'`);
        return this;
    }
    /**
     * Query changeSets after version.
     * @param versionId Id of the version.
     * @returns This query.
     */
    afterVersion(versionId) {
        this.addFilter(`FollowingChangeSet-backward-Version.Id+eq+'${versionId}'`);
        return this;
    }
    /**
     * Query changeSets between two versions.
     * @param sourceVersionId Id of the source version.
     * @param destinationVersionId Id of the destination version.
     * @returns This query.
     */
    betweenVersions(sourceVersionId, destinationVersionId) {
        let query;
        query = `(FollowingChangeSet-backward-Version.Id+eq+'${sourceVersionId}'`;
        query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${destinationVersionId}')`;
        query += `+or+(FollowingChangeSet-backward-Version.Id+eq+'${destinationVersionId}'`;
        query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${sourceVersionId}')`;
        this.addFilter(query);
        return this;
    }
    /**
     * Query changeSets between version and changeSet.
     * @param versionId Id of the version.
     * @param changeSetId Id of the changeSet.
     * @returns This query.
     */
    betweenVersionAndChangeSet(versionId, changeSetId) {
        let query;
        query = `(CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;
        query += `+or+`;
        query += `(FollowingChangeSet-backward-Version.Id+eq+'${versionId}'+and+CumulativeChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;
        this.addFilter(query);
        return this;
    }
    /**
     * Query changeSets by seed file id.
     * @param seedFileId Id of the seed file.
     * @returns This query.
     */
    bySeedFileId(seedFileId) {
        this.addFilter(`SeedFileId+eq+'${seedFileId}'`);
        return this;
    }
}
exports.ChangeSetQuery = ChangeSetQuery;
/**
 * Handler for all methods related to ChangeSets.
 */
class ChangeSetHandler {
    /**
     * Constructor for ChangeSetHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /**
     * Gets relative url for ChangeSet requests.
     * @param imodelId Id of the iModel.
     * @param changeSetId Id of the ChangeSet.
     */
    getRelativeUrl(imodelId, changeSetId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/ChangeSet/${changeSetId || ""}`;
    }
    /** Check if ChangeSet Id is valid. */
    isValid(changesetId) {
        return changesetId.length === 40;
    }
    /**
     * Gets ChangeSets.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object to modify this methods results.
     * @returns Resolves to an array of change sets.
     */
    async get(token, imodelId, query = new ChangeSetQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying changesets for iModel ${imodelId}`);
        const id = query.getId();
        if (id && !this.isValid(id))
            return Promise.reject(Errors_1.IModelHubRequestError.invalidArgument("changeSetId"));
        const changeSets = await this._handler.getInstances(ChangeSet, token, this.getRelativeUrl(imodelId, id), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${changeSets.length} changesets for iModel ${imodelId}`);
        return changeSets;
    }
    /**
     * Downloads the specified ChangeSets.
     * Creates the directory containing the ChangeSets if necessary.
     * If there is an error in downloading some ChangeSet, throws an error and any incomplete ChangeSet is deleted from disk.
     * @param changeSets Change sets to download. These need to include a download link. @see ChangeSetQuery.selectDownloadUrl().
     * @param downloadToPath Directory where the ChangeSets should be downloaded.
     * @param progressCallback Callback for tracking progress.
     */
    async download(changeSets, downloadToPath, progressCallback) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Downloading ${changeSets.length} changesets`);
        if (Config_1.Config.isBrowser())
            return Promise.reject(Errors_1.IModelHubRequestError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubRequestError.fileHandler());
        changeSets.forEach((changeSet) => {
            if (!changeSet.downloadUrl)
                throw Errors_1.IModelHubRequestError.missingDownloadUrl("changeSets");
        });
        const promises = new Array();
        let totalSize = 0;
        let downloadedSize = 0;
        changeSets.forEach((value) => totalSize += parseInt(value.fileSize, 10));
        for (const changeSet of changeSets) {
            const downloadUrl = changeSet.downloadUrl;
            const downloadToPathname = this._fileHandler.join(downloadToPath, changeSet.fileName);
            let previouslyDownloaded = 0;
            const callback = (progress) => {
                downloadedSize += (progress.loaded - previouslyDownloaded);
                previouslyDownloaded = progress.loaded;
                progressCallback({ loaded: downloadedSize, total: totalSize, percent: downloadedSize / totalSize });
            };
            promises.push(this._fileHandler.downloadFile(downloadUrl, downloadToPathname, parseInt(changeSet.fileSize, 10), progressCallback ? callback : undefined));
        }
        await Promise.all(promises);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Downloaded ${changeSets.length} changesets`);
    }
    /**
     * Uploads a ChangeSet
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param changeSet Information of the ChangeSet to be uploaded.
     * @param changeSetPathname Pathname of the ChangeSet to be uploaded.
     * @param progressCallback Callback for tracking progress.
     * @throws [[ResponseError]] if the upload fails.
     */
    async create(token, imodelId, changeSet, changeSetPathname, progressCallback) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Uploading changeset ${changeSet.id} to iModel ${imodelId}`);
        if (Config_1.Config.isBrowser())
            return Promise.reject(Errors_1.IModelHubRequestError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubRequestError.fileHandler());
        if (!this._fileHandler.exists(changeSetPathname) || this._fileHandler.isDirectory(changeSetPathname))
            return Promise.reject(Errors_1.IModelHubRequestError.fileNotFound());
        const postChangeSet = await this._handler.postInstance(ChangeSet, token, this.getRelativeUrl(imodelId), changeSet);
        await this._fileHandler.uploadFile(postChangeSet.uploadUrl, changeSetPathname, progressCallback);
        postChangeSet.uploadUrl = undefined;
        postChangeSet.downloadUrl = undefined;
        postChangeSet.isUploaded = true;
        const confirmChangeSet = await this._handler.postInstance(ChangeSet, token, this.getRelativeUrl(imodelId, postChangeSet.wsgId), postChangeSet);
        changeSet.isUploaded = true;
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Uploaded changeset ${changeSet.id} to iModel ${imodelId}`);
        return confirmChangeSet;
    }
}
exports.ChangeSetHandler = ChangeSetHandler;


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Request_1 = __webpack_require__(23);
const Codes_1 = __webpack_require__(180);
const bentleyjs_core_1 = __webpack_require__(0);
const EventsBase_1 = __webpack_require__(181);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Base type for all iModelHub events */
class IModelHubEvent extends EventsBase_1.IModelHubBaseEvent {
}
exports.IModelHubEvent = IModelHubEvent;
/** Base type for iModelHub events that have BriefcaseId */
class BriefcaseEvent extends IModelHubEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.briefcaseId = obj.BriefcaseId;
    }
}
exports.BriefcaseEvent = BriefcaseEvent;
/** Sent when a Lock is acquired */
class LockEvent extends BriefcaseEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.lockType = obj.LockType;
        this.lockLevel = obj.LockLevel;
        this.objectIds = obj.ObjectIds;
        this.releasedWithChangeSet = obj.ReleasedWithChangeSet;
    }
}
exports.LockEvent = LockEvent;
/** Sent when all Locks for a Briefcase are deleted */
class AllLocksDeletedEvent extends BriefcaseEvent {
}
exports.AllLocksDeletedEvent = AllLocksDeletedEvent;
/** Sent when a ChangeSet is successfully pushed */
class ChangeSetPostPushEvent extends BriefcaseEvent {
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.changeSetId = obj.ChangeSetId;
        this.changeSetIndex = obj.ChangeSetIndex;
    }
}
exports.ChangeSetPostPushEvent = ChangeSetPostPushEvent;
/** Sent when a ChangeSet push has started */
class ChangeSetPrePushEvent extends IModelHubEvent {
}
exports.ChangeSetPrePushEvent = ChangeSetPrePushEvent;
/** Sent when a Code is reserved */
class CodeEvent extends BriefcaseEvent {
    constructor() {
        super(...arguments);
        this.state = Codes_1.CodeState.Reserved;
    }
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.codeSpecId = obj.CodeSpecId;
        this.codeScope = obj.CodeScope;
        this.values = obj.Values;
        this.state = obj.State;
    }
}
exports.CodeEvent = CodeEvent;
/** Sent when all Codes for a Briefcase are deleted */
class AllCodesDeletedEvent extends BriefcaseEvent {
}
exports.AllCodesDeletedEvent = AllCodesDeletedEvent;
/** Sent when a Briefcase is deleted */
class BriefcaseDeletedEvent extends BriefcaseEvent {
}
exports.BriefcaseDeletedEvent = BriefcaseDeletedEvent;
/** Sent when a Seed File is deleted */
class SeedFileReplacedEvent extends IModelHubEvent {
    fromJson(obj) {
        super.fromJson(obj);
        this.fileId = obj.FileId;
    }
}
exports.SeedFileReplacedEvent = SeedFileReplacedEvent;
/** Sent when iModel is locked */
class IModelLockEvent extends IModelHubEvent {
    fromJson(obj) {
        super.fromJson(obj);
        this.locked = obj.Locked;
    }
}
exports.IModelLockEvent = IModelLockEvent;
/** Sent when iModel is deleted */
class IModelDeletedEvent extends IModelHubEvent {
}
exports.IModelDeletedEvent = IModelDeletedEvent;
/** Sent when a new Named Version is created */
class VersionEvent extends IModelHubEvent {
    fromJson(obj) {
        super.fromJson(obj);
        this.versionId = obj.VersionId;
        this.versionName = obj.VersionName;
        this.changeSetId = obj.ChangeSetId;
    }
}
exports.VersionEvent = VersionEvent;
/** Get constructor from EventType name. */
function ConstructorFromEventType(type) {
    switch (type) {
        case "LockEvent":
            return LockEvent;
        case "AllLocksDeletedEvent":
            return AllLocksDeletedEvent;
        case "ChangeSetPostPushEvent":
            return ChangeSetPostPushEvent;
        case "ChangeSetPrePushEvent":
            return ChangeSetPrePushEvent;
        case "CodeEvent":
            return CodeEvent;
        case "AllCodesDeletedEvent":
            return AllCodesDeletedEvent;
        case "BriefcaseDeletedEvent":
            return BriefcaseDeletedEvent;
        case "SeedFileReplacedEvent":
            return SeedFileReplacedEvent;
        case "iModelLockEvent":
            return IModelLockEvent;
        case "iModelDeletedEvent":
            return IModelDeletedEvent;
        case "VersionEvent":
            return VersionEvent;
    }
}
/**
 * Parse @see IModelHubEvent from response object.
 * @param response Response object to parse.
 * @returns Appropriate event object.
 */
function ParseEvent(response) {
    const constructor = ConstructorFromEventType(response.header["content-type"]);
    const event = new constructor();
    event.fromJson(response.body);
    return event;
}
exports.ParseEvent = ParseEvent;
/** EventSubscription */
let EventSubscription = class EventSubscription extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventTypes")
], EventSubscription.prototype, "eventTypes", void 0);
EventSubscription = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.EventSubscription", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], EventSubscription);
exports.EventSubscription = EventSubscription;
/** EventSAS */
let EventSAS = class EventSAS extends EventsBase_1.BaseEventSAS {
};
EventSAS = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.EventSAS", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], EventSAS);
exports.EventSAS = EventSAS;
/**
 * Handler for all methods related to @see EventSubscription instances.
 */
class EventSubscriptionHandler {
    /**
     * Constructor for EventSubscriptionHandler. Should use @see EventHandler instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for EventSubscription requests.
     * @param imodelId Id of the iModel.
     * @param instanceId Id of the subscription.
     */
    getRelativeUrl(imodelId, instanceId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/EventSubscription/${instanceId || ""}`;
    }
    /**
     * Creates event subscription.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param events Array of EventTypes to subscribe to.
     * @return Created EventSubscription instance.
     */
    async create(token, imodelId, events) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Creating event subscription on iModel ${imodelId}`);
        let subscription = new EventSubscription();
        subscription.eventTypes = events;
        subscription = await this._handler.postInstance(EventSubscription, token, this.getRelativeUrl(imodelId), subscription);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Created event subscription on iModel ${imodelId}`);
        return subscription;
    }
    /**
     * Updates event subscription.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param subscription Updated events subscription.
     * @return Updated EventSubscription instance.
     */
    async update(token, imodelId, subscription) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Updating event subscription on iModel ${subscription.wsgId}`);
        const updatedSubscription = await this._handler.postInstance(EventSubscription, token, this.getRelativeUrl(imodelId, subscription.wsgId), subscription);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Updated event subscription on iModel ${subscription.wsgId}`);
        return updatedSubscription;
    }
    /**
     * Deletes event subscription.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param eventSubscriptionId Id of the event subscription.
     * @returns Resolves if the EventSubscription has been successfully deleted.
     */
    async delete(token, imodelId, eventSubscriptionId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting event subscription ${eventSubscriptionId} from iModel ${imodelId}`);
        await this._handler.delete(token, this.getRelativeUrl(imodelId, eventSubscriptionId));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted event subscription ${eventSubscriptionId} from iModel ${imodelId}`);
    }
}
exports.EventSubscriptionHandler = EventSubscriptionHandler;
/**
 * Handler for all methods related to iModel Hub events.
 */
class EventHandler extends EventsBase_1.EventBaseHandler {
    /**
     * Constructor for EventHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        super();
        this._handler = handler;
    }
    /**
     * Get a handler for @see EventSubscription related methods.
     */
    Subscriptions() {
        if (!this._subscriptionHandler) {
            this._subscriptionHandler = new EventSubscriptionHandler(this._handler);
        }
        return this._subscriptionHandler;
    }
    /**
     * Gets relative url for EventSAS requests.
     * @param imodelId Id of the iModel.
     */
    getEventSASRelativeUrl(imodelId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/EventSAS/`;
    }
    /**
     * Gets event SAS Token.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @return SAS Token to connect to the topic.
     */
    async getSASToken(token, imodelId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Getting event SAS token from iModel ${imodelId}`);
        const eventSAS = await this._handler.postInstance(EventSAS, token, this.getEventSASRelativeUrl(imodelId), new EventSAS());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Got event SAS token from iModel ${imodelId}`);
        return eventSAS;
    }
    /**
     * Gets absolute url for event requests.
     * @param baseAddress Base address for the serviceBus.
     * @param subscriptionId Id of the subscription.
     * @param timeout Optional timeout for long polling.
     */
    getEventUrl(baseAddress, subscriptionId, timeout) {
        let url = `${baseAddress}/Subscriptions/${subscriptionId}/messages/head`;
        if (timeout) {
            url = url + `?timeout=${timeout}`;
        }
        return url;
    }
    /**
     * Gets event from Service Bus Topic.
     * @param sasToken Service Bus SAS Token.
     * @param baseAddress Base address of Service Bus topic.
     * @param subscriptionId Id of the subscription to the topic.
     * @param timeout Optional timeout duration in seconds for request, when using long polling.
     * @return Event if it exists, undefined otherwise.
     */
    async getEvent(sasToken, baseAddress, subscriptionId, timeout) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Getting event from subscription ${subscriptionId}`);
        const options = this.getEventRequestOptions(sasToken, timeout);
        const result = await Request_1.request(this.getEventUrl(baseAddress, subscriptionId, timeout), options);
        if (result.status === 204) {
            bentleyjs_core_1.Logger.logTrace(loggingCategory, `No events found on subscription ${subscriptionId}`);
            return undefined;
        }
        const event = ParseEvent(result);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Got event from subscription ${subscriptionId}`);
        return Promise.resolve(event);
    }
    /**
     * Creates a listener for long polling events from a subscription.
     * @param authenticationCallback Callback used to get AccessToken. Only the first registered callback for this subscription will be used.
     * @param subscriptionId Id of subscription.
     * @param imodelId Id of the iModel.
     * @param listener Callback that is called when an event is received.
     * @returns Function that deletes the listener.
     */
    createListener(authenticationCallback, subscriptionId, imodelId, listener) {
        const subscription = new EventsBase_1.ListenerSubscription();
        subscription.authenticationCallback = authenticationCallback;
        subscription.getEvent = (sasToken, baseAddress, id, timeout) => this.getEvent(sasToken, baseAddress, id, timeout);
        subscription.getSASToken = (token) => this.getSASToken(token, imodelId);
        subscription.id = subscriptionId;
        return EventsBase_1.EventListener.create(subscription, listener);
    }
}
exports.EventHandler = EventHandler;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const Errors_1 = __webpack_require__(49);
const Config_1 = __webpack_require__(31);
const Query_1 = __webpack_require__(41);
const bentleyjs_core_1 = __webpack_require__(0);
const loggingCategory = "imodeljs-clients.imodelhub";
/** HubIModel */
let IModelRepository = class IModelRepository extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], IModelRepository.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], IModelRepository.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], IModelRepository.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], IModelRepository.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Initialized")
], IModelRepository.prototype, "initialized", void 0);
IModelRepository = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "ProjectScope.iModel", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], IModelRepository);
exports.IModelRepository = IModelRepository;
var SeedFileInitState;
(function (SeedFileInitState) {
    SeedFileInitState[SeedFileInitState["Successful"] = 0] = "Successful";
    SeedFileInitState[SeedFileInitState["NotStarted"] = 1] = "NotStarted";
    SeedFileInitState[SeedFileInitState["Scheduled"] = 2] = "Scheduled";
    SeedFileInitState[SeedFileInitState["Failed"] = 3] = "Failed";
    SeedFileInitState[SeedFileInitState["OutdatedFile"] = 4] = "OutdatedFile";
    SeedFileInitState[SeedFileInitState["CodeTooLong"] = 5] = "CodeTooLong";
    SeedFileInitState[SeedFileInitState["SeedFileIsBriefcase"] = 6] = "SeedFileIsBriefcase";
})(SeedFileInitState = exports.SeedFileInitState || (exports.SeedFileInitState = {}));
/** SeedFile */
let SeedFile = class SeedFile extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], SeedFile.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
], SeedFile.prototype, "fileDescription", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], SeedFile.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
], SeedFile.prototype, "fileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Index")
], SeedFile.prototype, "index", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IModelName")
], SeedFile.prototype, "iModelName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MergedChangeSetId")
], SeedFile.prototype, "mergedChangeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserUploaded")
], SeedFile.prototype, "userUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UploadedDate")
], SeedFile.prototype, "uploadedDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsUploaded")
], SeedFile.prototype, "isUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.InitializationState")
], SeedFile.prototype, "initializationState", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], SeedFile.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl")
], SeedFile.prototype, "uploadUrl", void 0);
SeedFile = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.SeedFile", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], SeedFile);
exports.SeedFile = SeedFile;
/**
 * Query object for getting SeedFiles. You can use this to modify the query.
 * @see SeedFileHandler.get()
 */
class SeedFileQuery extends Query_1.InstanceIdQuery {
    /**
     * Query will additionally select SeedFile file download URL.
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
    /**
     * Change the order to latest changesets first in the query.
     * @returns This query.
     */
    latest() {
        this._query.$orderby = "Index+desc";
        return this;
    }
}
/**
 * Handler for all methods related to @see SeedFile instances.
 */
class SeedFileHandler {
    /**
     * Constructor for SeedFileHandler. Should use @see IModelHandler instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /**
     * Gets relative url for SeedFile requests.
     * @param imodelId Id of the iModel.
     * @param fileId Id of the Seed File.
     */
    getRelativeUrl(imodelId, fileId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/SeedFile/${fileId || ""}`;
    }
    /**
     * Gets the seed files given the id of the iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object to modify results of this query.
     * @returns Resolves to the seed file.
     */
    async get(token, imodelId, query = new SeedFileQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying seed files for iModel ${imodelId}`);
        const seedFiles = await this._handler.getInstances(SeedFile, token, this.getRelativeUrl(imodelId, query.getId()), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${seedFiles.length} seed files for iModel ${imodelId}`);
        return seedFiles;
    }
    /**
     * Uploads the seed file. Use confirmUploadSeedFile() to confirm the completion of the upload.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param seedFile Information of the SeedFile to be uploaded.
     * @param seedPathname Pathname of the SeedFile to be uploaded.
     * @param progressCallback Callback for tracking progress.
     * @throws [[Error]] if the upload fails.
     */
    async uploadSeedFile(token, imodelId, seedPathname, seedFileDescription, progressCallback) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Uploading seed file to iModel ${imodelId}`);
        const seedFile = new SeedFile();
        seedFile.fileName = this._fileHandler.basename(seedPathname);
        seedFile.fileSize = this._fileHandler.getFileSize(seedPathname).toString();
        if (seedFileDescription)
            seedFile.fileDescription = seedFileDescription;
        const createdSeedFile = await this._handler.postInstance(SeedFile, token, this.getRelativeUrl(imodelId), seedFile);
        await this._fileHandler.uploadFile(createdSeedFile.uploadUrl, seedPathname, progressCallback);
        createdSeedFile.uploadUrl = undefined;
        createdSeedFile.downloadUrl = undefined;
        createdSeedFile.isUploaded = true;
        const confirmSeedFile = await this._handler.postInstance(SeedFile, token, this.getRelativeUrl(imodelId, createdSeedFile.wsgId), createdSeedFile);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Uploaded seed file ${seedFile.wsgId} to iModel ${imodelId}`);
        return confirmSeedFile;
    }
}
/**
 * Query object for getting iModels. You can use this to modify the query.
 * @see IModelHandler.get()
 */
class IModelQuery extends Query_1.InstanceIdQuery {
    /**
     * Query iModel by its name.
     * @param name Name of the iModel.
     * @returns This query.
     */
    byName(name) {
        this.addFilter(`Name+eq+'${name}'`);
        return this;
    }
}
exports.IModelQuery = IModelQuery;
/**
 * Handler for all methods related to @see IModel instances.
 */
class IModelHandler {
    /**
     * Constructor for IModelHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
        this._seedFileHandler = new SeedFileHandler(this._handler, this._fileHandler);
    }
    /**
     * Gets relative url for iModel requests.
     * @param projectId Id of the project.
     * @param imodelId Id of the iModel.
     */
    getRelativeUrl(projectId, imodelId) {
        return `/Repositories/Project--${this._handler.formatProjectIdForUrl(projectId)}/ProjectScope/iModel/${imodelId || ""}`;
    }
    /**
     * Get IModels
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the connect project.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to the found iModel. Rejects if no iModels, or more than one iModel is found.
     */
    async get(token, projectId, query = new IModelQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying iModels in project ${projectId}`);
        const imodels = await this._handler.getInstances(IModelRepository, token, this.getRelativeUrl(projectId, query.getId()), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${imodels.length} iModels in project ${projectId}`);
        return imodels;
    }
    /**
     * Delete an iModel
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the connect project.
     * @param imodelId Id of the iModel to be deleted.
     * @returns Resolves if the iModels have been successfully deleted.
     */
    async delete(token, projectId, imodelId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting iModel with id ${imodelId} from project ${projectId}`);
        if (this._handler.getCustomRequestOptions().isSet()) {
            // In order to add custom request options, request with body is needed.
            const iModelRepository = new IModelRepository();
            iModelRepository.wsgId = imodelId;
            iModelRepository.changeState = "deleted";
            await this._handler.deleteInstance(token, this.getRelativeUrl(projectId, imodelId), iModelRepository);
        }
        else {
            await this._handler.delete(token, this.getRelativeUrl(projectId, imodelId));
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted iModel with id ${imodelId} from project ${projectId}`);
    }
    /**
     * Creates iModel instance
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the connect project.
     * @param iModelName Name of the iModel on the Hub.
     * @param description Description of the iModel on the Hub.
     */
    async createIModelInstance(token, projectId, iModelName, description) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Creating iModel with name ${iModelName} in project ${projectId}`);
        let imodel;
        const iModel = new IModelRepository();
        iModel.name = iModelName;
        if (description)
            iModel.description = description;
        try {
            imodel = await this._handler.postInstance(IModelRepository, token, this.getRelativeUrl(projectId), iModel);
            bentleyjs_core_1.Logger.logTrace(loggingCategory, `Created iModel instance with name ${iModelName} in project ${projectId}`);
        }
        catch (err) {
            if (!(err instanceof Errors_1.IModelHubError) || bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists !== err.errorNumber) {
                bentleyjs_core_1.Logger.logWarning(loggingCategory, `Can not create iModel: ${err.message}`);
                return Promise.reject(err);
            }
            const initialized = err.data.iModelInitialized;
            if (initialized) {
                bentleyjs_core_1.Logger.logWarning(loggingCategory, `Error creating iModel: iModel with name ${iModelName} already exists and is initialized`);
                return Promise.reject(err);
            }
            bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying iModel by name ${iModelName} in project ${projectId}`);
            const imodels = await this.get(token, projectId, new IModelQuery().byName(iModelName));
            bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried iModel by name ${iModelName} in project ${projectId}`);
            if (imodels.length > 0) {
                imodel = imodels[0];
            }
            else {
                bentleyjs_core_1.Logger.logTrace(loggingCategory, `iModel by name: iModel ${iModelName} not found`);
                return Promise.reject(new Error(`iModel by name: iModel ${iModelName} not found`));
            }
        }
        return imodel;
    }
    /**
     * Create an iModel
     * @param token Delegation token of the authorized user.
     * @param projectId Id of the connect project.
     * @param name Name of the iModel on the Hub.
     * @param description Description of the iModel on the Hub.
     * @param progressCallback Callback for tracking progress.
     * @param timeOutInMiliseconds Time to wait for iModel initialization.
     */
    async create(token, projectId, name, pathName, description, progressCallback, timeOutInMilliseconds = 2 * 60 * 1000) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Creating iModel in project ${projectId}`);
        if (Config_1.Config.isBrowser())
            return Promise.reject(Errors_1.IModelHubRequestError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubRequestError.fileHandler());
        if (!this._fileHandler.exists(pathName) || this._fileHandler.isDirectory(pathName))
            return Promise.reject(Errors_1.IModelHubRequestError.fileNotFound());
        const iModel = await this.createIModelInstance(token, projectId, name, description);
        try {
            await this._seedFileHandler.uploadSeedFile(token, iModel.wsgId, pathName, description, progressCallback);
        }
        catch (err) {
            await this.delete(token, projectId, iModel.wsgId);
            return Promise.reject(err);
        }
        const errorMessage = "Cannot upload SeedFile " + pathName;
        const retryDelay = timeOutInMilliseconds / 10;
        for (let retries = 10; retries > 0; --retries) {
            try {
                const confirmUploadSeedFiles = await this._seedFileHandler.get(token, iModel.wsgId);
                const initState = confirmUploadSeedFiles[0].initializationState;
                if (initState === SeedFileInitState.Successful) {
                    bentleyjs_core_1.Logger.logTrace(loggingCategory, `Created iModel with id ${iModel.wsgId} in project ${projectId}`);
                    iModel.initialized = true;
                    return iModel;
                }
                if (initState !== SeedFileInitState.NotStarted && initState !== SeedFileInitState.Scheduled) {
                    bentleyjs_core_1.Logger.logWarning(loggingCategory, errorMessage);
                    return Promise.reject(new Errors_1.IModelHubError(bentleyjs_core_1.IModelHubStatus.SeedFileInitializationFailed, `Seed file initialization failed with status ${SeedFileInitState[initState]}`));
                }
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
            }
            catch (err) {
                bentleyjs_core_1.Logger.logWarning(loggingCategory, errorMessage);
                return Promise.reject(err);
            }
        }
        bentleyjs_core_1.Logger.logWarning(loggingCategory, errorMessage);
        return Promise.reject(new Error("Timed out waiting for seed file initialization."));
    }
    /**
     * Method to download the seed file for iModel.
     * @param accessToken Delegation token of the authorized user.
     * @param imodelId Id of the iModel.
     * @param downloadToPathname Directory where the seed file should be downloaded.
     * @param progressCallback Callback for tracking progress.
     * @returns Resolves when the seed file is successfully downloaded.
     */
    async download(accessToken, imodelId, downloadToPathname, progressCallback) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Downloading seed file for iModel ${imodelId}`);
        if (Config_1.Config.isBrowser())
            return Promise.reject(Errors_1.IModelHubRequestError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubRequestError.fileHandler());
        const seedFiles = await this._seedFileHandler.get(accessToken, imodelId, new SeedFileQuery().selectDownloadUrl().latest());
        if (!seedFiles || !seedFiles[0] || !seedFiles[0].downloadUrl)
            return Promise.reject(Errors_1.IModelHubError.fromId(bentleyjs_core_1.IModelHubStatus.FileDoesNotExist, "Failed to get seed file."));
        await this._fileHandler.downloadFile(seedFiles[0].downloadUrl, downloadToPathname, parseInt(seedFiles[0].fileSize, 10), progressCallback);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Downloading seed file for iModel ${imodelId}`);
    }
}
exports.IModelHandler = IModelHandler;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const ECJsonTypeMap_1 = __webpack_require__(9);
const Request_1 = __webpack_require__(23);
const bentleyjs_core_1 = __webpack_require__(0);
const index_1 = __webpack_require__(69);
const Errors_1 = __webpack_require__(49);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Lock Type enumeration */
var LockType;
(function (LockType) {
    LockType[LockType["Db"] = 0] = "Db";
    LockType[LockType["Model"] = 1] = "Model";
    LockType[LockType["Element"] = 2] = "Element";
    LockType[LockType["Schemas"] = 3] = "Schemas";
})(LockType = exports.LockType || (exports.LockType = {}));
/** Lock Level enumeration */
var LockLevel;
(function (LockLevel) {
    LockLevel[LockLevel["None"] = 0] = "None";
    LockLevel[LockLevel["Shared"] = 1] = "Shared";
    LockLevel[LockLevel["Exclusive"] = 2] = "Exclusive";
})(LockLevel = exports.LockLevel || (exports.LockLevel = {}));
/**
 * Gets encoded instance id for a lock to be used in an URI.
 * @param lock Lock to get instance id for.
 * @returns Encoded lock instance id.
 */
function getLockInstanceId(lock) {
    if (!lock || lock.briefcaseId === undefined || lock.lockType === undefined || !lock.objectId)
        return undefined;
    return `${lock.lockType}-${lock.objectId}-${lock.briefcaseId}`;
}
/**
 * Provider for default LockUpdateOptions, used by LockHandler to set defaults.
 */
class DefaultLockUpdateOptionsProvider {
    /**
     * Creates an instance of DefaultRequestOptionsProvider and sets up the default options.
     */
    constructor() {
        this.defaultOptions = {
            locksPerRequest: 2000,
        };
    }
    /**
     * Augments options with the provider's default values.
     * @note The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this.defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultLockUpdateOptionsProvider = DefaultLockUpdateOptionsProvider;
/** Error for conflicting locks */
class ConflictingLocksError extends Errors_1.IModelHubError {
    /**
     * Create ConflictingLocksError from IModelHubError instance.
     * @param error IModelHubError to get error data from.
     * @returns Undefined if the error is not for a lock conflict, otherwise newly created error instance.
     */
    static fromError(error) {
        if (error.errorNumber !== bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase
            && error.errorNumber !== bentleyjs_core_1.IModelHubStatus.ConflictsAggregate) {
            return undefined;
        }
        const result = new ConflictingLocksError(error.errorNumber);
        deepAssign(result, error);
        result.addLocks(error);
        return result;
    }
    /**
     * Amends this error instance with conflicting locks from another IModelHubError.
     * @param error Error to get additional conflicting locks from.
     */
    addLocks(error) {
        if (!error.data || !error.data.ConflictingLocks) {
            return;
        }
        if (!this.conflictingLocks) {
            this.conflictingLocks = [];
        }
        for (const value of error.data.ConflictingLocks) {
            const instance = { className: "Lock", schemaName: "iModelScope", properties: value };
            const lock = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(Lock, "wsg", instance);
            if (lock) {
                this.conflictingLocks.push(lock);
            }
        }
    }
}
exports.ConflictingLocksError = ConflictingLocksError;
/** Base class for Lock and MultiLock */
class LockBase extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LockType")
], LockBase.prototype, "lockType", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LockLevel")
], LockBase.prototype, "lockLevel", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], LockBase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SeedFileId")
], LockBase.prototype, "seedFileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ReleasedWithChangeSet")
], LockBase.prototype, "releasedWithChangeSet", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ReleasedWithChangeSetIndex")
], LockBase.prototype, "releasedWithChangeSetIndex", void 0);
exports.LockBase = LockBase;
/** Lock */
let Lock = class Lock extends LockBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ObjectId")
], Lock.prototype, "objectId", void 0);
Lock = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Lock", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Lock);
exports.Lock = Lock;
/**
 * MultiLock
 * Data about locks grouped by BriefcaseId, LockLevel and LockType.
 */
let MultiLock = class MultiLock extends LockBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ObjectIds")
], MultiLock.prototype, "objectIds", void 0);
MultiLock = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.MultiLock", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], MultiLock);
exports.MultiLock = MultiLock;
/**
 * Query object for getting Locks. You can use this to modify the query.
 * @see LockHandler.get()
 */
class LockQuery extends index_1.Query {
    constructor() {
        super(...arguments);
        this._isMultiLockQuery = true;
    }
    /**
     * Used by the hanlder to check whether locks in query can be grouped.
     */
    isMultiLockQuery() {
        return this._isMultiLockQuery;
    }
    /**
     * Query Locks by Briefcase id.
     * @param briefcaseId Id of the Briefcase.
     * @returns This query.
     */
    byBriefcaseId(briefcaseId) {
        this.addFilter(`BriefcaseId+eq+${briefcaseId}`);
        return this;
    }
    /**
     * Query Locks by LockType.
     * @param lockType lockType.
     * @returns This query.
     */
    byLockType(lockType) {
        this.addFilter(`LockType+eq+${lockType}`);
        return this;
    }
    /**
     * Query Locks by LockLevel.
     * @param lockLevel lockLevel.
     * @returns This query.
     */
    byLockLevel(lockLevel) {
        this.addFilter(`LockLevel+eq+${lockLevel}`);
        return this;
    }
    /**
     * Query Locks by ObjectId.
     * @param objectId Id of the object.
     * @returns This query.
     */
    byObjectId(objectId) {
        this._isMultiLockQuery = false;
        this.addFilter(`ObjectId+eq+'${objectId}'`);
        return this;
    }
    /**
     * Query Locks by ReleasedWithChangeSet.
     * @param changesetId Id of the changeSet.
     * @returns This query.
     */
    byReleasedWithChangeSet(changeSetId) {
        this.addFilter(`ReleasedWithChangeSet+eq+'${changeSetId}'`);
        return this;
    }
    /**
     * Query Locks by ReleasedWithChangeSetIndex.
     * @param changeSetIndex Index of the changeSet.
     * @returns This query.
     */
    byReleasedWithChangeSetIndex(changeSetIndex) {
        this.addFilter(`ReleasedWithChangeSetIndex+eq+${changeSetIndex}`);
        return this;
    }
    /**
     * Query Locks by their instance ids.
     * @param locks Locks to query. They must have their BriefcaseId, LockType and ObjectId set.
     * @returns This query.
     */
    byLocks(locks) {
        if (locks.length < 1) {
            throw Errors_1.IModelHubRequestError.invalidArgument("locks");
        }
        let filter = "$id+in+[";
        let first = true;
        for (const lock of locks) {
            const id = getLockInstanceId(lock);
            if (!id) {
                throw Errors_1.IModelHubRequestError.invalidArgument("locks");
            }
            first ? first = false : filter += ",";
            filter += `'${id}'`;
        }
        filter += "]";
        this.addFilter(filter);
        this._isMultiLockQuery = false;
        return this;
    }
    /**
     * Select only top entries from the query.
     * This is applied after @see Query.skip parameter.
     * @param n Number of top entries to select.
     * @returns This query.
     */
    top(n) {
        this._isMultiLockQuery = false;
        return super.top(n);
    }
    /**
     * Query unavailable Locks.
     * @param briefcaseId Id of the briefcase.
     * @param lastChangeSetIndex Index of the last changeSet.
     * @returns This query.
     */
    unavailableLocks(briefcaseId, lastChangeSetIndex) {
        let filter = `BriefcaseId+ne+${briefcaseId}`;
        filter += `+and+(LockLevel+gt+0+or+ReleasedWithChangeSetIndex+gt+${lastChangeSetIndex})`;
        this.addFilter(filter);
        return this;
    }
}
exports.LockQuery = LockQuery;
/**
 * Handler for all methods related to @see Lock instances.
 */
class LockHandler {
    /**
     * Constructor for LockHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for Lock requests.
     * @param imodelId Id of the iModel.
     * @param lockId Id of the lock.
     */
    getRelativeUrl(imodelId, multilock = true, lockId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/${multilock ? "MultiLock" : "Lock"}/${lockId || ""}`;
    }
    /** Convert Locks to MultiLocks. */
    static convertLocksToMultiLocks(locks) {
        const map = new Map();
        for (const lock of locks) {
            const id = `${lock.lockType}-${lock.lockLevel}`;
            if (map.has(id)) {
                map.get(id).objectIds.push(lock.objectId);
            }
            else {
                const multiLock = new MultiLock();
                multiLock.changeState = "new";
                multiLock.briefcaseId = lock.briefcaseId;
                multiLock.seedFileId = lock.seedFileId;
                multiLock.releasedWithChangeSet = lock.releasedWithChangeSet;
                multiLock.releasedWithChangeSetIndex = lock.releasedWithChangeSetIndex;
                multiLock.lockLevel = lock.lockLevel;
                multiLock.lockType = lock.lockType;
                multiLock.objectIds = [lock.objectId];
                map.set(id, multiLock);
            }
        }
        return Array.from(map.values());
    }
    /** Convert MultiLocks to Locks. */
    static convertMultiLocksToLocks(multiLocks) {
        const result = [];
        for (const multiLock of multiLocks) {
            for (const value of multiLock.objectIds) {
                const lock = new Lock();
                lock.objectId = value;
                lock.briefcaseId = multiLock.briefcaseId;
                if (lock.seedFileId)
                    lock.seedFileId = multiLock.seedFileId;
                lock.lockLevel = multiLock.lockLevel;
                lock.lockType = multiLock.lockType;
                result.push(lock);
            }
        }
        return result;
    }
    /**
     * Augments update options with defaults returned by the DefaultLockUpdateOptionsProvider.
     * @note The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!LockHandler._defaultUpdateOptionsProvider)
            LockHandler._defaultUpdateOptionsProvider = new DefaultLockUpdateOptionsProvider();
        return LockHandler._defaultUpdateOptionsProvider.assignOptions(options);
    }
    /** Send partial request for lock updates */
    async updateInternal(token, imodelId, locks, updateOptions) {
        let requestOptions;
        if (updateOptions) {
            requestOptions = {};
            requestOptions.CustomOptions = {};
            if (updateOptions.deniedLocks === false) {
                requestOptions.CustomOptions.DetailedError_Codes = "false";
            }
            if (updateOptions.unlimitedReporting) {
                requestOptions.CustomOptions.DetailedError_MaximumInstances = "-1";
            }
            if (updateOptions.continueOnConflict) {
                requestOptions.CustomOptions.ConflictStrategy = "Continue";
            }
            if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0) {
                requestOptions = undefined;
            }
        }
        const result = await this._handler.postInstances(MultiLock, token, `/Repositories/iModel--${imodelId}/$changeset`, LockHandler.convertLocksToMultiLocks(locks), requestOptions);
        return LockHandler.convertMultiLocksToLocks(result);
    }
    /**
     * Updates multiple locks.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param locks Locks to acquire. Requires briefcaseId, seedFileId to be set in the lock. Set queryOnly to true
     * to just check if a lock is available.
     * @param updateOptions Options for the update request.
     * @returns The lock that was just obtained from the server.
     */
    async update(token, imodelId, locks, updateOptions) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Requesting locks for iModel ${imodelId}`);
        updateOptions = updateOptions || {};
        this.setupOptionDefaults(updateOptions);
        const result = [];
        let conflictError;
        const aggregateError = new index_1.AggregateResponseError();
        for (let i = 0; i < locks.length; i += updateOptions.locksPerRequest) {
            const chunk = locks.slice(i, i + updateOptions.locksPerRequest);
            try {
                result.push(...await this.updateInternal(token, imodelId, chunk, updateOptions));
            }
            catch (error) {
                if (error instanceof Request_1.ResponseError) {
                    if (updateOptions && updateOptions.deniedLocks && error instanceof Errors_1.IModelHubError
                        && (error.errorNumber === bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase || error.errorNumber === bentleyjs_core_1.IModelHubStatus.ConflictsAggregate)) {
                        if (conflictError) {
                            conflictError.addLocks(error);
                        }
                        else {
                            conflictError = ConflictingLocksError.fromError(error);
                        }
                        if (!updateOptions.continueOnConflict) {
                            return Promise.reject(conflictError);
                        }
                    }
                    else {
                        aggregateError.errors.push(error);
                    }
                }
            }
        }
        if (conflictError) {
            return Promise.reject(conflictError);
        }
        if (aggregateError.errors.length > 0) {
            return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Requested ${locks.length} locks for iModel ${imodelId}`);
        return result;
    }
    /**
     * Gets the locks that have been acquired for the iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object used to modify results of this query.
     * @returns Resolves to an array of locks.
     */
    async get(token, imodelId, query = new LockQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying locks for iModel ${imodelId}`);
        let locks;
        if (query.isMultiLockQuery()) {
            const result = await this._handler.getInstances(MultiLock, token, this.getRelativeUrl(imodelId), query.getQueryOptions());
            locks = LockHandler.convertMultiLocksToLocks(result);
        }
        else {
            locks = await this._handler.postQuery(Lock, token, this.getRelativeUrl(imodelId, false), query.getQueryOptions());
            locks = locks.map((value) => {
                const result = new Lock();
                result.briefcaseId = value.briefcaseId;
                result.lockLevel = value.lockLevel;
                result.lockType = value.lockType;
                result.objectId = value.objectId;
                if (value.seedFileId)
                    result.seedFileId = value.seedFileId;
                return result;
            });
        }
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried ${locks.length} locks for iModel ${imodelId}`);
        return locks;
    }
    /**
     * Deletes all locks owned by the specified briefcase
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param briefcaseId Id of the briefcacase
     */
    async deleteAll(token, imodelId, briefcaseId) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Deleting all locks from briefcase ${briefcaseId} in iModel ${imodelId}`);
        if (!index_1.isBriefcaseIdValid(briefcaseId))
            return Promise.reject(Errors_1.IModelHubRequestError.invalidArgument("briefcaseId"));
        await this._handler.delete(token, this.getRelativeUrl(imodelId, false, `DeleteAll-${briefcaseId}`));
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Deleted all locks from briefcase ${briefcaseId} in iModel ${imodelId}`);
    }
}
exports.LockHandler = LockHandler;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const bentleyjs_core_1 = __webpack_require__(0);
const Query_1 = __webpack_require__(41);
const loggingCategory = "imodeljs-clients.imodelhub";
/** Version */
let Version = class Version extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], Version.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Version.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], Version.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], Version.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ChangeSetId")
], Version.prototype, "changeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId")
], Version.prototype, "smallThumbnailId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasThumbnail].relatedInstance[LargeThumbnail].instanceId")
], Version.prototype, "largeThumbnailId", void 0);
Version = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Version", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Version);
exports.Version = Version;
/**
 * Query object for getting Versions. You can use this to modify the query.
 * @see VersionHandler.get()
 */
class VersionQuery extends Query_1.InstanceIdQuery {
    /**
     * Query version by its name.
     * @param name Name of the version.
     * @returns This query.
     */
    byName(name) {
        this.addFilter(`Name+eq+'${name}'`);
        return this;
    }
    /**
     * Query version by its changeSet id.
     * @param changesetId Id of the changeSet.
     * @returns This query.
     */
    byChangeSet(changesetId) {
        this.addFilter(`ChangeSetId+eq+'${changesetId}'`);
        return this;
    }
    /**
     * Query will additionally select given sizes ids of thumbnails.
     * @returns This query.
     */
    selectThumbnailId(...sizes) {
        if (!this._query.$select)
            this._query.$select = "*";
        for (const size of sizes) {
            this._query.$select += `,HasThumbnail-forward-${size}Thumbnail.*`;
        }
        return this;
    }
}
exports.VersionQuery = VersionQuery;
/**
 * Handler for all methods related to @see Version instances.
 */
class VersionHandler {
    /**
     * Constructor for VersionHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Gets relative url for Version requests.
     * @param imodelId Id of the iModel.
     * @param versionId Id of the version.
     */
    getRelativeUrl(imodelId, versionId) {
        return `/Repositories/iModel--${imodelId}/iModelScope/Version/${versionId || ""}`;
    }
    /**
     * Gets (the named) versions of an iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel
     * @param query Object used to modify results of this query.
     * @returns Resolves to array of versions.
     */
    async get(token, imodelId, query = new VersionQuery()) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Querying named versions for iModel ${imodelId}`);
        const versions = await this._handler.getInstances(Version, token, this.getRelativeUrl(imodelId, query.getId()), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Queried named versions for iModel ${imodelId}`);
        return versions;
    }
    /**
     * Creates named version of an iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel.
     * @param changeSetId Id of the ChangeSet.
     * @param name Version name.
     * @param description Version description.
     * @returns Created Version instance.
     */
    async create(token, imodelId, changeSetId, name, description) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Creating named version for iModel ${imodelId}, changeSet id: ${changeSetId}`);
        let version = new Version();
        version.changeSetId = changeSetId;
        version.name = name;
        version.description = description;
        version = await this._handler.postInstance(Version, token, this.getRelativeUrl(imodelId), version);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Created named version for iModel ${imodelId}, changeSet id: ${changeSetId}`);
        return version;
    }
    /**
     * Updates named version of an iModel.
     * @param token Delegation token of the authorized user.
     * @param imodelId Id of the iModel.
     * @param version Named version.
     * @returns Updated Version instance.
     */
    async update(token, imodelId, version) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, `Updating named version for iModel ${imodelId}, changeSet id: ${version.changeSetId}`);
        const updatedVersion = await this._handler.postInstance(Version, token, this.getRelativeUrl(imodelId, version.wsgId), version);
        bentleyjs_core_1.Logger.logTrace(loggingCategory, `Updated named version for iModel ${imodelId}, changeSet id: ${version.changeSetId}`);
        return updatedVersion;
    }
}
exports.VersionHandler = VersionHandler;


/***/ }),
/* 303 */
/***/ (function(module, exports) {

// empty (null-loader)

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IModelClient_1 = __webpack_require__(114);
const BaseHandler_1 = __webpack_require__(112);
/** Class that allows access to different iModel Hub class handlers.
 * Handlers should be accessed through an instance of this class, rather than constructed directly.
 */
class IModelHubClient extends IModelClient_1.IModelClient {
    /**
     * Creates an instance of IModelHubClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv = "PROD", fileHandler) {
        super(new BaseHandler_1.IModelBaseHandler(deploymentEnv), deploymentEnv, fileHandler);
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets the (delegation) access token to access the service
     * @param authorizationToken Authorization token.
     * @returns Resolves to the (delegation) access token.
     */
    async getAccessToken(authorizationToken) {
        return this._handler.getAccessToken(authorizationToken);
    }
}
exports.IModelHubClient = IModelHubClient;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ECJsonTypeMap_1 = __webpack_require__(9);
const WsgClient_1 = __webpack_require__(32);
const IModelWebNavigatorClient_1 = __webpack_require__(187);
/** Job */
let Job = class Job extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContextId")
], Job.prototype, "contextId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Data")
], Job.prototype, "data", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataId")
], Job.prototype, "dataId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DocumentId")
], Job.prototype, "documentId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Failure")
], Job.prototype, "failure", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.File")
], Job.prototype, "file", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OwnedBy")
], Job.prototype, "ownedBy", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Status")
], Job.prototype, "status", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Tiles")
], Job.prototype, "tiles", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.TilesId")
], Job.prototype, "tilesId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.VersionId")
], Job.prototype, "versionId", void 0);
Job = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "TilePublisher.Job", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Job);
exports.Job = Job;
/**
 * Client API to query for Tile Jobs.
 */
class TilesGeneratorClient extends WsgClient_1.WsgClient {
    /**
     * Creates an instance of TilesGeneratorClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv, "v2.5", TilesGeneratorClient.defaultUrlDescriptor[deploymentEnv] + "/");
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return TilesGeneratorClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return TilesGeneratorClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Queries for tile generator jobs
     * @param token Delegation token of the authorized user issued for this service.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to array of jobs.
     */
    async getJobs(token, queryOptions) {
        return this.getInstances(Job, token, "/Repositories/BentleyCONNECT--Main/TilePublisher/Job", queryOptions);
    }
    /**
     * Gets a tile gnerator job
     * @param token Delegation token of the authorized user issued for this service.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to the found job. Rejects if no jobs, or more than one job is found.
     */
    async getJob(token, queryOptions) {
        return this.getJobs(token, queryOptions)
            .then((jobs) => {
            if (jobs.length !== 1) {
                return Promise.reject(new Error("Expected a single version to be returned by query"));
            }
            return Promise.resolve(jobs[0]);
        });
    }
    /**
     * Builds the URL to navigate/browse a iModel on the Web
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId Id of the connect project containing the iModel to be navigated.
     * @param iModelId Id of the iModel to be navigated.
     * @param versionId Id of the named version to be navigated.
     */
    async buildWebNavigatorUrl(accessToken, projectId, iModelId, versionId) {
        // The service can be queried ONLY by single instance ID filter.
        const instanceId = `${projectId}--${iModelId}--${versionId}`;
        const queryOptions = {
            $select: "*",
            $filter: `$id+eq+'${instanceId}'`,
        };
        const job = await this.getJob(accessToken, queryOptions);
        const webNavigatorClient = new IModelWebNavigatorClient_1.IModelWebNavigatorClient(this.deploymentEnv);
        const webNavigatorUrl = await webNavigatorClient.getUrl();
        return `${webNavigatorUrl}/?id=${job.tilesId}&projectId=${job.contextId}&dataId=${job.dataId}`;
    }
}
TilesGeneratorClient.searchKey = "3dTilesGenerator.URL";
TilesGeneratorClient.defaultUrlDescriptor = {
    DEV: "https://dev-3dtilesgenerator.bentley.com",
    QA: "https://qa-3dtilesgenerator.bentley.com",
    PROD: "https://3dtilesgenerator.bentley.com",
    PERF: "https://perf-3dtilesgenerator.bentley.com",
};
exports.TilesGeneratorClient = TilesGeneratorClient;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const WsgClient_1 = __webpack_require__(32);
const url_1 = __webpack_require__(113);
const Request_1 = __webpack_require__(23);
const Config_1 = __webpack_require__(31);
/** RealityData */
let RealityData = class RealityData extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], RealityData.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OrganizationId")
], RealityData.prototype, "organizationId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UltimateId")
], RealityData.prototype, "ultimateId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContainerName")
], RealityData.prototype, "containerName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataLocationGuid")
], RealityData.prototype, "dataLocationGuid", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], RealityData.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataSet")
], RealityData.prototype, "dataSet", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Group")
], RealityData.prototype, "group", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], RealityData.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RootDocument")
], RealityData.prototype, "rootDocument", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Size")
], RealityData.prototype, "size", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Classification")
], RealityData.prototype, "classification", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Streamed")
], RealityData.prototype, "streamed", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], RealityData.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Footprint")
], RealityData.prototype, "footprint", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ThumbnailDocument")
], RealityData.prototype, "thumbnailDocument", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MetadataUrl")
], RealityData.prototype, "metadataUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Copyright")
], RealityData.prototype, "copyright", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.TermsOfUse")
], RealityData.prototype, "termsOfUse", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AccuracyInMeters")
], RealityData.prototype, "accuracyInMeters", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ResolutionInMeters")
], RealityData.prototype, "resolutionInMeters", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Visibility")
], RealityData.prototype, "visibility", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Listable")
], RealityData.prototype, "listable", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ModifiedTimestamp")
], RealityData.prototype, "modifiedTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedTimestamp")
], RealityData.prototype, "createdTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OwnedBy")
], RealityData.prototype, "ownedBy", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Version")
], RealityData.prototype, "version", void 0);
RealityData = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "S3MX.RealityData", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RealityData);
exports.RealityData = RealityData;
/** Document */
let FileAccessKey = class FileAccessKey extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Url")
], FileAccessKey.prototype, "url", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], FileAccessKey.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Permissions")
], FileAccessKey.prototype, "permissions", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RequiresConfirmation")
], FileAccessKey.prototype, "requiresConfirmation", void 0);
FileAccessKey = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "FileAccess.FileAccessKey", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], FileAccessKey);
exports.FileAccessKey = FileAccessKey;
/**
 * Client wrapper to Reality Data Service
 */
class RealityDataServicesClient extends WsgClient_1.WsgClient {
    /**
     * Creates an instance of RealityDataServicesClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv, "v2.5", RealityDataServicesClient.defaultUrlDescriptor[deploymentEnv] + "/");
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Potentially a model name will be of this format: {{root}}/{{name}}
     * When this occurs, the tile content requests will be made without the root portion prefixed, which results in 404's
     * As a workaround, when the root document json is fetched, we can determine if a root name exists and if so,
     * save it so we can conditionally prefix it the child tile names when they are requested
     *
     * This method is where we conditionally prefix that root into the name field
     * @param name
     */
    updateModelName(name) {
        // a compound name implies that it includes a forward slash or equivalent character
        const isCompound = name.includes("/") || name.includes("~2F");
        // if the name is already compound or the blobRoot is not set, then we do not prefix the model name as it would be redundant
        // otherwise, we return the name prefixed with that value
        return (!isCompound && !name.includes("%2F") && undefined !== this.blobRoot) ? this.blobRoot + "/" + name : name;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return RealityDataServicesClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return RealityDataServicesClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets reality data properties
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns an array of RealityData
     */
    async getRealityData(token, projectId, tilesId) {
        return this.getInstances(RealityData, token, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${tilesId}`);
    }
    /**
     * Gets a tileset's app data json file access key
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns an array of FileAccessKey
     */
    async getAppDataFileAccessKey(token, projectId, tilesId) {
        return this.getFileAccessKey(token, projectId, tilesId, "Bim_AppData.json");
    }
    /**
     * Gets a tile file access key
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns a string url
     */
    async getFileAccessKey(token, projectId, tilesId, name) {
        const path = encodeURIComponent(tilesId + "/" + this.updateModelName(name)).split("%").join("~");
        return this.getInstances(FileAccessKey, token, `/Repositories/S3MXECPlugin--${projectId}/S3MX/Document/${path}/FileAccess.FileAccessKey?$filter=Permissions+eq+%27Read%27`);
    }
    /**
     * Gets a tileset's tile data blob key url
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns a string url
     */
    async getTileDataBlobUrl(token, projectId, tilesId, name) {
        const keys = await this.getFileAccessKey(token, projectId, tilesId, name);
        return keys[0].url;
    }
    /**
     * Gets a tileset's app data json blob url
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns a string url
     */
    async getAppDataBlobUrl(token, projectId, tilesId) {
        const keys = await this.getFileAccessKey(token, projectId, tilesId, "Bim_AppData.json");
        return keys[0].url;
    }
    /**
     * Gets a tileset's app data json
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns app data json object
     */
    async getAppData(token, projectId, tilesId) {
        return this.getTileJson(token, projectId, tilesId, "Bim_AppData.json");
    }
    /**
     * trims off the TileSets segment from a url
     * @param url string url to cleanup
     * @returns clean url string
     */
    cleanTilesetUrl(url) {
        const path = url.split("//").filter((v) => v !== "TileSets" && v !== "Bim").join("/");
        return path.includes("?") ? path.slice(0, path.indexOf("?")) : path;
    }
    /**
     * Gets a tileset's tile data
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns tile data json
     */
    async getModelData(token, projectId, tilesId, name) {
        return this.getTileJson(token, projectId, tilesId, this.cleanTilesetUrl(name));
    }
    /**
     * Gets a tile access url URL object
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns app URL object for blob url
     */
    async getBlobUrl(token, projectId, tilesId, name) {
        const urlString = await this.getTileDataBlobUrl(token, projectId, tilesId, name);
        if (typeof this.blobUrl === "undefined")
            this.blobUrl = (Config_1.Config.isBrowser()) ? new window.URL(urlString) : new url_1.URL(urlString);
        return Promise.resolve(this.blobUrl);
    }
    /**
     * Gets string url to fetch blob data from
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns string url for blob data
     */
    async getBlobStringUrl(token, projectId, tilesId, name) {
        const url = await this.getBlobUrl(token, projectId, tilesId, name);
        const host = url.origin + url.pathname;
        const query = url.search;
        return `${host}/${this.updateModelName(name)}${query}`;
    }
    /**
     * Gets a tileset's app data json
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns app data json object
     */
    async getTileJson(token, projectId, tilesId, name) {
        const stringUrl = await this.getBlobStringUrl(token, projectId, tilesId, name);
        const options = {
            method: "GET",
            responseType: "json",
        };
        const data = await Request_1.request(stringUrl, options);
        return data.body;
    }
    /**
     * Gets tile content
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @param name name or path of tile
     * @returns array buffer of tile content
     */
    async getTileContent(token, projectId, tilesId, name) {
        const stringUrl = await this.getBlobStringUrl(token, projectId, tilesId, this.cleanTilesetUrl(name));
        const options = {
            method: "GET",
            responseType: "arraybuffer",
        };
        const data = await Request_1.request(stringUrl, options);
        return data.body;
    }
    /**
     * Gets a reality data root document json
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns tile data json
     */
    async getRootDocumentJson(token, projectId, tilesId) {
        const realityData = await this.getRealityData(token, projectId, tilesId);
        const root = realityData[0].rootDocument;
        // if the model is split by a forward slash, then we need to preserve the root so we can prefix it to the blob path used when requesting the tile content
        this.blobRoot = root.includes("/") ? root.split("/")[0] : undefined;
        return (await this.getModelData(token, projectId, tilesId, root));
    }
    /**
     * Gets reality data corresponding to given url
     * @param token Delegation token of the authorized user issued for this service.
     * @param url expected to be similar to this: https://qa-connect-realitydataservices.bentley.com/v2.4/Repositories/S3MXECPlugin--fb1696c8-c074-4c76-a539-a5546e048cc6/S3MX/RealityData/62ad85eb-854f-4814-b7de-3479855a2165/Medium_3SM.json
     * @param tileRequest method to fetch tile data from (either getTileJson or getTileContent)
     * @returns tile data json
     */
    async getTileDataFromUrl(token, url, tileRequest) {
        try {
            const urlParts = url.split("/");
            const projectId = urlParts.find((val) => val.includes("--")).split("--")[1];
            const tilesId = urlParts.find((val) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(val));
            const modelName = url.split(tilesId + "/")[1];
            // if the model is split by a forward slash, then we need to preserve the root so we can prefix it to the blob path used when requesting the tile content
            this.blobRoot = modelName.includes("/") ? modelName.split("/")[0] : undefined;
            return tileRequest(token, projectId, tilesId, modelName);
        }
        catch (ex) {
            throw new Error(ex);
        }
    }
    /**
     * Gets a reality data tile json corresponding to given url
     * @param token Delegation token of the authorized user issued for this service.
     * @param url expected to be similar to this: https://qa-connect-realitydataservices.bentley.com/v2.4/Repositories/S3MXECPlugin--fb1696c8-c074-4c76-a539-a5546e048cc6/S3MX/RealityData/62ad85eb-854f-4814-b7de-3479855a2165/Medium_3SM.json
     * @returns tile data json
     */
    async getTileJsonFromUrl(token, url) {
        return this.getTileDataFromUrl(token, url, this.getTileJson.bind(this));
    }
    /**
     * Gets a reality data tile content corresponding to given url
     * @param token Delegation token of the authorized user issued for this service.
     * @param url expected to be similar to this: https://qa-connect-realitydataservices.bentley.com/v2.4/Repositories/S3MXECPlugin--fb1696c8-c074-4c76-a539-a5546e048cc6/S3MX/RealityData/62ad85eb-854f-4814-b7de-3479855a2165/Medium_3SM.json
     * @returns tile data content
     */
    async getTileContentFromUrl(token, url) {
        return this.getTileDataFromUrl(token, url, this.getTileContent.bind(this));
    }
}
RealityDataServicesClient.searchKey = "RealityDataServices";
RealityDataServicesClient.defaultUrlDescriptor = {
    DEV: "https://dev-realitydataservices-eus.cloudapp.net",
    QA: "https://qa-connect-realitydataservices.bentley.com",
    PROD: "https://connect-realitydataservices.bentley.com",
    PERF: "https://perf-realitydataservices-eus.cloudapp.net",
};
exports.RealityDataServicesClient = RealityDataServicesClient;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const ECJsonTypeMap_1 = __webpack_require__(9);
const WsgClient_1 = __webpack_require__(32);
/** RealityData */
let InstanceData = class InstanceData extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Content")
], InstanceData.prototype, "content", void 0);
InstanceData = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "TileDataAccess.InstanceData", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], InstanceData);
exports.InstanceData = InstanceData;
/**
 * Client wrapper to Tile Data Access Service
 */
class TileDataAccessClient extends WsgClient_1.WsgClient {
    /**
     * Creates an instance of TileDataAccessClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(deploymentEnv) {
        super(deploymentEnv, "v2.5", TileDataAccessClient.defaultUrlDescriptor[deploymentEnv] + "/");
        this.deploymentEnv = deploymentEnv;
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return TileDataAccessClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    getDefaultUrl() {
        return TileDataAccessClient.defaultUrlDescriptor[this.deploymentEnv];
    }
    /**
     * Gets reality data properties
     * @param token Delegation token of the authorized user issued for this service.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns an array of RealityData
     */
    async getPropertyData(token, dataId, elemId) {
        return this.getInstances(InstanceData, token, `/Repositories/BentleyCONNECT--${dataId}/TileDataAccess/InstanceData/${elemId}`);
    }
}
TileDataAccessClient.searchKey = "tilesdataaccess";
TileDataAccessClient.defaultUrlDescriptor = {
    DEV: "https://dev-connect-tilesdataaccess.bentley.com",
    QA: "https://qa-connect-tilesdataaccess.bentley.com",
    PROD: "https://connect-tilesdataaccess.bentley.com",
    PERF: "https://perf-connect-tilesdataaccess.bentley.com",
};
exports.TileDataAccessClient = TileDataAccessClient;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(188));
__export(__webpack_require__(189));


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const BaseHandler_1 = __webpack_require__(112);
const WsgClient_1 = __webpack_require__(32);
const bentleyjs_core_1 = __webpack_require__(0);
const UrlFileHandler_1 = __webpack_require__(115);
const Errors_1 = __webpack_require__(310);
const __1 = __webpack_require__(18);
/**
 * Provides default options for iModelBank requests.
 */
class DefaultIModelBankRequestOptionsProvider extends WsgClient_1.DefaultWsgRequestOptionsProvider {
    constructor(agent) {
        super();
        this.defaultOptions.errorCallback = Errors_1.IModelBankError.parse;
        this.defaultOptions.retryCallback = Errors_1.IModelBankError.shouldRetry;
        this.defaultOptions.agent = agent;
    }
}
function constructUrlFileHandler() {
    return __1.Config.isBrowser() ? undefined : new UrlFileHandler_1.UrlFileHandler();
}
/**
 * This class acts as the WsgClient for other iModelBank Handlers.
 */
class IModelBankHandler extends BaseHandler_1.IModelBaseHandler {
    /**
     * Creates an instance of IModelBankWsgClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(url, keepAliveDuration = 30000) {
        super("PROD", keepAliveDuration, constructUrlFileHandler());
        this._url = url;
    }
    /**
     * Augments request options with defaults returned by the DefaultIModelHubRequestOptionsProvider.
     * Note that the options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!this._defaultIModelBankOptionsProvider)
            this._defaultIModelBankOptionsProvider = new DefaultIModelBankRequestOptionsProvider(this._agent);
        return this._defaultIModelBankOptionsProvider.assignOptions(options);
    }
    formatProjectIdForUrl(_projectId) { return ""; }
    getUrlSearchKey() { bentleyjs_core_1.assert(false, "Bentley cloud-specific method should be factored out of WsgClient base class"); return ""; }
    getDefaultUrl() { return this._url; }
    async getUrl(excludeApiVersion) {
        if (this.url)
            return Promise.resolve(this.url);
        this.url = this.getDefaultUrl();
        if (!excludeApiVersion) {
            this.url += "/" + this.apiVersion;
        }
        return Promise.resolve(this.url);
    }
}
exports.IModelBankHandler = IModelBankHandler;


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const deepAssign = __webpack_require__(48);
const WsgClient_1 = __webpack_require__(32);
const bentleyjs_core_1 = __webpack_require__(0);
const loggingCategory = "imodeljs-clients.imodelhub";
/**
 * Error returned from iModelBank service.
 */
class IModelBankError extends WsgClient_1.WsgError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, getMetaData);
    }
    /**
     * Gets IModelHubStatus from the string value returned by the service.
     * @param error Error id returned by the service.
     * @returns IModelHubStatus id
     */
    static getErrorId(error) {
        const id = bentleyjs_core_1.IModelHubStatus[error.slice(IModelBankError._idPrefix.length)];
        return id ? id : bentleyjs_core_1.IModelHubStatus.Unknown;
    }
    /**
     * Checks whether error could have extended data.
     * @param id Id of the error.
     * @returns True if service can return extended data for this error id.
     */
    static requiresExtendedData(id) {
        switch (id) {
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.FileAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.CodeStateInvalid:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.ConflictsAggregate:
                return true;
            default:
                return false;
        }
    }
    /**
     * Makes extended data available publically.
     */
    copyExtendedData() {
        this.data = this._data;
    }
    /**
     * Creates IModelBankError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     */
    static fromId(id, message) {
        const error = new IModelBankError(id);
        error.name = bentleyjs_core_1.IModelHubStatus[id];
        error.message = message;
        return error;
    }
    /**
     * Attempts to parse IModelBankError from server response.
     * @param response Response from the server.
     * @returns Parsed error.
     */
    static parse(response, log = true) {
        const wsgError = super.parse(response, false);
        if (wsgError instanceof WsgClient_1.WsgError && wsgError.name && wsgError.name.startsWith(IModelBankError._idPrefix)) {
            const errorId = IModelBankError.getErrorId(wsgError.name);
            const error = new IModelBankError(errorId);
            deepAssign(error, wsgError);
            error.errorNumber = errorId;
            if (IModelBankError.requiresExtendedData(error.errorNumber)) {
                error.copyExtendedData();
            }
            if (log)
                error.log();
            return error;
        }
        if (log)
            wsgError.log();
        return wsgError;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error returned by request
     * @param response Response returned by request
     */
    static shouldRetry(error, response) {
        if (response === undefined || response === null) {
            return super.shouldRetry(error, response);
        }
        if (super.parseHttpStatus(response.statusType) === 0 /* Success */) {
            return false;
        }
        const parsedError = IModelBankError.parse({ response }, false);
        if (!(parsedError instanceof WsgClient_1.WsgError)) {
            return super.shouldRetry(error, response);
        }
        if ((parsedError instanceof IModelBankError)) {
            return false;
        }
        const errorCodesToRetry = [94212 /* ServerError */,
            98305 /* Unknown */];
        const errorStatus = super.getErrorStatus(parsedError.name !== undefined ?
            super.getWSStatusId(parsedError.name) : 98305 /* Unknown */, response.statusType);
        return errorCodesToRetry.includes(errorStatus);
    }
    /**
     * Get log function
     */
    getLogLevel() {
        switch (this.errorNumber) {
            case bentleyjs_core_1.IModelHubStatus.AnotherUserPushing:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
                return bentleyjs_core_1.Logger.logWarning;
            default:
                return bentleyjs_core_1.Logger.logError;
        }
    }
    /**
     * Logs this error
     */
    log() {
        (this.getLogLevel())(loggingCategory, this.logMessage(), this.getMetaData());
    }
}
IModelBankError._idPrefix = "iModelHub.";
exports.IModelBankError = IModelBankError;
/**
 * Errors for incorrect iModel Hub requests.
 */
class IModelHubRequestError extends IModelBankError {
    /**
     * Creates IModelHubRequestError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     */
    static fromId(id, message) {
        const error = new IModelHubRequestError(id, message);
        error.log();
        return error;
    }
    /**
     * Create error for undefined arguments being passed.
     * @param argumentName Undefined argument name
     * @returns Created error.
     */
    static undefinedArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.UndefinedArgumentError, `Argument ${argumentName} is null or undefined`);
    }
    /**
     * Create error for invalid arguments being passed.
     * @param argumentName Invalid argument name
     * @returns Created error.
     */
    static invalidArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.InvalidArgumentError, `Argument ${argumentName} has an invalid value.`);
    }
    /**
     * Create error for arguments being passed that are missing download URL.
     * @param argumentName Argument name
     * @returns Created error.
     */
    static missingDownloadUrl(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.MissingDownloadUrlError, `Supplied ${argumentName} must include download URL. Use selectDownloadUrl() when getting ${argumentName}.`);
    }
    /**
     * Create error for incompatible operation being used in browser.
     * @returns Created error.
     */
    static browser() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.NotSupportedInBrowser, "Operation is not supported in browser.");
    }
    /**
     * Create error for incompatible operation being used in browser.
     * @returns Created error.
     */
    static fileHandler() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileHandlerNotSet, "File handler is required to be set for file download / upload.");
    }
    /**
     * Create error for a missing file.
     * @returns Created error.
     */
    static fileNotFound() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileNotFound, "Could not find the file to upload.");
    }
}
exports.IModelHubRequestError = IModelHubRequestError;
/** Class for aggregating multiple errors from multiple requests */
class AggregateResponseError extends Error {
    constructor() {
        super(...arguments);
        this.errors = [];
    }
}
exports.AggregateResponseError = AggregateResponseError;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module ECSQL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
/** Describes the different data types an ECSQL value can be of.
 *
 * See also [ECSQL]($docs/learning/ECSQL).
 */
var ECSqlValueType;
(function (ECSqlValueType) {
    // do not change the values of the enum as it must match its counterpart in the addon
    ECSqlValueType[ECSqlValueType["Blob"] = 1] = "Blob";
    ECSqlValueType[ECSqlValueType["Boolean"] = 2] = "Boolean";
    ECSqlValueType[ECSqlValueType["DateTime"] = 3] = "DateTime";
    ECSqlValueType[ECSqlValueType["Double"] = 4] = "Double";
    ECSqlValueType[ECSqlValueType["Geometry"] = 5] = "Geometry";
    ECSqlValueType[ECSqlValueType["Id"] = 6] = "Id";
    ECSqlValueType[ECSqlValueType["Int"] = 7] = "Int";
    ECSqlValueType[ECSqlValueType["Int64"] = 8] = "Int64";
    ECSqlValueType[ECSqlValueType["Point2d"] = 9] = "Point2d";
    ECSqlValueType[ECSqlValueType["Point3d"] = 10] = "Point3d";
    ECSqlValueType[ECSqlValueType["String"] = 11] = "String";
    ECSqlValueType[ECSqlValueType["Navigation"] = 12] = "Navigation";
    ECSqlValueType[ECSqlValueType["Struct"] = 13] = "Struct";
    ECSqlValueType[ECSqlValueType["PrimitiveArray"] = 14] = "PrimitiveArray";
    ECSqlValueType[ECSqlValueType["StructArray"] = 15] = "StructArray";
    ECSqlValueType[ECSqlValueType["Guid"] = 16] = "Guid";
})(ECSqlValueType = exports.ECSqlValueType || (exports.ECSqlValueType = {}));
/** Type of an [ECSqlTypedString]($common) */
var ECSqlStringType;
(function (ECSqlStringType) {
    /** The string represents a BLOB value, formatted as Base64 string. */
    ECSqlStringType[ECSqlStringType["Blob"] = 0] = "Blob";
    /** The string represents a DateTime value, formatted as ISO8601 string. */
    ECSqlStringType[ECSqlStringType["DateTime"] = 1] = "DateTime";
    /** The string represents a GUID value, formatted as GUID string (see [Guid]($bentleyjs-core)). */
    ECSqlStringType[ECSqlStringType["Guid"] = 2] = "Guid";
    /** The string represents an Id value, formatted as hexadecimal string (see [Id64]($bentleyjs-core)). */
    ECSqlStringType[ECSqlStringType["Id"] = 3] = "Id";
    /** The string is not specifically typed. */
    ECSqlStringType[ECSqlStringType["String"] = 4] = "String";
})(ECSqlStringType = exports.ECSqlStringType || (exports.ECSqlStringType = {}));
/** Equivalent of the ECEnumeration OpCode in the **ECDbChange** ECSchema.
 *
 * The enum can be used when programmatically binding values to the InstanceChange.OpCode property of
 * the ECDbChange ECSchema.
 *
 *  See also
 *  - [ChangeSummary Overview]($docs/learning/ChangeSummaries)
 */
var ChangeOpCode;
(function (ChangeOpCode) {
    ChangeOpCode[ChangeOpCode["Insert"] = 1] = "Insert";
    ChangeOpCode[ChangeOpCode["Update"] = 2] = "Update";
    ChangeOpCode[ChangeOpCode["Delete"] = 4] = "Delete";
})(ChangeOpCode = exports.ChangeOpCode || (exports.ChangeOpCode = {}));
/** The enum represents the values for the ChangedValueState argument of the ECSQL function
 *  **Changes**.
 *
 * The enum can be used when programmatically binding values to the ChangedValueState argument
 * in an ECSQL using the **Changes** ECSQL function.
 *
 *  See also
 *  - [ChangeSummary Overview]($docs/learning/ChangeSummaries)
 */
var ChangedValueState;
(function (ChangedValueState) {
    ChangedValueState[ChangedValueState["AfterInsert"] = 1] = "AfterInsert";
    ChangedValueState[ChangedValueState["BeforeUpdate"] = 2] = "BeforeUpdate";
    ChangedValueState[ChangedValueState["AfterUpdate"] = 3] = "AfterUpdate";
    ChangedValueState[ChangedValueState["BeforeDelete"] = 4] = "BeforeDelete";
})(ChangedValueState = exports.ChangedValueState || (exports.ChangedValueState = {}));
/** Defines the ECSQL system properties.
 *
 * See also [ECSQL]($docs/learning/ECSQL).
 */
var ECSqlSystemProperty;
(function (ECSqlSystemProperty) {
    ECSqlSystemProperty[ECSqlSystemProperty["ECInstanceId"] = 0] = "ECInstanceId";
    ECSqlSystemProperty[ECSqlSystemProperty["ECClassId"] = 1] = "ECClassId";
    ECSqlSystemProperty[ECSqlSystemProperty["SourceECInstanceId"] = 2] = "SourceECInstanceId";
    ECSqlSystemProperty[ECSqlSystemProperty["SourceECClassId"] = 3] = "SourceECClassId";
    ECSqlSystemProperty[ECSqlSystemProperty["TargetECInstanceId"] = 4] = "TargetECInstanceId";
    ECSqlSystemProperty[ECSqlSystemProperty["TargetECClassId"] = 5] = "TargetECClassId";
    ECSqlSystemProperty[ECSqlSystemProperty["NavigationId"] = 6] = "NavigationId";
    ECSqlSystemProperty[ECSqlSystemProperty["NavigationRelClassId"] = 7] = "NavigationRelClassId";
    ECSqlSystemProperty[ECSqlSystemProperty["PointX"] = 8] = "PointX";
    ECSqlSystemProperty[ECSqlSystemProperty["PointY"] = 9] = "PointY";
    ECSqlSystemProperty[ECSqlSystemProperty["PointZ"] = 10] = "PointZ";
})(ECSqlSystemProperty = exports.ECSqlSystemProperty || (exports.ECSqlSystemProperty = {}));
/** Utility to format ECProperty names according to the iModelJs formatting rules.
 *
 *  See also [ECSQL Row Format]($docs/learning/ECSQLRowFormat).
 */
class ECJsNames {
    /** Formats the specified ECProperty name according to the iModelJs formatting rules.
     *
     *  See [ECSQL Row Format]($docs/learning/ECSQLRowFormat) which describes the formatting rules.
     *
     * @param ecProperty Property name as defined in the ECSchema for regular ECProperties
     *        or the name of an ECSQL system properties
     * @param isSystemProperty if ommitted, the method will try to find out whether the given property
     *        is a system property or not. If true is specified, the method will throw if the property name
     *        is not a known system property. If false is specified, the method will not attempt to recognize
     *        the property name as system property.
     */
    static toJsName(propName, isSystemProperty) {
        bentleyjs_core_1.assert(propName !== undefined, "propName must not be undefined");
        const propTypeUnknown = isSystemProperty === undefined || isSystemProperty === null;
        const accessStringTokens = propName.split(".");
        const tokenCount = accessStringTokens.length;
        bentleyjs_core_1.assert(tokenCount > 0);
        if (tokenCount === 1) {
            if (propTypeUnknown || isSystemProperty) {
                if (propName === "ECInstanceId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.ECInstanceId);
                if (propName === "ECClassId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.ECClassId);
                if (propName === "SourceECInstanceId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.SourceECInstanceId);
                if (propName === "TargetECInstanceId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.TargetECInstanceId);
                if (propName === "SourceECClassId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.SourceECClassId);
                if (propName === "TargetECClassId")
                    return ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.TargetECClassId);
                if (propTypeUnknown)
                    return ECJsNames.lowerFirstChar(propName);
                throw new Error(`Property ${propName} is no ECSQL system property.`);
            }
            return ECJsNames.lowerFirstChar(propName);
        }
        // parse access string and convert the leaf tokens if they are system props
        // The first char of the access string is lowered.
        let jsName = ECJsNames.lowerFirstChar(accessStringTokens[0] + ".");
        for (let j = 1; j < tokenCount - 1; j++) {
            jsName += accessStringTokens[j] + ".";
        }
        const leafToken = accessStringTokens[tokenCount - 1];
        if (propTypeUnknown || isSystemProperty) {
            if (leafToken === "Id")
                jsName += ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.NavigationId);
            else if (leafToken === "RelECClassId")
                jsName += ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.NavigationRelClassId);
            else if (leafToken === "X")
                jsName += ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.PointX);
            else if (leafToken === "Y")
                jsName += ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.PointY);
            else if (leafToken === "Z")
                jsName += ECJsNames.systemPropertyToJsName(ECSqlSystemProperty.PointZ);
            else if (propTypeUnknown)
                jsName += ECJsNames.lowerFirstChar(leafToken);
            else
                throw new Error(`Property ${leafToken} of access string ${propName} is no ECSQL system property.`);
        }
        else
            jsName += leafToken;
        return jsName;
    }
    /** Returns the name of the specified ECSQL system property according to the
     *  iModelJs formatting rules.
     *
     *  See [ECSQL Row Format]($docs/learning/ECSQLRowFormat) which describes the formatting rules.
     * @param systemPropertyType System property type
     */
    static systemPropertyToJsName(systemPropertyType) {
        switch (systemPropertyType) {
            case ECSqlSystemProperty.ECInstanceId:
            case ECSqlSystemProperty.NavigationId:
                return "id";
            case ECSqlSystemProperty.ECClassId:
                return "className";
            case ECSqlSystemProperty.SourceECInstanceId:
                return "sourceId";
            case ECSqlSystemProperty.SourceECClassId:
                return "sourceClassName";
            case ECSqlSystemProperty.TargetECInstanceId:
                return "targetId";
            case ECSqlSystemProperty.TargetECClassId:
                return "targetClassName";
            case ECSqlSystemProperty.NavigationRelClassId:
                return "relClassName";
            case ECSqlSystemProperty.PointX:
                return "x";
            case ECSqlSystemProperty.PointY:
                return "y";
            case ECSqlSystemProperty.PointZ:
                return "z";
            default:
                throw new Error(`Unknown ECSqlSystemProperty enum value ${systemPropertyType}.`);
        }
    }
    static lowerFirstChar(name) { return name[0].toLowerCase() + name.substring(1); }
}
exports.ECJsNames = ECJsNames;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
*--------------------------------------------------------------------------------------------*/
/** @module WireFormats */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const ElementProps_1 = __webpack_require__(193);
/** Metadata for a property. */
class PropertyMetaData {
    constructor(jsonObj) {
        this.primitiveType = jsonObj.primitiveType;
        if (jsonObj.structName)
            this.structName = jsonObj.structName;
        this.extendedType = jsonObj.extendedType;
        this.description = jsonObj.description;
        this.displayLabel = jsonObj.displayLabel;
        if (undefined !== jsonObj.minimumValue)
            this.minimumValue = jsonObj.minimumValue;
        if (undefined !== jsonObj.maximumValue)
            this.maximumValue = jsonObj.maximumValue;
        if (undefined !== jsonObj.minimumLength)
            this.minimumLength = jsonObj.minimumLength;
        if (undefined !== jsonObj.maximumLength)
            this.maximumLength = jsonObj.maximumLength;
        this.readOnly = jsonObj.readOnly;
        this.kindOfQuantity = jsonObj.kindOfQuantity;
        this.isCustomHandled = jsonObj.isCustomHandled;
        if (undefined !== jsonObj.minOccurs)
            this.minOccurs = jsonObj.minOccurs;
        if (undefined !== jsonObj.maxOccurs)
            this.maxOccurs = jsonObj.maxOccurs;
        this.direction = jsonObj.direction;
        this.relationshipClass = jsonObj.relationshipClass;
        this.customAttributes = jsonObj.customAttributes;
    }
    /** Create a typed value, or array of values, from a factory and an input object */
    createValueOrArray(func, jsonObj) {
        if (undefined === this.minOccurs)
            return func(jsonObj); // not an array
        const val = [];
        jsonObj.forEach((element) => val.push(func(element)));
        return val;
    }
    /** construct a single property from an input object according to this metadata */
    createProperty(jsonObj) {
        if (jsonObj === undefined)
            return undefined;
        if (undefined !== this.primitiveType) {
            switch (this.primitiveType) {
                case 513 /* Boolean */:
                case 1025 /* Double */:
                case 1281 /* Integer */:
                case 2305 /* String */:
                    return jsonObj; // this works even for arrays or strings that are JSON because the parsed JSON is already the right type
                case 1793 /* Point2d */:
                    return this.createValueOrArray(geometry_core_1.Point2d.fromJSON, jsonObj);
                case 2049 /* Point3d */:
                    return this.createValueOrArray(geometry_core_1.Point3d.fromJSON, jsonObj);
            }
        }
        if (this.direction !== undefined)
            return jsonObj.id !== undefined ? new ElementProps_1.RelatedElement(jsonObj) : bentleyjs_core_1.Id64.fromJSON(jsonObj);
        return jsonObj;
    }
}
exports.PropertyMetaData = PropertyMetaData;
/** Metadata for an Entity. */
class EntityMetaData {
    constructor(jsonObj) {
        this.ecclass = jsonObj.ecclass;
        this.description = jsonObj.description;
        this.modifier = jsonObj.modifier;
        this.displayLabel = jsonObj.displayLabel;
        this.baseClasses = jsonObj.baseClasses;
        this.customAttributes = jsonObj.customAttributes;
        this.properties = {};
        for (const propName in jsonObj.properties) {
            if (propName)
                this.properties[propName] = new PropertyMetaData(jsonObj.properties[propName]);
        }
    }
}
exports.EntityMetaData = EntityMetaData;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module FeatureGates */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A set of "gates" that can enable or disable [features at runtime]($docs/learning/common/FeatureGates.md).
 */
class FeatureGates {
    constructor() {
        this.gates = {};
    }
    /**
     * Get the value of a potentially gated feature.
     * @param feature the name of the feature to check. May be a "path" of period-separated feature sub-groups (e.g. "feature1.groupA.showMe").
     *       Feature names are case-sensitive.
     * @param defaultVal optionally, value to return if feature is undefined.
     */
    check(feature, defaultVal) {
        if (feature.length === 0)
            return defaultVal;
        let gate = this.gates;
        for (const name of feature.split(".")) {
            gate = gate[name];
            if (typeof gate !== "object")
                break;
        }
        switch (typeof gate) {
            case "undefined":
                return defaultVal;
            case "object":
                return Object.assign(gate); // always return a copy of objects so caller doesn't accidentally change their value.
        }
        return gate;
    }
    /**
     * Gate access to a feature.
     * @param feature the name of the feature to gate. May be a "path" of period-separated feature sub-groups (e.g. "feature1.groupA.showMe").
     *  Feature names are case-sensitive.
     * @param val value to set
     */
    setGate(feature, val) {
        if (feature.length === 0 || typeof val === "undefined")
            return;
        let gate = this.gates;
        const arr = feature.split(".");
        while (arr.length > 1) {
            const obj = gate[arr[0]];
            if (typeof obj !== "object")
                gate[arr[0]] = {};
            gate = gate[arr.shift()];
        }
        gate[arr[0]] = val;
    }
}
exports.FeatureGates = FeatureGates;


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const ColorDef_1 = __webpack_require__(58);
class NonUniformColor {
    constructor(colors, indices, hasAlpha) {
        this.colors = new Uint32Array(colors.buffer);
        this.indices = new Uint16Array(indices.buffer);
        this.isOpaque = !hasAlpha;
    }
}
exports.NonUniformColor = NonUniformColor;
class ColorIndex {
    get hasAlpha() { return !this.color.isOpaque; }
    get isUniform() { return this.color instanceof ColorDef_1.ColorDef; }
    get numColors() { return this.isUniform ? 1 : this.nonUniform.colors.length; }
    constructor() { this.color = ColorDef_1.ColorDef.white.clone(); }
    reset() { this.color = ColorDef_1.ColorDef.white.clone(); }
    get uniform() { return this.isUniform ? this.color : undefined; }
    initUniform(color) { this.color = ("number" === typeof color) ? new ColorDef_1.ColorDef(color) : color.clone(); }
    get nonUniform() { return !this.isUniform ? this.color : undefined; }
    initNonUniform(colors, indices, hasAlpha) {
        this.color = new NonUniformColor(colors, indices, hasAlpha);
    }
}
exports.ColorIndex = ColorIndex;
class FeatureIndex {
    constructor() {
        this.type = 0 /* Empty */;
        this.featureID = 0;
        this.reset();
    }
    isUniform() { return 1 /* Uniform */ === this.type; }
    isEmpty() { return 0 /* Empty */ === this.type; }
    reset() { this.type = 0 /* Empty */; this.featureID = 0; this.featureIDs = undefined; }
}
exports.FeatureIndex = FeatureIndex;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/** The 8 corners of an [[Npc]] Frustum. */
// tslint:disable-next-line:variable-name
exports.NpcCorners = [
    new geometry_core_1.Point3d(0.0, 0.0, 0.0),
    new geometry_core_1.Point3d(1.0, 0.0, 0.0),
    new geometry_core_1.Point3d(0.0, 1.0, 0.0),
    new geometry_core_1.Point3d(1.0, 1.0, 0.0),
    new geometry_core_1.Point3d(0.0, 0.0, 1.0),
    new geometry_core_1.Point3d(1.0, 0.0, 1.0),
    new geometry_core_1.Point3d(0.0, 1.0, 1.0),
    new geometry_core_1.Point3d(1.0, 1.0, 1.0),
];
exports.NpcCorners.forEach((corner) => Object.freeze(corner));
Object.freeze(exports.NpcCorners);
// tslint:disable-next-line:variable-name
exports.NpcCenter = new geometry_core_1.Point3d(.5, .5, .5);
Object.freeze(exports.NpcCenter);
/**
 * The region of physical (3d) space that appears in a view. It forms the field-of-view of a camera.
 *
 * It is stored as 8 points, in [[Npc]] order, that must define a truncated pyramid.
 */
class Frustum {
    /** Constructor for Frustum. Members are initialized to the Npc cube. */
    constructor() {
        /** Array of the 8 points of this Frustum. */
        this.points = [];
        for (let i = 0; i < 8; ++i)
            this.points[i] = exports.NpcCorners[i].clone();
    }
    /** Initialize this Frustum to the 8 corners of the NPC cube. */
    initNpc() { for (let i = 0; i < 8; ++i)
        geometry_core_1.Point3d.createFrom(exports.NpcCorners[i], this.points[i]); return this; }
    /** Get a corner Point from this Frustum. */
    getCorner(i) { return this.points[i]; }
    /** Get the point at the center of this Frustum (halfway between RightTopFront and LeftBottomRear. */
    getCenter() { return this.getCorner(7 /* RightTopFront */).interpolate(0.5, this.getCorner(0 /* LeftBottomRear */)); }
    /** Get the distance between two corners of this Frustum. */
    distance(corner1, corner2) { return this.getCorner(corner1).distance(this.getCorner(corner2)); }
    /** Get the ratio of the length of the diagonal of the front plane to the diagonal of the back plane. */
    getFraction() { return geometry_core_1.Geometry.safeDivideFraction(this.distance(6 /* LeftTopFront */, 5 /* RightBottomFront */), this.distance(2 /* LeftTopRear */, 1 /* RightBottomRear */), 0); }
    /** Multiply all the points of this Frustum by a Transform, in place. */
    multiply(trans) { trans.multiplyPoint3dArrayInPlace(this.points); }
    /** Offset all of the points of this Frustum by a vector. */
    translate(offset) { for (const pt of this.points)
        pt.plus(offset); }
    /** Transform all the points of this Frustum and return the result in another Frustum. */
    transformBy(trans, result) { result = result ? result : new Frustum(); trans.multiplyPoint3dArray(this.points, result.points); return result; }
    /** Calculate a bounding range from the 8 points in this Frustum. */
    toRange(range) { range = range ? range : new geometry_core_1.Range3d(); geometry_core_1.Range3d.createArray(this.points, range); return range; }
    /** Make a copy of this Frustum.
     * @param result Optional Frustum for copy. If undefined allocate a new Frustum.
     */
    clone(result) { result = result ? result : new Frustum(); result.setFrom(this); return result; }
    /** Set the points of this Frustum to be copies of the points in another Frustum. */
    setFrom(other) { for (let i = 0; i < 8; ++i) {
        this.points[i].setFrom(other.points[i]);
    } }
    /** Scale this Frustum, in place, about its center by a scale factor. */
    scaleAboutCenter(scale) {
        const orig = this.clone();
        const f = 0.5 * (1.0 + scale);
        orig.points[7 /* _111 */].interpolate(f, orig.points[0 /* _000 */], this.points[0 /* _000 */]);
        orig.points[6 /* _011 */].interpolate(f, orig.points[1 /* _100 */], this.points[1 /* _100 */]);
        orig.points[5 /* _101 */].interpolate(f, orig.points[2 /* _010 */], this.points[2 /* _010 */]);
        orig.points[4 /* _001 */].interpolate(f, orig.points[3 /* _110 */], this.points[3 /* _110 */]);
        orig.points[3 /* _110 */].interpolate(f, orig.points[4 /* _001 */], this.points[4 /* _001 */]);
        orig.points[2 /* _010 */].interpolate(f, orig.points[5 /* _101 */], this.points[5 /* _101 */]);
        orig.points[1 /* _100 */].interpolate(f, orig.points[6 /* _011 */], this.points[6 /* _011 */]);
        orig.points[0 /* _000 */].interpolate(f, orig.points[7 /* _111 */], this.points[7 /* _111 */]);
    }
    /** Create a Map4d that converts world coordinates to/from [[Npc]] coordinates of this Frustum. */
    toMap4d() {
        const org = this.getCorner(0 /* LeftBottomRear */);
        const xVec = org.vectorTo(this.getCorner(1 /* RightBottomRear */));
        const yVec = org.vectorTo(this.getCorner(2 /* LeftTopRear */));
        const zVec = org.vectorTo(this.getCorner(4 /* LeftBottomFront */));
        return geometry_core_1.Map4d.createVectorFrustum(org, xVec, yVec, zVec, this.getFraction());
    }
    /** Invalidate this Frustum by setting all 8 points to zero. */
    invalidate() { for (let i = 0; i < 8; ++i)
        this.points[i].set(0, 0, 0); }
    /** Return true if this Frustum is equal to another Frustum */
    equals(rhs) {
        for (let i = 0; i < 8; ++i) {
            if (!this.points[i].isExactEqual(rhs.points[i]))
                return false;
        }
        return true;
    }
    /** Return true if all of the points in this Frustum are *almost* the same as the points in another Frustum.
     * @see [[equals]], [XYZ.isAlmostEqual]($geometry)
     */
    isSame(other) { for (let i = 0; i < 8; ++i) {
        if (!this.points[i].isAlmostEqual(other.points[i]))
            return false;
    } return true; }
    /** Initialize this Frustum from a Range */
    initFromRange(range) {
        const getZ = (arg) => arg.z !== undefined ? arg.z : 0;
        const pts = this.points;
        pts[0].x = pts[3].x = pts[4].x = pts[7].x = range.low.x;
        pts[1].x = pts[2].x = pts[5].x = pts[6].x = range.high.x;
        pts[0].y = pts[1].y = pts[4].y = pts[5].y = range.low.y;
        pts[2].y = pts[3].y = pts[6].y = pts[7].y = range.high.y;
        pts[0].z = pts[1].z = pts[2].z = pts[3].z = getZ(range.low);
        pts[4].z = pts[5].z = pts[6].z = pts[7].z = getZ(range.high);
    }
    /** Create a new Frustum from a Range3d */
    static fromRange(range, out) {
        const frustum = undefined !== out ? out : new Frustum();
        frustum.initFromRange(range);
        return frustum;
    }
    /** Return true if this Frustum has a mirror (is not in the correct order.) */
    hasMirror() {
        const pts = this.points;
        const u = pts[0 /* _000 */].vectorTo(pts[4 /* _001 */]);
        const v = pts[0 /* _000 */].vectorTo(pts[2 /* _010 */]);
        const w = pts[0 /* _000 */].vectorTo(pts[1 /* _100 */]);
        return (u.tripleProduct(v, w) > 0);
    }
    /** Make sure the frustum point order does not include mirroring. If so, reverse the order. */
    fixPointOrder() {
        if (!this.hasMirror())
            return;
        // frustum has mirroring, reverse points
        const pts = this.points;
        for (let i = 0; i < 8; i += 2) {
            const tmpPoint = pts[i];
            pts[i] = pts[i + 1];
            pts[i + 1] = tmpPoint;
        }
    }
    /** Get a convex set of clipping planes bounding the region contained by this Frustum. */
    getRangePlanes(clipFront, clipBack, expandPlaneDistance) {
        const convexSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        const scratchNormal = geometry_core_1.Vector3d.create();
        geometry_core_1.Vector3d.createCrossProductToPoints(this.points[5], this.points[3], this.points[1], scratchNormal);
        if (scratchNormal.normalizeInPlace())
            convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[1]) - expandPlaneDistance));
        geometry_core_1.Vector3d.createCrossProductToPoints(this.points[2], this.points[4], this.points[0], scratchNormal);
        if (scratchNormal.normalizeInPlace())
            convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));
        geometry_core_1.Vector3d.createCrossProductToPoints(this.points[3], this.points[6], this.points[2], scratchNormal);
        if (scratchNormal.normalizeInPlace())
            convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[2]) - expandPlaneDistance));
        geometry_core_1.Vector3d.createCrossProductToPoints(this.points[4], this.points[1], this.points[0], scratchNormal);
        if (scratchNormal.normalizeInPlace())
            convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));
        if (clipBack) {
            geometry_core_1.Vector3d.createCrossProductToPoints(this.points[1], this.points[2], this.points[0], scratchNormal);
            if (scratchNormal.normalizeInPlace())
                convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));
        }
        if (clipFront) {
            geometry_core_1.Vector3d.createCrossProductToPoints(this.points[6], this.points[5], this.points[4], scratchNormal);
            if (scratchNormal.normalizeInPlace())
                convexSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[4]) - expandPlaneDistance));
        }
        return convexSet;
    }
}
exports.Frustum = Frustum;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Symbology */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FontMap holds the table of known fonts available in an iModel.
 * A font is referenced by an "id" that is local to the iModel. This table maps those local ids to a FontProps.
 */
class FontMap {
    constructor(props) {
        this.fonts = new Map();
        props.fonts.forEach((font) => this.fonts.set(font.id, font));
    }
    toJSON() {
        const fonts = [];
        this.fonts.forEach((font) => fonts.push(font));
        return { fonts };
    }
    /** look up a font by name or number and return its FontProps */
    getFont(arg) {
        if (typeof arg === "number")
            return this.fonts.get(arg);
        for (const font of this.fonts.values())
            if (font.name === arg)
                return font;
        return undefined;
    }
}
exports.FontMap = FontMap;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ColorDef_1 = __webpack_require__(58);
const geometry_core_1 = __webpack_require__(1);
/** A light to illuminate the contents of a scene. */
class Light {
    constructor(opts) {
        opts = opts ? opts : {};
        this.lightType = bentleyjs_core_1.JsonUtils.asInt(opts.lightType);
        this.intensity = bentleyjs_core_1.JsonUtils.asDouble(opts.intensity);
        this.kelvin = bentleyjs_core_1.JsonUtils.asDouble(opts.kelvin);
        this.shadows = bentleyjs_core_1.JsonUtils.asDouble(opts.shadows);
        this.bulbs = bentleyjs_core_1.JsonUtils.asInt(opts.bulbs);
        this.lumens = bentleyjs_core_1.JsonUtils.asDouble(opts.lumens);
        this.color = ColorDef_1.ColorDef.fromJSON(opts.color);
        if (opts.intensity2)
            this.intensity2 = bentleyjs_core_1.JsonUtils.asDouble(opts.intensity2);
        if (opts.color2)
            this.color2 = ColorDef_1.ColorDef.fromJSON(opts.color2);
    }
    isValid() { return this.lightType !== 0 /* Invalid */; }
    isVisible() { return this.isValid() && this.intensity > 0.0; }
}
exports.Light = Light;
/** A light from a single location. */
class Spot extends Light {
    constructor(opts) {
        opts = opts ? opts : {};
        super(opts);
        this.lightType = 6 /* Spot */;
        this.inner = geometry_core_1.Angle.fromJSON(opts.inner);
        this.outer = geometry_core_1.Angle.fromJSON(opts.outer);
    }
}
exports.Spot = Spot;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const Utility_1 = __webpack_require__(197);
const bentleyjs_core_1 = __webpack_require__(0);
class OctEncodedNormal {
    constructor(val) {
        this._value = 0;
        this.init(val);
    }
    get value() { return Utility_1.PointUtil.toUint16(this._value); }
    init(val) { this._value = Utility_1.PointUtil.isNumber(val) ? val : OctEncodedNormal.encode(val); }
    decode() { return OctEncodedNormal.decode(this.value); }
    static clamp(val, minVal, maxVal) {
        return val < minVal ? minVal : (val > maxVal ? maxVal : val);
    }
    static signNotZero(val) {
        return val < 0.0 ? -1.0 : 1.0;
    }
    static toUInt16(val) {
        return Utility_1.PointUtil.toUint16(0.5 + (OctEncodedNormal.clamp(val, -1, 1) * 0.5 + 0.5) * 255);
    }
    static decode(val) {
        let ex = val & 0xff;
        let ey = val >> 8;
        ex = ex / 255.0 * 2.0 - 1.0;
        ey = ey / 255.0 * 2.0 - 1.0;
        const n = new geometry_core_1.Vector3d(ex, ey, 1 - (Math.abs(ex) + Math.abs(ey)));
        if (n.z < 0) {
            const x = n.x;
            const y = n.y;
            n.x = (1 - Math.abs(y)) * OctEncodedNormal.signNotZero(x);
            n.y = (1 - Math.abs(x)) * OctEncodedNormal.signNotZero(y);
        }
        return n.normalize();
    }
    static encode(vec) {
        OctEncodedNormal.verifyNormalized(vec);
        const denom = Math.abs(vec.x) + Math.abs(vec.y) + Math.abs(vec.z);
        let rx = vec.x / denom;
        let ry = vec.y / denom;
        if (vec.z < 0) {
            const x = rx;
            const y = ry;
            rx = (1 - Math.abs(y)) * OctEncodedNormal.signNotZero(x);
            ry = (1 - Math.abs(x)) * OctEncodedNormal.signNotZero(y);
        }
        const value = OctEncodedNormal.toUInt16(ry) << 8 | OctEncodedNormal.toUInt16(rx);
        OctEncodedNormal.verifyEncoded(value, vec);
        return value;
    }
    static verifyNormalized(vec) {
        const magSq = vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;
        bentleyjs_core_1.assert(Math.abs(magSq - 1) < 0.001);
    }
    static verifyEncoded(val, inVal) {
        const enc = new OctEncodedNormal(val);
        const out = enc.decode();
        bentleyjs_core_1.assert(typeof out !== "undefined" && inVal.isAlmostEqual(out, 0.05));
    }
}
exports.OctEncodedNormal = OctEncodedNormal;
class Pair {
    constructor(first, second) {
        this.first = first;
        this.second = second;
    }
}
exports.Pair = Pair;
class OctEncodedNormalPair extends Pair {
    constructor(first, second) {
        super(first instanceof OctEncodedNormal ? first : new OctEncodedNormal(first), second instanceof OctEncodedNormal ? second : new OctEncodedNormal(second));
    }
}
exports.OctEncodedNormalPair = OctEncodedNormalPair;


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const geometry_core_2 = __webpack_require__(1);
const bentleyjs_core_1 = __webpack_require__(0);
/**
 * Provides facilities for quantizing floating point values within a specified range into 16-bit unsigned integers.
 * This is a lossy compression technique.
 * Given a floating point range [min, max], a floating point value `x` within that range is quantized by subtracting
 * `min`, scaling the result according to `max`, and truncating the result to an integer.
 * Therefore min quantizes to 0, max to 0xffff, (min+max)/2 to 0x7fff, and so on.
 * These routines are chiefly used internally by classes like QPoint2d and QPoint3d.
 */
var Quantization;
(function (Quantization) {
    const rangeScale = 0xffff;
    function computeScale(extent) { return 0.0 === extent ? extent : rangeScale / extent; }
    Quantization.computeScale = computeScale;
    function isInRange(qpos) { return qpos >= 0.0 && qpos < rangeScale + 1.0; }
    Quantization.isInRange = isInRange;
    function quantize(pos, origin, scale) { return Math.floor(Math.max(0.0, Math.min(rangeScale, 0.5 + (pos - origin) * scale))); }
    Quantization.quantize = quantize;
    function isQuantizable(pos, origin, scale) { return isInRange(quantize(pos, origin, scale)); }
    Quantization.isQuantizable = isQuantizable;
    function unquantize(qpos, origin, scale) { return 0.0 === scale ? origin : origin + qpos / scale; }
    Quantization.unquantize = unquantize;
    function isQuantized(qpos) { return isInRange(qpos) && qpos === Math.floor(qpos); }
    Quantization.isQuantized = isQuantized;
})(Quantization = exports.Quantization || (exports.Quantization = {}));
/** Parameters used for quantization of 2d points. */
class QParams2d {
    constructor(ox = 0, oy = 0, sx = 0, sy = 0) {
        this.origin = new geometry_core_2.Point2d();
        this.scale = new geometry_core_2.Point2d();
        this.setFrom(ox, oy, sx, sy);
    }
    setFrom(ox, oy, sx, sy) {
        this.origin.x = ox;
        this.origin.y = oy;
        this.scale.x = sx;
        this.scale.y = sy;
    }
    copyFrom(src) { this.setFrom(src.origin.x, src.origin.y, src.scale.x, src.scale.y); }
    clone(out) {
        const result = undefined !== out ? out : new QParams2d();
        result.copyFrom(this);
        return result;
    }
    /** Initialize these parameters to support quantization of values within the specified range. */
    setFromRange(range) {
        if (!range.isNull()) {
            this.setFrom(range.low.x, range.low.y, Quantization.computeScale(range.high.x - range.low.x), Quantization.computeScale(range.high.y - range.low.y));
        }
        else {
            this.origin.x = this.origin.y = this.scale.x = this.scale.y = 0;
        }
    }
    /** Creates parameters to support quantization of values within the specified range. */
    static fromRange(range, out) {
        const params = undefined !== out ? out : new QParams2d();
        params.setFromRange(range);
        return params;
    }
    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0]. */
    static fromNormalizedRange() { return QParams2d.fromRange(geometry_core_1.Range2d.createArray([geometry_core_2.Point2d.create(-1, -1), geometry_core_2.Point2d.create(1, 1)])); }
    /** Creates parameters supporting quantization of values within the range [0.0, 1.0]. */
    static fromZeroToOne() { return QParams2d.fromRange(geometry_core_1.Range2d.createArray([geometry_core_2.Point2d.create(0, 0), geometry_core_2.Point2d.create(1, 1)])); }
}
exports.QParams2d = QParams2d;
/** Represents a quantized 2d point as an (x, y) pair in the integer range [0, 0xffff]. */
class QPoint2d {
    constructor() {
        this._x = 0;
        this._y = 0;
    }
    get x() { return this._x; }
    set x(x) { bentleyjs_core_1.assert(Quantization.isQuantized(x)); this._x = x; }
    get y() { return this._y; }
    set y(y) { bentleyjs_core_1.assert(Quantization.isQuantized(y)); this._y = y; }
    /** Initialize this point by quantizing the supplied Point2d using the specified params */
    init(pos, params) {
        this.x = Quantization.quantize(pos.x, params.origin.x, params.scale.x);
        this.y = Quantization.quantize(pos.y, params.origin.y, params.scale.y);
    }
    /** Creates a quantized point from the supplied Point2d using the specified params */
    static create(pos, params) {
        const qpt = new QPoint2d();
        qpt.init(pos, params);
        return qpt;
    }
    copyFrom(src) {
        this.x = src.x;
        this.y = src.y;
    }
    clone(out) {
        const result = undefined !== out ? out : new QPoint2d();
        result.copyFrom(this);
        return result;
    }
    /**
     * Sets the x and y components directly.
     * @param x Must be an integer in the range [0, 0xffff]
     * @param y Must be an integer in the range [0, 0xffff]
     */
    setFromScalars(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Creates a QPoint2d directly from x and y components.
     * @param x Must be an integer in the range [0, 0xffff]
     * @param y Must be an integer in the range [0, 0xffff]
     */
    static fromScalars(x, y) {
        const pt = new QPoint2d();
        pt.setFromScalars(x, y);
        return pt;
    }
    /** Returns a Point2d unquantized according to the supplied params. */
    unquantize(params, out) {
        const pt = undefined !== out ? out : new geometry_core_2.Point2d();
        pt.x = Quantization.unquantize(this.x, params.origin.x, params.scale.x);
        pt.y = Quantization.unquantize(this.y, params.origin.y, params.scale.y);
        return pt;
    }
}
exports.QPoint2d = QPoint2d;
/** A list of 2d points all quantized to the same range. */
class QPoint2dList {
    constructor(params) {
        this._list = new Array();
        this.params = params.clone();
    }
    /** Clears out the contents of the list */
    clear() { this._list.length = 0; }
    /** Clears out the contents of the list and changes the quantization parameters. */
    reset(params) { this.clear(); this.params.copyFrom(params); }
    /** Quantizes the supplied Point2d to this list's range and appends it to the list. */
    add(pt) { this._list.push(QPoint2d.create(pt, this.params)); }
    /** Adds a previously-quantized point to this list. */
    push(qpt) { this._list.push(qpt.clone()); }
    /** Returns the number of points in the list. */
    get length() { return this._list.length; }
    /** Returns the unquantized value of the point at the specified index in the list. */
    unquantize(index, out) {
        bentleyjs_core_1.assert(index < this.length);
        if (index < this.length) {
            return this._list[index].unquantize(this.params, out);
        }
        else {
            return undefined !== out ? out : new geometry_core_2.Point2d();
        }
    }
    /** Changes the quantization parameters and requantizes all points in the list to the new range. */
    requantize(params) {
        for (let i = 0; i < this.length; i++) {
            const pt = this.unquantize(i);
            this._list[i].init(pt, params);
        }
        this.params.copyFrom(params);
    }
    /** Extracts the current contents of the list as a Uint16Array. */
    toTypedArray() {
        const array = new Uint16Array(this.length * 2);
        const pts = this._list;
        for (let i = 0; i < this.length; i++) {
            const pt = pts[i];
            array[i * 2] = pt.x;
            array[i * 2 + 1] = pt.y;
        }
        return array;
    }
}
exports.QPoint2dList = QPoint2dList;
/** Parameters used for quantization of 3d points. */
class QParams3d {
    constructor(ox = 0, oy = 0, oz = 0, sx = 0, sy = 0, sz = 0) {
        this.origin = new geometry_core_2.Point3d();
        this.scale = new geometry_core_2.Point3d();
        this.setFrom(ox, oy, oz, sx, sy, sz);
    }
    setFrom(ox, oy, oz, sx, sy, sz) {
        this.origin.x = ox;
        this.origin.y = oy;
        this.origin.z = oz;
        this.scale.x = sx;
        this.scale.y = sy;
        this.scale.z = sz;
    }
    copyFrom(src) { this.setFrom(src.origin.x, src.origin.y, src.origin.z, src.scale.x, src.scale.y, src.scale.z); }
    clone(out) {
        const result = undefined !== out ? out : new QParams3d();
        result.copyFrom(this);
        return result;
    }
    /** Initialize from origin and scale */
    setFromOriginAndScale(origin, scale) { this.setFrom(origin.x, origin.y, origin.z, scale.x, scale.y, scale.z); }
    /** Initialize these parameters to support quantization of values within the specified range. */
    setFromRange(range) {
        if (!range.isNull()) {
            this.setFrom(range.low.x, range.low.y, range.low.z, Quantization.computeScale(range.high.x - range.low.x), Quantization.computeScale(range.high.y - range.low.y), Quantization.computeScale(range.high.z - range.low.z));
        }
        else {
            this.origin.x = this.origin.y = this.origin.z = 0;
            this.scale.x = this.scale.y = this.scale.z = 0;
        }
    }
    /** Creates parameters to support quantization of values within the specified range. */
    static fromRange(range, out) {
        const params = undefined !== out ? out : new QParams3d();
        params.setFromRange(range);
        return params;
    }
    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0]. */
    static fromOriginAndScale(origin, scale, out) {
        const params = undefined !== out ? out : new QParams3d();
        params.setFromOriginAndScale(origin, scale);
        return params;
    }
    /** Creates parameters supporting quantization of values within the range [-1.0, 1.0]. */
    static fromNormalizedRange() { return QParams3d.fromRange(geometry_core_1.Range3d.createArray([geometry_core_2.Point3d.create(-1, -1, -1), geometry_core_2.Point3d.create(1, 1, 1)])); }
    /** Creates parameters supporting quantization of values within the range [0.0, 1.0]. */
    static fromZeroToOne() { return QParams3d.fromRange(geometry_core_1.Range3d.createArray([geometry_core_2.Point3d.create(0, 0, 0), geometry_core_2.Point3d.create(1, 1, 1)])); }
}
exports.QParams3d = QParams3d;
/** Represents a quantized 3d point as an (x, y, z) tripliet in the integer range [0, 0xffff]. */
class QPoint3d {
    constructor() {
        this._x = 0;
        this._y = 0;
        this._z = 0;
    }
    get x() { return this._x; }
    set x(x) { bentleyjs_core_1.assert(Quantization.isQuantized(x)); this._x = x; }
    get y() { return this._y; }
    set y(y) { bentleyjs_core_1.assert(Quantization.isQuantized(y)); this._y = y; }
    get z() { return this._z; }
    set z(z) { bentleyjs_core_1.assert(Quantization.isQuantized(z)); this._z = z; }
    /** Initialize this point by quantizing the supplied Point3d using the specified params */
    init(pos, params) {
        this.x = Quantization.quantize(pos.x, params.origin.x, params.scale.x);
        this.y = Quantization.quantize(pos.y, params.origin.y, params.scale.y);
        this.z = Quantization.quantize(pos.z, params.origin.z, params.scale.z);
    }
    /** Creates a quantized point from the supplied Point3d using the specified params */
    static create(pos, params) {
        const qpt = new QPoint3d();
        qpt.init(pos, params);
        return qpt;
    }
    copyFrom(src) {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
    }
    clone(out) {
        const result = undefined !== out ? out : new QPoint3d();
        result.copyFrom(this);
        return result;
    }
    /**
     * Sets the x, y, and z components directly.
     * @param x Must be an integer in the range [0, 0xffff]
     * @param y Must be an integer in the range [0, 0xffff]
     * @param z Must be an integer in the range [0, 0xffff]
     */
    setFromScalars(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    /**
     * Creates a QPoint3d directly from x, y, and z components.
     * @param x Must be an integer in the range [0, 0xffff]
     * @param y Must be an integer in the range [0, 0xffff]
     * @param z Must be an integer in the range [0, 0xffff]
     */
    static fromScalars(x, y, z, out) {
        const pt = undefined === out ? new QPoint3d() : out;
        pt.setFromScalars(x, y, z);
        return pt;
    }
    /** Returns a Point3d unquantized according to the supplied params. */
    unquantize(params, out) {
        const pt = undefined !== out ? out : new geometry_core_2.Point3d();
        pt.x = Quantization.unquantize(this.x, params.origin.x, params.scale.x);
        pt.y = Quantization.unquantize(this.y, params.origin.y, params.scale.y);
        pt.z = Quantization.unquantize(this.z, params.origin.z, params.scale.z);
        return pt;
    }
    equals(other) {
        return this.x === other.x && this.y === other.y && this.z === other.z;
    }
    compare(rhs) {
        let diff = this.x - rhs.x;
        if (0 === diff) {
            diff = this.y - rhs.y;
            if (0 === diff) {
                diff = this.z - rhs.z;
            }
        }
        return diff;
    }
}
exports.QPoint3d = QPoint3d;
/** A list of 3d points all quantized to the same range. */
class QPoint3dList extends bentleyjs_core_1.Iterable {
    get list() { return this._list; }
    constructor(paramsIn) {
        super();
        this.params = paramsIn ? paramsIn.clone() : QParams3d.fromRange(geometry_core_1.Range3d.createNull());
    }
    /** Construct a QPoint3dList containing all points in the supplied list, quantized to the range of those points. */
    static fromPoints(points) {
        const qpoints = new QPoint3dList(QParams3d.fromRange(geometry_core_1.Range3d.createArray(points)));
        for (const point of points)
            qpoints.add(point);
        return qpoints;
    }
    /** Clears out the contents of the list */
    clear() { this._list.length = 0; }
    /** Clears out the contents of the list and changes the quantization parameters. */
    reset(params) { this.clear(); this.params.copyFrom(params); }
    /** Quantizes the supplied Point3d to this list's range and appends it to the list. */
    add(pt) { this._list.push(QPoint3d.create(pt, this.params)); }
    /** Adds a previously-quantized point to this list. */
    push(qpt) { this._list.push(qpt.clone()); }
    /** Returns the number of points in the list. */
    get length() { return this._list.length; }
    /** Returns the unquantized value of the point at the specified index in the list. */
    unquantize(index, out) {
        bentleyjs_core_1.assert(index < this.length);
        if (index < this.length) {
            return this._list[index].unquantize(this.params, out);
        }
        else {
            return undefined !== out ? out : new geometry_core_2.Point3d();
        }
    }
    /** Changes the quantization parameters and requantizes all points in the list to the new range. */
    requantize(params) {
        for (let i = 0; i < this.length; i++) {
            const pt = this.unquantize(i);
            this._list[i].init(pt, params);
        }
        this.params.copyFrom(params);
    }
    /** Extracts the current contents of the list as a Uint16Array. */
    toTypedArray() {
        const array = new Uint16Array(this.length * 3);
        const pts = this._list;
        for (let i = 0; i < this.length; i++) {
            const pt = pts[i];
            array[i * 3 + 0] = pt.x;
            array[i * 3 + 1] = pt.y;
            array[i * 3 + 2] = pt.z;
        }
        return array;
    }
    static createFrom(points, params) {
        const list = new QPoint3dList(params);
        for (const point of points)
            list.add(point);
        return list;
    }
}
exports.QPoint3dList = QPoint3dList;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ColorDef_1 = __webpack_require__(58);
/** Parameters that define the way geometry on a SubCategory appears. */
class SubCategoryAppearance {
    constructor(props) {
        if (!props) {
            this.color = ColorDef_1.ColorDef.black;
            this.weight = 0;
            this.priority = 0;
            this.transparency = 0;
            this.invisible = this.dontPlot = this.dontSnap = this.dontLocate = false;
            this.styleId = new bentleyjs_core_1.Id64();
            this.materialId = new bentleyjs_core_1.Id64();
            return;
        }
        this.invisible = bentleyjs_core_1.JsonUtils.asBool(props.invisible);
        this.dontSnap = bentleyjs_core_1.JsonUtils.asBool(props.dontSnap);
        this.dontLocate = bentleyjs_core_1.JsonUtils.asBool(props.dontLocate);
        this.dontPlot = bentleyjs_core_1.JsonUtils.asBool(props.dontPlot);
        this.color = ColorDef_1.ColorDef.fromJSON(props.color);
        this.weight = bentleyjs_core_1.JsonUtils.asInt(props.weight);
        this.styleId = bentleyjs_core_1.Id64.fromJSON(props.style);
        this.priority = bentleyjs_core_1.JsonUtils.asInt(props.priority);
        this.materialId = bentleyjs_core_1.Id64.fromJSON(props.material);
        this.transparency = bentleyjs_core_1.JsonUtils.asInt(props.transp);
    }
    equals(other) {
        return this.invisible === other.invisible &&
            this.dontPlot === other.dontPlot &&
            this.dontSnap === other.dontSnap &&
            this.dontLocate === other.dontLocate &&
            this.color.equals(other.color) &&
            this.weight === other.weight &&
            this.priority === other.priority &&
            this.styleId.equals(other.styleId) &&
            this.materialId.equals(other.materialId) &&
            this.transparency === other.transparency;
    }
    toJSON() {
        const val = { color: this.color.toJSON() };
        if (this.invisible)
            val.invisible = true;
        if (this.dontPlot)
            val.dontPlot = true;
        if (this.dontSnap)
            val.dontSnap = true;
        if (this.dontLocate)
            val.dontLocate = true;
        if (0 !== this.weight)
            val.weight = this.weight;
        if (this.styleId.isValid())
            val.style = this.styleId;
        if (0 !== this.priority)
            val.priority = this.priority;
        if (this.materialId.isValid())
            val.material = this.materialId;
        if (0.0 !== this.transparency)
            val.transp = this.transparency;
        return val;
    }
    clone() { return new SubCategoryAppearance(this.toJSON()); }
}
SubCategoryAppearance.defaults = new SubCategoryAppearance();
exports.SubCategoryAppearance = SubCategoryAppearance;
/** Overrides selected aspects of a SubCategoryAppearance. */
class SubCategoryOverride {
    constructor(props) {
        if (undefined !== props.invisible)
            this.invisible = bentleyjs_core_1.JsonUtils.asBool(props.invisible);
        if (undefined !== props.color)
            this.color = ColorDef_1.ColorDef.fromJSON(props.color);
        if (undefined !== props.weight)
            this.weight = bentleyjs_core_1.JsonUtils.asInt(props.weight);
        if (undefined !== props.style)
            this.style = bentleyjs_core_1.Id64.fromJSON(props.style);
        if (undefined !== props.material)
            this.material = bentleyjs_core_1.Id64.fromJSON(props.material);
        if (undefined !== props.priority)
            this.priority = bentleyjs_core_1.JsonUtils.asInt(props.priority);
        if (undefined !== props.transp)
            this.transparency = bentleyjs_core_1.JsonUtils.asDouble(props.transp);
    }
    get anyOverridden() {
        return undefined !== this.invisible || undefined !== this.color || undefined !== this.weight || undefined !== this.style || undefined !== this.priority || undefined !== this.material || undefined !== this.transparency;
    }
    /** Returns a SubCategoryAppearance overridden to match the properties defined by this SubCategoryOverride. */
    override(appearance) {
        if (!this.anyOverridden)
            return appearance;
        const props = appearance.toJSON();
        const ovrProps = this.toJSON();
        if (undefined !== ovrProps.invisible)
            props.invisible = ovrProps.invisible;
        if (undefined !== ovrProps.weight)
            props.weight = ovrProps.weight;
        if (undefined !== ovrProps.style)
            props.style = ovrProps.style;
        if (undefined !== ovrProps.material)
            props.material = ovrProps.material;
        if (undefined !== ovrProps.priority)
            props.priority = ovrProps.priority;
        if (undefined !== ovrProps.transp)
            props.transp = ovrProps.transp;
        if (undefined !== ovrProps.color)
            props.color = ovrProps.color;
        return new SubCategoryAppearance(props);
    }
    /** Convert this SubCategoryOverride to a JSON object */
    toJSON() {
        const val = {
            invisible: this.invisible,
            weight: this.weight,
            style: this.style,
            material: this.material,
            priority: this.priority,
            transp: this.transparency,
        };
        if (undefined !== this.color)
            val.color = this.color.toJSON();
        return val;
    }
    /** Create a new SubCategoryOverride from a JSON object */
    static fromJSON(json) {
        return undefined !== json ? new SubCategoryOverride(json) : this.defaults;
    }
}
SubCategoryOverride.defaults = new SubCategoryOverride({});
exports.SubCategoryOverride = SubCategoryOverride;


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Geometry */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const IModelJsonSchema_1 = __webpack_require__(109);
const bentleyjs_core_1 = __webpack_require__(0);
const ColorDef_1 = __webpack_require__(58);
const Render_1 = __webpack_require__(119);
const TextString_1 = __webpack_require__(200);
const LineStyle_1 = __webpack_require__(201);
const AreaPattern_1 = __webpack_require__(199);
const common_1 = __webpack_require__(2);
/** GeometryStreamBuilder is a helper class for populating the GeometryStreamEntryProps array needed to create a GeometricElement or GeometryPart */
class GeometryStreamBuilder {
    constructor() {
        /** GeometryStream entries */
        this.geometryStream = [];
    }
    /** Supply optional local to world transform. Used to transform world coordinate input relative to element placement.
     * For a GeometricElement's placement to be meaningful, world coordinate geometry should never be appended to an element with an identity placement.
     * Can be called with undefined or identity transform to start appending geometry supplied in local coordinates again.
     */
    setLocalToWorld(localToWorld) {
        this.worldToLocal = (undefined === localToWorld || localToWorld.isIdentity() ? undefined : localToWorld.inverse());
    }
    /** Supply local to world transform from Point3d and YawPitchRollAngles */
    setLocalToWorld3d(origin, angles = geometry_core_1.YawPitchRollAngles.createDegrees(0.0, 0.0, 0.0)) {
        this.setLocalToWorld(geometry_core_1.Transform.createOriginAndMatrix(origin, angles.toRotMatrix()));
    }
    /** Supply local to world transform from Point2d and Angle */
    setLocalToWorld2d(origin, angle = geometry_core_1.Angle.createDegrees(0.0)) {
        this.setLocalToWorld(geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createFrom(origin), geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), angle)));
    }
    /** Store local ranges in GeometryStream for all subsequent geometry appended. Can improve performance of locate and range testing for elements with a GeometryStream
     * containing more than one GeometryQuery differentiable by range. Not useful for a single GeometryQuery, its range and that of the GeometricElement are the same.
     * Ignored when defining a GeometryPart, and not needed when only appending GeometryPart instances to a GeometricElement as these store their own range.
     */
    appendGeometryRanges() {
        this.geometryStream.push({ subRange: geometry_core_1.Range3d.createNull() });
    }
    /** Change sub-category or reset to sub-category appearance for subsequent geometry.
     *  An invalid sub-category id can be supplied to force a reset to the current sub-category appearance.
     *  It is not valid to change the sub-category when defining a GeometryPart. GeometryParts inherit the symbology of their instance for anything not explicitly overridden.
     */
    appendSubCategoryChange(subCategoryId) {
        this.geometryStream.push({ appearance: { subCategory: subCategoryId } });
        return true;
    }
    /** Change GeometryParams for subsequent geometry.
     *  It is not valid to change the sub-category when defining a GeometryPart. A GeometryPart inherits the symbology of their instance for anything not explicitly overridden.
     */
    appendGeometryParamsChange(geomParams) {
        const appearance = {
            subCategory: geomParams.subCategoryId,
            color: geomParams.lineColor,
            weight: geomParams.weight,
            style: geomParams.styleInfo ? geomParams.styleInfo.styleId : undefined,
            transparency: geomParams.elmTransparency,
            displayPriority: geomParams.elmPriority,
            geometryClass: geomParams.geometryClass,
        };
        this.geometryStream.push({ appearance });
        if (undefined !== geomParams.materialId)
            this.geometryStream.push({ material: { materialId: geomParams.materialId } });
        if (undefined !== geomParams.fillDisplay && 0 /* Never */ !== geomParams.fillDisplay) {
            const fill = {
                display: geomParams.fillDisplay,
                transparency: geomParams.fillTransparency,
            };
            if (undefined !== geomParams.gradient && 0 /* None */ !== geomParams.gradient.mode)
                fill.gradient = geomParams.gradient.clone();
            else if (undefined !== geomParams.backgroundFill && 0 /* None */ !== geomParams.backgroundFill)
                fill.backgroundFill = geomParams.backgroundFill;
            else if (undefined !== geomParams.fillColor)
                fill.color = geomParams.fillColor;
            this.geometryStream.push({ fill });
        }
        if (undefined !== geomParams.pattern) {
            const localPattern = geomParams.pattern.clone();
            if (undefined !== this.worldToLocal && !localPattern.applyTransform(this.worldToLocal))
                return false;
            this.geometryStream.push({ pattern: localPattern });
        }
        if (undefined !== geomParams.styleInfo && undefined !== geomParams.styleInfo.styleMod) {
            const localStyleMod = new LineStyle_1.LineStyle.Modifier(geomParams.styleInfo.styleMod);
            if (undefined !== this.worldToLocal && !localStyleMod.applyTransform(this.worldToLocal))
                return false;
            this.geometryStream.push({ styleMod: localStyleMod });
        }
        return true;
    }
    /** Append a GeometryPart instance with relative position, orientation, and scale to a GeometryStreamEntryProps array for creating a GeometricElement3d.
     *  Not valid when defining a GeometryPart as nested GeometryParts are not allowed.
     */
    appendGeometryPart3d(partId, instanceOrigin, instanceRotation, instanceScale) {
        if (undefined === this.worldToLocal) {
            this.geometryStream.push({ geomPart: { part: partId, origin: instanceOrigin, rotation: instanceRotation, scale: instanceScale } });
            return true;
        }
        const partTrans = geometry_core_1.Transform.createOriginAndMatrix(instanceOrigin, instanceRotation ? instanceRotation.toRotMatrix() : geometry_core_1.RotMatrix.createIdentity());
        if (undefined !== instanceScale)
            partTrans.matrix.scaleColumnsInPlace(instanceScale, instanceScale, instanceScale);
        const resultTrans = partTrans.multiplyTransformTransform(this.worldToLocal);
        const scales = new geometry_core_1.Vector3d();
        if (!resultTrans.matrix.normalizeColumnsInPlace(scales))
            return false;
        const newRotation = geometry_core_1.YawPitchRollAngles.createFromRotMatrix(resultTrans.matrix);
        if (undefined === newRotation)
            return false;
        this.geometryStream.push({ geomPart: { part: partId, origin: resultTrans.getOrigin(), rotation: newRotation, scale: scales.x } });
        return true;
    }
    /** Append a GeometryPart instance with relative position, orientation, and scale to a GeometryStreamEntryProps array for creating a GeometricElement2d.
     *  Not valid when defining a GeometryPart as nested GeometryParts are not allowed.
     */
    appendGeometryPart2d(partId, instanceOrigin, instanceRotation, instanceScale) {
        return this.appendGeometryPart3d(partId, instanceOrigin ? geometry_core_1.Point3d.createFrom(instanceOrigin) : undefined, instanceRotation ? new geometry_core_1.YawPitchRollAngles(instanceRotation) : undefined, instanceScale);
    }
    /** Append a TextString supplied in either local or world coordinates to the GeometryStreamProps array */
    appendTextString(textString) {
        if (undefined === this.worldToLocal) {
            this.geometryStream.push({ textString });
            return true;
        }
        const localTextString = new TextString_1.TextString(textString);
        if (!localTextString.transformInPlace(this.worldToLocal))
            return false;
        this.geometryStream.push({ textString: localTextString });
        return true;
    }
    /** Append a GeometryQuery supplied in either local or world coordinates to the GeometryStreamProps array */
    appendGeometry(geometry) {
        if (undefined === this.worldToLocal) {
            const geomData = IModelJsonSchema_1.IModelJson.Writer.toIModelJson(geometry);
            if (undefined === geomData)
                return false;
            this.geometryStream.push(geomData);
            return true;
        }
        const localGeometry = geometry.cloneTransformed(this.worldToLocal);
        if (undefined === localGeometry)
            return false;
        const localGeomData = IModelJsonSchema_1.IModelJson.Writer.toIModelJson(localGeometry);
        if (undefined === localGeomData)
            return false;
        this.geometryStream.push(localGeomData);
        return true;
    }
    /** Append raw brep data supplied in either local or world coordinates to the GeometryStreamProps array */
    appendBRepData(brep) {
        if (undefined === this.worldToLocal) {
            this.geometryStream.push({ brep });
            return true;
        }
        const entityTrans = geometry_core_1.Transform.fromJSON(brep.transform);
        const localTrans = entityTrans.multiplyTransformTransform(this.worldToLocal);
        const localBrep = {
            data: brep.data,
            type: brep.type,
            transform: localTrans.isIdentity() ? undefined : localTrans,
            faceSymbology: brep.faceSymbology,
        };
        this.geometryStream.push({ brep: localBrep });
        return true;
    }
}
exports.GeometryStreamBuilder = GeometryStreamBuilder;
/** Hold current state information for GeometryStreamIterator */
class GeometryStreamIteratorEntry {
    constructor(category) {
        this.geomParams = new Render_1.GeometryParams(category !== undefined ? new bentleyjs_core_1.Id64(category) : bentleyjs_core_1.Id64.invalidId);
    }
}
exports.GeometryStreamIteratorEntry = GeometryStreamIteratorEntry;
/** GeometryStreamIterator is a helper class for iterating a GeometryStreamProps */
class GeometryStreamIterator {
    /** Construct a new GeometryStreamIterator given a GeometryStreamProps from either a GeometricElement3d, GeometricElement3d, or GeometryPart.
     * Supply the GeometricElement's category to initialize the appearance information for each geometric entry.
     */
    constructor(geometryStream, category) {
        /** Current entry position */
        this.index = 0;
        this.geometryStream = geometryStream;
        this.entry = new GeometryStreamIteratorEntry(category !== undefined ? new bentleyjs_core_1.Id64(category) : bentleyjs_core_1.Id64.invalidId);
    }
    /** Supply optional local to world transform. Used to transform entries that are stored relative to the element placement and return them in world coordinates. */
    setLocalToWorld(localToWorld) {
        this.entry.localToWorld = (undefined === localToWorld || localToWorld.isIdentity() ? undefined : localToWorld.clone());
    }
    /** Supply local to world transform from Point3d and YawPitchRollAngles of Placement3d */
    setLocalToWorld3d(origin, angles = geometry_core_1.YawPitchRollAngles.createDegrees(0.0, 0.0, 0.0)) {
        this.setLocalToWorld(geometry_core_1.Transform.createOriginAndMatrix(origin, angles.toRotMatrix()));
    }
    /** Supply local to world transform from Point2d and Angle of Placement2d */
    setLocalToWorld2d(origin, angle = geometry_core_1.Angle.createDegrees(0.0)) {
        this.setLocalToWorld(geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createFrom(origin), geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), angle)));
    }
    /** Create a new GeometryStream iterator for a GeometricElement3d.
     * If GeometricElement3dProps.placement is not undefined, placement relative entries will be returned transformed to world coordinates.
     * @throws [[IModelError]] if element.geom is undefined.
     */
    static fromGeometricElement3d(element) {
        if (element.geom === undefined)
            throw new common_1.IModelError(65570 /* NoGeometry */, "GeometricElement has no geometry or geometry wasn't requested");
        const result = new GeometryStreamIterator(element.geom, element.category);
        if (element.placement !== undefined)
            result.setLocalToWorld3d(geometry_core_1.Point3d.fromJSON(element.placement.origin), geometry_core_1.YawPitchRollAngles.fromJSON(element.placement.angles));
        return result;
    }
    /** Create a new GeometryStream iterator for a GeometricElement2d.
     * If GeometricElement2dProps.placement is not undefined, placement relative entries will be returned transformed to world coordinates.
     * @throws [[IModelError]] if element.geom is undefined.
     */
    static fromGeometricElement2d(element) {
        if (element.geom === undefined)
            throw new common_1.IModelError(65570 /* NoGeometry */, "GeometricElement has no geometry or geometry wasn't requested");
        const result = new GeometryStreamIterator(element.geom, element.category);
        if (element.placement !== undefined)
            result.setLocalToWorld2d(geometry_core_1.Point2d.fromJSON(element.placement.origin), geometry_core_1.Angle.fromJSON(element.placement.angle));
        return result;
    }
    /** Create a new GeometryStream iterator for a GeometryPart.
     * To iterate a part's GeometryStream in the context of a part instance found for a GeometricElement, provide the optional GeometryParams and Transform from the GeometricElement's GeometryStreamIterator.
     * Supply the GeometryParams to return appearance information as inherited from the GeometricElement.
     * Supply the partToWorld transform to return the part geometry in world coordintates.
     * Supply the partToLocal transform to return the part geometry relative to the GeometricElement's placement.
     * @throws [[IModelError]] if geomPart.geom is undefined.
     */
    static fromGeometryPart(geomPart, geomParams, partTransform) {
        if (geomPart.geom === undefined)
            throw new common_1.IModelError(65570 /* NoGeometry */, "GeometryPart has no geometry or geometry wasn't requested");
        const result = new GeometryStreamIterator(geomPart.geom);
        if (geomParams !== undefined)
            result.entry.geomParams = geomParams.clone();
        if (partTransform !== undefined)
            result.setLocalToWorld(partTransform);
        return result;
    }
    /** Get the transform that if applied to a GeometryPart's GeometryStream entries that would return them in world coordinates. */
    partToWorld() {
        if (this.entry.localToWorld === undefined || this.entry.partToLocal === undefined)
            return this.entry.localToWorld;
        return this.entry.partToLocal.multiplyTransformTransform(this.entry.localToWorld);
    }
    /** Advance to next displayable geometric entry while updating the current [[GeometryParams]] from appearance related entries.
     * Geometric entries are [[TextString]], [[GeometryQuery]], [[GeometryPart]], and [[BRepEntity.DataProps]].
     */
    next() {
        this.entry.partToLocal = this.entry.partId = this.entry.geometryQuery = this.entry.textString = this.entry.brep = undefined; // NOTE: localRange remains valid until new subRange entry is encountered
        while (this.index < this.geometryStream.length) {
            const entry = this.geometryStream[this.index++];
            if (entry.appearance) {
                this.entry.geomParams.resetAppearance();
                if (entry.appearance.subCategory)
                    this.entry.geomParams.subCategoryId = new bentleyjs_core_1.Id64(entry.appearance.subCategory);
                if (entry.appearance.color)
                    this.entry.geomParams.lineColor = new ColorDef_1.ColorDef(entry.appearance.color);
                if (entry.appearance.weight)
                    this.entry.geomParams.weight = entry.appearance.weight;
                if (entry.appearance.style)
                    this.entry.geomParams.styleInfo = new LineStyle_1.LineStyle.Info(new bentleyjs_core_1.Id64(entry.appearance.style));
                if (entry.appearance.transparency)
                    this.entry.geomParams.elmTransparency = entry.appearance.transparency;
                if (entry.appearance.displayPriority)
                    this.entry.geomParams.elmPriority = entry.appearance.displayPriority;
                if (entry.appearance.geometryClass)
                    this.entry.geomParams.geometryClass = entry.appearance.geometryClass;
            }
            else if (entry.styleMod) {
                if (this.entry.geomParams.styleInfo === undefined)
                    continue;
                const styleMod = new LineStyle_1.LineStyle.Modifier(entry.styleMod);
                if (this.entry.localToWorld !== undefined)
                    styleMod.applyTransform(this.entry.localToWorld);
                this.entry.geomParams.styleInfo = new LineStyle_1.LineStyle.Info(this.entry.geomParams.styleInfo.styleId, styleMod);
            }
            else if (entry.fill) {
                if (entry.fill.display)
                    this.entry.geomParams.fillDisplay = entry.fill.display;
                if (entry.fill.transparency)
                    this.entry.geomParams.fillTransparency = entry.fill.transparency;
                if (entry.fill.gradient)
                    this.entry.geomParams.gradient = Render_1.Gradient.Symb.fromJSON(entry.fill.gradient);
                else if (entry.fill.backgroundFill)
                    this.entry.geomParams.backgroundFill = entry.fill.backgroundFill;
                else if (entry.fill.color)
                    this.entry.geomParams.fillColor = new ColorDef_1.ColorDef(entry.fill.color);
            }
            else if (entry.pattern) {
                const params = AreaPattern_1.AreaPattern.Params.fromJSON(entry.pattern);
                if (this.entry.localToWorld !== undefined)
                    params.applyTransform(this.entry.localToWorld);
                this.entry.geomParams.pattern = params;
            }
            else if (entry.material) {
                if (entry.material.materialId)
                    this.entry.geomParams.materialId = new bentleyjs_core_1.Id64(entry.material.materialId);
            }
            else if (entry.subRange) {
                this.entry.localRange = geometry_core_1.Range3d.fromJSON(entry.subRange);
            }
            else if (entry.geomPart) {
                this.entry.partId = new bentleyjs_core_1.Id64(entry.geomPart.part);
                if (entry.geomPart.origin !== undefined || entry.geomPart.rotation !== undefined || entry.geomPart.scale !== undefined) {
                    const origin = entry.geomPart.origin ? geometry_core_1.Point3d.fromJSON(entry.geomPart.origin) : geometry_core_1.Point3d.createZero();
                    const rotation = entry.geomPart.rotation ? geometry_core_1.YawPitchRollAngles.fromJSON(entry.geomPart.rotation).toRotMatrix() : geometry_core_1.RotMatrix.createIdentity();
                    this.entry.partToLocal = geometry_core_1.Transform.createRefs(origin, rotation);
                    if (entry.geomPart.scale)
                        this.entry.partToLocal.multiplyTransformTransform(geometry_core_1.Transform.createRefs(geometry_core_1.Point3d.createZero(), geometry_core_1.RotMatrix.createUniformScale(entry.geomPart.scale)), this.entry.partToLocal);
                }
                return { value: this.entry, done: false };
            }
            else if (entry.textString) {
                this.entry.textString = new TextString_1.TextString(entry.textString);
                if (this.entry.localToWorld !== undefined)
                    this.entry.textString.transformInPlace(this.entry.localToWorld);
                return { value: this.entry, done: false };
            }
            else if (entry.brep) {
                this.entry.brep = entry.brep;
                if (this.entry.localToWorld !== undefined) {
                    const entityTrans = geometry_core_1.Transform.fromJSON(entry.brep.transform);
                    this.entry.brep.transform = entityTrans.multiplyTransformTransform(this.entry.localToWorld);
                }
                return { value: this.entry, done: false };
            }
            else {
                this.entry.geometryQuery = IModelJsonSchema_1.IModelJson.Reader.parse(entry);
                if (this.entry.geometryQuery === undefined)
                    continue;
                if (this.entry.localToWorld !== undefined)
                    this.entry.geometryQuery.tryTransformInPlace(this.entry.localToWorld);
                return { value: this.entry, done: false };
            }
        }
        return { value: this.entry, done: true };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.GeometryStreamIterator = GeometryStreamIterator;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcManager_1 = __webpack_require__(27);
const RpcConfiguration_1 = __webpack_require__(52);
const ElectronRpcProtocol_1 = __webpack_require__(202);
/** RPC interface configuration for an Electron-based application. */
class ElectronRpcConfiguration extends RpcConfiguration_1.RpcConfiguration {
    static get isElectron() { return ElectronRpcProtocol_1.interop !== null; }
}
exports.ElectronRpcConfiguration = ElectronRpcConfiguration;
/** Coordinates usage of RPC interfaces for an Electron-based application. */
class ElectronRpcManager extends RpcManager_1.RpcManager {
    /** Initializes ElectronRpcManager for the frontend of an application. */
    static initializeClient(params, interfaces) {
        return ElectronRpcManager.performInitialization(params, interfaces);
    }
    /** Initializes ElectronRpcManager for the backend of an application. */
    static initializeImpl(params, interfaces) {
        return ElectronRpcManager.performInitialization(params, interfaces);
    }
    static performInitialization(params, interfaces) {
        const protocol = (params.protocol || ElectronRpcProtocol_1.ElectronRpcProtocol);
        const config = class extends ElectronRpcConfiguration {
            constructor() {
                super(...arguments);
                this.interfaces = () => interfaces;
                this.protocol = new protocol(this);
            }
        };
        for (const def of interfaces) {
            RpcConfiguration_1.RpcConfiguration.assign(def, () => config);
        }
        const instance = RpcConfiguration_1.RpcConfiguration.obtain(config);
        RpcConfiguration_1.RpcConfiguration.initializeInterfaces(instance);
        return instance;
    }
}
exports.ElectronRpcManager = ElectronRpcManager;


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcRequest_1 = __webpack_require__(42);
const RpcProtocol_1 = __webpack_require__(28);
const ElectronRpcProtocol_1 = __webpack_require__(202);
class ElectronRpcRequest extends RpcRequest_1.RpcRequest {
    constructor() {
        super(...arguments);
        /** Convenience access to the protocol of this request. */
        this.protocol = this.client.configuration.protocol;
        /** The fulfillment of this request. */
        this.fulfillment = { result: "", status: 0, id: "", interfaceName: "" };
    }
    /** Sends the request. */
    send() {
        try {
            const request = this.protocol.serialize(this);
            ElectronRpcProtocol_1.interop.ipcRenderer.send(ElectronRpcProtocol_1.CHANNEL, request);
        }
        catch (e) {
            this.protocol.events.raiseEvent(RpcProtocol_1.RpcProtocolEvent.ConnectionErrorReceived, this);
        }
    }
    /** Supplies response status code. */
    getResponseStatusCode() {
        return this.fulfillment.status;
    }
    /** Supplies response text. */
    getResponseText() {
        return this.fulfillment.result || "";
    }
}
exports.ElectronRpcRequest = ElectronRpcRequest;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcManager_1 = __webpack_require__(27);
const RpcConfiguration_1 = __webpack_require__(52);
const RpcRequest_1 = __webpack_require__(42);
const BentleyCloudRpcProtocol_1 = __webpack_require__(325);
/** Operating parameters for Bentley cloud RPC interface deployments. */
class BentleyCloudRpcConfiguration extends RpcConfiguration_1.RpcConfiguration {
    constructor() {
        super(...arguments);
        /** Bentley user authorization header. */
        this.applicationAuthorizationKey = "Authorization";
    }
}
exports.BentleyCloudRpcConfiguration = BentleyCloudRpcConfiguration;
/** Coordinates usage of RPC interfaces for Bentley cloud deployments. */
class BentleyCloudRpcManager extends RpcManager_1.RpcManager {
    /** Initializes BentleyCloudRpcManager for the frontend of an application. */
    static initializeClient(params, interfaces) {
        return BentleyCloudRpcManager.performInitialization(params, interfaces);
    }
    /** Initializes BentleyCloudRpcManager for the backend of an application. */
    static initializeImpl(params, interfaces) {
        return BentleyCloudRpcManager.performInitialization(params, interfaces);
    }
    static performInitialization(params, interfaces) {
        const protocol = class extends (params.protocol || BentleyCloudRpcProtocol_1.BentleyCloudRpcProtocol) {
            constructor() {
                super(...arguments);
                this.pathPrefix = params.uriPrefix || "";
                this.info = params.info;
            }
        };
        const config = class extends BentleyCloudRpcConfiguration {
            constructor() {
                super(...arguments);
                this.interfaces = () => interfaces;
                this.protocol = new protocol(this);
            }
        };
        for (const def of interfaces) {
            RpcConfiguration_1.RpcConfiguration.assign(def, () => config);
        }
        const instance = RpcConfiguration_1.RpcConfiguration.obtain(config);
        RpcConfiguration_1.RpcConfiguration.initializeInterfaces(instance);
        if (params.pendingRequestListener) {
            const listener = params.pendingRequestListener;
            RpcRequest_1.RpcRequest.events.addListener((type, request) => {
                if (type === RpcRequest_1.RpcRequestEvent.PendingUpdateReceived && request.protocol === instance.protocol) {
                    listener(type, request);
                }
            });
        }
        return instance;
    }
}
exports.BentleyCloudRpcManager = BentleyCloudRpcManager;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const WebAppRpcProtocol_1 = __webpack_require__(326);
const IModelError_1 = __webpack_require__(16);
const bentleyjs_core_1 = __webpack_require__(0);
/** An http protocol for Bentley cloud RPC interface deployments. */
class BentleyCloudRpcProtocol extends WebAppRpcProtocol_1.WebAppRpcProtocol {
    constructor() {
        super(...arguments);
        /** The name of the HTTP request header  */
        this.requestIdHeaderName = "X-CorrelationId";
    }
    /** Returns the operation specified by an OpenAPI-compatible URI path. */
    getOperationFromPath(path) {
        const components = path.split("/");
        const operationComponent = components.slice(-1)[0];
        const [interfaceDefinition, interfaceVersion, operationName] = operationComponent.split("-");
        return { interfaceDefinition, operationName, interfaceVersion };
    }
    /** Supplies the OpenAPI-compatible URI path for an RPC operation. */
    supplyPathForOperation(operation, request) {
        const prefix = this.pathPrefix;
        const appTitle = this.info.title;
        const appVersion = this.info.version;
        const operationId = `${operation.interfaceDefinition.name}-${operation.interfaceVersion}-${operation.operationName}`;
        let appMode;
        let contextId;
        let iModelId;
        let changeSetId;
        if (request === undefined) {
            appMode = "{modeId}";
            contextId = "{contextId}";
            iModelId = "{iModelId}";
            changeSetId = "{changeSetId}";
        }
        else {
            const token = operation.policy.token(request);
            if (!token || !token.contextId || !token.iModelId) {
                throw new IModelError_1.IModelError(32768 /* ERROR */, "Invalid iModelToken for RPC operation request", bentleyjs_core_1.Logger.logError, "imodeljs-frontend.BentleyCloudRpcProtocol");
            }
            appMode = "1"; // WIP: need to determine appMode from iModelToken - hard-coded to 1 which means "milestone review" for now...
            contextId = encodeURIComponent(token.contextId);
            iModelId = encodeURIComponent(token.iModelId);
            changeSetId = token.changeSetId ? encodeURIComponent(token.changeSetId) : "0"; // if changeSetId not provided, use 0 to indicate initial iModel state (before any changeSets)
        }
        // WIP: if appMode === 2 (WorkGroupEdit) then changeset should not be included
        return `${prefix}/${appTitle}/${appVersion}/mode/${appMode}/context/${contextId}/imodel/${iModelId}/changeset/${changeSetId}/${operationId}`;
    }
    /** Returns the OpenAPI-compatible URI path parameters for an RPC operation. */
    supplyPathParametersForOperation(_operation) {
        return [
            { name: "modeId", in: "path", required: true, schema: { type: "string" } },
            { name: "contextId", in: "path", required: true, schema: { type: "string" } },
            { name: "iModelId", in: "path", required: true, schema: { type: "string" } },
            { name: "changeSetId", in: "path", required: false, schema: { type: "string" } },
        ];
    }
}
exports.BentleyCloudRpcProtocol = BentleyCloudRpcProtocol;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcRequest_1 = __webpack_require__(42);
const RpcProtocol_1 = __webpack_require__(28);
const WebAppRpcRequest_1 = __webpack_require__(203);
const OpenAPI_1 = __webpack_require__(327);
const WebAppRpcLogging_1 = __webpack_require__(328);
/** The HTTP application protocol. */
class WebAppRpcProtocol extends RpcProtocol_1.RpcProtocol {
    /** Constructs an http protocol. */
    constructor(configuration) {
        super(configuration);
        /** An optional prefix for RPC operation URI paths. */
        this.pathPrefix = "";
        /** The RPC request class for this protocol. */
        this.requestType = WebAppRpcRequest_1.WebAppRpcRequest;
        this.events.addListener(WebAppRpcLogging_1.WebAppRpcLogging.logProtocolEvent);
    }
    /** Convenience handler for an RPC operation post request for an http server. */
    async handleOperationPostRequest(req, res) {
        const request = WebAppRpcRequest_1.WebAppRpcRequest.deserialize(this, req);
        const fulfillment = await this.fulfill(request);
        res.status(fulfillment.status).send(fulfillment.result);
    }
    /** Convenience handler for an OpenAPI description request for an http server. */
    handleOpenApiDescriptionRequest(_req, res) {
        const description = JSON.stringify(this.openAPIDescription);
        res.send(description);
    }
    /** Supplies the status corresponding to a protocol-specific code value. */
    getStatus(code) {
        switch (code) {
            case 202: return RpcRequest_1.RpcRequestStatus.Provisioning;
            case 404: return RpcRequest_1.RpcRequestStatus.NotFound;
            case 409: return RpcRequest_1.RpcRequestStatus.Pending;
            case 200: return RpcRequest_1.RpcRequestStatus.Resolved;
            case 500: return RpcRequest_1.RpcRequestStatus.Rejected;
            default: return RpcRequest_1.RpcRequestStatus.Unknown;
        }
    }
    /** Supplies the protocol-specific code corresponding to a status value. */
    getCode(status) {
        switch (status) {
            case RpcRequest_1.RpcRequestStatus.Provisioning: return 202;
            case RpcRequest_1.RpcRequestStatus.NotFound: return 404;
            case RpcRequest_1.RpcRequestStatus.Pending: return 409;
            case RpcRequest_1.RpcRequestStatus.Resolved: return 200;
            case RpcRequest_1.RpcRequestStatus.Rejected: return 500;
            default: return 501;
        }
    }
    /** An OpenAPI-compatible description of this protocol. */
    get openAPIDescription() { return new OpenAPI_1.RpcOpenAPIDescription(this); }
    /** Supplies the HTTP verb for an RPC operation. */
    supplyMethodForOperation(_operation) {
        return "post";
    }
    /** Returns an HTTP request object for an RPC operation request. */
    supplyConnectionForRequest() {
        return new XMLHttpRequest();
    }
    /** Supplies error objects for protocol events. */
    supplyErrorForEvent(event, object) {
        if (object instanceof WebAppRpcRequest_1.WebAppRpcRequest) {
            return WebAppRpcLogging_1.WebAppRpcLogging.supplyError(event, object);
        }
        else {
            return super.supplyErrorForEvent(event, object);
        }
    }
}
exports.WebAppRpcProtocol = WebAppRpcProtocol;


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcOperation_1 = __webpack_require__(71);
/** An OpenAPI-compatible description of an RPC protocol. */
class RpcOpenAPIDescription {
    /** The OpenAPI paths object for the protocol. */
    get paths() {
        const paths = {};
        this.protocol.configuration.interfaces().forEach((definition) => {
            RpcOperation_1.RpcOperation.forEach(definition, (operation) => {
                const path = this.protocol.supplyPathForOperation(operation, undefined);
                paths[path] = this.generateDescription(operation);
            });
        });
        return paths;
    }
    /** An OpenAPI 3.0 (Swagger) description of the RESTful API that is exposed through the protocol. */
    get document() {
        return {
            openapi: "3.0.0",
            info: this.protocol.info,
            paths: this.paths,
        };
    }
    /** Creates an OpenAPI description of an RPC protocol. */
    constructor(protocol) {
        this.protocol = protocol;
    }
    /** Converts to JSON. */
    toJSON() {
        return this.document;
    }
    generateDescription(operation) {
        const requestContent = { "application/json": { schema: { type: "array" } } };
        const responseContent = { "application/json": { schema: { type: "object" } } };
        const description = {};
        description[this.protocol.supplyMethodForOperation(operation)] = {
            requestBody: { content: requestContent, required: true },
            responses: {
                200: { description: "Success", content: responseContent },
                default: { description: "Error", content: responseContent },
            },
        };
        const parameters = this.protocol.supplyPathParametersForOperation(operation);
        if (parameters.length)
            description.parameters = parameters;
        return description;
    }
}
exports.RpcOpenAPIDescription = RpcOpenAPIDescription;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcProtocol_1 = __webpack_require__(28);
const RpcInvocation_1 = __webpack_require__(117);
const WebAppRpcRequest_1 = __webpack_require__(203);
const bentleyjs_core_1 = __webpack_require__(0);
const IModelError_1 = __webpack_require__(16);
const loggingCategory = "imodeljs-rpc.WebAppRpcProtocol";
// tslint:disable-next-line:no-var-requires
const os = (typeof (process) !== "undefined") ? __webpack_require__(329) : undefined;
function getHostname() {
    if (os !== undefined) {
        return os.hostname();
    }
    else {
        if (typeof (window) !== "undefined") {
            return window.location.host;
        }
        else {
            return "imodeljs-mobile";
        }
    }
}
/** @hidden @internal */
class WebAppRpcLogging {
    static logProtocolEvent(event, object) {
        if (object instanceof WebAppRpcRequest_1.WebAppRpcRequest) {
            switch (event) {
                case RpcProtocol_1.RpcProtocolEvent.RequestCreated: return WebAppRpcLogging.logRequest("RpcInterface.frontend.request", object);
                case RpcProtocol_1.RpcProtocolEvent.ResponseLoaded: return WebAppRpcLogging.logResponse("RpcInterface.frontend.response", object, object.getResponseStatusCode(), object.elapsed);
                case RpcProtocol_1.RpcProtocolEvent.ConnectionErrorReceived: return WebAppRpcLogging.logErrorFrontend("RpcInterface.frontend.connectionError", object);
                case RpcProtocol_1.RpcProtocolEvent.ConnectionAborted: return WebAppRpcLogging.logErrorFrontend("RpcInterface.frontend.connectionAborted", object);
            }
        }
        else if (object instanceof RpcInvocation_1.RpcInvocation) {
            switch (event) {
                case RpcProtocol_1.RpcProtocolEvent.RequestReceived: return WebAppRpcLogging.logRequest("RpcInterface.backend.request", object.request);
                case RpcProtocol_1.RpcProtocolEvent.BackendErrorOccurred: return WebAppRpcLogging.logErrorBackend("RpcInterface.backend.error", object);
                case RpcProtocol_1.RpcProtocolEvent.BackendResponseCreated: return WebAppRpcLogging.logResponse("RpcInterface.backend.response", object.request, object.status, object.elapsed);
            }
        }
    }
    static supplyError(event, request) {
        switch (event) {
            case RpcProtocol_1.RpcProtocolEvent.BackendErrorReceived: return new IModelError_1.ServerError(request.getResponseStatusCode(), request.getResponseText());
            case RpcProtocol_1.RpcProtocolEvent.ConnectionErrorReceived: return new IModelError_1.ServerError(-1, "Connection error.");
            case RpcProtocol_1.RpcProtocolEvent.ConnectionAborted: return new IModelError_1.ServerError(-1, "Connection aborted.");
            default: return new IModelError_1.ServerError(request.getResponseStatusCode(), "Unhandled response.");
        }
    }
    static getRpcInterfaceName(g) {
        return (typeof g === "string") ? g : g.name;
    }
    static logRequest(message, object) {
        bentleyjs_core_1.Logger.logTrace(loggingCategory, message, () => ({
            method: object.method,
            path: object.path,
            operation: object.operation.operationName,
            rpcInterface: WebAppRpcLogging.getRpcInterfaceName(object.operation.interfaceDefinition),
            // Alert! The following properties are required by Bentley DevOps standards. Do not change their names!
            ActivityId: object.id,
            TimeElapsed: ("elapsed" in object) ? object.elapsed : 0,
            MachineName: getHostname(),
        }));
    }
    static logResponse(message, object, status, elapsed) {
        bentleyjs_core_1.Logger.logTrace(loggingCategory, message, () => ({
            method: object.method,
            path: object.path,
            operation: object.operation.operationName,
            rpcInterface: WebAppRpcLogging.getRpcInterfaceName(object.operation.interfaceDefinition),
            status,
            // Alert! The following properties are required by Bentley DevOps standards. Do not change their names!
            ActivityId: object.id,
            TimeElapsed: elapsed,
            MachineName: getHostname(),
        }));
    }
    static logErrorFrontend(message, request) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, message, () => ({
            method: request.method,
            path: request.path,
            // Alert! The following properties are required by Bentley DevOps standards. Do not change their names!
            ActivityId: request.id,
            MachineName: getHostname(),
        }));
    }
    static logErrorBackend(message, invocation) {
        bentleyjs_core_1.Logger.logInfo(loggingCategory, message, () => ({
            method: invocation.request.method,
            path: invocation.request.path,
            status: invocation.status,
            error: invocation.result,
            // Alert! The following properties are required by Bentley DevOps standards. Do not change their names!
            ActivityId: invocation.request.id,
            MachineName: getHostname(),
        }));
    }
}
exports.WebAppRpcLogging = WebAppRpcLogging;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 329 */
/***/ (function(module, exports) {

exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const IModel_1 = __webpack_require__(34);
const TileProps_1 = __webpack_require__(198);
class IModelTileRpcInterface extends RpcInterface_1.RpcInterface {
    static getClient() { return RpcManager_1.RpcManager.getClientForInterface(IModelTileRpcInterface); }
    getTileTreeProps(_iModelToken, _ids) { return this.forward.apply(this, arguments); }
    getTileProps(_iModelToken, _ids) { return this.forward.apply(this, arguments); }
}
IModelTileRpcInterface.version = "0.1.0";
IModelTileRpcInterface.types = () => [
    IModel_1.IModelToken,
    bentleyjs_core_1.Id64,
    TileProps_1.TileId,
];
exports.IModelTileRpcInterface = IModelTileRpcInterface;


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_clients_1 = __webpack_require__(18);
const geometry_core_1 = __webpack_require__(1);
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const IModel_1 = __webpack_require__(34);
const Primitives_1 = __webpack_require__(116);
const IModelReadRpcInterface_1 = __webpack_require__(204);
/**
 * The RPC interface for writing to an iModel.
 * All operations require read+write access.
 * This interface is not normally used directly. See IModelConnection for higher-level and more convenient API for accessing iModels from a frontend.
 */
class IModelWriteRpcInterface extends RpcInterface_1.RpcInterface {
    /** Returns the IModelWriteRpcInterface client instance for the frontend. */
    static getClient() { return RpcManager_1.RpcManager.getClientForInterface(IModelWriteRpcInterface); }
    openForWrite(_accessToken, _iModelToken) { return this.forward.apply(this, arguments); }
    saveChanges(_iModelToken, _description) { return this.forward.apply(this, arguments); }
    updateProjectExtents(_iModelToken, _newExtents) { return this.forward.apply(this, arguments); }
}
/** The version of the interface. */
IModelWriteRpcInterface.version = "1.0.0";
/** The types that can be marshaled by the interface. */
IModelWriteRpcInterface.types = () => [
    imodeljs_clients_1.AccessToken,
    Primitives_1.AxisAlignedBox3d,
    IModel_1.IModelToken,
    geometry_core_1.Point3d,
    IModelReadRpcInterface_1.IModelNotFoundResponse,
];
exports.IModelWriteRpcInterface = IModelWriteRpcInterface;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const IModel_1 = __webpack_require__(34);
/**
 * The RPC interface for working with standalone iModels.
 * Products are generally discouraged from using standalone iModels and therefore registering this interface.
 */
class StandaloneIModelRpcInterface extends RpcInterface_1.RpcInterface {
    /** Returns the StandaloneIModelRpcInterface client instance for the frontend. */
    static getClient() { return RpcManager_1.RpcManager.getClientForInterface(StandaloneIModelRpcInterface); }
    openStandalone(_fileName, _openMode) { return this.forward.apply(this, arguments); }
    closeStandalone(_iModelToken) { return this.forward.apply(this, arguments); }
}
/** The version of the interface. */
StandaloneIModelRpcInterface.version = "1.0.0";
/** The types that can be marshaled by the interface. */
StandaloneIModelRpcInterface.types = () => [IModel_1.IModelToken];
exports.StandaloneIModelRpcInterface = StandaloneIModelRpcInterface;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Fuse.js v3.2.1 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fuse", [], factory);
	else if(typeof exports === 'object')
		exports["Fuse"] = factory();
	else
		root["Fuse"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (obj) {
  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bitapRegexSearch = __webpack_require__(5);
var bitapSearch = __webpack_require__(7);
var patternAlphabet = __webpack_require__(4);

var Bitap = function () {
  function Bitap(pattern, _ref) {
    var _ref$location = _ref.location,
        location = _ref$location === undefined ? 0 : _ref$location,
        _ref$distance = _ref.distance,
        distance = _ref$distance === undefined ? 100 : _ref$distance,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,
        _ref$maxPatternLength = _ref.maxPatternLength,
        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,
        _ref$tokenSeparator = _ref.tokenSeparator,
        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;

    _classCallCheck(this, Bitap);

    this.options = {
      location: location,
      distance: distance,
      threshold: threshold,
      maxPatternLength: maxPatternLength,
      isCaseSensitive: isCaseSensitive,
      tokenSeparator: tokenSeparator,
      findAllMatches: findAllMatches,
      minMatchCharLength: minMatchCharLength
    };

    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();

    if (this.pattern.length <= maxPatternLength) {
      this.patternAlphabet = patternAlphabet(this.pattern);
    }
  }

  _createClass(Bitap, [{
    key: 'search',
    value: function search(text) {
      if (!this.options.isCaseSensitive) {
        text = text.toLowerCase();
      }

      // Exact match
      if (this.pattern === text) {
        return {
          isMatch: true,
          score: 0,
          matchedIndices: [[0, text.length - 1]]
        };
      }

      // When pattern length is greater than the machine word length, just do a a regex comparison
      var _options = this.options,
          maxPatternLength = _options.maxPatternLength,
          tokenSeparator = _options.tokenSeparator;

      if (this.pattern.length > maxPatternLength) {
        return bitapRegexSearch(text, this.pattern, tokenSeparator);
      }

      // Otherwise, use Bitap algorithm
      var _options2 = this.options,
          location = _options2.location,
          distance = _options2.distance,
          threshold = _options2.threshold,
          findAllMatches = _options2.findAllMatches,
          minMatchCharLength = _options2.minMatchCharLength;

      return bitapSearch(text, this.pattern, this.patternAlphabet, {
        location: location,
        distance: distance,
        threshold: threshold,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength
      });
    }
  }]);

  return Bitap;
}();

// let x = new Bitap("od mn war", {})
// let result = x.search("Old Man's War")
// console.log(result)

module.exports = Bitap;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(0);

var deepValue = function deepValue(obj, path, list) {
  if (!path) {
    // If there's no path left, we've gotten to the object we care about.
    list.push(obj);
  } else {
    var dotIndex = path.indexOf('.');
    var firstSegment = path;
    var remaining = null;

    if (dotIndex !== -1) {
      firstSegment = path.slice(0, dotIndex);
      remaining = path.slice(dotIndex + 1);
    }

    var value = obj[firstSegment];

    if (value !== null && value !== undefined) {
      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
        list.push(value.toString());
      } else if (isArray(value)) {
        // Search each item in the array.
        for (var i = 0, len = value.length; i < len; i += 1) {
          deepValue(value[i], remaining, list);
        }
      } else if (remaining) {
        // An object. Recurse further.
        deepValue(value, remaining, list);
      }
    }
  }

  return list;
};

module.exports = function (obj, path) {
  return deepValue(obj, path, []);
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  var matchedIndices = [];
  var start = -1;
  var end = -1;
  var i = 0;

  for (var len = matchmask.length; i < len; i += 1) {
    var match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        matchedIndices.push([start, end]);
      }
      start = -1;
    }
  }

  // (i-1 - start) + 1 => i - start
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    matchedIndices.push([start, i - 1]);
  }

  return matchedIndices;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (pattern) {
  var mask = {};
  var len = pattern.length;

  for (var i = 0; i < len; i += 1) {
    mask[pattern.charAt(i)] = 0;
  }

  for (var _i = 0; _i < len; _i += 1) {
    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;
  }

  return mask;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SPECIAL_CHARS_REGEX = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;

module.exports = function (text, pattern) {
  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;

  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\$&').replace(tokenSeparator, '|'));
  var matches = text.match(regex);
  var isMatch = !!matches;
  var matchedIndices = [];

  if (isMatch) {
    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {
      var match = matches[i];
      matchedIndices.push([text.indexOf(match), match.length - 1]);
    }
  }

  return {
    // TODO: revisit this score
    score: isMatch ? 0.5 : 1,
    isMatch: isMatch,
    matchedIndices: matchedIndices
  };
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (pattern, _ref) {
  var _ref$errors = _ref.errors,
      errors = _ref$errors === undefined ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === undefined ? 100 : _ref$distance;

  var accuracy = errors / pattern.length;
  var proximity = Math.abs(expectedLocation - currentLocation);

  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy;
  }

  return accuracy + proximity / distance;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bitapScore = __webpack_require__(6);
var matchedIndices = __webpack_require__(3);

module.exports = function (text, pattern, patternAlphabet, _ref) {
  var _ref$location = _ref.location,
      location = _ref$location === undefined ? 0 : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === undefined ? 100 : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;

  var expectedLocation = location;
  // Set starting location at beginning text and initialize the alphabet.
  var textLen = text.length;
  // Highest score beyond which we give up.
  var currentThreshold = threshold;
  // Is there a nearby exact match? (speedup)
  var bestLocation = text.indexOf(pattern, expectedLocation);

  var patternLen = pattern.length;

  // a mask of the matches
  var matchMask = [];
  for (var i = 0; i < textLen; i += 1) {
    matchMask[i] = 0;
  }

  if (bestLocation !== -1) {
    var score = bitapScore(pattern, {
      errors: 0,
      currentLocation: bestLocation,
      expectedLocation: expectedLocation,
      distance: distance
    });
    currentThreshold = Math.min(score, currentThreshold);

    // What about in the other direction? (speed up)
    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);

    if (bestLocation !== -1) {
      var _score = bitapScore(pattern, {
        errors: 0,
        currentLocation: bestLocation,
        expectedLocation: expectedLocation,
        distance: distance
      });
      currentThreshold = Math.min(_score, currentThreshold);
    }
  }

  // Reset the best location
  bestLocation = -1;

  var lastBitArr = [];
  var finalScore = 1;
  var binMax = patternLen + textLen;

  var mask = 1 << patternLen - 1;

  for (var _i = 0; _i < patternLen; _i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    var binMin = 0;
    var binMid = binMax;

    while (binMin < binMid) {
      var _score3 = bitapScore(pattern, {
        errors: _i,
        currentLocation: expectedLocation + binMid,
        expectedLocation: expectedLocation,
        distance: distance
      });

      if (_score3 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }

      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }

    // Use the result from this iteration as the maximum for the next.
    binMax = binMid;

    var start = Math.max(1, expectedLocation - binMid + 1);
    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

    // Initialize the bit array
    var bitArr = Array(finish + 2);

    bitArr[finish + 1] = (1 << _i) - 1;

    for (var j = finish; j >= start; j -= 1) {
      var currentLocation = j - 1;
      var charMatch = patternAlphabet[text.charAt(currentLocation)];

      if (charMatch) {
        matchMask[currentLocation] = 1;
      }

      // First pass: exact match
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

      // Subsequent passes: fuzzy match
      if (_i !== 0) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }

      if (bitArr[j] & mask) {
        finalScore = bitapScore(pattern, {
          errors: _i,
          currentLocation: currentLocation,
          expectedLocation: expectedLocation,
          distance: distance
        });

        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation;

          // Already passed `loc`, downhill from here on in.
          if (bestLocation <= expectedLocation) {
            break;
          }

          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }

    // No hope for a (better) match at greater error levels.
    var _score2 = bitapScore(pattern, {
      errors: _i + 1,
      currentLocation: expectedLocation,
      expectedLocation: expectedLocation,
      distance: distance
    });

    // console.log('score', score, finalScore)

    if (_score2 > currentThreshold) {
      break;
    }

    lastBitArr = bitArr;
  }

  // console.log('FINAL SCORE', finalScore)

  // Count exact matches (those with a score of 0) to be "almost" exact
  return {
    isMatch: bestLocation >= 0,
    score: finalScore === 0 ? 0.001 : finalScore,
    matchedIndices: matchedIndices(matchMask, minMatchCharLength)
  };
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Bitap = __webpack_require__(1);
var deepValue = __webpack_require__(2);
var isArray = __webpack_require__(0);

var Fuse = function () {
  function Fuse(list, _ref) {
    var _ref$location = _ref.location,
        location = _ref$location === undefined ? 0 : _ref$location,
        _ref$distance = _ref.distance,
        distance = _ref$distance === undefined ? 100 : _ref$distance,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,
        _ref$maxPatternLength = _ref.maxPatternLength,
        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,
        _ref$caseSensitive = _ref.caseSensitive,
        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,
        _ref$tokenSeparator = _ref.tokenSeparator,
        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,
        _ref$id = _ref.id,
        id = _ref$id === undefined ? null : _ref$id,
        _ref$keys = _ref.keys,
        keys = _ref$keys === undefined ? [] : _ref$keys,
        _ref$shouldSort = _ref.shouldSort,
        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,
        _ref$sortFn = _ref.sortFn,
        sortFn = _ref$sortFn === undefined ? function (a, b) {
      return a.score - b.score;
    } : _ref$sortFn,
        _ref$tokenize = _ref.tokenize,
        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,
        _ref$matchAllTokens = _ref.matchAllTokens,
        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,
        _ref$includeScore = _ref.includeScore,
        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,
        _ref$verbose = _ref.verbose,
        verbose = _ref$verbose === undefined ? false : _ref$verbose;

    _classCallCheck(this, Fuse);

    this.options = {
      location: location,
      distance: distance,
      threshold: threshold,
      maxPatternLength: maxPatternLength,
      isCaseSensitive: caseSensitive,
      tokenSeparator: tokenSeparator,
      findAllMatches: findAllMatches,
      minMatchCharLength: minMatchCharLength,
      id: id,
      keys: keys,
      includeMatches: includeMatches,
      includeScore: includeScore,
      shouldSort: shouldSort,
      getFn: getFn,
      sortFn: sortFn,
      verbose: verbose,
      tokenize: tokenize,
      matchAllTokens: matchAllTokens
    };

    this.setCollection(list);
  }

  _createClass(Fuse, [{
    key: 'setCollection',
    value: function setCollection(list) {
      this.list = list;
      return list;
    }
  }, {
    key: 'search',
    value: function search(pattern) {
      this._log('---------\nSearch pattern: "' + pattern + '"');

      var _prepareSearchers2 = this._prepareSearchers(pattern),
          tokenSearchers = _prepareSearchers2.tokenSearchers,
          fullSearcher = _prepareSearchers2.fullSearcher;

      var _search2 = this._search(tokenSearchers, fullSearcher),
          weights = _search2.weights,
          results = _search2.results;

      this._computeScore(weights, results);

      if (this.options.shouldSort) {
        this._sort(results);
      }

      return this._format(results);
    }
  }, {
    key: '_prepareSearchers',
    value: function _prepareSearchers() {
      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      var tokenSearchers = [];

      if (this.options.tokenize) {
        // Tokenize on the separator
        var tokens = pattern.split(this.options.tokenSeparator);
        for (var i = 0, len = tokens.length; i < len; i += 1) {
          tokenSearchers.push(new Bitap(tokens[i], this.options));
        }
      }

      var fullSearcher = new Bitap(pattern, this.options);

      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };
    }
  }, {
    key: '_search',
    value: function _search() {
      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var fullSearcher = arguments[1];

      var list = this.list;
      var resultMap = {};
      var results = [];

      // Check the first item in the list, if it's a string, then we assume
      // that every item in the list is also a string, and thus it's a flattened array.
      if (typeof list[0] === 'string') {
        // Iterate over every item
        for (var i = 0, len = list.length; i < len; i += 1) {
          this._analyze({
            key: '',
            value: list[i],
            record: i,
            index: i
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }

        return { weights: null, results: results };
      }

      // Otherwise, the first item is an Object (hopefully), and thus the searching
      // is done on the values of the keys of each item.
      var weights = {};
      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {
        var item = list[_i];
        // Iterate over every key
        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {
          var key = this.options.keys[j];
          if (typeof key !== 'string') {
            weights[key.name] = {
              weight: 1 - key.weight || 1
            };
            if (key.weight <= 0 || key.weight > 1) {
              throw new Error('Key weight has to be > 0 and <= 1');
            }
            key = key.name;
          } else {
            weights[key] = {
              weight: 1
            };
          }

          this._analyze({
            key: key,
            value: this.options.getFn(item, key),
            record: item,
            index: _i
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }
      }

      return { weights: weights, results: results };
    }
  }, {
    key: '_analyze',
    value: function _analyze(_ref2, _ref3) {
      var key = _ref2.key,
          _ref2$arrayIndex = _ref2.arrayIndex,
          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,
          value = _ref2.value,
          record = _ref2.record,
          index = _ref2.index;
      var _ref3$tokenSearchers = _ref3.tokenSearchers,
          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,
          _ref3$fullSearcher = _ref3.fullSearcher,
          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,
          _ref3$resultMap = _ref3.resultMap,
          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,
          _ref3$results = _ref3.results,
          results = _ref3$results === undefined ? [] : _ref3$results;

      // Check if the texvaluet can be searched
      if (value === undefined || value === null) {
        return;
      }

      var exists = false;
      var averageScore = -1;
      var numTextMatches = 0;

      if (typeof value === 'string') {
        this._log('\nKey: ' + (key === '' ? '-' : key));

        var mainSearchResult = fullSearcher.search(value);
        this._log('Full text: "' + value + '", score: ' + mainSearchResult.score);

        if (this.options.tokenize) {
          var words = value.split(this.options.tokenSeparator);
          var scores = [];

          for (var i = 0; i < tokenSearchers.length; i += 1) {
            var tokenSearcher = tokenSearchers[i];

            this._log('\nPattern: "' + tokenSearcher.pattern + '"');

            // let tokenScores = []
            var hasMatchInText = false;

            for (var j = 0; j < words.length; j += 1) {
              var word = words[j];
              var tokenSearchResult = tokenSearcher.search(word);
              var obj = {};
              if (tokenSearchResult.isMatch) {
                obj[word] = tokenSearchResult.score;
                exists = true;
                hasMatchInText = true;
                scores.push(tokenSearchResult.score);
              } else {
                obj[word] = 1;
                if (!this.options.matchAllTokens) {
                  scores.push(1);
                }
              }
              this._log('Token: "' + word + '", score: ' + obj[word]);
              // tokenScores.push(obj)
            }

            if (hasMatchInText) {
              numTextMatches += 1;
            }
          }

          averageScore = scores[0];
          var scoresLen = scores.length;
          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {
            averageScore += scores[_i2];
          }
          averageScore = averageScore / scoresLen;

          this._log('Token score average:', averageScore);
        }

        var finalScore = mainSearchResult.score;
        if (averageScore > -1) {
          finalScore = (finalScore + averageScore) / 2;
        }

        this._log('Score average:', finalScore);

        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;

        this._log('\nCheck Matches: ' + checkTextMatches);

        // If a match is found, add the item to <rawResults>, including its score
        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
          // Check if the item already exists in our results
          var existingResult = resultMap[index];
          if (existingResult) {
            // Use the lowest score
            // existingResult.score, bitapResult.score
            existingResult.output.push({
              key: key,
              arrayIndex: arrayIndex,
              value: value,
              score: finalScore,
              matchedIndices: mainSearchResult.matchedIndices
            });
          } else {
            // Add it to the raw result list
            resultMap[index] = {
              item: record,
              output: [{
                key: key,
                arrayIndex: arrayIndex,
                value: value,
                score: finalScore,
                matchedIndices: mainSearchResult.matchedIndices
              }]
            };

            results.push(resultMap[index]);
          }
        }
      } else if (isArray(value)) {
        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {
          this._analyze({
            key: key,
            arrayIndex: _i3,
            value: value[_i3],
            record: record,
            index: index
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }
      }
    }
  }, {
    key: '_computeScore',
    value: function _computeScore(weights, results) {
      this._log('\n\nComputing score:\n');

      for (var i = 0, len = results.length; i < len; i += 1) {
        var output = results[i].output;
        var scoreLen = output.length;

        var currScore = 1;
        var bestScore = 1;

        for (var j = 0; j < scoreLen; j += 1) {
          var weight = weights ? weights[output[j].key].weight : 1;
          var score = weight === 1 ? output[j].score : output[j].score || 0.001;
          var nScore = score * weight;

          if (weight !== 1) {
            bestScore = Math.min(bestScore, nScore);
          } else {
            output[j].nScore = nScore;
            currScore *= nScore;
          }
        }

        results[i].score = bestScore === 1 ? currScore : bestScore;

        this._log(results[i]);
      }
    }
  }, {
    key: '_sort',
    value: function _sort(results) {
      this._log('\n\nSorting....');
      results.sort(this.options.sortFn);
    }
  }, {
    key: '_format',
    value: function _format(results) {
      var finalOutput = [];

      if (this.options.verbose) {
        this._log('\n\nOutput:\n\n', JSON.stringify(results));
      }

      var transformers = [];

      if (this.options.includeMatches) {
        transformers.push(function (result, data) {
          var output = result.output;
          data.matches = [];

          for (var i = 0, len = output.length; i < len; i += 1) {
            var item = output[i];

            if (item.matchedIndices.length === 0) {
              continue;
            }

            var obj = {
              indices: item.matchedIndices,
              value: item.value
            };
            if (item.key) {
              obj.key = item.key;
            }
            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {
              obj.arrayIndex = item.arrayIndex;
            }
            data.matches.push(obj);
          }
        });
      }

      if (this.options.includeScore) {
        transformers.push(function (result, data) {
          data.score = result.score;
        });
      }

      for (var i = 0, len = results.length; i < len; i += 1) {
        var result = results[i];

        if (this.options.id) {
          result.item = this.options.getFn(result.item, this.options.id)[0];
        }

        if (!transformers.length) {
          finalOutput.push(result.item);
          continue;
        }

        var data = {
          item: result.item
        };

        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {
          transformers[j](result, data);
        }

        finalOutput.push(data);
      }

      return finalOutput;
    }
  }, {
    key: '_log',
    value: function _log() {
      if (this.options.verbose) {
        var _console;

        (_console = console).log.apply(_console, arguments);
      }
    }
  }]);

  return Fuse;
}();

module.exports = Fuse;

/***/ })
/******/ ]);
});


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module RpcInterface */
Object.defineProperty(exports, "__esModule", { value: true });
const RpcInterface_1 = __webpack_require__(51);
const RpcManager_1 = __webpack_require__(27);
const IModel_1 = __webpack_require__(34);
/**
 * For unit testing purposes only. This interface should not be registered by real products.
 * @hidden
 */
class IModelUnitTestRpcInterface extends RpcInterface_1.RpcInterface {
    /** Returns the IModelUnitTestRpcInterface client instance for the frontend. */
    static getClient() { return RpcManager_1.RpcManager.getClientForInterface(IModelUnitTestRpcInterface); }
    executeTest(_iModelToken, _testName, _params) { return this.forward.apply(this, arguments); }
}
/** The version of the interface. */
IModelUnitTestRpcInterface.version = "1.0.0";
/** The types that can be marshaled by the interface. */
IModelUnitTestRpcInterface.types = () => [IModel_1.IModelToken];
exports.IModelUnitTestRpcInterface = IModelUnitTestRpcInterface;


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(74);
const GltfTileIO_1 = __webpack_require__(209);
const DisplayParams_1 = __webpack_require__(60);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
/** Provides facilities for deserializing Batched 3D Model (B3dm) tiles.  */
var B3dmTileIO;
(function (B3dmTileIO) {
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.featureTableJsonLength = stream.nextUint32;
            this.featureTableBinaryLength = stream.nextUint32;
            this.batchTableJsonLength = stream.nextUint32;
            this.batchTableBinaryLength = stream.nextUint32;
            stream.advance(this.featureTableJsonLength);
            stream.advance(this.featureTableBinaryLength);
            stream.advance(this.batchTableJsonLength);
            stream.advance(this.batchTableBinaryLength);
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get isValid() { return 1835283298 /* B3dm */ === this.format; }
    }
    B3dmTileIO.Header = Header;
    /** Deserializes an B3DM tile. */
    class Reader extends GltfTileIO_1.GltfTileIO.Reader {
        constructor(props, model, system, range, isCanceled) {
            super(props, model, system, isCanceled);
            this.range = range;
        }
        static create(stream, model, range, system, yAxisUp, isCanceled) {
            const header = new Header(stream);
            if (!header.isValid)
                return undefined;
            const props = GltfTileIO_1.GltfTileIO.ReaderProps.create(stream, yAxisUp);
            return undefined !== props ? new Reader(props, model, system, range, isCanceled) : undefined;
        }
        async read() {
            const isLeaf = true; // TBD...
            // TBD... Create an actual feature table if one exists.  For now we are only reading tiles from scalable mesh which have no features.
            const featureTable = new imodeljs_common_1.FeatureTable(1);
            const feature = new imodeljs_common_1.Feature();
            featureTable.insert(feature);
            await this.loadTextures();
            if (this.isCanceled)
                return Promise.resolve({ readStatus: 6 /* Canceled */, isLeaf });
            return Promise.resolve(this.readGltfAndCreateGraphics(isLeaf, false, true, featureTable, this.range));
        }
        readFeatures(features, _json) {
            const feature = new imodeljs_common_1.Feature();
            features.add(feature, 1);
            return true;
        }
        readColorTable(colorTable, _json) {
            colorTable.insert(0x777777);
            return true;
        }
        createDisplayParams(materialJson) {
            let textureMapping;
            if (undefined !== materialJson &&
                undefined !== materialJson.values.tex) {
                textureMapping = this.findTextureMapping(materialJson.values.tex);
            }
            const grey = new imodeljs_common_1.ColorDef(0x77777777);
            return new DisplayParams_1.DisplayParams(DisplayParams_1.DisplayParams.Type.Mesh, grey, grey, 1, 0 /* Solid */, imodeljs_common_1.FillFlags.Always, undefined, undefined, true, textureMapping);
        }
        extractReturnToCenter(extensions) {
            if (extensions === undefined) {
                return undefined;
            }
            const cesiumRtc = bentleyjs_core_1.JsonUtils.asObject(extensions.CESIUM_RTC);
            return (cesiumRtc === undefined) ? undefined : bentleyjs_core_1.JsonUtils.asArray(cesiumRtc.center);
        }
    }
    B3dmTileIO.Reader = Reader;
})(B3dmTileIO = exports.B3dmTileIO || (exports.B3dmTileIO = {}));


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(74);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const System_1 = __webpack_require__(17);
const bentleyjs_core_2 = __webpack_require__(0);
const PointCloudPrimitive_1 = __webpack_require__(337);
const PointVector_1 = __webpack_require__(4);
const geometry_core_1 = __webpack_require__(1);
/** Deserializes an Pnts tile. */
var PntsTileIO;
(function (PntsTileIO) {
    class Header extends TileIO_1.TileIO.Header {
        get isValid() { return 1937010288 /* Pnts */ === this.format; }
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.featureTableJsonLength = stream.nextUint32;
            this.featureTableBinaryLength = stream.nextUint32;
            this.batchTableJsonLength = stream.nextUint32;
            this.batchTableBinaryLength = stream.nextUint32;
        }
    }
    function readPointCloud(stream, model, _range, system, yAxisUp) {
        const header = new Header(stream);
        if (!header.isValid)
            return undefined;
        const featureTableJsonOffset = stream.curPos;
        const featureStrData = stream.nextBytes(header.featureTableJsonLength);
        const featureStr = bentleyjs_core_2.StringUtils.utf8ToString(featureStrData);
        const featureValue = JSON.parse(featureStr);
        if (undefined === featureValue) { }
        if (undefined === featureValue.POSITION_QUANTIZED ||
            undefined === featureValue.QUANTIZED_VOLUME_OFFSET ||
            undefined === featureValue.QUANTIZED_VOLUME_SCALE ||
            undefined === featureValue.POINTS_LENGTH ||
            undefined === featureValue.POSITION_QUANTIZED) {
            bentleyjs_core_1.assert(false, "quantized point cloud points not found");
            return undefined;
        }
        const qOrigin = new PointVector_1.Point3d(featureValue.QUANTIZED_VOLUME_OFFSET[0], featureValue.QUANTIZED_VOLUME_OFFSET[1], featureValue.QUANTIZED_VOLUME_OFFSET[2]);
        const qScale = new PointVector_1.Point3d(imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[0]), imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[1]), imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[2]));
        const qParams = imodeljs_common_1.QParams3d.fromOriginAndScale(qOrigin, qScale);
        const qPoints = new Uint16Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.POSITION_QUANTIZED.byteOffset, 3 * featureValue.POINTS_LENGTH);
        let colors;
        if (undefined !== featureValue.RGB) {
            colors = new Uint8Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.RGB.byteOffset, 3 * featureValue.POINTS_LENGTH);
        }
        else {
            colors = new Uint8Array(3 * featureValue.POINTS_LENGTH);
            colors.fill(0xff, 0, colors.length); // TBD... Default color?
        }
        let renderGraphic = system.createPointCloud(new PointCloudPrimitive_1.PointCloudArgs(qPoints, qParams, colors), model.iModel);
        if (yAxisUp) {
            const branch = new System_1.GraphicBranch();
            branch.add(renderGraphic);
            const transform = geometry_core_1.Transform.createOriginAndMatrix(undefined, geometry_core_1.RotMatrix.createRotationAroundVector(geometry_core_1.Vector3d.create(1.0, 0.0, 0.0), geometry_core_1.Angle.createRadians(geometry_core_1.Angle.piOver2Radians)));
            renderGraphic = system.createBranch(branch, transform);
        }
        return renderGraphic;
    }
    PntsTileIO.readPointCloud = readPointCloud;
})(PntsTileIO = exports.PntsTileIO || (exports.PntsTileIO = {}));


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
const imodeljs_common_1 = __webpack_require__(2);
class PointCloudArgs {
    constructor(points = new Uint16Array(), pointParams = imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull()), colors = new Uint8Array()) { this.points = points; this.pointParams = pointParams, this.colors = colors; }
}
exports.PointCloudArgs = PointCloudArgs;


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const TileIO_1 = __webpack_require__(74);
const GltfTileIO_1 = __webpack_require__(209);
const DisplayParams_1 = __webpack_require__(60);
const bentleyjs_core_1 = __webpack_require__(0);
const ImageUtil_1 = __webpack_require__(72);
const imodeljs_common_1 = __webpack_require__(2);
/** Provides facilities for deserializing iModel tiles. iModel tiles contain element geometry. */
var IModelTileIO;
(function (IModelTileIO) {
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.flags = stream.nextUint32;
            this.contentRange = imodeljs_common_1.ElementAlignedBox3d.createFromPoints(stream.nextPoint3d64, stream.nextPoint3d64);
            this.length = stream.nextUint32;
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get isValid() { return 1416521572 /* IModel */ === this.format; }
    }
    IModelTileIO.Header = Header;
    class FeatureTableHeader {
        constructor(length, maxFeatures, count) {
            this.length = length;
            this.maxFeatures = maxFeatures;
            this.count = count;
        }
        static readFrom(stream) {
            const length = stream.nextUint32;
            const maxFeatures = stream.nextUint32;
            const count = stream.nextUint32;
            return stream.isPastTheEnd ? undefined : new FeatureTableHeader(length, maxFeatures, count);
        }
    }
    /** Deserializes an iModel tile. */
    class Reader extends GltfTileIO_1.GltfTileIO.Reader {
        constructor(props, model, system, isCanceled) {
            super(props, model, system, isCanceled);
        }
        static create(stream, model, system, isCanceled) {
            const header = new Header(stream);
            if (!header.isValid)
                return undefined;
            // The feature table follows the dgnT header
            if (!this.skipFeatureTable(stream))
                return undefined;
            // A glTF header follows the feature table
            const props = GltfTileIO_1.GltfTileIO.ReaderProps.create(stream);
            return undefined !== props ? new Reader(props, model, system, isCanceled) : undefined;
        }
        extractReturnToCenter(_extensions) { return undefined; } // Original IModel Tile creator set RTC unnecessarily and incorrectly.
        static skipFeatureTable(stream) {
            const startPos = stream.curPos;
            const header = FeatureTableHeader.readFrom(stream);
            if (undefined !== header)
                stream.curPos = startPos + header.length;
            return undefined !== header;
        }
        async read() {
            // ###TODO don't re-read the headers...
            this.buffer.reset();
            const header = new Header(this.buffer);
            let isLeaf = true;
            if (!header.isValid)
                return { readStatus: 2 /* InvalidHeader */, isLeaf };
            isLeaf = 0 /* None */ !== (header.flags & 4 /* IsLeaf */);
            const featureTable = this.readFeatureTable();
            if (undefined === featureTable)
                return { readStatus: 5 /* InvalidFeatureTable */, isLeaf };
            const isComplete = 0 /* None */ === (header.flags & 2 /* Incomplete */);
            const isCurved = 0 /* None */ !== (header.flags & 1 /* ContainsCurves */);
            // Textures must be loaded asynchronously first...
            await this.loadNamedTextures();
            if (this.isCanceled)
                return Promise.resolve({ readStatus: 6 /* Canceled */, isLeaf });
            else
                return Promise.resolve(this.readGltfAndCreateGraphics(isLeaf, isCurved, isComplete, featureTable, header.contentRange));
        }
        readFeatureTable() {
            const startPos = this.buffer.curPos;
            const header = FeatureTableHeader.readFrom(this.buffer);
            if (undefined === header)
                return undefined;
            const featureTable = new imodeljs_common_1.FeatureTable(header.maxFeatures, this.modelId);
            for (let i = 0; i < header.count; i++) {
                const elementId = this.buffer.nextId64;
                const subCategoryId = this.buffer.nextId64;
                const geometryClass = this.buffer.nextUint32;
                const index = this.buffer.nextUint32;
                if (this.buffer.isPastTheEnd)
                    return undefined;
                featureTable.insertWithIndex(new imodeljs_common_1.Feature(elementId, subCategoryId, geometryClass), index);
            }
            this.buffer.curPos = startPos + header.length;
            return featureTable;
        }
        readFeatureIndices(json) {
            const featureId = json.featureID;
            if (undefined !== featureId)
                return [featureId];
            else
                return this.readIndices(json, "featureIDs");
        }
        readColorTable(colorTable, meshJson) {
            const json = bentleyjs_core_1.JsonUtils.asArray(meshJson.colorTable);
            if (undefined !== json) {
                for (const color of json)
                    colorTable.insert(color);
            }
            return 0 < colorTable.length;
        }
        createDisplayParams(json) {
            const type = bentleyjs_core_1.JsonUtils.asInt(json.type, DisplayParams_1.DisplayParams.Type.Mesh);
            const lineColor = new imodeljs_common_1.ColorDef(bentleyjs_core_1.JsonUtils.asInt(json.lineColor));
            const fillColor = new imodeljs_common_1.ColorDef(bentleyjs_core_1.JsonUtils.asInt(json.fillColor));
            const width = bentleyjs_core_1.JsonUtils.asInt(json.lineWidth);
            const linePixels = bentleyjs_core_1.JsonUtils.asInt(json.linePixels, 0 /* Solid */);
            const fillFlags = bentleyjs_core_1.JsonUtils.asInt(json.fillFlags, imodeljs_common_1.FillFlags.None);
            const ignoreLighting = bentleyjs_core_1.JsonUtils.asBool(json.ignoreLighting);
            // Material will always contain its own texture if it has one
            const materialKey = json.materialId;
            const material = undefined !== materialKey ? this.materialFromJson(materialKey) : undefined;
            // We will only attempt to include the texture if material is undefined
            let textureMapping;
            if (!material) {
                const textureJson = json.texture;
                textureMapping = undefined !== textureJson ? this.textureMappingFromJson(textureJson) : undefined;
                if (undefined === textureMapping) {
                    // Look for a gradient. If defined, create a texture mapping. No reason to pass the Gradient.Symb to the DisplayParams once we have the texture.
                    const gradientProps = json.gradient;
                    const gradient = undefined !== gradientProps ? imodeljs_common_1.Gradient.Symb.fromJSON(gradientProps) : undefined;
                    if (undefined !== gradient) {
                        const texture = this.system.getGradientTexture(gradient, this.model.iModel);
                        if (undefined !== texture) {
                            // ###TODO: would be better if DisplayParams created the TextureMapping - but that requires an IModelConnection and a RenderSystem...
                            textureMapping = new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params({ textureMat2x3: new imodeljs_common_1.TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0) }));
                        }
                    }
                }
            }
            return new DisplayParams_1.DisplayParams(type, lineColor, fillColor, width, linePixels, fillFlags, material, undefined, ignoreLighting, textureMapping);
        }
        colorDefFromMaterialJson(json) {
            return undefined !== json ? imodeljs_common_1.ColorDef.from(json[0] * 255 + 0.5, json[1] * 255 + 0.5, json[2] * 255 + 0.5) : undefined;
        }
        materialFromJson(key) {
            if (this.renderMaterials === undefined || this.renderMaterials[key] === undefined)
                return undefined;
            let material = this.system.findMaterial(key, this.model.iModel);
            if (!material) {
                const materialJson = this.renderMaterials[key];
                const materialParams = new imodeljs_common_1.RenderMaterial.Params(key);
                materialParams.diffuseColor = this.colorDefFromMaterialJson(materialJson.diffuseColor);
                if (materialJson.diffuse !== undefined)
                    materialParams.diffuse = bentleyjs_core_1.JsonUtils.asDouble(materialJson.diffuse);
                materialParams.specularColor = this.colorDefFromMaterialJson(materialJson.specularColor);
                if (materialJson.specular !== undefined)
                    materialParams.specular = bentleyjs_core_1.JsonUtils.asDouble(materialJson.specular);
                materialParams.reflectColor = this.colorDefFromMaterialJson(materialJson.reflectColor);
                if (materialJson.reflect !== undefined)
                    materialParams.reflect = bentleyjs_core_1.JsonUtils.asDouble(materialJson.reflect);
                if (materialJson.specularExponent !== undefined)
                    materialParams.specularExponent = materialJson.specularExponent;
                if (materialJson.transparency !== undefined)
                    materialParams.transparency = materialJson.transparency;
                materialParams.refract = bentleyjs_core_1.JsonUtils.asDouble(materialJson.refract);
                materialParams.shadows = bentleyjs_core_1.JsonUtils.asBool(materialJson.shadows);
                materialParams.ambient = bentleyjs_core_1.JsonUtils.asDouble(materialJson.ambient);
                if (undefined !== materialJson.textureMapping)
                    materialParams.textureMapping = this.textureMappingFromJson(materialJson.textureMapping.texture);
                material = this.system.createMaterial(materialParams, this.model.iModel);
            }
            return material;
        }
        textureMappingFromJson(json) {
            if (undefined === json)
                return undefined;
            const name = bentleyjs_core_1.JsonUtils.asString(json.name);
            const namedTex = 0 !== name.length ? this.namedTextures[name] : undefined;
            const texture = undefined !== namedTex ? namedTex.renderTexture : undefined;
            if (undefined === texture)
                return undefined;
            const paramsJson = json.params;
            const tf = paramsJson.transform;
            const paramProps = {
                textureMat2x3: new imodeljs_common_1.TextureMapping.Trans2x3(tf[0][0], tf[0][1], tf[0][2], tf[1][0], tf[1][1], tf[1][2]),
                textureWeight: bentleyjs_core_1.JsonUtils.asDouble(paramsJson.weight, 1.0),
                mapMode: bentleyjs_core_1.JsonUtils.asInt(paramsJson.mode),
                worldMapping: bentleyjs_core_1.JsonUtils.asBool(paramsJson.worldMapping),
            };
            return new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params(paramProps));
        }
        async loadNamedTextures() {
            if (undefined === this.namedTextures)
                return Promise.resolve();
            const promises = new Array();
            for (const name of Object.keys(this.namedTextures))
                promises.push(this.loadNamedTexture(name));
            return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();
        }
        async loadNamedTexture(name) {
            if (this.isCanceled)
                return Promise.resolve();
            const namedTex = this.namedTextures[name];
            bentleyjs_core_1.assert(undefined !== namedTex); // we got here by iterating the keys of this.namedTextures...
            if (undefined === namedTex)
                return Promise.resolve();
            const imodel = this.model.iModel;
            const texture = this.system.findTexture(name, imodel);
            if (undefined !== texture)
                return Promise.resolve();
            return this.readNamedTexture(namedTex).then((result) => { namedTex.renderTexture = result; });
        }
        async readNamedTexture(namedTex) {
            const bufferViewId = bentleyjs_core_1.JsonUtils.asString(namedTex.bufferView);
            const bufferViewJson = 0 !== bufferViewId.length ? this.bufferViews[bufferViewId] : undefined;
            if (undefined === bufferViewJson)
                return Promise.resolve(undefined);
            const byteOffset = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteOffset);
            const byteLength = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteLength);
            if (0 === byteLength)
                return Promise.resolve(undefined);
            const bytes = this.binaryData.subarray(byteOffset, byteOffset + byteLength);
            const format = namedTex.format;
            const imageSource = new imodeljs_common_1.ImageSource(bytes, format);
            return ImageUtil_1.ImageUtil.extractImage(imageSource).then((image) => {
                if (this.isCanceled)
                    return undefined;
                let textureType = 0 /* Normal */;
                if (bentleyjs_core_1.JsonUtils.asBool(namedTex.isGlyph))
                    textureType = 1 /* Glyph */;
                else if (bentleyjs_core_1.JsonUtils.asBool(namedTex.isTileSection))
                    textureType = 2 /* TileSection */;
                const params = new imodeljs_common_1.RenderTexture.Params(name, textureType);
                return this.system.createTextureFromImage(image, 2 /* Png */ === format, this.model.iModel, params);
            });
        }
    }
    IModelTileIO.Reader = Reader;
})(IModelTileIO = exports.IModelTileIO || (exports.IModelTileIO = {}));


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_1 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const imodeljs_clients_1 = __webpack_require__(18);
const TileTree_1 = __webpack_require__(62);
const IModelApp_1 = __webpack_require__(5);
function debugPrint(str) {
    console.log(str); // tslint:disable-line:no-console
}
class CesiumUtils {
    static rangeFromBoundingVolume(boundingVolume) {
        const box = boundingVolume.box;
        const center = geometry_core_1.Point3d.create(box[0], box[1], box[2]);
        const ux = geometry_core_1.Vector3d.create(box[3], box[4], box[5]);
        const uy = geometry_core_1.Vector3d.create(box[6], box[7], box[8]);
        const uz = geometry_core_1.Vector3d.create(box[9], box[10], box[11]);
        const corners = [];
        for (let j = 0; j < 2; j++) {
            for (let k = 0; k < 2; k++) {
                for (let l = 0; l < 2; l++) {
                    corners.push(center.plus3Scaled(ux, (j ? -1.0 : 1.0), uy, (k ? -1.0 : 1.0), uz, (l ? -1.0 : 1.0)));
                }
            }
        }
        return geometry_core_1.Range3d.createArray(corners);
    }
    static maximumSizeFromGeometricTolerance(range, geometricError) {
        const minToleranceRatio = .5; // Nominally the error on screen size of a tile.  Increasing generally increases performance (fewer draw calls) at expense of higher load times.
        return minToleranceRatio * range.diagonal().magnitude() / geometricError;
    }
    static transformFromJson(jTrans) {
        return (jTrans === undefined) ? geometry_core_1.Transform.createIdentity() : geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.create(jTrans[12], jTrans[13], jTrans[14]), geometry_core_1.RotMatrix.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));
    }
}
class RealityModelTileTreeProps {
    constructor(json, client, tileToDb, rootGeometry) {
        this.client = client;
        this.id = "";
        this.yAxisUp = false;
        this.tilesetJson = json.root;
        this.id = new bentleyjs_core_1.Id64();
        this.rootTile = new RealityModelTileProps(json.root, "", this, rootGeometry);
        this.location = tileToDb.toJSON();
        if (json.asset.gltfUpAxis === undefined || json.asset.gltfUpAxis === "y")
            this.yAxisUp = true;
    }
}
class RealityModelTileProps {
    constructor(json, thisId, tree, geometry) {
        this.tree = tree;
        this.id = new imodeljs_common_1.TileId(new bentleyjs_core_1.Id64(), thisId);
        this.range = CesiumUtils.rangeFromBoundingVolume(json.boundingVolume);
        this.maximumSize = 0.0; // nonzero only if content present.   CesiumUtils.maximumSizeFromGeometricTolerance(Range3d.fromJSON(this.range), json.geometricError);
        this.yAxisUp = tree.yAxisUp;
        this.childIds = [];
        const prefix = thisId.length ? thisId + "_" : "";
        if (Array.isArray(json.children))
            for (let i = 0; i < json.children.length; i++)
                this.childIds.push(prefix + i);
        if (geometry !== undefined) {
            this.contentRange = json.content.boundingVolume && CesiumUtils.rangeFromBoundingVolume(json.content.boundingVolume);
            this.maximumSize = CesiumUtils.maximumSizeFromGeometricTolerance(geometry_core_1.Range3d.fromJSON(this.range), json.geometricError);
            this.geometry = geometry;
        }
    }
}
class RealityModelTileLoader {
    constructor(tree) {
        this.tree = tree;
    }
    getMaxDepth() { return 32; } // Can be removed when element tile selector is working.
    async getTileProps(tileIds) {
        const props = [];
        const stopWatch = new bentleyjs_core_1.StopWatch("", true);
        debugPrint("requesting " + tileIds.length + " tiles");
        await Promise.all(tileIds.map(async (tileId) => {
            const tile = await this.findTileInJson(this.tree.tilesetJson, tileId, "");
            if (tile !== undefined)
                props.push(tile);
        }));
        let totalBytes = 0;
        for (const prop of props) {
            if (undefined !== prop.geometry)
                totalBytes += prop.geometry.byteLength;
        }
        debugPrint("returning " + props.length + " tiles, Size: " + totalBytes + " Elapsed time: " + stopWatch.elapsedSeconds);
        return props;
    }
    async findTileInJson(tilesetJson, id, parentId) {
        const separatorIndex = id.indexOf("_");
        const childId = (separatorIndex < 0) ? id : id.substring(0, separatorIndex);
        const childIndex = parseInt(childId, 10);
        if (isNaN(childIndex) || tilesetJson === undefined || tilesetJson.children === undefined || childIndex >= tilesetJson.children.length) {
            bentleyjs_core_1.assert(false, "scalable mesh child not found.");
            return undefined;
        }
        let foundChild = tilesetJson.children[childIndex];
        const thisParentId = parentId.length ? (parentId + "_" + childId) : childId;
        if (separatorIndex >= 0) {
            return this.findTileInJson(foundChild, id.substring(separatorIndex + 1), thisParentId);
        }
        if (undefined === foundChild.content)
            return new RealityModelTileProps(foundChild, thisParentId, this.tree, undefined);
        if (foundChild.content.url.endsWith("json")) {
            const subTree = await this.tree.client.getTileJson(foundChild.content.url);
            foundChild = subTree.root;
            tilesetJson.children[childIndex] = subTree.root;
        }
        const content = await this.tree.client.getTileContent(foundChild.content.url);
        bentleyjs_core_1.assert(content !== undefined, "scalable mesh tile content not found.");
        return new RealityModelTileProps(foundChild, thisParentId, this.tree, content);
    }
}
/** @hidden */
class RealityModelTileTree {
    static loadRealityModelTileTree(url, modelState) {
        this.getTileTreeProps(url, modelState.iModel).then((tileTreeProps) => {
            modelState.setTileTree(tileTreeProps, new RealityModelTileLoader(tileTreeProps));
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        }).catch((_err) => modelState.loadStatus = TileTree_1.TileTree.LoadStatus.NotFound);
    }
    static async getTileTreeProps(url, iModel) {
        if (undefined !== url) {
            const urlParts = url.split("/");
            const tilesId = urlParts.find(bentleyjs_core_1.Guid.isGuid);
            let clientProps;
            if (undefined !== tilesId) {
                // ###TODO determine appropriate way to get token (probably from the imodel, but for standalone testing a workaround is needed)
                const authToken = await (new imodeljs_clients_1.ImsActiveSecureTokenClient("QA")).getToken("Regular.IModelJsTestUser@mailinator.com", "Regular@iMJs");
                const client = new imodeljs_clients_1.RealityDataServicesClient("QA");
                const accessToken = await client.getAccessToken(authToken);
                const projectId = urlParts.find((val) => val.includes("--")).split("--")[1];
                clientProps = { accessToken, projectId, tilesId, client };
            }
            const tileClient = new RealityModelTileClient(clientProps);
            const json = await tileClient.getRootDocument(url);
            const ecefLocation = iModel.ecefLocation;
            const rootTransform = CesiumUtils.transformFromJson(json.root.transform);
            let tileToDb = geometry_core_1.Transform.createIdentity();
            if (ecefLocation !== undefined) {
                const dbToEcef = geometry_core_1.Transform.createOriginAndMatrix(ecefLocation.origin, ecefLocation.orientation.toRotMatrix());
                const ecefToDb = dbToEcef.inverse();
                tileToDb.setMultiplyTransformTransform(ecefToDb, rootTransform);
            }
            else {
                tileToDb = rootTransform;
            }
            let rootGeometry;
            if (undefined !== json.root.content && undefined !== json.root.content.url)
                rootGeometry = await tileClient.getTileContent(json.root.content.url);
            return new RealityModelTileTreeProps(json, tileClient, tileToDb, rootGeometry);
        }
        else {
            throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Unable to read reality data");
        }
    }
}
exports.RealityModelTileTree = RealityModelTileTree;
class RealityModelTileClient {
    constructor(props) {
        this.baseUrl = "";
        this.rdsProps = props;
    }
    setBaseUrl(url) {
        const urlParts = url.split("/");
        urlParts.pop();
        this.baseUrl = urlParts.join("/") + "/";
    }
    async getRootDocument(url) {
        if (undefined !== this.rdsProps)
            return this.rdsProps.client.getRootDocumentJson(this.rdsProps.accessToken, this.rdsProps.projectId, this.rdsProps.tilesId);
        this.setBaseUrl(url);
        return imodeljs_clients_1.getJson(url);
    }
    async getTileContent(url) {
        if (undefined !== this.rdsProps)
            return this.rdsProps.client.getTileContent(this.rdsProps.accessToken, this.rdsProps.projectId, this.rdsProps.tilesId, url);
        if (undefined !== this.baseUrl) {
            const tileUrl = this.baseUrl + url;
            return imodeljs_clients_1.getArrayBuffer(tileUrl);
        }
        throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Unable to determine reality data content url");
    }
    async getTileJson(url) {
        if (undefined !== this.rdsProps)
            return this.rdsProps.client.getTileJson(this.rdsProps.accessToken, this.rdsProps.projectId, this.rdsProps.tilesId, url);
        if (undefined !== this.baseUrl) {
            const tileUrl = this.baseUrl + url;
            return imodeljs_clients_1.getJson(tileUrl);
        }
        throw new imodeljs_common_1.IModelError(32768 /* ERROR */, "Unable to determine reality data json url");
    }
}


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const PointVector_1 = __webpack_require__(4);
const Render_1 = __webpack_require__(119);
const Geometry_1 = __webpack_require__(3);
const common_1 = __webpack_require__(2);
const Range_1 = __webpack_require__(21);
const geometry_core_1 = __webpack_require__(1);
const Id_1 = __webpack_require__(162);
const JsonUtils_1 = __webpack_require__(163);
const TileTree_1 = __webpack_require__(62);
const FeatureSymbology_1 = __webpack_require__(73);
const Time_1 = __webpack_require__(164);
const System_1 = __webpack_require__(17);
const Assert_1 = __webpack_require__(93);
/** Contains functionality specific to sheet views. */
var Sheet;
(function (Sheet) {
    /** Describes the geometry and styling of a sheet border decoration. */
    class Border {
        constructor(rect, shadow, gradient) {
            this.rect = rect;
            this.shadow = shadow;
            this.gradient = gradient;
        }
        /** Create a new sheet border. If a context is supplied, points are transformed to view coordinates. */
        static create(width, height, context) {
            // Rect
            const rect = [
                PointVector_1.Point3d.create(0, height),
                PointVector_1.Point3d.create(0, 0),
                PointVector_1.Point3d.create(width, 0),
                PointVector_1.Point3d.create(width, height),
                PointVector_1.Point3d.create(0, height)
            ];
            if (context) {
                context.viewport.worldToViewArray(rect);
            }
            // Shadow
            const shadowWidth = .01 * Math.sqrt(width * width + height * height);
            const shadow = [
                PointVector_1.Point3d.create(shadowWidth, 0),
                PointVector_1.Point3d.create(shadowWidth, -shadowWidth),
                PointVector_1.Point3d.create(width + shadowWidth, -shadowWidth),
                PointVector_1.Point3d.create(width + shadowWidth, height - shadowWidth),
                PointVector_1.Point3d.create(width, height - shadowWidth),
                PointVector_1.Point3d.create(width, 0),
                PointVector_1.Point3d.create(shadowWidth, 0),
            ];
            if (context) {
                context.viewport.worldToViewArray(shadow);
            }
            // Gradient
            const gradient = new Render_1.Gradient.Symb();
            gradient.mode = 1 /* Linear */;
            gradient.angle = Geometry_1.Angle.createDegrees(-45);
            gradient.keys = [{ value: 0, color: common_1.ColorDef.from(25, 25, 25) }, { value: 0.5, color: common_1.ColorDef.from(150, 150, 150) }];
            // Copy over points
            // ### TODO: Allow for conversion of 2d points array to view coordinates from world coordinates to avoid these copies?..
            const rect2d = [];
            for (const point of rect)
                rect2d.push(PointVector_1.Point2d.createFrom(point));
            const shadow2d = [];
            for (const point of shadow)
                shadow2d.push(PointVector_1.Point2d.createFrom(point));
            return new Border(rect2d, shadow2d, gradient);
        }
        getRange() {
            const range = Range_1.Range2d.createArray(this.rect);
            const shadowRange = Range_1.Range2d.createArray(this.shadow);
            range.extendRange(shadowRange);
            return range;
        }
        /** Add this border to the given GraphicBuilder. */
        addToBuilder(builder) {
            builder.setSymbology(common_1.ColorDef.black, common_1.ColorDef.black, 2);
            builder.addLineString2d(this.rect, 0);
            const params = new Render_1.GraphicParams();
            params.setFillColor(common_1.ColorDef.black);
            if (Border._wantGradient)
                params.gradient = this.gradient;
            builder.activateGraphicParams(params);
            builder.addShape2d(this.shadow, System_1.RenderTarget.frustumDepth2d);
        }
    }
    Border._wantGradient = false; // ###TODO not working properly yet...
    Sheet.Border = Border;
    /** An extension of Tile specific to rendering 2d attachments. */
    class Tile2d extends TileTree_1.Tile {
        constructor(root, range) {
            super(new TileTree_1.Tile.Params(root, "", new common_1.ElementAlignedBox3d(), 512, // does not matter... have no children
            []));
            this.range.low.set(0, 0, -System_1.RenderTarget.frustumDepth2d);
            this.range.high.set(range.high.x, range.high.y, System_1.RenderTarget.frustumDepth2d);
        }
        // override
        get hasChildren() { return false; }
        // override
        get hasGraphics() { return true; }
        // override
        drawGraphics(args) {
            const myRoot = this.root;
            const viewRoot = myRoot.viewRoot;
            const drawArgs = viewRoot.createDrawArgs(args.context);
            drawArgs.location.setFrom(myRoot.drawingToAttachment);
            // drawArgs.viewFlagOverrides = new ViewFlag.Overrides(myRoot.view.viewFlags);
            drawArgs.clip = myRoot.graphicsClip;
            drawArgs.graphics.symbologyOverrides = myRoot.symbologyOverrides;
            myRoot.view.createSceneFromDrawArgs(drawArgs);
        }
    }
    Sheet.Tile2d = Tile2d;
    /** An extension of TileTree specific to rendering attachments. */
    class Tree extends TileTree_1.TileTree {
        constructor(model) {
            // The root tile set here does not matter, as it will be overwritten by the Tree2d and Tree3d constructors
            super(new TileTree_1.TileTree.Params(new Id_1.Id64(), {
                id: { treeId: "", tileId: "" },
                range: {
                    low: { x: 0, y: 0, z: 0 },
                    high: { x: 0, y: 0, z: 0 },
                },
                maximumSize: 512,
                childIds: [],
            }, model, undefined, geometry_core_1.Transform.createIdentity(), undefined, undefined, // ClipVector build in child class constructors
            undefined));
            this.biasDistance = 0;
        }
    }
    Sheet.Tree = Tree;
    /** An extension of TileTree specific to rendering 2d attachments. */
    class Tree2d extends Tree {
        constructor(model, attachment, view, viewRoot) {
            super(model);
            this.view = view;
            this.viewRoot = viewRoot;
            // Ensure elements inside the view attachment are not affected to changes to category display for the sheet view
            this.symbologyOverrides = new FeatureSymbology_1.FeatureSymbology.Overrides(view);
            const attachRange = attachment.placement.calculateRange();
            const attachWidth = attachRange.high.x - attachRange.low.x;
            const attachHeight = attachRange.high.y - attachRange.low.y;
            const viewExtents = view.getExtents();
            const scale = PointVector_1.Point2d.create(attachWidth / viewExtents.x, attachHeight / viewExtents.y);
            const worldToAttachment = PointVector_1.Point3d.createFrom(attachment.placement.origin);
            worldToAttachment.z = System_1.RenderTarget.depthFromDisplayPriority(attachment.displayPriority);
            const location = geometry_core_1.Transform.createOriginAndMatrix(worldToAttachment, geometry_core_1.RotMatrix.createIdentity());
            this.location.setFrom(location);
            const aspectRatioSkew = view.getAspectRatioSkew();
            this.drawingToAttachment = geometry_core_1.Transform.createOriginAndMatrix(PointVector_1.Point3d.create(), view.getRotation());
            this.drawingToAttachment.matrix.scaleColumns(scale.x, aspectRatioSkew * scale.y, 1, this.drawingToAttachment.matrix);
            const translation = viewRoot.location.origin.cloneAsPoint3d();
            const viewOrg = view.getOrigin().minus(translation);
            this.drawingToAttachment.multiplyPoint3d(viewOrg, viewOrg);
            translation.plus(viewOrg, viewOrg);
            viewOrg.z = 0;
            const viewOrgToAttachment = worldToAttachment.minus(viewOrg);
            translation.plus(viewOrgToAttachment, translation);
            this.drawingToAttachment.origin.setFrom(translation);
            this.expirationTime = Time_1.BeDuration.fromSeconds(15);
            // The renderer needs the unclipped range of the attachment in order to produce polys to be rendered as clip mask...
            // (Containment tests can also be more efficiently performed if boundary range is specified)
            const clipTf = location.inverse();
            if (clipTf !== undefined) {
                this.clipVector = attachment.getOrCreateClip(clipTf);
                clipTf.multiplyRange(attachRange, this.clipVector.boundingRange);
            }
            const sheetToDrawing = this.drawingToAttachment.inverse();
            if (sheetToDrawing !== undefined) {
                this.graphicsClip = attachment.getOrCreateClip(sheetToDrawing);
                sheetToDrawing.multiplyRange(attachRange, this.graphicsClip.boundingRange);
            }
            else {
                this.graphicsClip = geometry_core_1.ClipVector.createEmpty();
            }
            this._rootTile = new Tile2d(this, attachment.placement.bbox);
        }
        /** Create a Tree2d tile tree for a 2d attachment. Returns a Tree2d if the model tile tree is ready. Otherwise, returns the status of the tiles. */
        static create(attachment) {
            const view = attachment.view;
            const viewedModel = view.getViewedModel();
            if (!viewedModel)
                return TileTree_1.TileTree.LoadStatus.NotFound;
            const tileTree = viewedModel.getOrLoadTileTree();
            if (tileTree !== undefined)
                attachment.tree = new Tree2d(viewedModel, attachment, view, tileTree);
            return viewedModel.loadStatus;
        }
    }
    Sheet.Tree2d = Tree2d;
    /** An extension of TileTree specific to rendering 3d attachments. It contains a chain of tiles with texture renderings of the sheet (increasing in detail). */
    class Tree3d /* extends Tree */ {
    }
    Sheet.Tree3d = Tree3d;
    /** An attachment is a reference to a View, placed on a sheet. THe attachment specifies its view and its position on the sheet. */
    class Attachment {
        constructor(props, view) {
            this.id = new Id_1.Id64(props.id);
            this.view = view;
            this.displayPriority = 0;
            let scale;
            let placement;
            const jsonProps = props.jsonProperties;
            if (props.placement)
                placement = common_1.Placement2d.fromJSON(props.placement);
            if (jsonProps !== undefined) {
                scale = jsonProps.scale !== undefined ? JsonUtils_1.JsonUtils.asDouble(jsonProps.scale) : undefined;
                this.clip = jsonProps.clip !== undefined ? geometry_core_1.ClipVector.fromJSON(jsonProps.clip) : geometry_core_1.ClipVector.createEmpty();
                this.displayPriority = JsonUtils_1.JsonUtils.asInt(props.jsonProperties.displayPriority);
            }
            else {
                this.clip = geometry_core_1.ClipVector.createEmpty();
            }
            this.clip.parseClipPlanes();
            // Compute placement from scale, or scale from placement if necessary
            if (scale === undefined && placement === undefined) {
                scale = 1;
                placement = Attachment.computePlacement(view, PointVector_1.Point2d.create(), scale);
            }
            else if (scale === undefined) {
                scale = Attachment.computeScale(view, placement);
            }
            else if (placement === undefined) {
                placement = Attachment.computePlacement(view, PointVector_1.Point2d.create(), scale);
            }
            this.scale = scale;
            this.placement = placement;
        }
        /** Returns the tile tree corresponding to this attachment, which may be 2d or 3d. Returns undefined if the tree has not been loaded. */
        get tree() { return this._tree; }
        /** @hidden - Sets the reference to the tile tree corresponding to this attachment view's model. */
        set tree(tree) { this._tree = tree; }
        /** Given a view and placement, compute a scale for an attachment. */
        static computeScale(view, placement) {
            return view.getExtents().x / placement.bbox.width;
        }
        /** Given a view and an origin point, compute a placement for an attachment. */
        static computePlacement(view, origin, scale) {
            const viewExtents = view.getExtents();
            const box = new common_1.ElementAlignedBox2d();
            box.low.setZero();
            box.high.x = viewExtents.x / scale;
            box.high.y = viewExtents.y / scale;
            return new common_1.Placement2d(origin, Geometry_1.Angle.createDegrees(0), box);
        }
        /** Remove the clip vector from this view attachment. */
        clearClipping() { this.clip.clear(); }
        /** Create a boundary clip vector around this attachment. */
        createBoundaryClip() {
            const range = this.placement.calculateRange();
            const box = [
                PointVector_1.Point3d.create(range.low.x, range.low.y),
                PointVector_1.Point3d.create(range.high.x, range.low.y),
                PointVector_1.Point3d.create(range.high.x, range.high.y),
                PointVector_1.Point3d.create(range.low.x, range.high.y),
                PointVector_1.Point3d.create(range.low.x, range.low.y),
            ];
            const clip = geometry_core_1.ClipVector.createEmpty();
            clip.appendShape(box);
            return clip;
        }
        /** Returns a clone of the current clipping if it is defined and not null. Otherwise, attempt to create a new stored boundary clipping. */
        getOrCreateClip(transform) {
            if (!this.clip.isValid())
                this.clip = this.createBoundaryClip();
            const clipReturn = this.clip.clone();
            if (transform !== undefined)
                clipReturn.transformInPlace(transform);
            return clipReturn;
        }
        // DEBUG ONLY
        drawDebugBorder(context) {
            const origin = this.placement.origin;
            const bbox = this.placement.bbox;
            const rect = [
                PointVector_1.Point2d.create(origin.x, origin.y),
                PointVector_1.Point2d.create(origin.x + bbox.high.x, origin.y),
                PointVector_1.Point2d.create(origin.x + bbox.high.x, origin.y + bbox.high.y),
                PointVector_1.Point2d.create(origin.x, origin.y + bbox.high.y),
                PointVector_1.Point2d.create(origin.x, origin.y)
            ];
            const builder = context.createGraphic(geometry_core_1.Transform.createIdentity(), 2 /* WorldDecoration */);
            builder.setSymbology(Attachment.boundingBoxColor, Attachment.boundingBoxColor, 2);
            builder.addLineString2d(rect, 0);
            const attachmentBorder = builder.finish();
            context.outputGraphic(attachmentBorder);
        }
    }
    Attachment.boundingBoxColor = common_1.ColorDef.red; // ***DEBUG
    Sheet.Attachment = Attachment;
    /** A 2d sheet view attachment. */
    class Attachment2d extends Attachment {
        constructor(props, view) {
            super(props, view);
            this._loadStatus = TileTree_1.TileTree.LoadStatus.NotLoaded;
        }
        getLoadStatus() { return this._loadStatus; }
        load() {
            if (this._loadStatus === TileTree_1.TileTree.LoadStatus.Loaded)
                return;
            this._loadStatus = Tree2d.create(this);
        }
    }
    Sheet.Attachment2d = Attachment2d;
    /** A 3d sheet view attachment. */
    class Attachment3d extends Attachment {
        constructor(props /*, sheetView: SheetViewState*/, view) {
            super(props, view);
            // this.sheetView = sheetView;
            this.states = [];
        }
        /** Returns true if every level of the tree has a load status of 'Loaded'. */
        /*
        private get allDepthsLoaded(): boolean {
          for (const state of this.states)
            if (state !== TileTree.LoadStatus.Loaded)
              return false;
          return true;
        }
        */
        /** Returns the load status of the tile tree up to the depth level provided. */
        getLoadStatus(depth) {
            return depth < this.states.length ? this.states[depth] : TileTree_1.TileTree.LoadStatus.NotLoaded;
        }
        load() {
            /*
            if (this.allDepthsLoaded)
              return;
            Tree3d.create(this.sheetView, this);
            */
        }
    }
    Sheet.Attachment3d = Attachment3d;
    /** A list of view attachments for a sheet. */
    class Attachments {
        constructor() {
            this.list = [];
            this._allLoaded = true;
        }
        /** The number of attachments in this list. */
        get length() { return this.list.length; }
        /** Returns true if all of the attachments in the list have loaded tile trees. */
        get allLoaded() { return this._allLoaded; }
        /** Given a view id, return an attachment containing that view from the list. If no attachment in the list stores that view, returns undefined. */
        findByViewId(viewId) {
            for (const attachment of this.list)
                if (attachment.view.id.equals(viewId))
                    return attachment;
            return undefined;
        }
        /** Clear this list of attachments. */
        clear() {
            this.list.length = 0;
        }
        /** Add an attachment to this list of attachments. */
        add(attachment) {
            this._allLoaded = this._allLoaded && (attachment.getLoadStatus() === TileTree_1.TileTree.LoadStatus.Loaded);
            this.list.push(attachment);
        }
        /** Drop an attachment from this list by reference. */
        drop(attachment) {
            const idx = this.list.indexOf(attachment);
            if (idx !== -1)
                this.list.splice(idx, 1);
            this.updateAllLoaded();
        }
        /** Update the flag on this attachments list recording whether or not all attachments have loaded tile trees. */
        updateAllLoaded() {
            this._allLoaded = true;
            for (const attachment of this.list) {
                if (attachment.getLoadStatus() !== TileTree_1.TileTree.LoadStatus.Loaded) {
                    this._allLoaded = false;
                    break;
                }
            }
        }
        /** Load the tile tree for the attachment at the given index. Returns the load status of that attachment. */
        load(idx) {
            Assert_1.assert(idx < this.length);
            const attachment = this.list[idx];
            if (attachment.tree !== undefined)
                return TileTree_1.TileTree.LoadStatus.Loaded;
            attachment.load();
            if (attachment.getLoadStatus() === TileTree_1.TileTree.LoadStatus.NotFound || attachment.getLoadStatus() === TileTree_1.TileTree.LoadStatus.NotLoaded)
                this.list.splice(idx, 1);
            this.updateAllLoaded();
            return attachment.getLoadStatus();
        }
    }
    Sheet.Attachments = Attachments;
})(Sheet = exports.Sheet || (exports.Sheet = {}));


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const imodeljs_common_1 = __webpack_require__(2);
const bentleyjs_core_2 = __webpack_require__(0);
const geometry_core_1 = __webpack_require__(1);
const TileTree_1 = __webpack_require__(62);
const bentleyjs_core_3 = __webpack_require__(0);
const imodeljs_clients_1 = __webpack_require__(18);
const ModelState_1 = __webpack_require__(76);
class WebMercatorTileTreeProps {
    constructor(provider) {
        /** The unique identifier of this TileTree within the iModel */
        this.id = "";
        this.rootTile = new WebMercatorTileProps();
        this.location = geometry_core_1.Transform.createIdentity();
        this._provider = provider;
    }
}
class WebMercatorTileLoader extends TileTree_1.TileLoader {
    constructor(_props) {
        super();
        this._props = _props;
    }
    async getTileProps(_ids) { return [new WebMercatorTileProps()]; }
    getMaxDepth() { return this._props._provider.maximumZoomLevel; }
}
class WebMercatorTileProps {
    constructor() {
        /** The maximum size in pixels at which the tile should be drawn on the screen. */
        this.maximumSize = 30;
        /** Optional - set to True for Y Axis Up */
        this.yAxisUp = true;
        this.id = new imodeljs_common_1.TileId(new bentleyjs_core_2.Id64(""), "");
        this.childIds = new Array();
        this.range = new geometry_core_1.Range3d();
    }
}
// The type of background map
var MapType;
(function (MapType) {
    MapType[MapType["Street"] = 0] = "Street";
    MapType[MapType["Aerial"] = 1] = "Aerial";
    MapType[MapType["Hybrid"] = 2] = "Hybrid";
})(MapType || (MapType = {}));
// Represents the service that is providing map tiles for Web Mercator models (background maps).
class ImageryProvider {
    constructor(mapType) {
        this.mapType = mapType;
    }
    // returns true if the tile data matches the tile data of a "missing tile". See BingMapProvider.initialize.
    matchesMissingTile(_tileData) {
        return false;
    }
    // returns a Uint8Array with the contents of the tile.
    async loadTile(row, column, zoomLevel) {
        const tileUrl = this.constructUrl(row, column, zoomLevel);
        const tileRequestOptions = { method: "GET", responseType: "arraybuffer" };
        try {
            const tileResponse = await imodeljs_clients_1.request(tileUrl, tileRequestOptions);
            const byteArray = new Uint8Array(tileResponse.body);
            if (!byteArray || (byteArray.length === 0))
                return undefined;
            if (this.matchesMissingTile(byteArray))
                return undefined;
            return byteArray;
        }
        catch (error) {
            return undefined;
        }
    }
}
// Represents one range of geography and tile zoom levels for a bing data provider
class Coverage {
    constructor(lowerLeftLongitude, lowerLeftLatitude, upperRightLongitude, upperRightLatitude, minimumZoomLevel, maximumZoomLevel) {
        this.lowerLeftLongitude = lowerLeftLongitude;
        this.lowerLeftLatitude = lowerLeftLatitude;
        this.upperRightLongitude = upperRightLongitude;
        this.upperRightLatitude = upperRightLatitude;
        this.minimumZoomLevel = minimumZoomLevel;
        this.maximumZoomLevel = maximumZoomLevel;
    }
}
// Represents the copyright message and an array of coverage data for one of bing's data providers (HERE for example).
class BingAttribution {
    constructor(copyrightMessage, coverages) {
        this.copyrightMessage = copyrightMessage;
        this.coverages = coverages;
    }
}
// Our ImageryProvider for Bing Maps.
class BingMapProvider extends ImageryProvider {
    constructor(mapType) {
        super(mapType);
        this._zoomMin = this._zoomMax = 0;
        this._tileHeight = this._tileWidth = 0;
    }
    get tileWidth() { return this._tileWidth; }
    get tileHeight() { return this._tileHeight; }
    get minimumZoomLevel() { return this._zoomMin; }
    get maximumZoomLevel() { return this._zoomMax; }
    tileXYToQuadKey(tileX, tileY, zoomLevel) {
        // from C# example in bing documentation https://msdn.microsoft.com/en-us/library/bb259689.aspx
        let quadKey = "";
        // Root tile is not displayable. Returns 0 for _GetMaximumSize(). Should not end up here.
        bentleyjs_core_1.assert(0 !== zoomLevel);
        for (let i = zoomLevel; i > 0; i--) {
            let digit = 0x30; // '0'
            const mask = 1 << (i - 1);
            if ((tileX & mask) !== 0) {
                digit++;
            }
            if ((tileY & mask) !== 0) {
                digit++;
                digit++;
            }
            quadKey = quadKey.concat(String.fromCharCode(digit));
        }
        return quadKey;
    }
    // construct the Url from the desired Tile
    constructUrl(row, column, zoomLevel) {
        // From the tile, get a "quadKey" the Microsoft way.
        const quadKey = this.tileXYToQuadKey(column, row, zoomLevel);
        const subdomain = this._urlSubdomains[(row + column) % this._urlSubdomains.length];
        // from the template url, construct the tile url.
        let url = this._urlTemplate.replace("{subdomain}", subdomain);
        url = url.replace("{quadkey}", quadKey);
        return url;
    }
    getCopyrightImage() { return this._logoByteArray; }
    getCopyrightMessage() { return ""; } // NEEDSWORK
    matchesMissingTile(tileData) {
        if (!this._missingTileData)
            return false;
        if (tileData.length !== this._missingTileData.length)
            return false;
        for (let i = 0; i < tileData.length; i += 10) {
            if (this._missingTileData[i] !== tileData[i]) {
                return false;
            }
        }
        return true;
    }
    // initializes the BingMapProvider by reading the templateUrl, logo image, and attribution list.
    async initialize() {
        // get the template url
        // NEEDSWORK - should get bing key from server.
        const bingKey = "AtaeI3QDNG7Bpv1L53cSfDBgBKXIgLq3q-xmn_Y2UyzvF-68rdVxwAuje49syGZt";
        let imagerySet = "Road";
        if (MapType.Aerial === this.mapType)
            imagerySet = "Aerial";
        else if (MapType.Hybrid === this.mapType)
            imagerySet = "AerialWithLabels";
        let bingRequestUrl = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?o=json&incl=ImageryProviders&key={bingKey}";
        bingRequestUrl = bingRequestUrl.replace("{imagerySet}", imagerySet);
        bingRequestUrl = bingRequestUrl.replace("{bingKey}", bingKey);
        const requestOptions = {
            method: "GET",
        };
        try {
            const response = await imodeljs_clients_1.request(bingRequestUrl, requestOptions);
            const bingResponseProps = response.body;
            this._logoUrl = bingResponseProps.brandLogoUri;
            const thisResourceSetProps = bingResponseProps.resourceSets[0];
            const thisResourceProps = thisResourceSetProps.resources[0];
            this._zoomMin = thisResourceProps.zoomMin;
            this._zoomMax = thisResourceProps.zoomMax;
            this._tileHeight = thisResourceProps.imageHeight;
            this._tileWidth = thisResourceProps.imageWidth;
            this._urlTemplate = thisResourceProps.imageUrl.replace("{culture}", "en-US"); // NEEDSWORK - get locale from somewhere.
            this._urlSubdomains = thisResourceProps.imageUrlSubdomains;
            // read the list of Bing's data suppliers and the range of data they provide. Used in calculation of copyright message.
            this.readAttributions(thisResourceProps.imageryProviders);
            // read the Bing logo data, used in getCopyrightImage
            this.readLogo().then((logoByteArray) => { this._logoByteArray = logoByteArray; });
            // Bing sometimes provides tiles that have nothing but a stupid camera icon in the middle of them when you ask
            // for tiles at zoom levels where they don't have data. Their application stops you from zooming in when that's the
            // case, but we can't stop - the user might want to look at design data a closer zoom. So we intentionally load such
            // a tile, and then compare other tiles to it, rejecting them if they match.
            this.loadTile(0, 0, this._zoomMax - 1).then((tileData) => {
                this._missingTileData = tileData;
            });
        }
        catch (error) {
            throw new bentleyjs_core_3.BentleyError(65541 /* BadModel */, "Error in Bing Server communications");
        }
    }
    // reads the Bing logo from the url returned as part of the first response.
    readLogo() {
        if (!this._logoUrl || (this._logoUrl.length === 0))
            return Promise.resolve(undefined);
        const logoRequestOptions = { method: "GET", responseType: "arraybuffer" };
        return imodeljs_clients_1.request(this._logoUrl, logoRequestOptions).then((logoResponse) => {
            const byteArray = new Uint8Array(logoResponse.body);
            if (!byteArray || (byteArray.length === 0))
                return undefined;
            return byteArray;
        }, (_error) => {
            return undefined;
        });
    }
    // reads the list of Bing data providers and the map range for which they each provide data.
    readAttributions(attributionProps) {
        for (const thisAttributionProps of attributionProps) {
            const copyrightMessage = thisAttributionProps.attribution;
            const coverages = new Array();
            for (const thisCoverageProps of thisAttributionProps.coverageAreas) {
                const thisCoverage = new Coverage(thisCoverageProps.bbox[0], thisCoverageProps.bbox[1], thisCoverageProps.bbox[2], thisCoverageProps.bbox[3], thisCoverageProps.zoomMin, thisCoverageProps.zoomMax);
                coverages.push(thisCoverage);
            }
            const thisAttribution = new BingAttribution(copyrightMessage, coverages);
            if (!this._attributions)
                this._attributions = new Array();
            this._attributions.push(thisAttribution);
        }
    }
}
// Our ImageryProvider for Bing Maps.
class MapBoxProvider extends ImageryProvider {
    constructor(mapType) {
        super(mapType);
        this._zoomMin = this._zoomMax = 0;
        switch (mapType) {
            case MapType.Street:
                this._baseUrl = "http://api.mapbox.com/v4/mapbox.streets/";
                break;
            case MapType.Aerial:
                this._baseUrl = "http://api.mapbox.com/v4/mapbox.satellite/";
                break;
            case MapType.Hybrid:
                this._baseUrl = "http://api.mapbox.com/v4/mapbox.streets-satellite/";
                break;
            default:
                this._baseUrl = "";
                bentleyjs_core_1.assert(false);
        }
    }
    get tileWidth() { return 256; }
    get tileHeight() { return 256; }
    get minimumZoomLevel() { return this._zoomMin; }
    get maximumZoomLevel() { return this._zoomMax; }
    // construct the Url from the desired Tile
    constructUrl(row, column, zoomLevel) {
        // from the template url, construct the tile url.
        let url = this._baseUrl.concat(zoomLevel.toString());
        url = url.concat("/").concat(column.toString()).concat("/").concat(row.toString());
        url = url.concat(".jpg80?access_token=pk%2EeyJ1IjoibWFwYm94YmVudGxleSIsImEiOiJjaWZvN2xpcW00ZWN2czZrcXdreGg2eTJ0In0%2Ef7c9GAxz6j10kZvL%5F2DBHg");
        return url;
    }
    getCopyrightImage() { return undefined; }
    getCopyrightMessage() { return "(c) Mapbox, (c) OpenStreetMap contributors"; }
    // no initialization needed for MapBoxProvider.
    async initialize() { }
}
/** @hidden */
class WebMercatorModelState extends ModelState_1.SpatialModelState {
    // The Tile Tree generated from a WebMercator map model.
    static async getTileTreeProps(jsonProperties, _iModel) {
        if (jsonProperties.hasOwnProperty("providerName") && jsonProperties.hasOwnProperty("providerData")) {
            const providerName = jsonProperties.providerName;
            const providerData = jsonProperties.providerData;
            let provider;
            if (("BingProvider" === providerName) && (providerData.hasOwnProperty("mapType"))) {
                const mapType = Number(providerData.mapType);
                provider = new BingMapProvider(mapType);
            }
            else if (("MapBoxProvider" === providerName) && (providerData.hasOwnProperty("mapType"))) {
                const mapType = Number(providerData.mapType);
                provider = new MapBoxProvider(mapType);
            }
            else {
                throw new bentleyjs_core_3.BentleyError(65541 /* BadModel */, "WebMercator provider invalid");
            }
            await (provider.initialize());
            return new WebMercatorTileTreeProps(provider);
        }
        throw new bentleyjs_core_3.BentleyError(65541 /* BadModel */, "WebMercator specification invalid");
    }
    loadTileTree() {
        if (TileTree_1.TileTree.LoadStatus.NotLoaded !== this._loadStatus)
            return this._loadStatus;
        this._loadStatus = TileTree_1.TileTree.LoadStatus.Loading;
        WebMercatorModelState.getTileTreeProps(this.jsonProperties.webMercatorModel, this.iModel).then((tileTreeProps) => {
            this.setTileTree(tileTreeProps, new WebMercatorTileLoader(tileTreeProps));
        }).catch((_err) => this._loadStatus = TileTree_1.TileTree.LoadStatus.NotFound);
        return this._loadStatus;
    }
}
exports.WebMercatorModelState = WebMercatorModelState;


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(343));
//# sourceMappingURL=i18n.js.map

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module AppAdministration */
Object.defineProperty(exports, "__esModule", { value: true });
const i18next = __webpack_require__(344);
const i18nextXHRBackend = __webpack_require__(354);
const i18nextBrowserLanguageDetector = __webpack_require__(358);
const bentleyjs_core_1 = __webpack_require__(0);
const bentleyjs_core_2 = __webpack_require__(0);
class I18N {
    constructor(nameSpaces, defaultNameSpace, options, renderFunction) {
        this.namespaceRegistry = new Map();
        this.i18n = i18next.createInstance();
        const initOptions = {
            interpolation: { escapeValue: true },
            fallbackLng: "en",
            ns: nameSpaces,
            defaultNS: defaultNameSpace,
            backend: {
                loadPath: options && options.urlTemplate ? options.urlTemplate : "locales/{{lng}}/{{ns}}.json",
                crossDomain: true,
            },
        };
        // if in a development environment, set to pseudo-localize, otherwise detect from browser.
        const isDevelopment = process.env.NODE_ENV === "development";
        if (isDevelopment) {
            initOptions.debug = true;
        }
        else {
            this.i18n = this.i18n.use(i18nextBrowserLanguageDetector);
        }
        // call the changeLanguage method right away, before any calls to I18NNamespace.register. Otherwise, the call doesn't happen until the deferred load of the default namespace
        this.i18n.use(i18nextXHRBackend)
            .init(initOptions, renderFunction)
            .changeLanguage(isDevelopment ? "en-pseudo" : undefined, undefined);
    }
    /**
     * Replace all instances of `%{key}` within a string with the translations of those keys.
     * For example:
     * ``` ts
     * "MyKeys": {
     *   "Key1": "First value",
     *   "Key2": "Second value"
     *  }
     * ```
     *
     * ``` ts
     * i18.translateKeys("string with %{MyKeys.Key1} followed by %{MyKeys.Key2}!"") // returns "string with First Value followed by Second Value!"
     * ```
     * @param line The input line, potentially containing %{keys}.
     * @returns The line with all %{keys} translated
     */
    translateKeys(line) { return line.replace(/\%\{(.+?)\}/g, (_match, tag) => this.translate(tag)); }
    /** Return the translated value of a key. */
    translate(key, options) { return this.i18n.t(key, options); }
    loadNamespace(name, i18nCallback) { this.i18n.loadNamespaces(name, i18nCallback); }
    languageList() { return this.i18n.languages; }
    // register a new Namespace. Must be unique in the system.
    registerNamespace(name) {
        if (this.namespaceRegistry.get(name))
            throw new bentleyjs_core_1.BentleyError(-1, "namespace '" + name + "' is not unique");
        const theReadPromise = new Promise((resolve, _reject) => {
            this.loadNamespace(name, (err, _t) => {
                if (!err) {
                    resolve();
                    return;
                }
                // Here we got a non-null err object.
                // This method is called when the system has attempted to load the resources for the namespace for each
                // possible locale. For example 'fr-ca' might be the most specific local, in which case 'fr' ) and 'en are fallback locales.
                // using i18next-xhr-backend, err will be an array of strings that includes the namespace it tried to read and the locale. There
                // might be errs for some other namespaces as well as this one. We resolve the promise unless there's an error for each possible language.
                const errorList = err;
                let locales = this.languageList().map((thisLocale) => "/" + thisLocale + "/");
                for (const thisError of errorList) {
                    if (!thisError.includes(name))
                        continue;
                    locales = locales.filter((thisLocale) => !thisError.includes(thisLocale));
                }
                // if we removed every locale from the array, it wasn't loaded.
                if (locales.length === 0)
                    bentleyjs_core_2.Logger.logError("I81N", "The resource for namespace " + name + " could not be loaded");
                resolve();
            });
        });
        const thisNamespace = new I18NNamespace(name, theReadPromise);
        this.namespaceRegistry.set(name, thisNamespace);
        return thisNamespace;
    }
    waitForAllRead() {
        const namespacePromises = new Array();
        for (const thisNamespace of this.namespaceRegistry.values()) {
            namespacePromises.push(thisNamespace.readFinished);
        }
        return Promise.all(namespacePromises);
    }
}
exports.I18N = I18N;
class I18NNamespace {
    constructor(name, readFinished) {
        this.name = name;
        this.readFinished = readFinished;
    }
}
exports.I18NNamespace = I18NNamespace;
//# sourceMappingURL=Localization.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeLanguage", function() { return changeLanguage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneInstance", function() { return cloneInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInstance", function() { return createInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dir", function() { return dir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exists", function() { return exists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFixedT", function() { return getFixedT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLanguages", function() { return loadLanguages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadNamespaces", function() { return loadNamespaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadResources", function() { return loadResources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultNamespace", function() { return setDefaultNamespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "use", function() { return use; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__i18next_js__ = __webpack_require__(345);


/* harmony default export */ __webpack_exports__["default"] = (__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);

var changeLanguage = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].changeLanguage.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var cloneInstance = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].cloneInstance.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var createInstance = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].createInstance.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var dir = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].dir.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var exists = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].exists.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var getFixedT = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].getFixedT.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var init = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].init.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var loadLanguages = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].loadLanguages.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var loadNamespaces = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].loadNamespaces.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var loadResources = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].loadResources.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var off = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].off.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var on = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].on.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var setDefaultNamespace = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].setDefaultNamespace.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var t = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].t.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);
var use = __WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */].use.bind(__WEBPACK_IMPORTED_MODULE_0__i18next_js__["a" /* default */]);

/***/ }),
/* 345 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__logger_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ResourceStore_js__ = __webpack_require__(346);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Translator_js__ = __webpack_require__(347);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LanguageUtils_js__ = __webpack_require__(348);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__PluralResolver_js__ = __webpack_require__(349);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Interpolator_js__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__BackendConnector_js__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__CacheConnector_js__ = __webpack_require__(352);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__defaults_js__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__postProcessor_js__ = __webpack_require__(216);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }













function noop() {}

var I18n = function (_EventEmitter) {
  _inherits(I18n, _EventEmitter);

  function I18n() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments[1];

    _classCallCheck(this, I18n);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.options = Object(__WEBPACK_IMPORTED_MODULE_9__defaults_js__["b" /* transformOptions */])(options);
    _this.services = {};
    _this.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */];
    _this.modules = { external: [] };

    if (callback && !_this.isInitialized && !options.isClone) {
      var _ret;

      // https://github.com/i18next/i18next/issues/879
      if (!_this.options.initImmediate) return _ret = _this.init(options, callback), _possibleConstructorReturn(_this, _ret);
      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }

  I18n.prototype.init = function init() {
    var _this2 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments[1];

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    this.options = _extends({}, Object(__WEBPACK_IMPORTED_MODULE_9__defaults_js__["a" /* get */])(), this.options, Object(__WEBPACK_IMPORTED_MODULE_9__defaults_js__["b" /* transformOptions */])(options));

    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;

    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === 'function') return new ClassOrObject();
      return ClassOrObject;
    }

    // init services
    if (!this.options.isClone) {
      if (this.modules.logger) {
        __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].init(null, this.options);
      }

      var lu = new __WEBPACK_IMPORTED_MODULE_4__LanguageUtils_js__["a" /* default */](this.options);
      this.store = new __WEBPACK_IMPORTED_MODULE_2__ResourceStore_js__["a" /* default */](this.options.resources, this.options);

      var s = this.services;
      s.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */];
      s.resourceStore = this.store;
      s.resourceStore.on('added removed', function (lng, ns) {
        s.cacheConnector.save();
      });
      s.languageUtils = lu;
      s.pluralResolver = new __WEBPACK_IMPORTED_MODULE_5__PluralResolver_js__["a" /* default */](lu, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON, simplifyPluralSuffix: this.options.simplifyPluralSuffix });
      s.interpolator = new __WEBPACK_IMPORTED_MODULE_6__Interpolator_js__["a" /* default */](this.options);

      s.backendConnector = new __WEBPACK_IMPORTED_MODULE_7__BackendConnector_js__["a" /* default */](createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      // pipe events from backendConnector
      s.backendConnector.on('*', function (event) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });

      s.backendConnector.on('loaded', function (loaded) {
        s.cacheConnector.save();
      });

      s.cacheConnector = new __WEBPACK_IMPORTED_MODULE_8__CacheConnector_js__["a" /* default */](createClassOnDemand(this.modules.cache), s.resourceStore, s, this.options);
      // pipe events from backendConnector
      s.cacheConnector.on('*', function (event) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });

      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        s.languageDetector.init(s, this.options.detection, this.options);
      }

      this.translator = new __WEBPACK_IMPORTED_MODULE_3__Translator_js__["a" /* default */](this.services, this.options);
      // pipe events from translator
      this.translator.on('*', function (event) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });

      this.modules.external.forEach(function (m) {
        if (m.init) m.init(_this2);
      });
    }

    // append api
    var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle'];
    storeApi.forEach(function (fcName) {
      _this2[fcName] = function () {
        var _store;

        return (_store = _this2.store)[fcName].apply(_store, arguments);
      };
    });

    var load = function load() {
      _this2.changeLanguage(_this2.options.lng, function (err, t) {
        _this2.isInitialized = true;
        _this2.logger.log('initialized', _this2.options);
        _this2.emit('initialized', _this2.options);

        callback(err, t);
      });
    };

    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }

    return this;
  };

  /* eslint consistent-return: 0 */


  I18n.prototype.loadResources = function loadResources() {
    var _this3 = this;

    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

    if (!this.options.resources) {
      if (this.language && this.language.toLowerCase() === 'cimode') return callback(); // avoid loading resources for cimode

      var toLoad = [];

      var append = function append(lng) {
        if (!lng) return;
        var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach(function (l) {
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };

      if (!this.language) {
        // at least load fallbacks in this case
        var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach(function (l) {
          return append(l);
        });
      } else {
        append(this.language);
      }

      if (this.options.preload) {
        this.options.preload.forEach(function (l) {
          return append(l);
        });
      }

      this.services.cacheConnector.load(toLoad, this.options.ns, function () {
        _this3.services.backendConnector.load(toLoad, _this3.options.ns, callback);
      });
    } else {
      callback(null);
    }
  };

  I18n.prototype.reloadResources = function reloadResources(lngs, ns) {
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    this.services.backendConnector.reload(lngs, ns);
  };

  I18n.prototype.use = function use(module) {
    if (module.type === 'backend') {
      this.modules.backend = module;
    }

    if (module.type === 'cache') {
      this.modules.cache = module;
    }

    if (module.type === 'logger' || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }

    if (module.type === 'languageDetector') {
      this.modules.languageDetector = module;
    }

    if (module.type === 'postProcessor') {
      __WEBPACK_IMPORTED_MODULE_10__postProcessor_js__["a" /* default */].addPostProcessor(module);
    }

    if (module.type === '3rdParty') {
      this.modules.external.push(module);
    }

    return this;
  };

  I18n.prototype.changeLanguage = function changeLanguage(lng, callback) {
    var _this4 = this;

    var done = function done(err, l) {
      _this4.translator.changeLanguage(l);

      if (l) {
        _this4.emit('languageChanged', l);
        _this4.logger.log('languageChanged', l);
      }

      if (callback) callback(err, function () {
        return _this4.t.apply(_this4, arguments);
      });
    };

    var setLng = function setLng(l) {
      if (l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        if (!_this4.translator.language) _this4.translator.changeLanguage(l);

        if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
      }

      _this4.loadResources(function (err) {
        done(err, l);
      });
    };

    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      this.services.languageDetector.detect(setLng);
    } else {
      setLng(lng);
    }
  };

  I18n.prototype.getFixedT = function getFixedT(lng, ns) {
    var _this5 = this;

    var fixedT = function fixedT(key, opts) {
      for (var _len4 = arguments.length, rest = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        rest[_key4 - 2] = arguments[_key4];
      }

      var options = _extends({}, opts);
      if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      }

      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      return _this5.t(key, options);
    };
    if (typeof lng === 'string') {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    return fixedT;
  };

  I18n.prototype.t = function t() {
    var _translator;

    return this.translator && (_translator = this.translator).translate.apply(_translator, arguments);
  };

  I18n.prototype.exists = function exists() {
    var _translator2;

    return this.translator && (_translator2 = this.translator).exists.apply(_translator2, arguments);
  };

  I18n.prototype.setDefaultNamespace = function setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  };

  I18n.prototype.loadNamespaces = function loadNamespaces(ns, callback) {
    var _this6 = this;

    if (!this.options.ns) return callback && callback();
    if (typeof ns === 'string') ns = [ns];

    ns.forEach(function (n) {
      if (_this6.options.ns.indexOf(n) < 0) _this6.options.ns.push(n);
    });

    this.loadResources(callback);
  };

  I18n.prototype.loadLanguages = function loadLanguages(lngs, callback) {
    if (typeof lngs === 'string') lngs = [lngs];
    var preloaded = this.options.preload || [];

    var newLngs = lngs.filter(function (lng) {
      return preloaded.indexOf(lng) < 0;
    });
    // Exit early if all given languages are already preloaded
    if (!newLngs.length) return callback();

    this.options.preload = preloaded.concat(newLngs);
    this.loadResources(callback);
  };

  I18n.prototype.dir = function dir(lng) {
    if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
    if (!lng) return 'rtl';

    var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];

    return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
  };

  /* eslint class-methods-use-this: 0 */


  I18n.prototype.createInstance = function createInstance() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments[1];

    return new I18n(options, callback);
  };

  I18n.prototype.cloneInstance = function cloneInstance() {
    var _this7 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    var mergedOptions = _extends({}, this.options, options, { isClone: true });
    var clone = new I18n(mergedOptions);
    var membersToCopy = ['store', 'services', 'language'];
    membersToCopy.forEach(function (m) {
      clone[m] = _this7[m];
    });
    clone.translator = new __WEBPACK_IMPORTED_MODULE_3__Translator_js__["a" /* default */](clone.services, clone.options);
    clone.translator.on('*', function (event) {
      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      clone.emit.apply(clone, [event].concat(args));
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = clone.options; // sync options

    return clone;
  };

  return I18n;
}(__WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (new I18n());

/***/ }),
/* 346 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__EventEmitter_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_js__ = __webpack_require__(99);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }




var ResourceStore = function (_EventEmitter) {
  _inherits(ResourceStore, _EventEmitter);

  function ResourceStore(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { ns: ['translation'], defaultNS: 'translation' };

    _classCallCheck(this, ResourceStore);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.data = data || {};
    _this.options = options;
    return _this;
  }

  ResourceStore.prototype.addNamespaces = function addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  };

  ResourceStore.prototype.removeNamespaces = function removeNamespaces(ns) {
    var index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  };

  ResourceStore.prototype.getResource = function getResource(lng, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var keySeparator = options.keySeparator || this.options.keySeparator;
    if (keySeparator === undefined) keySeparator = '.';

    var path = [lng, ns];
    if (key && typeof key !== 'string') path = path.concat(key);
    if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
    }

    return __WEBPACK_IMPORTED_MODULE_1__utils_js__["d" /* getPath */](this.data, path);
  };

  ResourceStore.prototype.addResource = function addResource(lng, ns, key, value) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { silent: false };

    var keySeparator = this.options.keySeparator;
    if (keySeparator === undefined) keySeparator = '.';

    var path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      value = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);

    __WEBPACK_IMPORTED_MODULE_1__utils_js__["h" /* setPath */](this.data, path, value);

    if (!options.silent) this.emit('added', lng, ns, key, value);
  };

  ResourceStore.prototype.addResources = function addResources(lng, ns, resources) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { silent: false };

    /* eslint no-restricted-syntax: 0 */
    for (var m in resources) {
      if (typeof resources[m] === 'string') this.addResource(lng, ns, m, resources[m], { silent: true });
    }
    if (!options.silent) this.emit('added', lng, ns, resources);
  };

  ResourceStore.prototype.addResourceBundle = function addResourceBundle(lng, ns, resources, deep, overwrite) {
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : { silent: false };

    var path = [lng, ns];
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      deep = resources;
      resources = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);

    var pack = __WEBPACK_IMPORTED_MODULE_1__utils_js__["d" /* getPath */](this.data, path) || {};

    if (deep) {
      __WEBPACK_IMPORTED_MODULE_1__utils_js__["b" /* deepExtend */](pack, resources, overwrite);
    } else {
      pack = _extends({}, pack, resources);
    }

    __WEBPACK_IMPORTED_MODULE_1__utils_js__["h" /* setPath */](this.data, path, pack);

    if (!options.silent) this.emit('added', lng, ns, resources);
  };

  ResourceStore.prototype.removeResourceBundle = function removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);

    this.emit('removed', lng, ns);
  };

  ResourceStore.prototype.hasResourceBundle = function hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== undefined;
  };

  ResourceStore.prototype.getResourceBundle = function getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;

    // COMPATIBILITY: remove extend in v2.1.0
    if (this.options.compatibilityAPI === 'v1') return _extends({}, this.getResource(lng, ns));

    return this.getResource(lng, ns);
  };

  ResourceStore.prototype.toJSON = function toJSON() {
    return this.data;
  };

  return ResourceStore;
}(__WEBPACK_IMPORTED_MODULE_0__EventEmitter_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ResourceStore);

/***/ }),
/* 347 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__logger_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__postProcessor_js__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_js__ = __webpack_require__(99);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }






var Translator = function (_EventEmitter) {
  _inherits(Translator, _EventEmitter);

  function Translator(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Translator);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    __WEBPACK_IMPORTED_MODULE_3__utils_js__["a" /* copy */](['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector'], services, _this);

    _this.options = options;
    _this.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].create('translator');
    return _this;
  }

  Translator.prototype.changeLanguage = function changeLanguage(lng) {
    if (lng) this.language = lng;
  };

  Translator.prototype.exists = function exists(key) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { interpolation: {} };

    var resolved = this.resolve(key, options);
    return resolved && resolved.res !== undefined;
  };

  Translator.prototype.extractFromKey = function extractFromKey(key, options) {
    var nsSeparator = options.nsSeparator || this.options.nsSeparator;
    if (nsSeparator === undefined) nsSeparator = ':';
    var keySeparator = options.keySeparator || this.options.keySeparator || '.';

    var namespaces = options.ns || this.options.defaultNS;
    if (nsSeparator && key.indexOf(nsSeparator) > -1) {
      var parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === 'string') namespaces = [namespaces];

    return {
      key: key,
      namespaces: namespaces
    };
  };

  Translator.prototype.translate = function translate(keys, options) {
    var _this2 = this;

    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' && this.options.overloadTranslationOptionHandler) {
      /* eslint prefer-rest-params: 0 */
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (!options) options = {};

    // non valid keys handling
    if (keys === undefined || keys === null || keys === '') return '';
    if (typeof keys === 'number') keys = String(keys);
    if (typeof keys === 'string') keys = [keys];

    // separators
    var keySeparator = options.keySeparator || this.options.keySeparator || '.';

    // get namespace(s)

    var _extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
        key = _extractFromKey.key,
        namespaces = _extractFromKey.namespaces;

    var namespace = namespaces[namespaces.length - 1];

    // return key on CIMode
    var lng = options.lng || this.language;
    var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === 'cimode') {
      if (appendNamespaceToCIMode) {
        var nsSeparator = options.nsSeparator || this.options.nsSeparator;
        return namespace + nsSeparator + key;
      }

      return key;
    }

    // resolve from store
    var resolved = this.resolve(keys, options);
    var res = resolved && resolved.res;
    var resUsedKey = resolved && resolved.usedKey || key;

    var resType = Object.prototype.toString.apply(res);
    var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
    var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;

    // object
    var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';
    if (res && handleAsObject && noObject.indexOf(resType) < 0 && !(joinArrays && resType === '[object Array]')) {
      if (!options.returnObjects && !this.options.returnObjects) {
        this.logger.warn('accessing an object - but returnObjects options is not enabled!');
        return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : 'key \'' + key + ' (' + this.language + ')\' returned an object instead of string.';
      }

      // if we got a separator we loop over children - else we just return object as is
      // as having it set to false means no hierarchy so no lookup for nested values
      if (options.keySeparator || this.options.keySeparator) {
        var copy = resType === '[object Array]' ? [] : {}; // apply child translation on a copy

        /* eslint no-restricted-syntax: 0 */
        for (var m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            var deepKey = '' + resUsedKey + keySeparator + m;
            copy[m] = this.translate(deepKey, _extends({}, options, { joinArrays: false, ns: namespaces }));
            if (copy[m] === deepKey) copy[m] = res[m]; // if nothing found use orginal value as fallback
          }
        }
        res = copy;
      }
    } else if (joinArrays && resType === '[object Array]') {
      // array special treatment
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options);
    } else {
      // string, empty or null
      var usedDefault = false;
      var usedKey = false;

      // fallback value
      if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
        usedDefault = true;
        res = options.defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }

      // save missing
      var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);

        var lngs = [];
        var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
          for (var i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === 'all') {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }

        var send = function send(l, k) {
          if (_this2.options.missingKeyHandler) {
            _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
          } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
            _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
          }
          _this2.emit('missingKey', l, namespace, k, res);
        };

        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && options.count) {
            lngs.forEach(function (l) {
              var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

              plurals.forEach(function (p) {
                return send([l], p);
              });
            });
          } else {
            send(lngs, key);
          }
        }
      }

      // extend
      res = this.extendTranslation(res, keys, options);

      // append namespace if still key
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = namespace + ':' + key;

      // parseMissingKeyHandler
      if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
    }

    // return
    return res;
  };

  Translator.prototype.extendTranslation = function extendTranslation(res, key, options) {
    var _this3 = this;

    if (options.interpolation) this.interpolator.init(_extends({}, options, { interpolation: _extends({}, this.options.interpolation, options.interpolation) }));

    // interpolate
    var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
    if (this.options.interpolation.defaultVariables) data = _extends({}, this.options.interpolation.defaultVariables, data);
    res = this.interpolator.interpolate(res, data, options.lng || this.language);

    // nesting
    if (options.nest !== false) res = this.interpolator.nest(res, function () {
      return _this3.translate.apply(_this3, arguments);
    }, options);

    if (options.interpolation) this.interpolator.reset();

    // post process
    var postProcess = options.postProcess || this.options.postProcess;
    var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

    if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = __WEBPACK_IMPORTED_MODULE_2__postProcessor_js__["a" /* default */].handle(postProcessorNames, res, key, options, this);
    }

    return res;
  };

  Translator.prototype.resolve = function resolve(keys) {
    var _this4 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var found = void 0;
    var usedKey = void 0;

    if (typeof keys === 'string') keys = [keys];

    // forEach possible key
    keys.forEach(function (k) {
      if (_this4.isValidLookup(found)) return;
      var extracted = _this4.extractFromKey(k, options);
      var key = extracted.key;
      usedKey = key;
      var namespaces = extracted.namespaces;
      if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);

      var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
      var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';

      var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language);

      namespaces.forEach(function (ns) {
        if (_this4.isValidLookup(found)) return;

        codes.forEach(function (code) {
          if (_this4.isValidLookup(found)) return;

          var finalKey = key;
          var finalKeys = [finalKey];

          var pluralSuffix = void 0;
          if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count);

          // fallback for plural if context not found
          if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);

          // get key for context if needed
          if (needsContextHandling) finalKeys.push(finalKey += '' + _this4.options.contextSeparator + options.context);

          // get key for plural if needed
          if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);

          // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only
          var possibleKey = void 0;
          /* eslint no-cond-assign: 0 */
          while (possibleKey = finalKeys.pop()) {
            if (!_this4.isValidLookup(found)) {
              found = _this4.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });

    return { res: found, usedKey: usedKey };
  };

  Translator.prototype.isValidLookup = function isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
  };

  Translator.prototype.getResource = function getResource(code, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    return this.resourceStore.getResource(code, ns, key, options);
  };

  return Translator;
}(__WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Translator);

/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__logger_js__ = __webpack_require__(54);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil = function () {
  function LanguageUtil(options) {
    _classCallCheck(this, LanguageUtil);

    this.options = options;

    this.whitelist = this.options.whitelist || false;
    this.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].create('languageUtils');
  }

  LanguageUtil.prototype.getScriptPartFromCode = function getScriptPartFromCode(code) {
    if (!code || code.indexOf('-') < 0) return null;

    var p = code.split('-');
    if (p.length === 2) return null;
    p.pop();
    return this.formatLanguageCode(p.join('-'));
  };

  LanguageUtil.prototype.getLanguagePartFromCode = function getLanguagePartFromCode(code) {
    if (!code || code.indexOf('-') < 0) return code;

    var p = code.split('-');
    return this.formatLanguageCode(p[0]);
  };

  LanguageUtil.prototype.formatLanguageCode = function formatLanguageCode(code) {
    // http://www.iana.org/assignments/language-tags/language-tags.xhtml
    if (typeof code === 'string' && code.indexOf('-') > -1) {
      var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
      var p = code.split('-');

      if (this.options.lowerCaseLng) {
        p = p.map(function (part) {
          return part.toLowerCase();
        });
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();

        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();

        // if lenght 2 guess it's a country
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();

        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }

      return p.join('-');
    }

    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  };

  LanguageUtil.prototype.isWhitelisted = function isWhitelisted(code) {
    if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
  };

  LanguageUtil.prototype.getFallbackCodes = function getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === 'string') fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;

    if (!code) return fallbacks.default || [];

    // asume we have an object defining fallbacks
    var found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks.default;

    return found || [];
  };

  LanguageUtil.prototype.toResolveHierarchy = function toResolveHierarchy(code, fallbackCode) {
    var _this = this;

    var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);

    var codes = [];
    var addCode = function addCode(c) {
      if (!c) return;
      if (_this.isWhitelisted(c)) {
        codes.push(c);
      } else {
        _this.logger.warn('rejecting non-whitelisted language code: ' + c);
      }
    };

    if (typeof code === 'string' && code.indexOf('-') > -1) {
      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === 'string') {
      addCode(this.formatLanguageCode(code));
    }

    fallbackCodes.forEach(function (fc) {
      if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
    });

    return codes;
  };

  return LanguageUtil;
}();

/* harmony default export */ __webpack_exports__["a"] = (LanguageUtil);

/***/ }),
/* 349 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__logger_js__ = __webpack_require__(54);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



// definition http://translate.sourceforge.net/wiki/l10n/pluralforms
/* eslint-disable */
var sets = [{ lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'], nr: [1, 2], fc: 1 }, { lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'he', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'], nr: [1, 2], fc: 2 }, { lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'], nr: [1], fc: 3 }, { lngs: ['be', 'bs', 'dz', 'hr', 'ru', 'sr', 'uk'], nr: [1, 2, 5], fc: 4 }, { lngs: ['ar'], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: ['cs', 'sk'], nr: [1, 2, 5], fc: 6 }, { lngs: ['csb', 'pl'], nr: [1, 2, 5], fc: 7 }, { lngs: ['cy'], nr: [1, 2, 3, 8], fc: 8 }, { lngs: ['fr'], nr: [1, 2], fc: 9 }, { lngs: ['ga'], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: ['gd'], nr: [1, 2, 3, 20], fc: 11 }, { lngs: ['is'], nr: [1, 2], fc: 12 }, { lngs: ['jv'], nr: [0, 1], fc: 13 }, { lngs: ['kw'], nr: [1, 2, 3, 4], fc: 14 }, { lngs: ['lt'], nr: [1, 2, 10], fc: 15 }, { lngs: ['lv'], nr: [1, 2, 0], fc: 16 }, { lngs: ['mk'], nr: [1, 2], fc: 17 }, { lngs: ['mnk'], nr: [0, 1, 2], fc: 18 }, { lngs: ['mt'], nr: [1, 2, 11, 20], fc: 19 }, { lngs: ['or'], nr: [2, 1], fc: 2 }, { lngs: ['ro'], nr: [1, 2, 20], fc: 20 }, { lngs: ['sl'], nr: [5, 1, 2, 3], fc: 21 }];

var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  }
};
/* eslint-enable */

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver = function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;

    this.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].create('pluralResolver');

    this.rules = createRules();
  }

  PluralResolver.prototype.addRule = function addRule(lng, obj) {
    this.rules[lng] = obj;
  };

  PluralResolver.prototype.getRule = function getRule(code) {
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  };

  PluralResolver.prototype.needsPlural = function needsPlural(code) {
    var rule = this.getRule(code);

    return rule && rule.numbers.length > 1;
  };

  PluralResolver.prototype.getPluralFormsOfKey = function getPluralFormsOfKey(code, key) {
    var _this = this;

    var ret = [];

    var rule = this.getRule(code);

    if (!rule) return ret;

    rule.numbers.forEach(function (n) {
      var suffix = _this.getSuffix(code, n);
      ret.push('' + key + suffix);
    });

    return ret;
  };

  PluralResolver.prototype.getSuffix = function getSuffix(code, count) {
    var _this2 = this;

    var rule = this.getRule(code);

    if (rule) {
      // if (rule.numbers.length === 1) return ''; // only singular

      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];

      // special treatment for lngs only having singular and plural
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = 'plural';
        } else if (suffix === 1) {
          suffix = '';
        }
      }

      var returnSuffix = function returnSuffix() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };

      // COMPATIBILITY JSON
      // v1
      if (this.options.compatibilityJSON === 'v1') {
        if (suffix === 1) return '';
        if (typeof suffix === 'number') return '_plural_' + suffix.toString();
        return returnSuffix();
      } else if ( /* v2 */this.options.compatibilityJSON === 'v2' || rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      } else if ( /* v3 - gettext index */rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }

    this.logger.warn('no plural rule found for: ' + code);
    return '';
  };

  return PluralResolver;
}();

/* harmony default export */ __webpack_exports__["a"] = (PluralResolver);

/***/ }),
/* 350 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__logger_js__ = __webpack_require__(54);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




var Interpolator = function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpolator);

    this.logger = __WEBPACK_IMPORTED_MODULE_1__logger_js__["a" /* default */].create('interpolator');

    this.init(options, true);
  }

  /* eslint no-param-reassign: 0 */


  Interpolator.prototype.init = function init() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var reset = arguments[1];

    if (reset) {
      this.options = options;
      this.format = options.interpolation && options.interpolation.format || function (value) {
        return value;
      };
      this.escape = options.interpolation && options.interpolation.escape || __WEBPACK_IMPORTED_MODULE_0__utils_js__["c" /* escape */];
    }
    if (!options.interpolation) options.interpolation = { escapeValue: true };

    var iOpts = options.interpolation;

    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;

    this.prefix = iOpts.prefix ? __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */](iOpts.prefix) : iOpts.prefixEscaped || '{{';
    this.suffix = iOpts.suffix ? __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */](iOpts.suffix) : iOpts.suffixEscaped || '}}';

    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';

    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';

    this.nestingPrefix = iOpts.nestingPrefix ? __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */](iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */]('$t(');
    this.nestingSuffix = iOpts.nestingSuffix ? __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */](iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || __WEBPACK_IMPORTED_MODULE_0__utils_js__["g" /* regexEscape */](')');

    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;

    // the regexp
    this.resetRegExp();
  };

  Interpolator.prototype.reset = function reset() {
    if (this.options) this.init(this.options);
  };

  Interpolator.prototype.resetRegExp = function resetRegExp() {
    // the regexp
    var regexpStr = this.prefix + '(.+?)' + this.suffix;
    this.regexp = new RegExp(regexpStr, 'g');

    var regexpUnescapeStr = '' + this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;
    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');

    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;
    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
  };

  Interpolator.prototype.interpolate = function interpolate(str, data, lng) {
    var _this = this;

    var match = void 0;
    var value = void 0;
    var replaces = void 0;

    function regexSafe(val) {
      return val.replace(/\$/g, '$$$$');
    }

    var handleFormat = function handleFormat(key) {
      if (key.indexOf(_this.formatSeparator) < 0) return __WEBPACK_IMPORTED_MODULE_0__utils_js__["d" /* getPath */](data, key);

      var p = key.split(_this.formatSeparator);
      var k = p.shift().trim();
      var f = p.join(_this.formatSeparator).trim();

      return _this.format(__WEBPACK_IMPORTED_MODULE_0__utils_js__["d" /* getPath */](data, k), f, lng);
    };

    this.resetRegExp();

    replaces = 0;
    // unescape if has unescapePrefix/Suffix
    /* eslint no-cond-assign: 0 */
    while (match = this.regexpUnescape.exec(str)) {
      value = handleFormat(match[1].trim());
      str = str.replace(match[0], value);
      this.regexpUnescape.lastIndex = 0;
      replaces++;
      if (replaces >= this.maxReplaces) {
        break;
      }
    }

    replaces = 0;
    // regular escape on demand
    while (match = this.regexp.exec(str)) {
      value = handleFormat(match[1].trim());
      if (typeof value !== 'string') value = __WEBPACK_IMPORTED_MODULE_0__utils_js__["e" /* makeString */](value);
      if (!value) {
        if (typeof this.options.missingInterpolationHandler === 'function') {
          var temp = this.options.missingInterpolationHandler(str, match);
          value = typeof temp === 'string' ? temp : '';
        } else {
          this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
          value = '';
        }
      }
      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
      replaces++;
      if (replaces >= this.maxReplaces) {
        break;
      }
    }
    return str;
  };

  Interpolator.prototype.nest = function nest(str, fc) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var match = void 0;
    var value = void 0;

    var clonedOptions = _extends({}, options);
    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup

    // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"
    function handleHasOptions(key, inheritedOptions) {
      if (key.indexOf(',') < 0) return key;

      var p = key.split(',');
      key = p.shift();
      var optionsString = p.join(',');
      optionsString = this.interpolate(optionsString, clonedOptions);
      optionsString = optionsString.replace(/'/g, '"');

      try {
        clonedOptions = JSON.parse(optionsString);

        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, clonedOptions);
      } catch (e) {
        this.logger.error('failed parsing options string in nesting for key ' + key, e);
      }

      return key;
    }

    // regular escape on demand
    while (match = this.nestingRegexp.exec(str)) {
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);

      // is only the nesting key (key1 = '$(key2)') return the value without stringify
      if (value && match[0] === str && typeof value !== 'string') return value;

      // no string to include or empty
      if (typeof value !== 'string') value = __WEBPACK_IMPORTED_MODULE_0__utils_js__["e" /* makeString */](value);
      if (!value) {
        this.logger.warn('missed to resolve ' + match[1] + ' for nesting ' + str);
        value = '';
      }
      // Nested keys should not be escaped by default #854
      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  };

  return Interpolator;
}();

/* harmony default export */ __webpack_exports__["a"] = (Interpolator);

/***/ }),
/* 351 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__logger_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EventEmitter_js__ = __webpack_require__(80);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }





function remove(arr, what) {
  var found = arr.indexOf(what);

  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}

var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(backend, store, services) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.backend = backend;
    _this.store = store;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = __WEBPACK_IMPORTED_MODULE_1__logger_js__["a" /* default */].create('backendConnector');

    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }

  Connector.prototype.queueLoad = function queueLoad(languages, namespaces, callback) {
    var _this2 = this;

    // find what needs to be loaded
    var toLoad = [];
    var pending = [];
    var toLoadLanguages = [];
    var toLoadNamespaces = [];

    languages.forEach(function (lng) {
      var hasAllNamespaces = true;

      namespaces.forEach(function (ns) {
        var name = lng + '|' + ns;

        if (_this2.store.hasResourceBundle(lng, ns)) {
          _this2.state[name] = 2; // loaded
        } else if (_this2.state[name] < 0) {
          // nothing to do for err
        } else if (_this2.state[name] === 1) {
          if (pending.indexOf(name) < 0) pending.push(name);
        } else {
          _this2.state[name] = 1; // pending

          hasAllNamespaces = false;

          if (pending.indexOf(name) < 0) pending.push(name);
          if (toLoad.indexOf(name) < 0) toLoad.push(name);
          if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
        }
      });

      if (!hasAllNamespaces) toLoadLanguages.push(lng);
    });

    if (toLoad.length || pending.length) {
      this.queue.push({
        pending: pending,
        loaded: {},
        errors: [],
        callback: callback
      });
    }

    return {
      toLoad: toLoad,
      pending: pending,
      toLoadLanguages: toLoadLanguages,
      toLoadNamespaces: toLoadNamespaces
    };
  };

  Connector.prototype.loaded = function loaded(name, err, data) {
    var _this3 = this;

    var _name$split = name.split('|'),
        _name$split2 = _slicedToArray(_name$split, 2),
        lng = _name$split2[0],
        ns = _name$split2[1];

    if (err) this.emit('failedLoading', lng, ns, err);

    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }

    // set loaded
    this.state[name] = err ? -1 : 2;

    // callback if ready
    this.queue.forEach(function (q) {
      __WEBPACK_IMPORTED_MODULE_0__utils_js__["f" /* pushPath */](q.loaded, [lng], ns);
      remove(q.pending, name);

      if (err) q.errors.push(err);

      if (q.pending.length === 0 && !q.done) {
        _this3.emit('loaded', q.loaded);
        /* eslint no-param-reassign: 0 */
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });

    // remove done load requests
    this.queue = this.queue.filter(function (q) {
      return !q.done;
    });
  };

  Connector.prototype.read = function read(lng, ns, fcName) {
    var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var _this4 = this;

    var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
    var callback = arguments[5];

    if (!lng.length) return callback(null, {}); // noting to load

    return this.backend[fcName](lng, ns, function (err, data) {
      if (err && data /* = retryFlag */ && tried < 5) {
        setTimeout(function () {
          _this4.read.call(_this4, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    });
  };

  /* eslint consistent-return: 0 */


  Connector.prototype.load = function load(languages, namespaces, callback) {
    var _this5 = this;

    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
      return callback && callback();
    }
    var options = _extends({}, this.backend.options, this.options.backend);

    if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];

    var toLoad = this.queueLoad(languages, namespaces, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now
      return null; // pendings will trigger callback
    }

    // load with multi-load
    if (options.allowMultiLoading && this.backend.readMulti) {
      this.read(toLoad.toLoadLanguages, toLoad.toLoadNamespaces, 'readMulti', null, null, function (err, data) {
        if (err) _this5.logger.warn('loading namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading failed', err);
        if (!err && data) _this5.logger.log('successfully loaded namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading', data);

        toLoad.toLoad.forEach(function (name) {
          var _name$split3 = name.split('|'),
              _name$split4 = _slicedToArray(_name$split3, 2),
              l = _name$split4[0],
              n = _name$split4[1];

          var bundle = __WEBPACK_IMPORTED_MODULE_0__utils_js__["d" /* getPath */](data, [l, n]);
          if (bundle) {
            _this5.loaded(name, err, bundle);
          } else {
            var error = 'loading namespace ' + n + ' for language ' + l + ' via multiloading failed';
            _this5.loaded(name, error);
            _this5.logger.error(error);
          }
        });
      });
    } else {
      toLoad.toLoad.forEach(function (name) {
        _this5.loadOne(name);
      });
    }
  };

  Connector.prototype.reload = function reload(languages, namespaces) {
    var _this6 = this;

    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
    }
    var options = _extends({}, this.backend.options, this.options.backend);

    if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];

    // load with multi-load
    if (options.allowMultiLoading && this.backend.readMulti) {
      this.read(languages, namespaces, 'readMulti', null, null, function (err, data) {
        if (err) _this6.logger.warn('reloading namespaces ' + namespaces.join(', ') + ' for languages ' + languages.join(', ') + ' via multiloading failed', err);
        if (!err && data) _this6.logger.log('successfully reloaded namespaces ' + namespaces.join(', ') + ' for languages ' + languages.join(', ') + ' via multiloading', data);

        languages.forEach(function (l) {
          namespaces.forEach(function (n) {
            var bundle = __WEBPACK_IMPORTED_MODULE_0__utils_js__["d" /* getPath */](data, [l, n]);
            if (bundle) {
              _this6.loaded(l + '|' + n, err, bundle);
            } else {
              var error = 'reloading namespace ' + n + ' for language ' + l + ' via multiloading failed';
              _this6.loaded(l + '|' + n, error);
              _this6.logger.error(error);
            }
          });
        });
      });
    } else {
      languages.forEach(function (l) {
        namespaces.forEach(function (n) {
          _this6.loadOne(l + '|' + n, 're');
        });
      });
    }
  };

  Connector.prototype.loadOne = function loadOne(name) {
    var _this7 = this;

    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var _name$split5 = name.split('|'),
        _name$split6 = _slicedToArray(_name$split5, 2),
        lng = _name$split6[0],
        ns = _name$split6[1];

    this.read(lng, ns, 'read', null, null, function (err, data) {
      if (err) _this7.logger.warn(prefix + 'loading namespace ' + ns + ' for language ' + lng + ' failed', err);
      if (!err && data) _this7.logger.log(prefix + 'loaded namespace ' + ns + ' for language ' + lng, data);

      _this7.loaded(name, err, data);
    });
  };

  Connector.prototype.saveMissing = function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

    if (this.backend && this.backend.create) {
      this.backend.create(languages, namespace, key, fallbackValue, null /* unused callback */, _extends({}, options, { isUpdate: isUpdate }));
    }

    // write to store to avoid resending
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  };

  return Connector;
}(__WEBPACK_IMPORTED_MODULE_2__EventEmitter_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Connector);

/***/ }),
/* 352 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__logger_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__ = __webpack_require__(80);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }




var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(cache, store, services) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.cache = cache;
    _this.store = store;
    _this.services = services;
    _this.options = options;
    _this.logger = __WEBPACK_IMPORTED_MODULE_0__logger_js__["a" /* default */].create('cacheConnector');

    if (_this.cache && _this.cache.init) _this.cache.init(services, options.cache, options);
    return _this;
  }

  /* eslint consistent-return: 0 */


  Connector.prototype.load = function load(languages, namespaces, callback) {
    var _this2 = this;

    if (!this.cache) return callback && callback();
    var options = _extends({}, this.cache.options, this.options.cache);

    var loadLngs = typeof languages === 'string' ? this.services.languageUtils.toResolveHierarchy(languages) : languages;

    if (options.enabled) {
      this.cache.load(loadLngs, function (err, data) {
        if (err) _this2.logger.error('loading languages ' + loadLngs.join(', ') + ' from cache failed', err);
        if (data) {
          /* eslint no-restricted-syntax: 0 */
          for (var l in data) {
            if (Object.prototype.hasOwnProperty.call(data, l)) {
              for (var n in data[l]) {
                if (Object.prototype.hasOwnProperty.call(data[l], n)) {
                  if (n !== 'i18nStamp') {
                    var bundle = data[l][n];
                    if (bundle) _this2.store.addResourceBundle(l, n, bundle);
                  }
                }
              }
            }
          }
        }
        if (callback) callback();
      });
    } else if (callback) {
      callback();
    }
  };

  Connector.prototype.save = function save() {
    if (this.cache && this.options.cache && this.options.cache.enabled) this.cache.save(this.store.data);
  };

  return Connector;
}(__WEBPACK_IMPORTED_MODULE_1__EventEmitter_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Connector);

/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return get; });
/* harmony export (immutable) */ __webpack_exports__["b"] = transformOptions;

function get() {
  return {
    debug: false,
    initImmediate: true,

    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false, // string or array of namespaces

    whitelist: false, // array with whitelisted languages
    nonExplicitWhitelist: false,
    load: 'all', // | currentOnly | languageOnly
    preload: false, // array with preload languages

    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',

    saveMissing: false, // enable to send missing values
    updateMissing: false, // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: 'fallback', // 'current' || 'all'
    saveMissingPlurals: true, // will save all forms not only singular key
    missingKeyHandler: false, // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: false, // function(str, match)

    postProcess: false, // string or array of postProcessor names
    returnNull: true, // allows null value as valid translation
    returnEmptyString: true, // allows empty string value as valid translation
    returnObjects: false,
    joinArrays: false, // or string to join array
    returnedObjectHandler: function returnedObjectHandler() {}, // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: false, // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (args[1]) ret.defaultValue = args[1];
      if (args[2]) ret.tDescription = args[2];
      return ret;
    },

    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',

      nestingPrefix: '$t(',
      nestingSuffix: ')',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1000 // max replaces to prevent endless loop
    }
  };
}

/* eslint no-param-reassign: 0 */
function transformOptions(options) {
  // create namespace object if namespace is passed in as string
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  // extend whitelist with cimode
  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
    options.whitelist = options.whitelist.concat(['cimode']);
  }

  return options;
}

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(355).default;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(356);

var utils = _interopRequireWildcard(_utils);

var _ajax = __webpack_require__(357);

var _ajax2 = _interopRequireDefault(_ajax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getDefaults() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    allowMultiLoading: false,
    parse: JSON.parse,
    crossDomain: false,
    ajax: _ajax2.default
  };
}

var Backend = function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Backend);

    this.init(services, options);

    this.type = 'backend';
  }

  _createClass(Backend, [{
    key: 'init',
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.services = services;
      this.options = utils.defaults(options, this.options || {}, getDefaults());
    }
  }, {
    key: 'readMulti',
    value: function readMulti(languages, namespaces, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(languages, namespaces);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: languages.join('+'), ns: namespaces.join('+') });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'read',
    value: function read(language, namespace, callback) {
      var loadPath = this.options.loadPath;
      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath([language], [namespace]);
      }

      var url = this.services.interpolator.interpolate(loadPath, { lng: language, ns: namespace });

      this.loadUrl(url, callback);
    }
  }, {
    key: 'loadUrl',
    value: function loadUrl(url, callback) {
      var _this = this;

      this.options.ajax(url, this.options, function (data, xhr) {
        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true /* retry */);
        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false /* no retry */);

        var ret = void 0,
            err = void 0;
        try {
          ret = _this.options.parse(data, url);
        } catch (e) {
          err = 'failed parsing ' + url + ' to json';
        }
        if (err) return callback(err, false);
        callback(null, ret);
      });
    }
  }, {
    key: 'create',
    value: function create(languages, namespace, key, fallbackValue) {
      var _this2 = this;

      if (typeof languages === 'string') languages = [languages];

      var payload = {};
      payload[key] = fallbackValue || '';

      languages.forEach(function (lng) {
        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, { lng: lng, ns: namespace });

        _this2.options.ajax(url, _this2.options, function (data, xhr) {
          //const statusCode = xhr.status.toString();
          // TODO: if statusCode === 4xx do log
        }, payload);
      });
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';

exports.default = Backend;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
exports.extend = extend;
var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function extend(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function addQueryString(url, params) {
  if (params && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === 'object') {
    var queryString = '',
        e = encodeURIComponent;

    // Must encode data
    for (var paramName in params) {
      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
    }

    if (!queryString) {
      return url;
    }

    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
  }

  return url;
}

// https://gist.github.com/Xeoncross/7663273
function ajax(url, options, callback, data, cache) {

  if (data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
    if (!cache) {
      data['_t'] = new Date();
    }
    // URL encoded form data must be in querystring format
    data = addQueryString('', data).slice(1);
  }

  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  try {
    var x;
    if (XMLHttpRequest) {
      x = new XMLHttpRequest();
    } else {
      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
    }
    x.open(data ? 'POST' : 'GET', url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }
    x.withCredentials = !!options.withCredentials;
    if (data) {
      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    var h = options.customHeaders;
    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }
    x.onreadystatechange = function () {
      x.readyState > 3 && callback && callback(x.responseText, x);
    };
    x.send(data);
  } catch (e) {
    console && console.log(e);
  }
}

exports.default = ajax;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(359).default;


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(360);

var utils = _interopRequireWildcard(_utils);

var _cookie = __webpack_require__(361);

var _cookie2 = _interopRequireDefault(_cookie);

var _querystring = __webpack_require__(362);

var _querystring2 = _interopRequireDefault(_querystring);

var _localStorage = __webpack_require__(363);

var _localStorage2 = _interopRequireDefault(_localStorage);

var _navigator = __webpack_require__(364);

var _navigator2 = _interopRequireDefault(_navigator);

var _htmlTag = __webpack_require__(365);

var _htmlTag2 = _interopRequireDefault(_htmlTag);

var _path = __webpack_require__(366);

var _path2 = _interopRequireDefault(_path);

var _subdomain = __webpack_require__(367);

var _subdomain2 = _interopRequireDefault(_subdomain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getDefaults() {
  return {
    order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],
    lookupQuerystring: 'lng',
    lookupCookie: 'i18next',
    lookupLocalStorage: 'i18nextLng',

    // cache user language
    caches: ['localStorage'],
    excludeCacheFor: ['cimode']
    //cookieMinutes: 10,
    //cookieDomain: 'myDomain'
  };
}

var Browser = function () {
  function Browser(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Browser);

    this.type = 'languageDetector';
    this.detectors = {};

    this.init(services, options);
  }

  _createClass(Browser, [{
    key: 'init',
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      this.services = services;
      this.options = utils.defaults(options, this.options || {}, getDefaults());

      // backwards compatibility
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;

      this.i18nOptions = i18nOptions;

      this.addDetector(_cookie2.default);
      this.addDetector(_querystring2.default);
      this.addDetector(_localStorage2.default);
      this.addDetector(_navigator2.default);
      this.addDetector(_htmlTag2.default);
      this.addDetector(_path2.default);
      this.addDetector(_subdomain2.default);
    }
  }, {
    key: 'addDetector',
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: 'detect',
    value: function detect(detectionOrder) {
      var _this = this;

      if (!detectionOrder) detectionOrder = this.options.order;

      var detected = [];
      detectionOrder.forEach(function (detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup = _this.detectors[detectorName].lookup(_this.options);
          if (lookup && typeof lookup === 'string') lookup = [lookup];
          if (lookup) detected = detected.concat(lookup);
        }
      });

      var found = void 0;
      detected.forEach(function (lng) {
        if (found) return;
        var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
        if (_this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
      });

      if (!found) {
        var fallbacks = this.i18nOptions.fallbackLng;
        if (typeof fallbacks === 'string') fallbacks = [fallbacks];
        if (!fallbacks) fallbacks = [];

        if (Object.prototype.toString.apply(fallbacks) === '[object Array]') {
          found = fallbacks[0];
        } else {
          found = fallbacks[0] || fallbacks.default && fallbacks.default[0];
        }
      };

      return found;
    }
  }, {
    key: 'cacheUserLanguage',
    value: function cacheUserLanguage(lng, caches) {
      var _this2 = this;

      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function (cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);

  return Browser;
}();

Browser.type = 'languageDetector';

exports.default = Browser;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
exports.extend = extend;
var arr = [];
var each = arr.forEach;
var slice = arr.slice;

function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

function extend(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var cookie = {
  create: function create(name, value, minutes, domain) {
    var expires = void 0;
    if (minutes) {
      var date = new Date();
      date.setTime(date.getTime() + minutes * 60 * 1000);
      expires = '; expires=' + date.toGMTString();
    } else expires = '';
    domain = domain ? 'domain=' + domain + ';' : '';
    document.cookie = name + '=' + value + expires + ';' + domain + 'path=/';
  },

  read: function read(name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },

  remove: function remove(name) {
    this.create(name, '', -1);
  }
};

exports.default = {
  name: 'cookie',

  lookup: function lookup(options) {
    var found = void 0;

    if (options.lookupCookie && typeof document !== 'undefined') {
      var c = cookie.read(options.lookupCookie);
      if (c) found = c;
    }

    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== 'undefined') {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain);
    }
  }
};

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'querystring',

  lookup: function lookup(options) {
    var found = void 0;

    if (typeof window !== 'undefined') {
      var query = window.location.search.substring(1);
      var params = query.split('&');
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf('=');
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }

    return found;
  }
};

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var hasLocalStorageSupport = void 0;
try {
  hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
  var testKey = 'i18next.translate.boo';
  window.localStorage.setItem(testKey, 'foo');
  window.localStorage.removeItem(testKey);
} catch (e) {
  hasLocalStorageSupport = false;
}

exports.default = {
  name: 'localStorage',

  lookup: function lookup(options) {
    var found = void 0;

    if (options.lookupLocalStorage && hasLocalStorageSupport) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng) found = lng;
    }

    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupLocalStorage && hasLocalStorageSupport) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'navigator',

  lookup: function lookup(options) {
    var found = [];

    if (typeof navigator !== 'undefined') {
      if (navigator.languages) {
        // chrome only; not an array, so can't use .push.apply instead of iterating
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }

    return found.length > 0 ? found : undefined;
  }
};

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'htmlTag',

  lookup: function lookup(options) {
    var found = void 0;
    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);

    if (htmlTag && typeof htmlTag.getAttribute === 'function') {
      found = htmlTag.getAttribute('lang');
    }

    return found;
  }
};

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'path',

  lookup: function lookup(options) {
    var found = void 0;
    if (typeof window !== 'undefined') {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === 'number') {
          if (typeof language[options.lookupFromPathIndex] !== 'string') {
            return undefined;
          }
          found = language[options.lookupFromPathIndex].replace('/', '');
        } else {
          found = language[0].replace('/', '');
        }
      }
    }
    return found;
  }
};

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'subdomain',

  lookup: function lookup(options) {
    var found = void 0;
    if (typeof window !== 'undefined') {
      var language = window.location.pathname.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options.lookupFromSubdomainIndex === 'number') {
          found = language[options.lookupFromSubdomainIndex].replace('http://', '').replace('https://', '').replace('.', '');
        } else {
          found = language[0].replace('http://', '').replace('https://', '').replace('.', '');
        }
      }
    }
    return found;
  }
};

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FrameBuffer_1 = __webpack_require__(83);
const Texture_1 = __webpack_require__(19);
const CachedGeometry_1 = __webpack_require__(29);
const geometry_core_1 = __webpack_require__(1);
const System_1 = __webpack_require__(7);
const System_2 = __webpack_require__(17);
const bentleyjs_core_1 = __webpack_require__(0);
const GL_1 = __webpack_require__(8);
const DrawCommand_1 = __webpack_require__(56);
const RenderState_1 = __webpack_require__(82);
class Textures {
    dispose() {
        this.accumulation = bentleyjs_core_1.dispose(this.accumulation);
        this.revealage = bentleyjs_core_1.dispose(this.revealage);
        this.color = bentleyjs_core_1.dispose(this.color);
        this.idLow = bentleyjs_core_1.dispose(this.idLow);
        this.idHigh = bentleyjs_core_1.dispose(this.idHigh);
        this.depthAndOrder = bentleyjs_core_1.dispose(this.depthAndOrder);
        this.hilite = bentleyjs_core_1.dispose(this.hilite);
    }
    init(width, height) {
        bentleyjs_core_1.assert(undefined === this.accumulation);
        let pixelDataType = GL_1.GL.Texture.DataType.UnsignedByte;
        switch (System_1.System.instance.capabilities.maxRenderType) {
            case 2 /* TextureFloat */: {
                pixelDataType = GL_1.GL.Texture.DataType.Float;
                break;
            }
            case 1 /* TextureHalfFloat */: {
                // ###TODO...
            }
            /* falls through */
            case 0 /* TextureUnsignedByte */: {
                break;
            }
        }
        // NB: All 3 of these must be of the same type, because they are borrowed by pingpong and bound to the same frame buffer.
        // Otherwise there would be no reason to use FLOAT for hilite texture.
        this.accumulation = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, pixelDataType);
        this.revealage = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, pixelDataType);
        this.hilite = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, pixelDataType);
        this.color = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.idLow = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.idHigh = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.depthAndOrder = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        return undefined !== this.accumulation
            && undefined !== this.revealage
            && undefined !== this.color
            && undefined !== this.idLow
            && undefined !== this.idHigh
            && undefined !== this.depthAndOrder
            && undefined !== this.hilite;
    }
}
class FrameBuffers {
    init(textures, depth) {
        bentleyjs_core_1.assert(undefined === this.opaqueAll);
        const boundColor = System_1.System.instance.frameBufferStack.currentColorBuffer;
        if (undefined === boundColor) {
            return false;
        }
        const colorAndPick = [boundColor, textures.idLow, textures.idHigh, textures.depthAndOrder];
        this.opaqueAll = FrameBuffer_1.FrameBuffer.create(colorAndPick, depth);
        this.opaqueColor = FrameBuffer_1.FrameBuffer.create([boundColor], depth);
        colorAndPick[0] = textures.color;
        this.opaqueAndCompositeAll = FrameBuffer_1.FrameBuffer.create(colorAndPick, depth);
        this.opaqueAndCompositeColor = FrameBuffer_1.FrameBuffer.create([textures.color], depth);
        this.depthAndOrder = FrameBuffer_1.FrameBuffer.create([textures.depthAndOrder]);
        const colors = [textures.accumulation, textures.revealage];
        this.translucent = FrameBuffer_1.FrameBuffer.create(colors, depth);
        this.hilite = FrameBuffer_1.FrameBuffer.create([textures.hilite]);
        this.clearTranslucent = FrameBuffer_1.FrameBuffer.create(colors);
        // We borrow the SceneCompositor's accum, hilite, and revealage textures for the surface pass.
        // First we render edges, writing to our textures.
        // Then we copy our textures to borrowed textures.
        // Finally we render surfaces, writing to our textures and reading from borrowed textures.
        const pingPong = [textures.accumulation, textures.hilite, textures.revealage];
        this.pingPong = FrameBuffer_1.FrameBuffer.create(pingPong);
        return undefined !== this.opaqueAll
            && undefined !== this.opaqueColor
            && undefined !== this.opaqueAndCompositeAll
            && undefined !== this.opaqueAndCompositeColor
            && undefined !== this.depthAndOrder
            && undefined !== this.pingPong
            && undefined !== this.translucent
            && undefined !== this.clearTranslucent
            && undefined !== this.hilite;
    }
    dispose() {
        this.opaqueAll = bentleyjs_core_1.dispose(this.opaqueAll);
        this.opaqueColor = bentleyjs_core_1.dispose(this.opaqueColor);
        this.opaqueAndCompositeAll = bentleyjs_core_1.dispose(this.opaqueAndCompositeAll);
        this.opaqueAndCompositeColor = bentleyjs_core_1.dispose(this.opaqueAndCompositeColor);
        this.depthAndOrder = bentleyjs_core_1.dispose(this.depthAndOrder);
        this.pingPong = bentleyjs_core_1.dispose(this.pingPong);
        this.translucent = bentleyjs_core_1.dispose(this.translucent);
        this.clearTranslucent = bentleyjs_core_1.dispose(this.clearTranslucent);
        this.hilite = bentleyjs_core_1.dispose(this.hilite);
    }
}
class Geometry {
    init(textures) {
        bentleyjs_core_1.assert(undefined === this.copyPickBuffers);
        this.copyPickBuffers = CachedGeometry_1.CopyPickBufferGeometry.createGeometry(textures.idLow.getHandle(), textures.idHigh.getHandle(), textures.depthAndOrder.getHandle());
        this.composite = CachedGeometry_1.CompositeGeometry.createGeometry(textures.color.getHandle(), textures.accumulation.getHandle(), textures.revealage.getHandle(), textures.hilite.getHandle());
        this.clearTranslucent = CachedGeometry_1.ViewportQuadGeometry.create(9 /* OITClearTranslucent */);
        this.clearPickAndColor = CachedGeometry_1.ViewportQuadGeometry.create(13 /* ClearPickAndColor */);
        return undefined !== this.composite && undefined !== this.copyPickBuffers && undefined !== this.clearTranslucent && undefined !== this.clearPickAndColor;
    }
    dispose() {
        this.copyPickBuffers = bentleyjs_core_1.dispose(this.copyPickBuffers);
        this.composite = bentleyjs_core_1.dispose(this.composite);
        this.clearTranslucent = bentleyjs_core_1.dispose(this.clearTranslucent);
        this.clearPickAndColor = bentleyjs_core_1.dispose(this.clearPickAndColor);
    }
}
class PixelBuffer {
    constructor(rect, selector, compositor) {
        this._scratchUint32Array = new Uint32Array(1);
        this._scratchUint8Array = new Uint8Array(this._scratchUint32Array.buffer);
        this._scratchVector3d = new geometry_core_1.Vector3d();
        this._mult = new geometry_core_1.Vector3d(1.0, 1.0 / 255.0, 1.0 / 65025.0);
        this._invalidPixelData = new System_2.Pixel.Data();
        this._rect = rect.clone();
        this._selector = selector;
        if (0 /* None */ !== (selector & 6 /* GeometryAndDistance */)) {
            const depthAndOrderBytes = compositor.readDepthAndOrder(rect);
            if (undefined !== depthAndOrderBytes)
                this._depthAndOrder = new Uint32Array(depthAndOrderBytes.buffer);
            else
                this._selector &= ~6 /* GeometryAndDistance */;
        }
        if (0 /* None */ !== (selector & 1 /* ElementId */)) {
            const loBytes = compositor.readElementIds(false, rect);
            const hiBytes = undefined !== loBytes ? compositor.readElementIds(true, rect) : undefined;
            if (undefined !== loBytes && undefined !== hiBytes) {
                this._elemIdLow = new Uint32Array(loBytes.buffer);
                this._elemIdHi = new Uint32Array(hiBytes.buffer);
            }
            else {
                this._selector &= ~1 /* ElementId */;
            }
        }
    }
    get numPixels() { return this._rect.width * this._rect.height; }
    getPixelIndex(x, y) {
        if (x < this._rect.left || y < this._rect.top)
            return this.numPixels;
        x -= this._rect.left;
        y -= this._rect.top;
        if (x >= this._rect.width || y >= this._rect.height)
            return this.numPixels;
        // NB: View coords have origin at top-left; GL at bottom-left. So our rows are upside-down.
        y = this._rect.height - 1 - y;
        return y * this._rect.width + x;
    }
    getPixel32(data, pixelIndex) {
        return pixelIndex < data.length ? data[pixelIndex] : undefined;
    }
    getElementId(pixelIndex) {
        if (undefined === this._elemIdLow || undefined === this._elemIdHi)
            return undefined;
        const lo = this.getPixel32(this._elemIdLow, pixelIndex);
        const hi = this.getPixel32(this._elemIdHi, pixelIndex);
        return undefined !== lo && undefined !== hi ? bentleyjs_core_1.Id64.fromUint32Pair(lo, hi) : undefined;
    }
    decodeDepthRgba(depthAndOrder) {
        this._scratchUint32Array[0] = depthAndOrder;
        const bytes = this._scratchUint8Array;
        const fpt = geometry_core_1.Vector3d.create(bytes[1] / 255.0, bytes[2] / 255.0, bytes[3] / 255.0, this._scratchVector3d);
        let depth = fpt.dotProduct(this._mult);
        bentleyjs_core_1.assert(0.0 <= depth);
        bentleyjs_core_1.assert(1.01 >= depth); // rounding error...
        depth = Math.min(1.0, depth);
        depth = Math.max(0.0, depth);
        return depth;
    }
    decodeRenderOrderRgba(depthAndOrder) {
        this._scratchUint32Array[0] = depthAndOrder;
        const encByte = this._scratchUint8Array[0];
        const enc = encByte / 255.0;
        const dec = Math.floor(16.0 * enc + 0.5);
        return dec;
    }
    getPixel(x, y) {
        const px = this._invalidPixelData;
        const index = this.getPixelIndex(x, y);
        if (index >= this.numPixels)
            return px;
        // Initialize to the defaults...
        let distanceFraction = px.distanceFraction;
        let geometryType = px.type;
        let planarity = px.planarity;
        const elemId = 0 /* None */ !== (this._selector & 1 /* ElementId */) ? this.getElementId(index) : undefined;
        if (undefined !== this._depthAndOrder) {
            const wantDistance = 0 /* None */ !== (this._selector & 2 /* Distance */);
            const wantGeometry = 0 /* None */ !== (this._selector & 4 /* Geometry */);
            const depthAndOrder = wantDistance || wantGeometry ? this.getPixel32(this._depthAndOrder, index) : undefined;
            if (undefined !== depthAndOrder) {
                if (wantDistance)
                    distanceFraction = this.decodeDepthRgba(depthAndOrder);
                if (wantGeometry) {
                    const orderWithPlanarBit = this.decodeRenderOrderRgba(depthAndOrder);
                    const order = orderWithPlanarBit & ~8 /* PlanarBit */;
                    planarity = (orderWithPlanarBit === order) ? 3 /* NonPlanar */ : 2 /* Planar */;
                    switch (order) {
                        case 0 /* None */:
                            geometryType = 1 /* None */;
                            planarity = 1 /* None */;
                            break;
                        case 1 /* BlankingRegion */:
                        case 2 /* Surface */:
                            geometryType = 2 /* Surface */;
                            break;
                        case 3 /* Linear */:
                            geometryType = 3 /* Linear */;
                            break;
                        case 4 /* Edge */:
                            geometryType = 4 /* Edge */;
                            break;
                        case 5 /* Silhouette */:
                            geometryType = 5 /* Silhouette */;
                            break;
                        default:
                            // ###TODO: may run into issues with point clouds - they are not written correctly in C++.
                            bentleyjs_core_1.assert(false, "Invalid render order");
                            geometryType = 1 /* None */;
                            planarity = 1 /* None */;
                            break;
                    }
                }
            }
        }
        return new System_2.Pixel.Data(elemId, distanceFraction, geometryType, planarity);
    }
    get isEmpty() { return 0 /* None */ === this._selector; }
    static create(rect, selector, compositor) {
        const pdb = new PixelBuffer(rect, selector, compositor);
        return pdb.isEmpty ? undefined : pdb;
    }
}
class SceneCompositor {
    constructor(target) {
        this._width = -1;
        this._height = -1;
        this._textures = new Textures();
        this._fbos = new FrameBuffers();
        this._geometry = new Geometry();
        this._readPickDataFromPingPong = true;
        this._opaqueRenderState = new RenderState_1.RenderState();
        this._translucentRenderState = new RenderState_1.RenderState();
        this._noDepthMaskRenderState = new RenderState_1.RenderState();
        this._target = target;
        this._opaqueRenderState.flags.depthTest = true;
        this._translucentRenderState.flags.depthMask = false;
        this._translucentRenderState.flags.blend = this._translucentRenderState.flags.depthTest = true;
        this._translucentRenderState.blend.setBlendFuncSeparate(GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.Zero, GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.OneMinusSrcAlpha);
        this._noDepthMaskRenderState.flags.depthMask = false;
    }
    update() {
        const rect = this._target.viewRect;
        const width = rect.width;
        const height = rect.height;
        if (this._textures.accumulation !== undefined && width === this._width && height === this._height) {
            return true;
        }
        this._width = width;
        this._height = height;
        const result = this.init();
        bentleyjs_core_1.assert(result);
        return result;
    }
    draw(commands) {
        if (!this.update()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        const flags = commands.compositeFlags;
        const needTranslucent = 0 /* None */ !== (flags & 1 /* Translucent */);
        const needHilite = 0 /* None */ !== (flags & 2 /* Hilite */);
        const needComposite = needTranslucent || needHilite;
        // Clear output targets
        this.clearOpaque(needComposite);
        // Render the background
        this.renderBackground(commands, needComposite);
        this._target.setFrameTime();
        // Render the sky box
        this.renderSkyBox(commands, needComposite);
        this._target.setFrameTime();
        // Enable clipping
        this._target.pushActiveVolume();
        this._target.setFrameTime();
        // Render opaque geometry
        this.renderOpaque(commands, needComposite);
        this._target.setFrameTime();
        if (needComposite) {
            this._geometry.composite.update(flags);
            this.clearTranslucent();
            this.renderTranslucent(commands);
            this._target.setFrameTime();
            this.renderHilite(commands);
            this._target.setFrameTime();
            this.composite();
        }
        else {
            this._target.setFrameTime();
            this._target.setFrameTime();
        }
        this._target.popActiveVolume();
    }
    get fullHeight() { return this._target.viewRect.height; }
    drawForReadPixels(commands) {
        if (!this.update()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this.clearOpaque(false);
        this._target.pushActiveVolume();
        this.renderOpaque(commands, false, true);
        this._target.popActiveVolume();
    }
    readPixels(rect, selector) {
        return PixelBuffer.create(rect, selector, this);
    }
    readDepthAndOrder(rect) { return this.readFrameBuffer(rect, this._fbos.depthAndOrder); }
    readElementIds(high, rect) {
        const tex = high ? this._textures.idHigh : this._textures.idLow;
        if (undefined === tex)
            return undefined;
        const fbo = FrameBuffer_1.FrameBuffer.create([tex]);
        const result = this.readFrameBuffer(rect, fbo);
        bentleyjs_core_1.dispose(fbo);
        return result;
    }
    readFrameBuffer(rect, fbo) {
        if (undefined === fbo || !fbo.isValid)
            return undefined;
        // NB: ViewRect origin at top-left; GL origin at bottom-left
        const bottom = this.fullHeight - rect.bottom;
        const gl = System_1.System.instance.context;
        const bytes = new Uint8Array(rect.width * rect.height * 4);
        let result = bytes;
        System_1.System.instance.frameBufferStack.execute(fbo, true, () => {
            try {
                gl.readPixels(rect.left, bottom, rect.width, rect.height, gl.RGBA, gl.UNSIGNED_BYTE, bytes);
            }
            catch (e) {
                result = undefined;
            }
        });
        return result;
    }
    get elementId0() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 0 : 1); }
    get elementId1() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 1 : 2); }
    get depthAndOrder() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 2 : 3); }
    dispose() {
        this._depth = bentleyjs_core_1.dispose(this._depth);
        bentleyjs_core_1.dispose(this._textures);
        bentleyjs_core_1.dispose(this._fbos);
        bentleyjs_core_1.dispose(this._geometry);
    }
    init() {
        this.dispose();
        this._depth = System_1.System.instance.createDepthBuffer(this._width, this._height);
        if (this._depth !== undefined) {
            return this._textures.init(this._width, this._height) && this._fbos.init(this._textures, this._depth) && this._geometry.init(this._textures);
        }
        return false;
    }
    clearOpaque(needComposite) {
        const fbo = needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll;
        const system = System_1.System.instance;
        system.frameBufferStack.execute(fbo, true, () => {
            // Clear pick data buffers to 0's and color buffer to background color
            // (0,0,0,0) in elementID0 and ElementID1 buffers indicates invalid element id
            // (0,0,0,0) in DepthAndOrder buffer indicates render order 0 and encoded depth of 0 (= far plane)
            system.applyRenderState(this._noDepthMaskRenderState);
            const params = new DrawCommand_1.DrawParams(this._target, this._geometry.clearPickAndColor);
            this._target.techniques.draw(params);
            // Clear depth buffer
            system.applyRenderState(RenderState_1.RenderState.defaults); // depthMask == true.
            system.context.clearDepth(1.0);
            system.context.clear(GL_1.GL.BufferBit.Depth);
        });
    }
    renderOpaque(commands, needComposite, renderForReadPixels = false) {
        // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels()).
        this._readPickDataFromPingPong = true;
        let fbStack = System_1.System.instance.frameBufferStack;
        fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll, true, () => {
            this.drawPass(commands, 1 /* OpaqueLinear */);
            this.drawPass(commands, 2 /* OpaquePlanar */, true);
            if (renderForReadPixels) {
                this.drawPass(commands, 3 /* OpaqueGeneral */, true);
            }
        });
        this._readPickDataFromPingPong = false;
        // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.
        if (!renderForReadPixels) {
            fbStack = System_1.System.instance.frameBufferStack;
            fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, true, () => {
                this.drawPass(commands, 3 /* OpaqueGeneral */, false);
                this.drawPass(commands, 5 /* HiddenEdge */, false);
            });
        }
    }
    renderSkyBox(commands, needComposite) {
        const cmds = commands.getCommands(9 /* SkyBox */);
        if (0 === cmds.length) {
            return;
        }
        // ###TODO: Alter viewport so skyBox maintains aspect ratio of textures.
        // const dim = this._target.viewRect.width > this._target.viewRect.height ? this._target.viewRect.width : this._target.viewRect.height;
        // System.instance.context.viewport(0, 0, dim, dim);
        const fbStack = System_1.System.instance.frameBufferStack;
        fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, true, () => {
            this._target.pushState(this._target.decorationState);
            System_1.System.instance.applyRenderState(this.getRenderState(9 /* SkyBox */));
            this._target.techniques.execute(this._target, cmds, 9 /* SkyBox */);
            this._target.popBranch();
        });
        // System.instance.context.viewport(0, 0, this._target.viewRect.width, this._target.viewRect.height);
    }
    renderBackground(commands, needComposite) {
        const cmds = commands.getCommands(0 /* Background */);
        if (0 === cmds.length) {
            return;
        }
        const fbStack = System_1.System.instance.frameBufferStack;
        fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, true, () => {
            this._target.pushState(this._target.decorationState);
            System_1.System.instance.applyRenderState(this.getRenderState(0 /* Background */));
            this._target.techniques.execute(this._target, cmds, 0 /* Background */);
            this._target.popBranch();
        });
    }
    pingPong() {
        System_1.System.instance.applyRenderState(this._noDepthMaskRenderState);
        System_1.System.instance.frameBufferStack.execute(this._fbos.pingPong, true, () => {
            const params = new DrawCommand_1.DrawParams(this._target, this._geometry.copyPickBuffers);
            this._target.techniques.draw(params);
        });
    }
    clearTranslucent() {
        System_1.System.instance.applyRenderState(this._noDepthMaskRenderState);
        System_1.System.instance.frameBufferStack.execute(this._fbos.clearTranslucent, true, () => {
            const params = new DrawCommand_1.DrawParams(this._target, this._geometry.clearTranslucent);
            this._target.techniques.draw(params);
        });
    }
    renderTranslucent(commands) {
        System_1.System.instance.frameBufferStack.execute(this._fbos.translucent, true, () => {
            this.drawPass(commands, 4 /* Translucent */);
        });
    }
    renderHilite(commands) {
        // Clear the hilite buffer.
        const system = System_1.System.instance;
        system.frameBufferStack.execute(this._fbos.hilite, true, () => {
            system.context.clearColor(0, 0, 0, 0);
            system.context.clear(GL_1.GL.BufferBit.Color);
            this.drawPass(commands, 6 /* Hilite */);
        });
    }
    composite() {
        System_1.System.instance.applyRenderState(RenderState_1.RenderState.defaults);
        const params = new DrawCommand_1.DrawParams(this._target, this._geometry.composite);
        this._target.techniques.draw(params);
    }
    getRenderState(pass) {
        switch (pass) {
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
            case 3 /* OpaqueGeneral */:
                return this._opaqueRenderState;
            case 4 /* Translucent */:
                return this._translucentRenderState;
            default:
                return this._noDepthMaskRenderState;
        }
    }
    drawPass(commands, pass, pingPong = false) {
        const cmds = commands.getCommands(pass);
        if (0 === cmds.length) {
            return;
        }
        else if (pingPong) {
            this.pingPong();
        }
        System_1.System.instance.applyRenderState(this.getRenderState(pass));
        this._target.techniques.execute(this._target, cmds, pass);
    }
    get samplerFbo() { return this._readPickDataFromPingPong ? this._fbos.pingPong : this._fbos.opaqueAll; }
    getSamplerTexture(index) { return this.samplerFbo.getColor(index); }
}
exports.SceneCompositor = SceneCompositor;


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ViewportQuad_1 = __webpack_require__(84);
const computeBaseColor = "return vec4(0.0);";
const assignFragData = `
  FragColor0 = vec4(0.0, 0.0, 0.0, 1.0);
  FragColor1 = vec4(1.0, 0.0, 0.0, 1.0);
`;
function createClearTranslucentProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(false);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    frag.addDrawBuffersExtension();
    frag.set(13 /* AssignFragData */, assignFragData);
    return builder.buildProgram(context);
}
exports.createClearTranslucentProgram = createClearTranslucentProgram;


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ViewportQuad_1 = __webpack_require__(84);
const FloatRGBA_1 = __webpack_require__(35);
const computeBaseColor = "return u_bgColor;";
const assignFragData = `
  FragColor0 = baseColor;
  FragColor1 = vec4(0.0);
  FragColor2 = vec4(0.0);
  FragColor3 = vec4(0.0);
`;
function createClearPickAndColorProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(false);
    const frag = builder.frag;
    frag.addUniform("u_bgColor", 6 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_bgColor", (uniform, params) => {
            const bgColor = FloatRGBA_1.FloatRgba.fromColorDef(params.target.bgColor);
            bgColor.bind(uniform);
        });
    });
    frag.addDrawBuffersExtension();
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    frag.set(13 /* AssignFragData */, assignFragData);
    return builder.buildProgram(context);
}
exports.createClearPickAndColorProgram = createClearPickAndColorProgram;


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(24);
const Texture_1 = __webpack_require__(19);
const Fragment_1 = __webpack_require__(25);
const ViewportQuad_1 = __webpack_require__(84);
const computeColor = "return TEXTURE(u_color, v_texCoord);";
const computeColorNoAlpha = "return vec4(TEXTURE(u_color, v_texCoord).rgb, 1.0);";
function createCopyColorProgram(context, copyAlpha = true) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, copyAlpha ? computeColor : computeColorNoAlpha);
    frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_color", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_color", (uniform, params) => {
            const geom = params.geometry;
            Texture_1.TextureHandle.bindSampler(uniform, geom.texture, RenderFlags_1.TextureUnit.Zero);
        });
    });
    return builder.buildProgram(context);
}
exports.createCopyColorProgram = createCopyColorProgram;


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(24);
const Texture_1 = __webpack_require__(19);
const ViewportQuad_1 = __webpack_require__(84);
const computeBaseColor = "return vec4(1.0);";
const assignFragData = `
  FragColor0 = TEXTURE(u_pickElementId0, v_texCoord);
  FragColor1 = TEXTURE(u_pickElementId1, v_texCoord);
  FragColor2 = TEXTURE(u_pickDepthAndOrder, v_texCoord);
`;
function createCopyPickBuffersProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.addUniform("u_pickElementId0", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_pickElementId0", (uniform, params) => {
            Texture_1.TextureHandle.bindSampler(uniform, params.geometry.elemIdLow, RenderFlags_1.TextureUnit.Zero);
        });
    }, 3 /* High */);
    frag.addUniform("u_pickElementId1", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_pickElementId1", (uniform, params) => {
            Texture_1.TextureHandle.bindSampler(uniform, params.geometry.elemIdHigh, RenderFlags_1.TextureUnit.One);
        });
    }, 3 /* High */);
    frag.addUniform("u_pickDepthAndOrder", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_pickDepthAndOrder", (uniform, params) => {
            Texture_1.TextureHandle.bindSampler(uniform, params.geometry.depthAndOrder, RenderFlags_1.TextureUnit.Two);
        });
    }, 3 /* High */);
    frag.addDrawBuffersExtension();
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    frag.set(13 /* AssignFragData */, assignFragData);
    return builder.buildProgram(context);
}
exports.createCopyPickBuffersProgram = createCopyPickBuffersProgram;


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const RenderFlags_1 = __webpack_require__(24);
const Texture_1 = __webpack_require__(19);
const ViewportQuad_1 = __webpack_require__(84);
const Fragment_1 = __webpack_require__(25);
const FeatureSymbology_1 = __webpack_require__(86);
const isEdgePixel = `
bool isEdgePixel(float xOffset, float yOffset) {
  vec2 t = windowCoordsToTexCoords(gl_FragCoord.xy + vec2(xOffset, yOffset));
  vec4 texel = TEXTURE(u_hilite, t);
  return 0.0 != texel.r;
}
`;
const isOutlined = `
bool isOutlined() {
  float width = u_hilite_settings.z;
  if (0.0 == width)
    return false;

  // 1-pixel-wide outline requires max 9 samples. 2-pixel-wide requires max 25 samples.
  if (isEdgePixel(0.0, 1.0) || isEdgePixel(1.0, 0.0) || isEdgePixel(1.0, 1.0)
      || isEdgePixel(0.0, -1.0) || isEdgePixel(-1.0, 0.0) || isEdgePixel(-1.0, -1.0)
      || isEdgePixel(1.0, -1.0) || isEdgePixel(-1.0, 1.0))
    return true;

  if (1.0 == width)
    return false;

  return isEdgePixel(-2.0, -2.0) || isEdgePixel(-1.0, -2.0) || isEdgePixel(0.0, -2.0) || isEdgePixel(1.0, -2.0) || isEdgePixel(2.0, -2.0)
    || isEdgePixel(-2.0, -1.0) || isEdgePixel(2.0, -1.0)
    || isEdgePixel(-2.0, 0.0) || isEdgePixel(2.0, 0.0)
    || isEdgePixel(-2.0, 1.0) || isEdgePixel(2.0, 1.0)
    || isEdgePixel(-2.0, 2.0) || isEdgePixel(-1.0, 2.0) || isEdgePixel(0.0, 2.0) || isEdgePixel(1.0, 2.0) || isEdgePixel(2.0, 2.0);
}
`;
const isInHiliteRegion = "\nbool isInHiliteRegion() { return 0.0 != TEXTURE(u_hilite, v_texCoord).r; }\n";
const computeHiliteColor = "\nvec4 computeColor() { return TEXTURE(u_opaque, v_texCoord); }\n";
const computeHiliteBaseColor = `
  bool isHilite = isInHiliteRegion();
  if (isHilite || !isOutlined()) {
    float ratio = isHilite ? u_hilite_settings.y : 0.0;
    vec4 baseColor = computeColor();
    baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, ratio);
    return baseColor;
  } else {
    return vec4(u_hilite_color.rgb, 1.0);
  }
`;
const computeTranslucentColor = `
vec4 computeColor() {
  vec4 opaque = TEXTURE(u_opaque, v_texCoord);
  vec4 accum = TEXTURE(u_accumulation, v_texCoord);
  float r = TEXTURE(u_revealage, v_texCoord).r;

  vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);
  return (1.0 - transparent.a) * transparent + transparent.a * opaque;
}
`;
const computeTranslucentBaseColor = "return computeColor();";
function createCompositeProgram(flags, context) {
    bentleyjs_core_1.assert(0 /* None */ !== flags);
    const wantHilite = 0 /* None */ !== (flags & 2 /* Hilite */);
    const wantTranslucent = 0 /* None */ !== (flags & 1 /* Translucent */);
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_opaque", 9 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_opaque", (uniform, params) => {
            Texture_1.TextureHandle.bindSampler(uniform, params.geometry.opaque, RenderFlags_1.TextureUnit.Zero);
        });
    });
    if (wantHilite) {
        FeatureSymbology_1.addHiliteSettings(frag);
        Fragment_1.addWindowToTexCoords(frag);
        frag.addFunction(isEdgePixel);
        frag.addFunction(isOutlined);
        frag.addFunction(isInHiliteRegion);
        frag.addUniform("u_hilite", 9 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_hilite", (uniform, params) => {
                Texture_1.TextureHandle.bindSampler(uniform, params.geometry.hilite, RenderFlags_1.TextureUnit.Three);
            });
        });
        frag.set(1 /* ComputeBaseColor */, computeHiliteBaseColor);
        if (!wantTranslucent) {
            frag.addFunction(computeHiliteColor);
        }
    }
    if (wantTranslucent) {
        frag.addUniform("u_accumulation", 9 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_accumulation", (uniform, params) => {
                Texture_1.TextureHandle.bindSampler(uniform, params.geometry.accum, RenderFlags_1.TextureUnit.One);
            });
        });
        frag.addUniform("u_revealage", 9 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_revealage", (uniform, params) => {
                Texture_1.TextureHandle.bindSampler(uniform, params.geometry.reveal, RenderFlags_1.TextureUnit.Two);
            });
        });
        frag.addFunction(computeTranslucentColor);
        if (!wantHilite) {
            frag.set(1 /* ComputeBaseColor */, computeTranslucentBaseColor);
        }
    }
    return builder.buildProgram(context);
}
exports.createCompositeProgram = createCompositeProgram;


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(30);
const Fragment_1 = __webpack_require__(25);
const Vertex_1 = __webpack_require__(20);
const computePosition = "return u_mvp * rawPos;";
const computeBaseColor = "return vec4(1.0);";
function createClipMaskProgram(context) {
    const builder = new ShaderBuilder_1.ProgramBuilder(false);
    Vertex_1.addModelViewProjectionMatrix(builder.vert);
    builder.vert.set(3 /* ComputePosition */, computePosition);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    builder.frag.set(13 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    return builder.buildProgram(context);
}
exports.createClipMaskProgram = createClipMaskProgram;


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const computeAlphaWeight = `
float computeAlphaWeight(float a) {
  // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:
  // http://jcgt.org/published/0002/02/09/
  // We are using Equation 10 from the above paper.  Equation 10 directly uses screen-space gl_FragCoord.z.
  // Dividing this z by w puts it in linear space, necessary for bigger ranges.
  // flatAlphaWeight bit is set if we want to apply OIT transparency using a constant Z value of 1.

  float z = isShaderBitSet(kShaderBit_OITFlatAlphaWeight) ? 1.0 : 1.0 - gl_FragCoord.z / gl_FragCoord.w;
  return pow(a + 0.01, 4.0) + max(1e-2, 3.0 * 1e3 * pow(z, 3.0));
}
`;
const assignFragData = `
  vec3 Ci = baseColor.rgb;
  float ai = min(0.99, baseColor.a); // OIT algorithm does not nicely handle a=1
  float wzi = computeAlphaWeight(ai);

  // If we are scaling output into the 0 to 1 range, we use the maximum output of the alpha weight function.
  float outputScale = isShaderBitSet(kShaderBit_OITScaleOutput) ? 1.0 / 3001.040604 : 1.0;

  FragColor0 = vec4(Ci * wzi * outputScale, ai);
  FragColor1 = vec4(ai * wzi * outputScale);
`;
function addTranslucency(frag) {
    frag.addDrawBuffersExtension();
    frag.addFunction(computeAlphaWeight);
    frag.set(13 /* AssignFragData */, assignFragData);
}
exports.addTranslucency = addTranslucency;


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FloatRGBA_1 = __webpack_require__(35);
const applyMonochromeColor = `
  if (!isShaderBitSet(kShaderBit_Monochrome))
    return baseColor;

  // The alpha component of the mono color = 1.0 if lit, 0.0 if unlit
  // We need to use the mono color directly for unlit stuff (i.e. edges, polylines) in order for white-on-white reversal to work correctly.
  // But it looks terrible for lit surfaces.
  if (u_monoRgb.a  > 0.5) {
    // Preserve translucency...
    if (baseColor.a > 0.0)
      baseColor.rgb /= baseColor.a;

    baseColor.rgb = vec3(dot(baseColor.rgb, vec3(.222, .707, .071)));
    baseColor.rgb *= u_monoRgb.rgb;
  } else {
    baseColor.rgb = u_monoRgb.rgb;
  }

  baseColor.rgb *= baseColor.a;
  return baseColor;
`;
function addMonochrome(frag) {
    frag.set(8 /* ApplyMonochrome */, applyMonochromeColor);
    frag.addUniform("u_monoRgb", 6 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_monoRgb", (uniform, params) => {
            // alpha = 1.0 indicates lit surface, 0.0 = unlit
            const transparency = params.geometry.isLitSurface ? 0 : 255;
            const color = FloatRGBA_1.FloatRgba.fromColorDef(params.target.monoColor, transparency);
            color.bind(uniform);
        });
    });
}
exports.addMonochrome = addMonochrome;


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Common_1 = __webpack_require__(45);
const Material_1 = __webpack_require__(130);
/* ###TODO: IBL
import { addNormalMatrixF } from "./Fragment";
import { TextureUnit } from "../RenderFlags";
*/
/* ###TODO: Source Lighting
const maxShaderLights = 64;
*/
/**
 * Lights - stored in a u_lightData array (3 entries per light)
 *     Type is determined from the sign of cosHPhi and cosHTheta.
 *                 Point:       cosHPhi   < 0
 *                 Spot:        cosHTheta >= 0 && cosHPhi >= 0
 *                 Directional: cosHTheta < 0
 *     Attenuation 0, 1, and 2 are calculated here based on using no attenuation,
 *         using linear attenuation, or using distance squared.
 *     If linear, the equation we use is:  1 / (0.5 + 1.5 / halfBrightDist * d)
 *         where atten1 = -1.5 / halfBrightDist (linear not used here)
 *     If distance squared, the equation is:  realBright / (1 + d * d)
 *         where atten1 = realBright
 *     For no attenuation (atten = 1), atten1 is 0
 *     cosHTheta (cos(Theta / 2)) is passed for spots
 *     cosHPhi   (cos(Phi / 2)) is passed for spots
 */
/* ###TODO: Source Lighting
const computeSourceLighting = `
void computeSingleSourceLight (inout vec3 diffuse, inout vec3 specular, vec3 camPos, vec3 norm, vec3 vPntToView, float specPow,
                               vec3 lightCol, vec3 lightPos, vec3 lightDir, float lCosHTheta, float lCosHPhi, float atten1) {
  vec3 curDiff = vec3(0.0, 0.0, 0.0);
  vec3 curSpec = vec3(0.0, 0.0, 0.0);

  // vPosToLt is the normalized vector from the vertex pos to the light pos
  vec3 vPosToLt = lightPos - camPos;
  float lpDist = length (vPosToLt);   // calc lpDist separately for later
  if (lCosHTheta < 0.0)  // if directional
    vPosToLt = lightDir;
  else
    vPosToLt *= 1.0 / lpDist;   // normalize

  // Calculate spot factor
  float spotf = 1.0;  // default value for not spot or if (rho > lCosHTheta)
  if ((lCosHTheta >= 0.0) && (lCosHPhi >= 0.0)) { // if spotlight
      float rho = dot (vPosToLt, lightDir);
      if  (rho <= lCosHPhi) // outside of spot
        spotf = 0.0;
      else if (rho <= lCosHTheta) { // between inner and outer cones
        float t1 = lCosHTheta - lCosHPhi;
        // prevent divisor from being less than 0 (which still could happen here)
        if (t1 > 0.0) {
          spotf = (rho - lCosHPhi) / t1;
          // do hermite blending on spotf
          spotf = (3.0 - 2.0 * spotf) * spotf * spotf;
        }
      }
    }

  // Calculate attenuation
  float atten = 1.0;  // for dir light or no atten
  if (atten1 > 0.0)  // D2 (only distance squared currently used if attenuation)
    atten = atten1 / (1.0 + lpDist * lpDist);

  atten *= spotf; // at this point atten and spotf are 1.0 if not applicable

  float NdotL = dot (norm, vPosToLt);
  float attenNdotL = atten * NdotL;

  if (attenNdotL > 0.0) {
    curDiff = attenNdotL * lightCol;
    // use the Phong reflection V dot R where R = 2N * (N dot L) - L
    vec3 R = 2.0 * NdotL * norm - vPosToLt;
    float rDotV = dot (vPntToView, R);
    if (rDotV > 0.0)
        curSpec = atten * pow (abs(rDotV), specPow) * lightCol;  //TODO: abs should not be necessary here
  }
  diffuse += curDiff;  specular += curSpec;
}

void computeAllSourceLights (inout vec3 diffuse, inout vec3 specular, vec3 position, vec3 normal, vec3 vPntToView, float specularExp) {
  for (int i = 0;  i < kMaxShaderLights;  ++i)
    computeSingleSourceLight (diffuse, specular, position, normal, vPntToView, specularExp, LightColor(i), LightPos(i), LightDir(i), cosHTheta(i), cosHPhi(i), LightAtten1(i));
}

vec3 computeSourceLighting (vec3 normal, vec3 toEye, vec3 position, float specularExp, vec3 specularColor, vec3 inputColor) {
  vec3 diffuse = vec3(0.0, 0.0, 0.0);
  vec3 specular = vec3(0.0, 0.0, 0.0);

  if (u_lightCount > 0)
    computeAllSourceLights (diffuse, specular, position, normal, -toEye, specularExp);

  // diffuse = diffuse * inputColor.rgb + u_ambientLight * ambientCol + specular * specularColor + emissiveCol;
  vec3 total = diffuse * inputColor + specular * specularColor;

  // since not HDR, just scale by u_fstop value
  if (u_fstop >= 0.0)
    total *= (u_fstop + 1.0);
  else
    total /= (-u_fstop + 1.0);

  return total;
}
`;
*/
/* ###TODO: IBL
const sampleRGBM = `
vec3 decodeRGBM(in vec4 rgbm) {
  return 5.0 * rgbm.rgb * rgbm.a;
}

vec3 sampleRGBM (in sampler2D map, in vec3 dir) { // Normalized direction.
  vec2 uv;
  uv.x = .25 - atan(dir.y, dir.x) / (2.0 * 3.141592); // To match crazy skybox code.
  uv.y =  .5 - asin(dir.z) / 3.141592;
  return  decodeRGBM(TEXTURE(map, uv));
}
`;

const applyReflection = `
  vec3 toScreen(in vec3 linear) { return pow (linear, vec3(1.0/2.2)); }

  vec3 applyReflection(in vec3 inColor, in vec3 normal, in vec4 reflectivity) {
    if (!isSurfaceBitSet(kSurfaceBit_EnvironmentMap) || reflectivity.a <= 0.0)
      return inColor;
    vec3 reflWorld  = normalize(reflect(v_pos.xyz, normal.xyz)) * u_nmx;
    vec3 environmentMapColor = reflectivity.rgb * toScreen(sampleRGBM(u_environmentMap, reflWorld));
    return mix (inColor, environmentMapColor, reflectivity.a);
  }
`;
*/
const computeSimpleLighting = `
void computeSimpleLight (inout float diffuse, inout float specular, vec3 normal, vec3 toEye, vec3 lightDir, float lightIntensity, float specularExponent) {
  diffuse += lightIntensity * max(dot(normal, lightDir), 0.0);
  vec3 toReflectedLight = normalize(reflect(lightDir, normal));
  float specularDot = max(dot(toReflectedLight, toEye), 0.0);
  specular += lightIntensity * pow(specularDot, specularExponent);
}
`;
/* ###TODO
#ifdef PBR_WIP
  const toLinear = `{ return "vec3 toLinear(in vec3 gamma) { return pow(gamma, vec3(1.8)); }`;
#endif
*/
/* ###TODO: IBL & PBR
const toLuminance = `{ return "float toLuminance(in vec3 rgb) { return 0.299*rgb.r + 0.587*rgb.g + 0.114*rgb.b; }`;
*/
const applyLighting = `
  if (isSurfaceBitSet(kSurfaceBit_ApplyLighting) && baseColor.a > 0.0) {
    // Lighting algorithms written in terms of non-pre-multiplied alpha...
    float alpha = baseColor.a;
    baseColor.rgb /= alpha;

    vec3 normal = normalize(v_n.xyz);
    vec3 toEye;

    if (!gl_FrontFacing)
      normal = -normal;

    if (kFrustumType_Perspective == u_frustum.z) // perspective
      toEye = normalize (v_pos.xyz);
    else
      toEye = vec3(0.0, 0.0, -1.0);

    bool    useDefaults = isSurfaceBitSet(kSurfaceBit_IgnoreMaterial);
    float   specularExp =  useDefaults ? 43.2 : u_specular.a;
    vec3    specularColor = useDefaults ? vec3(1.0) : u_specular.rgb;
    float   diffuseWeight = useDefaults ? .6 : u_material.r;
    float   specularWeight = useDefaults ? .4 : u_material.g;
    vec3    litColor = vec3(0.0);

    /* ##TODO: IBL
    baseColor.rgb = applyReflection(baseColor.rgb, normal, u_reflect);

    if (u_lightMix.x > 0.0001) {
      vec3    normalWorld = normal * u_nmx;
      vec3 normalWorld = normal * u_nmx;
      vec3 imageDiffuse = sampleRGBM(u_diffuseMap, normalWorld);

      litColor += u_lightMix.x * toLuminance (imageDiffuse) * baseColor.rgb;

      if (0.0 != u_imageSolar.w) {
        float diffuseIntensity = 0.0, specularIntensity = 0.0;

        computeSimpleLight(diffuseIntensity, specularIntensity, normalWorld, toEye, u_imageSolar.xyz, 1.0, specularExp);
        litColor += u_lightMix.x * (u_imageSolar.w * diffuseWeight * diffuseIntensity * baseColor.rgb + specularIntensity * specularWeight * specularColor);
      }
    }
    */

    if (u_lightMix.y > 0.0001) { // Default.
      float diffuseIntensity = 0.0, specularIntensity = 0.0;

      // Use a pair of lights that is something in-between portrait lighting & something more out-doorsy with a slightly more overhead main light.
      // This will make more sense in a wider variety of scenes since this is the only lighting currently supported.
      computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(0.2, 0.5, 0.5)), 1.0, specularExp);
      computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(-0.3, 0.0, 0.3)), .30, specularExp);

      litColor += u_lightMix.y * diffuseWeight * diffuseIntensity * baseColor.rgb + specularIntensity * specularWeight * specularColor;
    }

    /* ###TODO: Source Lighting
    if (u_lightMix.z > 0.0) // Source.
        litColor += u_lightMix.z * computeSourceLighting(normal, toEye, v_pos, specularExp, specularColor, baseColor.rgb);
    */

    if (u_lightMix.a > 0.0)
        litColor.rgb += u_lightMix.a * baseColor.rgb;

    // Clamp while preserving hue.
    float   maxIntensity = max(litColor.r, max(litColor.g, litColor.b));

    baseColor.rgb = (maxIntensity > 1.0) ? (litColor / maxIntensity) : litColor;

    // Restore pre-multiplied alpha...
    baseColor.rgb *= alpha;
  }

  return baseColor;
`;
const scratchLighting = {
    lightMix: new Float32Array(4),
};
function addLighting(builder) {
    Common_1.addFrustum(builder);
    const frag = builder.frag;
    frag.addUniform("u_lightMix", 6 /* Vec4 */, (shaderProg) => {
        shaderProg.addGraphicUniform("u_lightMix", (uniform, params) => {
            // const viewFlags = params.m_target.currentViewFlags(); // TODO set lighting based on these - always default for now.
            const data = scratchLighting.lightMix;
            data[0] = 0.0; // set to 1.0 for IBL
            data[1] = 0.0; // set to 1.0 for default portrait lighting
            data[2] = 0.0; // set to 1.0 for using scene lights
            data[3] = 0.0; // set > 0.0 for constant lighting
            // ###TODO: IBL - use the following commented out line instead of the one after it which is there just to use params.
            // const doDiffuseImageLighting: boolean = (undefined !== params.target.diffuseMap);
            const doDiffuseImageLighting = (undefined === params.target);
            if (doDiffuseImageLighting)
                data[0] = 1.0;
            else {
                // Use default lighting, a pair of directional lights + a little ambient.
                data[1] = 0.92;
                data[3] = 0.08;
            }
            uniform.setUniform4fv(data);
        });
    });
    // #if !defined(GLES3_CONFORMANT)
    //   frag.AddExtension("GL_EXT_shader_texture_lod");
    // #endif
    /* ###TODO: IBL
    addNormalMatrixF(frag);
    addEnvironmentMap(frag);
    addDiffuseMap(frag);
    frag.addFunction(sampleRGBM);
    frag.addFunction(toLuminance);
    frag.addFunction(applyReflection);
    frag.addUniform("u_imageSolar", VariableType.Vec4, (shader) => {
      shader.addGraphicUniform("u_imageSolar", (uniform, params) => {
        const imageSolar = params.target.imageSolar;
        const data = new Float32Array(4);
        if (undefined !== imageSolar) {
          data[0] = imageSolar.direction.x;
          data[1] = imageSolar.direction.y;
          data[2] = imageSolar.direction.z;
          data[3] = imageSolar.intensity;
        } else {
          data[0] = 0.0;
          data[1] = -1.0;
          data[2] = 0.0;
          data[3] = 1.0;
        }
        uniform.setUniform4fv(data);
      });
    });
    */
    /* ###TODO BPR
    frag.addFunction(ToLinear());
    frag.addFunction(ToLuminance());
    addIBLDiffuse(frag);
    addBRDFTexture(frag);
    frag.addFunction(IBLSpecular());
    */
    frag.addUniform("u_material", 5 /* Vec3 */, (shader) => {
        shader.addGraphicUniform("u_material", (uniform, params) => {
            const material = params.target.currentViewFlags.showMaterials() ? params.geometry.material : undefined;
            const weights = undefined !== material ? material.weights : Material_1.Material.default.weights;
            uniform.setUniform3fv(weights);
        });
    });
    frag.addUniform("u_specular", 6 /* Vec4 */, (shader) => {
        shader.addGraphicUniform("u_specular", (uniform, params) => {
            let mat = params.target.currentViewFlags.showMaterials() ? params.geometry.material : undefined;
            if (undefined === mat)
                mat = Material_1.Material.default;
            uniform.setUniform4fv(mat.specular);
        });
    });
    /* ###TODO BPR
    frag.addUniform("u_reflect", VariableType.Vec4, (shader) => {
      shader.addGraphicUniform("u_reflect", (uniform, params) => {
        const data = new Float32Array(4);
        if (params.target.currentViewFlags.showMaterials()) {
          // const mat = params.geometry.material;
          // data[0] = mat.reflectColor.red;
          // data[1] = mat.reflectColor.green;
          // data[2] = mat.reflectColor.blue;
          // data[3] = mat.reflect;
          data[0] = 1.0;
          data[1] = 1.0;
          data[2] = 1.0;
          data[3] = 0.0;
        } else {
          data[0] = 1.0;
          data[1] = 1.0;
          data[2] = 1.0;
          data[3] = 0.0;
        }
        uniform.setUniform4fv(data);
      });
    });
    */
    frag.addFunction(computeSimpleLighting);
    /* ###TODO: Source Lighting
    frag.addFunction(computeSourceLighting);
  
    frag.addUniform("u_fstop", VariableType.Float, (shader) => {
      shader.addGraphicUniform("u_fstop", (uniform, params) => {
      uniform.setUniform1f(params.target.fStop);
      });
    });
  
    // frag.addUniform("u_ambientLight", VariableType.Vec3, (shader) => {
    //   shader.addGraphicUniform("u_ambientLight", (uniform, params) => {
    //     uniform.setUniform3fv(params.target.ambientLight);
    //   });
    // }
  
    frag.addUniform("u_lightCount", VariableType.Int, (shader) => {
      shader.addGraphicUniform("u_lightCount", (uniform, params) => {
        if (undefined === params.target.shaderLights)
          uniform.setUniform1i(0);
        else
          uniform.setUniform1i(params.target.shaderLights.numLights);
      });
    });
  
    const name = "u_lightData[" + maxShaderLights + "*3]";
    frag.addUniform(name, VariableType.Vec4, (shader) => {
      shader.addGraphicUniform("u_lightData[0]", (uniform, params) => {
        if (undefined !== params.target.shaderLights) {
          let numLights = params.target.shaderLights.numLights;
          if (numLights > 0) {
            if (numLights > maxShaderLights)
              numLights = maxShaderLights;
            uniform.setUniform4fv(params.target.shaderLights.data);
          }
        }
      });
    });
    */
    frag.set(7 /* ApplyLighting */, applyLighting);
}
exports.addLighting = addLighting;
/* ###TODO: IBL
function addEnvironmentMap(frag: FragmentShaderBuilder) {
  frag.addUniform("u_environmentMap", VariableType.Sampler2D, (shader) => {
    shader.addGraphicUniform("u_environmentMap", (uniform, params) => {
      if (undefined !== params.target.environmentMap)
        params.target.environmentMap!.bindSampler (uniform, TextureUnit.EnvironmentMap);
      return true;
    });
  });
}

function addDiffuseMap(frag: FragmentShaderBuilder) {
  frag.addUniform("u_diffuseMap", VariableType.Sampler2D, (shader) => {
    shader.addGraphicUniform("u_diffuseMap", (uniform, params) => {
      if (undefined !== params.target.diffuseMap)
        params.target.diffuseMap.bindSampler (uniform, TextureUnit.DiffuseMap);
      return true;
    });
  });
}
*/


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FeatureSymbology_1 = __webpack_require__(86);
const Vertex_1 = __webpack_require__(20);
const Clipping_1 = __webpack_require__(89);
const Common_1 = __webpack_require__(45);
const Color_1 = __webpack_require__(103);
const Fragment_1 = __webpack_require__(25);
const ShaderBuilder_1 = __webpack_require__(30);
const computePosition = `
  float lineWeight = ComputeLineWeight();
  if (lineWeight > 4.0)
    lineWeight += 0.5; // ###TODO: Fudge factor for rounding fat points...

  gl_PointSize = lineWeight;
  return u_mvp * rawPos;
`;
const roundCorners = `
  // gl_PointSize specifies coordinates of this fragment within the point in range [0,1].
  // This should be the most precise of the many approaches we've tried, but it still yields some asymmetry...
  // Discarding if it meets radius precisely seems to reduce that slightly...
  // ###TODO try point sprites?
  const vec2 center = vec2(0.5, 0.5);
  vec2 vt = gl_PointCoord - center;
  return dot(vt, vt) * v_roundCorners >= 0.25; // meets or exceeds radius of circle
`;
const computeRoundCorners = "  v_roundCorners = gl_PointSize > 4.0 ? 1.0 : 0.0;";
function createBase(clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(true);
    // addShaderFlags(builder); // Commented out in the c++ code
    const vert = builder.vert;
    vert.set(3 /* ComputePosition */, computePosition);
    Vertex_1.addModelViewProjectionMatrix(vert);
    vert.addFunction(Vertex_1.GLSLVertex.computeLineWeight);
    vert.addUniform("u_lineWeight", 3 /* Float */, (prog) => {
        prog.addGraphicUniform("u_lineWeight", (uniform, params) => {
            uniform.setUniform1f(params.geometry.getLineWeight(params));
        });
    });
    builder.addInlineComputedVarying("v_roundCorners", 3 /* Float */, computeRoundCorners);
    builder.frag.set(0 /* CheckForEarlyDiscard */, roundCorners);
    if (1 /* Yes */ === clip)
        Clipping_1.addClipping(builder);
    return builder;
}
function createPointStringHiliter(clip) {
    const builder = createBase(clip);
    FeatureSymbology_1.addHiliter(builder, true);
    return builder;
}
exports.createPointStringHiliter = createPointStringHiliter;
function createPointStringBuilder(clip) {
    const builder = createBase(clip);
    Common_1.addShaderFlags(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createPointStringBuilder = createPointStringBuilder;


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const Vertex_1 = __webpack_require__(20);
const Clipping_1 = __webpack_require__(89);
const ShaderBuilder_1 = __webpack_require__(30);
const GL_1 = __webpack_require__(8);
const computePosition = "gl_PointSize = 1.0; return u_mvp * rawPos;";
const computeColor = "return vec4(a_color, 1.0);";
const computeBaseColor = "return v_color;";
function createPointCloudBuilder(clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(false);
    const vert = builder.vert;
    vert.set(3 /* ComputePosition */, computePosition);
    builder.frag.set(1 /* ComputeBaseColor */, computeColor);
    Vertex_1.addModelViewProjectionMatrix(vert);
    builder.vert.addAttribute("a_color", 5 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_color", (attr, params) => {
            const pointCloudGeom = params.geometry;
            bentleyjs_core_1.assert(pointCloudGeom !== undefined);
            if (undefined !== pointCloudGeom && undefined !== pointCloudGeom.colors)
                attr.enableArray(pointCloudGeom.colors, 3, GL_1.GL.DataType.UnsignedByte, true, 0, 0);
        });
    });
    if (1 /* Yes */ === clip)
        Clipping_1.addClipping(builder);
    builder.addFunctionComputedVarying("v_color", 6 /* Vec4 */, "computeNonUniformColor", computeColor);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    return builder;
}
exports.createPointCloudBuilder = createPointCloudBuilder;


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
const ShaderBuilder_1 = __webpack_require__(30);
const Vertex_1 = __webpack_require__(20);
const Viewport_1 = __webpack_require__(233);
const GL_1 = __webpack_require__(8);
const Clipping_1 = __webpack_require__(89);
const Color_1 = __webpack_require__(103);
const Fragment_1 = __webpack_require__(25);
const Common_1 = __webpack_require__(45);
const Polyline_1 = __webpack_require__(232);
const Mesh_1 = __webpack_require__(102);
const Vertex_2 = __webpack_require__(20);
const Surface_1 = __webpack_require__(231);
const decodeEndPointAndQuadIndices = `
  float index = decodeUInt32(a_endPointAndQuadIndices.xyz);
  vec2 tc = computeLUTCoords(index, u_vertParams.xy, g_vert_center, u_vertParams.z);
  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));
  g_otherPos = unquantizePosition(qpos, u_qOrigin, u_qScale);
  g_quadIndex = a_endPointAndQuadIndices.w;
`;
const checkForSilhouetteDiscard = `
  vec3 n0 = u_nmx * octDecodeNormal(a_normals.xy);
  vec3 n1 = u_nmx * octDecodeNormal(a_normals.zw);

  if (0.0 == u_mvp[0].w) {
    return n0.z * n1.z > 0.0;           // orthographic.
  } else {
    vec4  viewPos = u_mv * rawPos;     // perspective
    vec3  toEye = normalize(viewPos.xyz);
    float dot0 = dot(n0, toEye);
    float dot1 = dot(n1, toEye);

    if (dot0 * dot1 > 0.0)
      return true;

    // Need to discard if either is non-silhouette.
    vec4 otherPosition = g_otherPos;
    viewPos = u_mv * otherPosition;
    toEye = normalize(viewPos.xyz);
    dot0 = dot(n0, toEye);
    dot1 = dot(n1, toEye);

    return dot0 * dot1 > 0.0;
  }
`;
const computePosition = `
  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false

  // ###TODO if (u_animParams.z > 0.0)
  // ###TODO   rawPos.xyz += computeAnimatedDisplacement(u_animValue * u_animParams.z).xyz;

  vec4  pos = u_mvp * rawPos;
  vec4  other = g_otherPos;
  vec3  modelDir = other.xyz - pos.xyz;
  float miterAdjust = 0.0;
  float weight = ComputeLineWeight();

  g_windowPos = modelToWindowCoordinates(rawPos, other);

  if (g_windowPos.w == 0.0) // Clipped out.
    return g_windowPos;

  vec4 projOther = modelToWindowCoordinates(other, rawPos);

  g_windowDir = projOther.xy - g_windowPos.xy;

  adjustWidth(weight, g_windowDir, g_windowPos.xy);
  g_windowDir = normalize(g_windowDir);

  vec2  perp = vec2(-g_windowDir.y, g_windowDir.x);
  float perpDist = weight / 2.0;
  float alongDist = 0.0;

  if (g_quadIndex == 1.0) {
    perpDist = -perpDist;
  } else if (g_quadIndex == 2.0) {
    perpDist = -perpDist;
    alongDist = distance(rawPos, other);
  } else if (g_quadIndex == 3.0) {
    alongDist = distance(rawPos, other);
  }

  pos.x += perp.x * perpDist * 2.0 * pos.w / u_viewport.z;
  pos.y += perp.y * perpDist * 2.0 * pos.w / u_viewport.w;

  lineCodeEyePos = .5 * (rawPos + other);
  lineCodeDist = alongDist;

  return pos;
`;
const lineCodeArgs = "g_windowDir, g_windowPos, 0.0";
function createBase(isSilhouette, clip) {
    const builder = new ShaderBuilder_1.ProgramBuilder(true);
    const vert = builder.vert;
    vert.addGlobal("g_otherPos", 6 /* Vec4 */);
    vert.addGlobal("g_quadIndex", 3 /* Float */);
    vert.addGlobal("g_windowPos", 6 /* Vec4 */);
    vert.addGlobal("g_windowDir", 4 /* Vec2 */);
    vert.addInitializer(decodeEndPointAndQuadIndices);
    vert.addGlobal("lineCodeEyePos", 6 /* Vec4 */);
    vert.addGlobal("lineCodeDist", 3 /* Float */, "0.0");
    Viewport_1.addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation
    Vertex_1.addProjectionMatrix(vert);
    Polyline_1.addLineCode(builder, lineCodeArgs);
    vert.set(3 /* ComputePosition */, computePosition);
    vert.addFunction(Vertex_1.GLSLVertex.computeLineWeight);
    builder.addVarying("v_lnInfo", 6 /* Vec4 */);
    vert.addFunction(Polyline_1.adjustWidth);
    Viewport_1.addViewport(vert);
    Vertex_1.addModelViewMatrix(vert);
    vert.addAttribute("a_endPointAndQuadIndices", 6 /* Vec4 */, (shaderProg) => {
        shaderProg.addAttribute("a_endPointAndQuadIndices", (attr, params) => {
            const geom = params.geometry;
            bentleyjs_core_1.assert(geom instanceof Mesh_1.EdgeGeometry);
            const edgeGeom = geom;
            attr.enableArray(edgeGeom.endPointAndQuadIndices, 4, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
        });
    });
    vert.addUniform("u_lineWeight", 3 /* Float */, (shaderProg) => {
        shaderProg.addGraphicUniform("u_lineWeight", (attr, params) => {
            attr.setUniform1f(params.geometry.getLineWeight(params));
        });
    });
    if (isSilhouette) {
        Vertex_2.addNormalMatrix(vert);
        vert.set(0 /* CheckForEarlyDiscard */, checkForSilhouetteDiscard);
        vert.addFunction(Surface_1.octDecodeNormal);
        vert.addAttribute("a_normals", 6 /* Vec4 */, (shaderProg) => {
            shaderProg.addAttribute("a_normals", (attr, params) => {
                const geom = params.geometry;
                bentleyjs_core_1.assert(geom instanceof Mesh_1.SilhouetteEdgeGeometry);
                const silhouetteGeom = geom;
                attr.enableArray(silhouetteGeom.normalPairs, 4, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
            });
        });
    }
    if (1 /* Yes */ === clip)
        Clipping_1.addClipping(builder);
    return builder;
}
function createEdgeBuilder(isSilhouette, clip) {
    const builder = createBase(isSilhouette, clip);
    Common_1.addShaderFlags(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createEdgeBuilder = createEdgeBuilder;


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(30);
const RenderFlags_1 = __webpack_require__(24);
const Matrix_1 = __webpack_require__(81);
const computeBaseColor = `return vec4(0, 0, 0, 0);`;
const assignFragData = `
if (v_side < 0.2 - 0.001) FragColor = TEXTURE(s_front, v_texCoord);
else if (v_side < 0.4 - 0.001) FragColor = TEXTURE(s_back, v_texCoord);
else if (v_side < 0.6 - 0.001) FragColor = TEXTURE(s_top, v_texCoord);
else if (v_side < 0.8 - 0.001) FragColor = TEXTURE(s_bottom, v_texCoord);
else if (v_side < 1.0 - 0.001) FragColor = TEXTURE(s_left, v_texCoord);
else // if (1.0 == v_side)
  FragColor = TEXTURE(s_right, v_texCoord);
`;
const computePosition = `vec3 pos = u_rot * rawPos.xyz; return pos.xyzz;`;
const computeTexCoord = `v_texCoord = a_texCoord;`;
const computeSide = `v_side = a_side;`;
function addSkyBoxSide(vert) {
    vert.addAttribute("a_side", 3 /* Float */, (prog) => {
        prog.addAttribute("a_side", (attr, params) => {
            const geom = params.geometry;
            geom.bindSideArray(attr);
        });
    });
}
function addTexCoord(vert) {
    vert.addAttribute("a_texCoord", 4 /* Vec2 */, (prog) => {
        prog.addAttribute("a_texCoord", (attr, params) => {
            const geom = params.geometry;
            geom.bindTexCoordArray(attr);
        });
    });
}
function createSkyBoxProgram(context) {
    const prog = new ShaderBuilder_1.ProgramBuilder(false);
    prog.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    prog.frag.set(13 /* AssignFragData */, assignFragData);
    prog.vert.set(3 /* ComputePosition */, computePosition);
    prog.vert.addUniform("u_rot", 7 /* Mat3 */, (prg) => {
        prg.addGraphicUniform("u_rot", (uniform, params) => {
            const rot = params.viewMatrix.getRotation();
            const mat3 = new Matrix_1.Matrix3();
            mat3.m00 = -rot.m00;
            mat3.m01 = -rot.m01;
            mat3.m02 = -rot.m02;
            mat3.m10 = -rot.m10;
            mat3.m11 = -rot.m11;
            mat3.m12 = -rot.m12;
            mat3.m20 = rot.m20;
            mat3.m21 = rot.m21;
            mat3.m22 = rot.m22;
            // mat3.initIdentity(); // ###TODO: remove.  This is for testing only.
            uniform.setMatrix3(mat3);
        });
    });
    addSkyBoxSide(prog.vert);
    addTexCoord(prog.vert);
    prog.frag.addUniform("s_front", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_front", (uniform, params) => {
            const geom = params.geometry;
            geom.front.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Zero);
        });
    });
    prog.frag.addUniform("s_back", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_back", (uniform, params) => {
            const geom = params.geometry;
            geom.back.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.One);
        });
    });
    prog.frag.addUniform("s_top", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_top", (uniform, params) => {
            const geom = params.geometry;
            geom.top.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Two);
        });
    });
    prog.frag.addUniform("s_bottom", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_bottom", (uniform, params) => {
            const geom = params.geometry;
            geom.bottom.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Three);
        });
    });
    prog.frag.addUniform("s_left", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_left", (uniform, params) => {
            const geom = params.geometry;
            geom.left.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Four);
        });
    });
    prog.frag.addUniform("s_right", 9 /* Sampler2D */, (prg) => {
        prg.addGraphicUniform("s_right", (uniform, params) => {
            const geom = params.geometry;
            geom.right.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Five);
        });
    });
    prog.addInlineComputedVarying("v_texCoord", 4 /* Vec2 */, computeTexCoord);
    prog.addInlineComputedVarying("v_side", 3 /* Float */, computeSide);
    return prog.buildProgram(context);
}
exports.createSkyBoxProgram = createSkyBoxProgram;


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Primitive_1 = __webpack_require__(65);
const CachedGeometry_1 = __webpack_require__(29);
const Handle_1 = __webpack_require__(36);
const GL_1 = __webpack_require__(8);
const System_1 = __webpack_require__(7);
const bentleyjs_core_1 = __webpack_require__(0);
class PointCloudGraphic extends Primitive_1.Primitive {
    get renderOrder() { return 2 /* Surface */; }
    addCommands(commands) { commands.addPrimitive(this); }
    dispose() {
    }
    static create(args) {
        return new PointCloudGraphic(args);
    }
    constructor(args) {
        super(new PointCloudGeometry(args));
    }
}
exports.PointCloudGraphic = PointCloudGraphic;
class PointCloudGeometry extends CachedGeometry_1.CachedGeometry {
    constructor(pointCloud) {
        super();
        this.colorHandle = undefined;
        this.vertices = Handle_1.QBufferHandle3d.create(pointCloud.pointParams, pointCloud.points);
        this.vertexCount = pointCloud.points.length / 3;
        if (undefined !== pointCloud.colors)
            this.colorHandle = Handle_1.BufferHandle.createArrayBuffer(pointCloud.colors);
    }
    dispose() { bentleyjs_core_1.dispose(this.vertices); }
    _wantWoWReversal(_target) { return false; }
    getTechniqueId(_target) { return 2 /* PointCloud */; }
    getRenderPass(_target) { return 3 /* OpaqueGeneral */; }
    get renderOrder() { return 2 /* Surface */; }
    get qOrigin() { return this.vertices.origin; }
    get qScale() { return this.vertices.scale; }
    get colors() { return this.colorHandle; }
    bindVertexArray(attr) { attr.enableArray(this.vertices, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0); }
    draw() {
        const gl = System_1.System.instance.context;
        gl.drawArrays(GL_1.GL.PrimitiveType.Points, 0, this.vertexCount);
    }
}
exports.PointCloudGeometry = PointCloudGeometry;
class PointCloudPrimitive extends Primitive_1.Primitive {
    get renderOrder() { return 2 /* Surface */; }
    constructor(cachedGeom, _pointCloud) {
        super(cachedGeom);
    }
}
exports.PointCloudPrimitive = PointCloudPrimitive;


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(15);
const IModelApp_1 = __webpack_require__(5);
/**
 * A manipulator maintains a set of controls used to modify element(s) or pickable decorations.
 * Interactive modification is handled by installing an InputCollector tool.
 */
var EditManipulator;
(function (EditManipulator) {
    class Tool extends Tool_1.InputCollector {
        constructor(manipulator) {
            super();
            this.manipulator = manipulator;
        }
        /** Setup tool for press, hold, drag or click+click modification.
         * To support drag operation, request up event be sent to this tool even though it would not have received the down event.
         * By default a vertex type manipulator should honor all locks and support AccuSnap.
         */
        init() { IModelApp_1.IModelApp.toolAdmin.currentInputState.buttonDownTool = this; IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr = 0 /* None */; IModelApp_1.IModelApp.accuSnap.enableLocate(false); IModelApp_1.IModelApp.accuSnap.enableSnap(true); }
        cancel(_ev) { return true; }
        onPostInstall() { super.onPostInstall(); this.init(); }
        onDataButtonDown(ev) { if (!this.accept(ev))
            return false; this.exitTool(); this.manipulator.onManipulatorEvent(2 /* Accept */); return true; }
        onResetButtonUp(ev) { if (!this.cancel(ev))
            return false; this.exitTool(); this.manipulator.onManipulatorEvent(1 /* Cancel */); return true; }
    }
    Tool.toolId = "Select.Manipulator";
    Tool.hidden = true;
    EditManipulator.Tool = Tool;
    class Provider {
        constructor(iModel) {
            this.iModel = iModel;
            this.isActive = false;
        }
        allowTransientControls() { return false; }
        updateControls() {
            this.isActive = this.createControls();
            this.updateDecorationListener(this.isActive);
        }
        clearControls() {
            this.isActive = false;
            this.updateDecorationListener(false);
        }
        updateDecorationListener(add) {
            if (this.removeDecorationListener) {
                if (!add) {
                    this.removeDecorationListener();
                    this.removeDecorationListener = undefined;
                }
                IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            }
            else if (add) {
                if (!this.removeDecorationListener)
                    this.removeDecorationListener = IModelApp_1.IModelApp.viewManager.onDecorate.addListener(this.drawControls, this);
                IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            }
        }
        drawControls(_context) { }
        onDoubleClick(_ev) { return false; } // IModelApp.locateManager.currHit holds located element or pickable decoration
        onButtonEvent(ev) {
            if (ev.isDoubleClick)
                return this.onDoubleClick(ev);
            if (!this.isActive)
                return false;
            if (0 /* Data */ !== ev.button)
                return false;
            const isDragging = ev.isDown && IModelApp_1.IModelApp.toolAdmin.currentInputState.isDragging(0 /* Data */);
            if (isDragging && ev.isControlKey)
                return false; // Don't select or modify controls with ctrl+drag...
            if ((ev.isDown && !isDragging) || !this.selectControls(ev))
                return false; // Select controls on up event or down event only after drag started...
            if (ev.isControlKey)
                return true; // Support ctrl+click to select multiple controls...
            return this.modifyControls(ev); // Handle modification. Install InputCollector to modify using hold+drag, release or click+click.
        }
        onGestureEvent(_ev) { return false; }
        onManipulatorEvent(_eventType) { this.updateControls(); }
        onSelectionChanged(iModel, _eventType, _ids) { if (this.iModel === iModel)
            this.onManipulatorEvent(0 /* Synch */); }
        init() {
            this.removeSelectionListener = this.iModel.selectionSet.onChanged.addListener(this.onSelectionChanged, this);
            this.updateControls();
        }
        clear() {
            if (this.removeSelectionListener) {
                this.removeSelectionListener();
                this.removeSelectionListener = undefined;
            }
            this.clearControls();
        }
    }
    EditManipulator.Provider = Provider;
})(EditManipulator = exports.EditManipulator || (exports.EditManipulator = {}));
/** @hidden */
class TestEditManipulatorTool extends EditManipulator.Tool {
    init() { super.init(); this.beginDynamics(); }
    accept(_ev) { return true; }
    onDynamicFrame(_ev, _context) { }
}
exports.TestEditManipulatorTool = TestEditManipulatorTool;
/** @hidden */
class TestEditManipulatorProvider extends EditManipulator.Provider {
    createControls() {
        return 1 === this.iModel.selectionSet.size;
    }
    selectControls(_ev) {
        const autoHit = IModelApp_1.IModelApp.accuSnap.currHit;
        return (undefined !== autoHit && this.iModel.selectionSet.has(autoHit.sourceId));
    }
    modifyControls(_ev) {
        const manipTool = new TestEditManipulatorTool(this);
        return manipTool.run();
    }
    drawControls(_context) {
        /* console.log("Decorate"); */
    }
    onManipulatorEvent(eventType) {
        super.onManipulatorEvent(eventType);
        /* console.log("Event " + eventType); */
    }
}
exports.TestEditManipulatorProvider = TestEditManipulatorProvider;


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
| $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(0);
class ElementAgenda {
    constructor(iModel) {
        this.iModel = iModel;
        this.elements = [];
        this.groupMarks = [];
        /** whether elements are flagged as hilited when added to the agenda. */
        this.hiliteOnAdd = true;
        this.hilitedState = 0 /* Unknown */;
    }
    /**
     * Get the source for this ElementAgenda, if applicable. The "source" is merely an indication of what the collection of elements
     * in this agenda means. When the source is ModifyElementSource.SelectionSet, the attempt will be made to keep the Selection
     * Set current with changes to the agenda.
     */
    getSource() { return this.groupMarks.length === 0 ? 0 /* Unknown */ : this.groupMarks[this.groupMarks.length - 1].source; }
    /** Set the source for this ElementAgenda. */
    setSource(val) { if (this.groupMarks.length > 0)
        this.groupMarks[this.groupMarks.length - 1].source = val; }
    isEmpty() { return this.length === 0; }
    getCount() { return this.length; }
    get length() { return this.elements.length; }
    /** Calls ClearHilite and empties this ElementAgenda. */
    clear() { this.clearHilite(); this.elements.length = 0; this.groupMarks.length = 0; }
    /** clear hilite on any currently hilited entries */
    clearHilite() {
        if (2 /* No */ === this.hilitedState)
            return;
        this.setEntriesHiliteState(false); // make sure all entries have their hilite flag off
        this.hilitedState = 2 /* No */;
    }
    setEntriesHiliteState(onOff, groupStart = 0, groupEnd = 0) {
        const group = (0 === groupEnd) ? this.elements : this.elements.filter((_id, index) => index >= groupStart && index < groupEnd);
        this.iModel.hilited.setHilite(group, onOff);
    }
    /** Calls ClearHilite and removes the last group of elements added to this ElementAgenda. */
    popGroup() {
        if (this.groupMarks.length <= 1) {
            this.clear();
            return;
        }
        const group = this.groupMarks.pop();
        if (2 /* No */ !== this.hilitedState)
            this.setEntriesHiliteState(false, group.start, this.length); // make sure removed entries aren't left hilited...
        this.elements.splice(group.start);
    }
    /** Mark all entries in this agenda as being hilited. */
    hilite() {
        if (1 /* Yes */ === this.hilitedState)
            return;
        this.setEntriesHiliteState(this.hiliteOnAdd); // make sure all entries have their hilite flag on.
        this.hilitedState = 1 /* Yes */;
    }
    has(id) { return this.elements.some((entry) => id === entry); }
    /** Return true if elementId is already in this ElementAgenda. */
    find(id) { return this.has(id.value); }
    /** Add elements to this ElementAgenda. */
    add(arg) {
        const groupStart = this.length;
        bentleyjs_core_1.Id64.toIdSet(arg).forEach((id) => { if (!this.has(id))
            this.elements.push(id); });
        if (groupStart === this.length)
            return false;
        this.groupMarks.push({ start: groupStart, source: 0 /* Unknown */ });
        if (2 /* No */ !== this.hilitedState)
            this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length);
        return true;
    }
    removeOne(id) {
        let pos = -1;
        const elements = this.elements;
        const groupMarks = this.groupMarks;
        elements.some((entry, index) => { if (id !== entry)
            return false; pos = index; return true; });
        if (pos === -1)
            return false;
        if (1 === elements.length || (1 === groupMarks.length && 5 /* DragSelect */ !== groupMarks[groupMarks.length - 1].source)) {
            this.clear();
            return true;
        }
        const groupIndex = pos;
        let groupStart = 0, groupEnd = 0;
        let markToErase = 0;
        let removeSingleEntry = false;
        for (let iMark = 0; iMark < groupMarks.length; ++iMark) {
            if (0 === groupEnd) {
                if (iMark + 1 === groupMarks.length) {
                    markToErase = iMark;
                    removeSingleEntry = (5 /* DragSelect */ === groupMarks[iMark].source);
                    groupStart = groupMarks[iMark].start;
                    groupEnd = elements.length;
                }
                else if (groupMarks[iMark].start <= groupIndex && groupMarks[iMark + 1].start > groupIndex) {
                    markToErase = iMark;
                    removeSingleEntry = (5 /* DragSelect */ === groupMarks[iMark].source);
                    groupStart = groupMarks[iMark].start;
                    groupEnd = groupMarks[iMark + 1].start;
                }
                continue;
            }
            if (removeSingleEntry)
                groupMarks[iMark].start -= 1; // Only removing single entry, not entire group...
            else
                groupMarks[iMark].start -= (groupEnd - groupStart); // Adjust indices...
        }
        if (removeSingleEntry) {
            if (2 /* No */ !== this.hilitedState)
                this.setEntriesHiliteState(false, groupIndex, groupIndex + 1); // make sure removed entry isn't left hilited...
            elements.splice(groupIndex, 1);
            if (groupEnd === groupStart + 1)
                groupMarks.splice(markToErase, 1);
            return true;
        }
        if (2 /* No */ !== this.hilitedState)
            this.setEntriesHiliteState(false, groupStart, groupEnd); // make sure removed entries aren't left hilited...
        elements.splice(groupStart, groupEnd - groupStart);
        groupMarks.splice(markToErase, 1);
        return true;
    }
    remove(arg) {
        if (0 === this.length)
            return false;
        const elSet = bentleyjs_core_1.Id64.toIdSet(arg);
        if (elSet.size === 0)
            return false;
        const needClearHilite = (2 /* No */ !== this.hilitedState);
        if (needClearHilite)
            this.clearHilite(); // Avoid making multiple draws to unhilite entries as they are removed...
        elSet.forEach((elId) => this.removeOne(elId)); // NOTE: Removes group associated with this element, not just a single entry...
        if (needClearHilite)
            this.hilite();
        return true;
    }
    /** Add elements not currently in the ElementAgenda and remove elements currently in the ElementAgenda. */
    invert(arg) {
        if (0 === this.length)
            return this.add(arg);
        const elSet = bentleyjs_core_1.Id64.toIdSet(arg);
        if (elSet.size === 0)
            return false;
        const adds = [];
        const removes = [];
        elSet.forEach((id) => { if (this.has(id))
            removes.push(id);
        else
            adds.push(id); });
        if (adds.length === 0 && removes.length === 0)
            return false;
        const needClearHilite = (2 /* No */ !== this.hilitedState);
        if (needClearHilite)
            this.clearHilite(); // Avoid making multiple draws to unhilite/hilite entries as they are removed/added...
        removes.forEach((id) => this.removeOne(id));
        if (adds.length > 0) {
            const groupStart = this.length;
            adds.forEach((id) => this.elements.push(id));
            this.groupMarks.push({ start: groupStart, source: 0 /* Unknown */ });
            if (2 /* No */ !== this.hilitedState)
                this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length); // make sure added entries are hilited (when not also removing)...
        }
        if (needClearHilite)
            this.hilite();
        return true;
    }
}
exports.ElementAgenda = ElementAgenda;


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(1);
/**
 * Class for finding elements that are inside or overlap a volume defined by an
 * extrusion of a planar region profile.
 */
class FenceParams {
    constructor() {
        this.overlapMode = false;
        this.onTolerance = .25;
        this.clipMode = 0 /* None */;
        this.hasOverlaps = false;
        this.fenceRangeNPC = new geometry_core_1.Range3d();
    }
}
exports.FenceParams = FenceParams;


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const rendering_1 = __webpack_require__(238);
const IModelApp_1 = __webpack_require__(5);
const Viewport_1 = __webpack_require__(44);
/**
 * A RenderTarget for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 */
class NullTarget extends rendering_1.RenderTarget {
    get renderSystem() { return undefined; }
    get cameraFrustumNearScaleLimit() { return 0; }
    get viewRect() { return new Viewport_1.ViewRect(); }
    get wantInvertBlackBackground() { return false; }
    onDestroy() { }
    reset() { }
    changeScene() { }
    changeDynamics() { }
    changeDecorations() { }
    changeRenderPlan() { }
    drawFrame(_sceneMilSecElapsed) { }
    overrideFeatureSymbology() { }
    setHiliteSet() { }
    setFlashed() { }
    setViewRect() { }
    queueReset() { }
    onResized() { }
    dispose() { }
    updateViewRect() { return false; }
    readPixels() { return undefined; }
}
exports.NullTarget = NullTarget;
/**
 * A RenderSystem for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 */
class NullRenderSystem extends rendering_1.RenderSystem {
    createTarget() { return new NullTarget(); }
    createOffscreenTarget() { return new NullTarget(); }
    createGraphic() { return undefined; }
    createGraphicList() { return undefined; }
    createBranch() { return undefined; }
    createBatch() { return undefined; }
    dispose() { }
    constructor() { super(undefined); }
}
exports.NullRenderSystem = NullRenderSystem;
/**
 * An IModelApp for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 */
class NoRenderApp extends IModelApp_1.IModelApp {
    static supplyRenderSystem() { return new NullRenderSystem(); }
}
exports.NoRenderApp = NoRenderApp;


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Global information on the currently opened iModel and the state of the view. */
class SimpleViewState {
    constructor() { }
}
exports.SimpleViewState = SimpleViewState;


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const lib_1 = __webpack_require__(18);
const imodeljs_frontend_1 = __webpack_require__(104);
const common_1 = __webpack_require__(2);
const Utils_1 = __webpack_require__(131);
const ProjectAbstraction_1 = __webpack_require__(239);
var ProjectScope;
(function (ProjectScope) {
    ProjectScope[ProjectScope["Favorites"] = 0] = "Favorites";
    ProjectScope[ProjectScope["MostRecentlyUsed"] = 1] = "MostRecentlyUsed";
    ProjectScope[ProjectScope["Invited"] = 2] = "Invited";
    ProjectScope[ProjectScope["All"] = 3] = "All";
})(ProjectScope = exports.ProjectScope || (exports.ProjectScope = {}));
class ProjectApi {
    // Initialize the project Api
    static async init(env) {
        ProjectApi.connectClient = new lib_1.ConnectClient(env);
    }
    static async getProjectByName(accessToken, projectScope, projectName) {
        const queryOptions = {
            $select: "*",
            $top: 100,
            $skip: 0,
        };
        let projectList = [];
        if (projectScope === ProjectScope.Invited) {
            projectList = await ProjectApi.connectClient.getInvitedProjects(accessToken, queryOptions);
        }
        if (projectScope === ProjectScope.Favorites) {
            queryOptions.isFavorite = true;
        }
        else if (projectScope === ProjectScope.MostRecentlyUsed) {
            queryOptions.isMRU = true;
        }
        projectList = await ProjectApi.connectClient.getProjects(accessToken, queryOptions);
        for (const thisProject of projectList) {
            if (thisProject.name === projectName)
                return thisProject;
        }
        return undefined;
    }
}
class IModelApi {
    /** Initialize the iModelHub Api */
    static async init(env) {
        IModelApi.imodelClient = new lib_1.IModelHubClient(env);
    }
    /** Get all iModels in a project */
    static async getIModelByName(accessToken, projectId, iModelName) {
        const queryOptions = new lib_1.IModelQuery();
        queryOptions.select("*").top(100).skip(0);
        const iModels = await IModelApi.imodelClient.IModels().get(accessToken, projectId, queryOptions);
        if (iModels.length < 1)
            return undefined;
        for (const thisIModel of iModels) {
            if (thisIModel.name === iModelName) {
                const versions = await IModelApi.imodelClient.Versions().get(accessToken, thisIModel.wsgId, new lib_1.VersionQuery().select("Name,ChangeSetId").top(1));
                if (versions.length > 0) {
                    thisIModel.latestVersionName = versions[0].name;
                    thisIModel.latestVersionChangeSetId = versions[0].changeSetId;
                }
                return thisIModel;
            }
        }
        return undefined;
    }
    /** Open the specified version of the IModel */
    static async openIModel(accessToken, projectId, iModelId, changeSetId, openMode) {
        return await imodeljs_frontend_1.IModelConnection.open(accessToken, projectId, iModelId, openMode, changeSetId ? common_1.IModelVersion.asOfChangeSet(changeSetId) : common_1.IModelVersion.latest());
    }
}
// Logic to establish a connection to a Connect-hosted project and iModel
class ConnectProject extends ProjectAbstraction_1.ProjectAbstraction {
    constructor() {
        super(...arguments);
        this._cfg = { userName: "", password: "", projectName: "", iModelName: "" };
    }
    // Retrieves the configuration for Connect-related settings from connect-configuration.json file located in the built public folder
    retrieveConfiguration() {
        return new Promise((resolve, _reject) => {
            const request = new XMLHttpRequest();
            request.open("GET", "connect-configuration.json", false);
            request.setRequestHeader("Cache-Control", "no-cache");
            request.onreadystatechange = ((_event) => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        const newConfigurationInfo = JSON.parse(request.responseText);
                        Object.assign(this._cfg, newConfigurationInfo);
                        resolve();
                    }
                    // Everything is good, the response was received.
                }
                else {
                    // Not ready yet.
                }
            });
            request.send();
        });
    }
    // Set up to access the iModel on Connect
    async loginAndOpenImodel(state) {
        const env = imodeljs_frontend_1.IModelApp.hubDeploymentEnv;
        imodeljs_frontend_1.IModelApp.iModelClient = new lib_1.IModelHubClient(env);
        await ProjectApi.init(env);
        await IModelApi.init(env);
        await this.retrieveConfiguration();
        // log in.
        Utils_1.showStatus("logging in as", this._cfg.userName);
        await ConnectProject.loginToConnect(state, this._cfg.userName, this._cfg.password);
        // open the specified project
        Utils_1.showStatus("opening Project", this._cfg.projectName);
        await ConnectProject.openProject(state, this._cfg.projectName);
        // open the specified iModel
        Utils_1.showStatus("opening iModel", this._cfg.iModelName);
        await ConnectProject.openIModel(state, this._cfg.iModelName);
    }
    // log in to connect
    static async loginToConnect(state, userName, password) {
        // tslint:disable-next-line:no-console
        console.log("Attempting login with userName", userName, "password", password);
        const authClient = new lib_1.ImsActiveSecureTokenClient("QA");
        const accessClient = new lib_1.ImsDelegationSecureTokenClient("QA");
        const authToken = await authClient.getToken(userName, password);
        state.accessToken = await accessClient.getToken(authToken);
    }
    // opens the configured project
    static async openProject(state, projectName) {
        state.project = await ProjectApi.getProjectByName(state.accessToken, ProjectScope.Invited, projectName);
    }
    // opens the configured iModel
    static async openIModel(state, iModelName) {
        state.iModel = await IModelApi.getIModelByName(state.accessToken, state.project.wsgId, iModelName);
        state.iModelConnection = await IModelApi.openIModel(state.accessToken, state.project.wsgId, state.iModel.wsgId, undefined, 1 /* Readonly */);
    }
}
exports.ConnectProject = ConnectProject;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
const imodeljs_clients_1 = __webpack_require__(18);
const imodeljs_frontend_1 = __webpack_require__(104);
const bentleyjs_core_1 = __webpack_require__(0);
const ProjectAbstraction_1 = __webpack_require__(239);
const Utils_1 = __webpack_require__(131);
// A connection to a non-Connect-hosted project and iModel
class NonConnectProject extends ProjectAbstraction_1.ProjectAbstraction {
    // Simulates how an app frontend might call out to some kind of deployment
    // infrastructure to ask for the imodelbank to use for a specified iModel.
    // In this demo, this method just gets a static resource that is keyed
    // to the iModelId from the Web server.
    getIModelbankFor(iModelId) {
        return new Promise((resolve, _reject) => {
            const request = new XMLHttpRequest();
            request.open("GET", `imodelbank-${iModelId}.json`, false);
            request.setRequestHeader("Cache-Control", "no-cache");
            request.onreadystatechange = ((_event) => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        resolve(JSON.parse(request.responseText));
                    }
                }
            });
            request.send();
        });
    }
    // Set up to access the iModel using iModelBank
    async loginAndOpenImodel(state) {
        // This is where the app's frontend must be written to work with the
        // surrounding project, user, and deployment infrastructure.
        // *** NON-CONNECT - ask the user mgr to authenticate the user and obtain an AccessToken.
        const userProfile = new imodeljs_clients_1.UserProfile("first", "last", "email@organization.org", "userid", "organization");
        const foreignAccessTokenWrapper = {};
        foreignAccessTokenWrapper[imodeljs_clients_1.AccessToken.foreignProjectAccessTokenJsonProperty] = { userProfile };
        state.accessToken = imodeljs_clients_1.AccessToken.fromForeignProjectAccessTokenJson(JSON.stringify(foreignAccessTokenWrapper));
        // *** NON-CONNECT - ask the project mgr to let the user choose an iModel.
        const iModelId = "233e1f55-561d-42a4-8e80-d6f91743863e";
        // *** NON-CONNECT - ask the deployment infrastructure for the iModelBank to use for this iModel
        const iminfo = await this.getIModelbankFor(iModelId);
        bentleyjs_core_1.assert(iminfo.iModelId === iModelId);
        // Now that we know what iModelBank to use, we can set up IModelApp
        // to work with that bank.
        // Tell IModelApp to use this IModelBank client
        const imbcontext = new imodeljs_clients_1.IModelBankAccessContext(iminfo.iModelId, iminfo.url, imodeljs_frontend_1.IModelApp.hubDeploymentEnv);
        imodeljs_frontend_1.IModelApp.iModelClient = imbcontext.client;
        // Open the iModel
        state.iModel = { wsgId: iminfo.iModelId, ecId: iminfo.iModelId };
        state.project = { wsgId: "", ecId: "", name: iminfo.name };
        Utils_1.showStatus("opening iModel", state.project.name);
        state.iModelConnection = await imodeljs_frontend_1.IModelConnection.open(state.accessToken, imbcontext.toIModelTokenContextId(), iminfo.iModelId, 1 /* Readonly */);
    }
}
exports.NonConnectProject = NonConnectProject;


/***/ }),
/* 391 */
/***/ (function(module, exports) {

module.exports = require('electron');

/***/ })
/******/ ]);
//# sourceMappingURL=main.bundle.js.map